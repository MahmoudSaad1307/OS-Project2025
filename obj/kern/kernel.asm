
obj/kern/kernel:     file format elf32-i386


Disassembly of section .text:

f0100000 <start_of_kernel-0xc>:
.long MULTIBOOT_HEADER_FLAGS
.long CHECKSUM

.globl		start_of_kernel
start_of_kernel:
	movw	$0x1234,0x472			# warm boot
f0100000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
f0100006:	00 00                	add    %al,(%eax)
f0100008:	fb                   	sti    
f0100009:	4f                   	dec    %edi
f010000a:	52                   	push   %edx
f010000b:	e4 66                	in     $0x66,%al

f010000c <start_of_kernel>:
f010000c:	66 c7 05 72 04 00 00 	movw   $0x1234,0x472
f0100013:	34 12 

	# Establish our own GDT in place of the boot loader's temporary GDT.
	lgdt	RELOC(mygdtdesc)		# load descriptor table
f0100015:	0f 01 15 18 f0 17 00 	lgdtl  0x17f018

	# Immediately reload all segment registers (including CS!)
	# with segment selectors from the new GDT.
	movl	$DATA_SEL, %eax			# Data segment selector
f010001c:	b8 10 00 00 00       	mov    $0x10,%eax
	movw	%ax,%ds				# -> DS: Data Segment
f0100021:	8e d8                	mov    %eax,%ds
	movw	%ax,%es				# -> ES: Extra Segment
f0100023:	8e c0                	mov    %eax,%es
	movw	%ax,%ss				# -> SS: Stack Segment
f0100025:	8e d0                	mov    %eax,%ss
	ljmp	$CODE_SEL,$relocated		# reload CS by jumping
f0100027:	ea 2e 00 10 f0 08 00 	ljmp   $0x8,$0xf010002e

f010002e <relocated>:
relocated:

	# Clear the frame pointer register (EBP)
	# so that once we get into debugging C code,
	# stack backtraces will be terminated properly.
	movl	$0x0,%ebp			# nuke frame pointer
f010002e:	bd 00 00 00 00       	mov    $0x0,%ebp

    # Leave a few words on the stack for the user trap frame
	#2024: this line is changed since the trapframe is move to the user kernel stack of each process
	#movl	$(ptr_stack_top-SIZEOF_STRUCT_TRAPFRAME),%esp
	movl	$(ptr_stack_top),%esp
f0100033:	bc 00 f0 17 f0       	mov    $0xf017f000,%esp

	# now to C code
	call	FOS_initialize
f0100038:	e8 10 00 00 00       	call   f010004d <FOS_initialize>

f010003d <spin>:

	# Should never get here, but in case we do, just spin.
spin:	jmp	spin
f010003d:	eb fe                	jmp    f010003d <spin>

f010003f <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f010003f:	55                   	push   %ebp
f0100040:	89 e5                	mov    %esp,%ebp
f0100042:	8b 45 08             	mov    0x8(%ebp),%eax
f0100045:	a3 e8 6a 85 f0       	mov    %eax,0xf0856ae8
f010004a:	90                   	nop
f010004b:	5d                   	pop    %ebp
f010004c:	c3                   	ret    

f010004d <FOS_initialize>:
//=======================================

//First ever function called in FOS kernel
extern bool __autograde__ ;
void FOS_initialize()
{
f010004d:	55                   	push   %ebp
f010004e:	89 e5                	mov    %esp,%ebp
f0100050:	57                   	push   %edi
f0100051:	56                   	push   %esi
f0100052:	53                   	push   %ebx
f0100053:	81 ec 2c 20 00 00    	sub    $0x202c,%esp
	//cprintf("*	1) Global data (BSS) section...");
	{
		// Before doing anything else,
		// clear the uninitialized global data (BSS) section of our program, from start_of_uninitialized_data_section to end_of_kernel
		// This ensures that all static/global variables start with zero value.
		memset(start_of_uninitialized_data_section, 0, end_of_kernel - start_of_uninitialized_data_section);
f0100059:	ba d0 d6 87 f0       	mov    $0xf087d6d0,%edx
f010005e:	b8 3c 59 81 f0       	mov    $0xf081593c,%eax
f0100063:	29 c2                	sub    %eax,%edx
f0100065:	89 d0                	mov    %edx,%eax
f0100067:	83 ec 04             	sub    $0x4,%esp
f010006a:	50                   	push   %eax
f010006b:	6a 00                	push   $0x0
f010006d:	68 3c 59 81 f0       	push   $0xf081593c
f0100072:	e8 f2 ac 01 00       	call   f011ad69 <memset>
f0100077:	83 c4 10             	add    $0x10,%esp
	//cprintf("[DONE]\n");

	{
		// Initialize the console.
		// Can't call cprintf until after we do this!
		cons_init();
f010007a:	e8 46 1a 00 00       	call   f0101ac5 <cons_init>
		//print welcome message
		print_welcome_message();
f010007f:	e8 b2 0d 00 00       	call   f0100e36 <print_welcome_message>
	}

	cprintf("\n********************************************************************\n");
f0100084:	83 ec 0c             	sub    $0xc,%esp
f0100087:	68 20 bc 11 f0       	push   $0xf011bc20
f010008c:	e8 cb 1b 00 00       	call   f0101c5c <cprintf>
f0100091:	83 c4 10             	add    $0x10,%esp
	cprintf("* INITIALIZATIONS:\n");
f0100094:	83 ec 0c             	sub    $0xc,%esp
f0100097:	68 67 bc 11 f0       	push   $0xf011bc67
f010009c:	e8 bb 1b 00 00       	call   f0101c5c <cprintf>
f01000a1:	83 c4 10             	add    $0x10,%esp
	cprintf("*=================\n");
f01000a4:	83 ec 0c             	sub    $0xc,%esp
f01000a7:	68 7b bc 11 f0       	push   $0xf011bc7b
f01000ac:	e8 ab 1b 00 00       	call   f0101c5c <cprintf>
f01000b1:	83 c4 10             	add    $0x10,%esp

	cprintf("* 1) CPU...");
f01000b4:	83 ec 0c             	sub    $0xc,%esp
f01000b7:	68 8f bc 11 f0       	push   $0xf011bc8f
f01000bc:	e8 9b 1b 00 00       	call   f0101c5c <cprintf>
f01000c1:	83 c4 10             	add    $0x10,%esp
	{
		//Initialize the Main CPU
		cpu_init(0);
f01000c4:	83 ec 0c             	sub    $0xc,%esp
f01000c7:	6a 00                	push   $0x0
f01000c9:	e8 ac 7f 00 00       	call   f010807a <cpu_init>
f01000ce:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("[DONE]\n");
f01000d1:	83 ec 0c             	sub    $0xc,%esp
f01000d4:	68 9b bc 11 f0       	push   $0xf011bc9b
f01000d9:	e8 7e 1b 00 00       	call   f0101c5c <cprintf>
f01000de:	83 c4 10             	add    $0x10,%esp

	cprintf("* 2) MEMORY:\n");
f01000e1:	83 ec 0c             	sub    $0xc,%esp
f01000e4:	68 a3 bc 11 f0       	push   $0xf011bca3
f01000e9:	e8 6e 1b 00 00       	call   f0101c5c <cprintf>
f01000ee:	83 c4 10             	add    $0x10,%esp
	{
		detect_memory();
f01000f1:	e8 ef 88 00 00       	call   f01089e5 <detect_memory>
		initialize_kernel_VM();
f01000f6:	e8 8f 84 00 00       	call   f010858a <initialize_kernel_VM>
		initialize_paging();
f01000fb:	e8 4e 8c 00 00       	call   f0108d4e <initialize_paging>
#if USE_KHEAP
		kheap_init();
f0100100:	e8 75 9a 00 00       	call   f0109b7a <kheap_init>
		sharing_init();
f0100105:	e8 aa 98 00 00       	call   f01099b4 <sharing_init>
#endif
		fault_handler_init();
f010010a:	e8 14 f9 00 00       	call   f010fa23 <fault_handler_init>
		set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f010010f:	83 ec 0c             	sub    $0xc,%esp
f0100112:	6a 05                	push   $0x5
f0100114:	e8 26 ff ff ff       	call   f010003f <set_uheap_strategy>
f0100119:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");

	cprintf("* 3) DISK...");
f010011c:	83 ec 0c             	sub    $0xc,%esp
f010011f:	68 b1 bc 11 f0       	push   $0xf011bcb1
f0100124:	e8 33 1b 00 00       	call   f0101c5c <cprintf>
f0100129:	83 c4 10             	add    $0x10,%esp
	{
		ide_init();
f010012c:	e8 88 b2 01 00       	call   f011b3b9 <ide_init>
	}
	cprintf("[DONE]\n");
f0100131:	83 ec 0c             	sub    $0xc,%esp
f0100134:	68 9b bc 11 f0       	push   $0xf011bc9b
f0100139:	e8 1e 1b 00 00       	call   f0101c5c <cprintf>
f010013e:	83 c4 10             	add    $0x10,%esp

	cprintf("* 4) USER ENVs...");
f0100141:	83 ec 0c             	sub    $0xc,%esp
f0100144:	68 be bc 11 f0       	push   $0xf011bcbe
f0100149:	e8 0e 1b 00 00       	call   f0101c5c <cprintf>
f010014e:	83 c4 10             	add    $0x10,%esp
	{
		env_init();
f0100151:	e8 70 ac 00 00       	call   f010adc6 <env_init>
		ts_init();
f0100156:	e8 61 ce 00 00       	call   f010cfbc <ts_init>
	}
	cprintf("[DONE]\n");
f010015b:	83 ec 0c             	sub    $0xc,%esp
f010015e:	68 9b bc 11 f0       	push   $0xf011bc9b
f0100163:	e8 f4 1a 00 00       	call   f0101c5c <cprintf>
f0100168:	83 c4 10             	add    $0x10,%esp

	cprintf("* 5) PROGRAMMABLE INTERRUPT CONTROLLER:\n");
f010016b:	83 ec 0c             	sub    $0xc,%esp
f010016e:	68 d0 bc 11 f0       	push   $0xf011bcd0
f0100173:	e8 e4 1a 00 00       	call   f0101c5c <cprintf>
f0100178:	83 c4 10             	add    $0x10,%esp
	{
		pic_init();
f010017b:	e8 e6 7b 00 00       	call   f0107d66 <pic_init>
		cprintf("*	PIC is initialized\n");
f0100180:	83 ec 0c             	sub    $0xc,%esp
f0100183:	68 f9 bc 11 f0       	push   $0xf011bcf9
f0100188:	e8 cf 1a 00 00       	call   f0101c5c <cprintf>
f010018d:	83 c4 10             	add    $0x10,%esp
		//Enable Clock Interrupt
		irq_clear_mask(0);
f0100190:	83 ec 0c             	sub    $0xc,%esp
f0100193:	6a 00                	push   $0x0
f0100195:	e8 be 7d 00 00       	call   f0107f58 <irq_clear_mask>
f010019a:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ0 (Clock): is Enabled\n");
f010019d:	83 ec 0c             	sub    $0xc,%esp
f01001a0:	68 0f bd 11 f0       	push   $0xf011bd0f
f01001a5:	e8 b2 1a 00 00       	call   f0101c5c <cprintf>
f01001aa:	83 c4 10             	add    $0x10,%esp
		//Enable KB Interrupt
		irq_clear_mask(1);
f01001ad:	83 ec 0c             	sub    $0xc,%esp
f01001b0:	6a 01                	push   $0x1
f01001b2:	e8 a1 7d 00 00       	call   f0107f58 <irq_clear_mask>
f01001b7:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ1 (Keyboard): is Enabled\n");
f01001ba:	83 ec 0c             	sub    $0xc,%esp
f01001bd:	68 2c bd 11 f0       	push   $0xf011bd2c
f01001c2:	e8 95 1a 00 00       	call   f0101c5c <cprintf>
f01001c7:	83 c4 10             	add    $0x10,%esp
		//Enable COM1 Interrupt
		irq_clear_mask(4);
f01001ca:	83 ec 0c             	sub    $0xc,%esp
f01001cd:	6a 04                	push   $0x4
f01001cf:	e8 84 7d 00 00       	call   f0107f58 <irq_clear_mask>
f01001d4:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ4 (COM1): is Enabled\n");
f01001d7:	83 ec 0c             	sub    $0xc,%esp
f01001da:	68 4b bd 11 f0       	push   $0xf011bd4b
f01001df:	e8 78 1a 00 00       	call   f0101c5c <cprintf>
f01001e4:	83 c4 10             	add    $0x10,%esp
		//Enable Primary ATA Hard Disk Interrupt
		irq_clear_mask(14);
f01001e7:	83 ec 0c             	sub    $0xc,%esp
f01001ea:	6a 0e                	push   $0xe
f01001ec:	e8 67 7d 00 00       	call   f0107f58 <irq_clear_mask>
f01001f1:	83 c4 10             	add    $0x10,%esp
		cprintf("*	IRQ14 (Primary ATA Hard Disk): is Enabled\n");
f01001f4:	83 ec 0c             	sub    $0xc,%esp
f01001f7:	68 68 bd 11 f0       	push   $0xf011bd68
f01001fc:	e8 5b 1a 00 00       	call   f0101c5c <cprintf>
f0100201:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("* 6) SCHEDULER & MULTI-TASKING:\n");
f0100204:	83 ec 0c             	sub    $0xc,%esp
f0100207:	68 98 bd 11 f0       	push   $0xf011bd98
f010020c:	e8 4b 1a 00 00       	call   f0101c5c <cprintf>
f0100211:	83 c4 10             	add    $0x10,%esp
	{
		kclock_init();
f0100214:	e8 40 5a 00 00       	call   f0105c59 <kclock_init>
		sched_init() ;
f0100219:	e8 c5 75 00 00       	call   f01077e3 <sched_init>
	}
	//cprintf("* [DONE]\n");

	cprintf("* 7) ESP to SCHED KERN STACK:\n");
f010021e:	83 ec 0c             	sub    $0xc,%esp
f0100221:	68 bc bd 11 f0       	push   $0xf011bdbc
f0100226:	e8 31 1a 00 00       	call   f0101c5c <cprintf>
f010022b:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010022e:	89 e0                	mov    %esp,%eax
f0100230:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return esp;
f0100233:	8b 45 d8             	mov    -0x28(%ebp),%eax
	{
		//Relocate SP to its corresponding location in the specific stack area below KERN_BASE (SCHD_KERN_STACK_TOP)
		uint32 old_sp = read_esp();
f0100236:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 sp_offset = (uint32)ptr_stack_top - old_sp ;
f0100239:	b8 00 f0 17 f0       	mov    $0xf017f000,%eax
f010023e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
f0100241:	89 45 e0             	mov    %eax,-0x20(%ebp)
		uint32 new_sp = KERN_STACK_TOP - sp_offset;
f0100244:	b8 00 00 c0 ef       	mov    $0xefc00000,%eax
f0100249:	2b 45 e0             	sub    -0x20(%ebp),%eax
f010024c:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010024f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0100252:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0100255:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0100258:	89 c4                	mov    %eax,%esp

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010025a:	89 e0                	mov    %esp,%eax
f010025c:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return esp;
f010025f:	8b 45 d0             	mov    -0x30(%ebp),%eax
		write_esp(new_sp);
		cprintf("*	old SP = %x - updated SP = %x\n", old_sp, read_esp());
f0100262:	83 ec 04             	sub    $0x4,%esp
f0100265:	50                   	push   %eax
f0100266:	ff 75 e4             	pushl  -0x1c(%ebp)
f0100269:	68 dc bd 11 f0       	push   $0xf011bddc
f010026e:	e8 e9 19 00 00       	call   f0101c5c <cprintf>
f0100273:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("* [DONE]\n");
	cprintf("********************************************************************\n");
f0100276:	83 ec 0c             	sub    $0xc,%esp
f0100279:	68 00 be 11 f0       	push   $0xf011be00
f010027e:	e8 d9 19 00 00       	call   f0101c5c <cprintf>
f0100283:	83 c4 10             	add    $0x10,%esp

	// start the kernel command prompt.
	while (1==1)
	{
		cprintf("\nWelcome to the FOS kernel command prompt!\n");
f0100286:	83 ec 0c             	sub    $0xc,%esp
f0100289:	68 48 be 11 f0       	push   $0xf011be48
f010028e:	e8 c9 19 00 00       	call   f0101c5c <cprintf>
f0100293:	83 c4 10             	add    $0x10,%esp
		cprintf("Type 'help' for a list of commands.\n");
f0100296:	83 ec 0c             	sub    $0xc,%esp
f0100299:	68 74 be 11 f0       	push   $0xf011be74
f010029e:	e8 b9 19 00 00       	call   f0101c5c <cprintf>
f01002a3:	83 c4 10             	add    $0x10,%esp
		if (__autograde__)
f01002a6:	a1 20 f0 17 f0       	mov    0xf017f020,%eax
f01002ab:	85 c0                	test   %eax,%eax
f01002ad:	0f 84 7e 0b 00 00    	je     f0100e31 <FOS_initialize+0xde4>
			/*CHECK THE FOLLOWING:
			 * 1) time of each test
			 * 2) "unhandled trap in" message
			 */

			cprintf("\nPROJECT Automatic testing is STARTED...\n") ;
f01002b3:	83 ec 0c             	sub    $0xc,%esp
f01002b6:	68 9c be 11 f0       	push   $0xf011be9c
f01002bb:	e8 9c 19 00 00       	call   f0101c5c <cprintf>
f01002c0:	83 c4 10             	add    $0x10,%esp

			//TEST#1: DYNAMIC ALLOCATOR
			{
				char cmd1[BUFLEN] = "tst dynalloc init";
f01002c3:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01002c9:	bb ec be 11 f0       	mov    $0xf011beec,%ebx
f01002ce:	ba 12 00 00 00       	mov    $0x12,%edx
f01002d3:	89 c7                	mov    %eax,%edi
f01002d5:	89 de                	mov    %ebx,%esi
f01002d7:	89 d1                	mov    %edx,%ecx
f01002d9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01002db:	8d 95 e2 ef ff ff    	lea    -0x101e(%ebp),%edx
f01002e1:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f01002e6:	b0 00                	mov    $0x0,%al
f01002e8:	89 d7                	mov    %edx,%edi
f01002ea:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst dynalloc alloc";
f01002ec:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01002f2:	bb ec c2 11 f0       	mov    $0xf011c2ec,%ebx
f01002f7:	ba 13 00 00 00       	mov    $0x13,%edx
f01002fc:	89 c7                	mov    %eax,%edi
f01002fe:	89 de                	mov    %ebx,%esi
f0100300:	89 d1                	mov    %edx,%ecx
f0100302:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100304:	8d 95 e3 f3 ff ff    	lea    -0xc1d(%ebp),%edx
f010030a:	b9 ed 03 00 00       	mov    $0x3ed,%ecx
f010030f:	b0 00                	mov    $0x0,%al
f0100311:	89 d7                	mov    %edx,%edi
f0100313:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst dynalloc free";
f0100315:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f010031b:	bb ec c6 11 f0       	mov    $0xf011c6ec,%ebx
f0100320:	ba 12 00 00 00       	mov    $0x12,%edx
f0100325:	89 c7                	mov    %eax,%edi
f0100327:	89 de                	mov    %ebx,%esi
f0100329:	89 d1                	mov    %edx,%ecx
f010032b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010032d:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100333:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100338:	b0 00                	mov    $0x0,%al
f010033a:	89 d7                	mov    %edx,%edi
f010033c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst dynalloc realloc";
f010033e:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100344:	bb ec ca 11 f0       	mov    $0xf011caec,%ebx
f0100349:	ba 15 00 00 00       	mov    $0x15,%edx
f010034e:	89 c7                	mov    %eax,%edi
f0100350:	89 de                	mov    %ebx,%esi
f0100352:	89 d1                	mov    %edx,%ecx
f0100354:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100356:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f010035c:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100361:	b0 00                	mov    $0x0,%al
f0100363:	89 d7                	mov    %edx,%edi
f0100365:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd4);
			}
			//TEST#2: KERNEL HEAP [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "tst kheap CF kmalloc blk";
f0100367:	8d 85 d0 df ff ff    	lea    -0x2030(%ebp),%eax
f010036d:	bb ec ce 11 f0       	mov    $0xf011ceec,%ebx
f0100372:	ba 19 00 00 00       	mov    $0x19,%edx
f0100377:	89 c7                	mov    %eax,%edi
f0100379:	89 de                	mov    %ebx,%esi
f010037b:	89 d1                	mov    %edx,%ecx
f010037d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010037f:	8d 95 e9 df ff ff    	lea    -0x2017(%ebp),%edx
f0100385:	b9 e7 03 00 00       	mov    $0x3e7,%ecx
f010038a:	b0 00                	mov    $0x0,%al
f010038c:	89 d7                	mov    %edx,%edi
f010038e:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF kmalloc page";
f0100390:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100396:	bb ec d2 11 f0       	mov    $0xf011d2ec,%ebx
f010039b:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003a0:	89 c7                	mov    %eax,%edi
f01003a2:	89 de                	mov    %ebx,%esi
f01003a4:	89 d1                	mov    %edx,%ecx
f01003a6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003a8:	8d 95 ea e3 ff ff    	lea    -0x1c16(%ebp),%edx
f01003ae:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003b3:	b0 00                	mov    $0x0,%al
f01003b5:	89 d7                	mov    %edx,%edi
f01003b7:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF kmalloc both";
f01003b9:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f01003bf:	bb ec d6 11 f0       	mov    $0xf011d6ec,%ebx
f01003c4:	ba 1a 00 00 00       	mov    $0x1a,%edx
f01003c9:	89 c7                	mov    %eax,%edi
f01003cb:	89 de                	mov    %ebx,%esi
f01003cd:	89 d1                	mov    %edx,%ecx
f01003cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003d1:	8d 95 ea e7 ff ff    	lea    -0x1816(%ebp),%edx
f01003d7:	b9 e6 03 00 00       	mov    $0x3e6,%ecx
f01003dc:	b0 00                	mov    $0x0,%al
f01003de:	89 d7                	mov    %edx,%edi
f01003e0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "tst kheap CF kfree blk";
f01003e2:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f01003e8:	bb ec da 11 f0       	mov    $0xf011daec,%ebx
f01003ed:	ba 17 00 00 00       	mov    $0x17,%edx
f01003f2:	89 c7                	mov    %eax,%edi
f01003f4:	89 de                	mov    %ebx,%esi
f01003f6:	89 d1                	mov    %edx,%ecx
f01003f8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01003fa:	8d 95 e7 eb ff ff    	lea    -0x1419(%ebp),%edx
f0100400:	b9 e9 03 00 00       	mov    $0x3e9,%ecx
f0100405:	b0 00                	mov    $0x0,%al
f0100407:	89 d7                	mov    %edx,%edi
f0100409:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "tst kheap CF kfree page";
f010040b:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100411:	bb ec de 11 f0       	mov    $0xf011deec,%ebx
f0100416:	ba 06 00 00 00       	mov    $0x6,%edx
f010041b:	89 c7                	mov    %eax,%edi
f010041d:	89 de                	mov    %ebx,%esi
f010041f:	89 d1                	mov    %edx,%ecx
f0100421:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100423:	8d 95 e8 ef ff ff    	lea    -0x1018(%ebp),%edx
f0100429:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010042e:	b8 00 00 00 00       	mov    $0x0,%eax
f0100433:	89 d7                	mov    %edx,%edi
f0100435:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd6[BUFLEN] = "tst kheap CF kfree both";
f0100437:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010043d:	bb ec e2 11 f0       	mov    $0xf011e2ec,%ebx
f0100442:	ba 06 00 00 00       	mov    $0x6,%edx
f0100447:	89 c7                	mov    %eax,%edi
f0100449:	89 de                	mov    %ebx,%esi
f010044b:	89 d1                	mov    %edx,%ecx
f010044d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010044f:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100455:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f010045a:	b8 00 00 00 00       	mov    $0x0,%eax
f010045f:	89 d7                	mov    %edx,%edi
f0100461:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd7[BUFLEN] = "tst kheap kvirtaddr";
f0100463:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100469:	bb ec e6 11 f0       	mov    $0xf011e6ec,%ebx
f010046e:	ba 05 00 00 00       	mov    $0x5,%edx
f0100473:	89 c7                	mov    %eax,%edi
f0100475:	89 de                	mov    %ebx,%esi
f0100477:	89 d1                	mov    %edx,%ecx
f0100479:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010047b:	8d 95 e4 f7 ff ff    	lea    -0x81c(%ebp),%edx
f0100481:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100486:	b8 00 00 00 00       	mov    $0x0,%eax
f010048b:	89 d7                	mov    %edx,%edi
f010048d:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd8[BUFLEN] = "tst kheap kphysaddr";
f010048f:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100495:	bb ec ea 11 f0       	mov    $0xf011eaec,%ebx
f010049a:	ba 05 00 00 00       	mov    $0x5,%edx
f010049f:	89 c7                	mov    %eax,%edi
f01004a1:	89 de                	mov    %ebx,%esi
f01004a3:	89 d1                	mov    %edx,%ecx
f01004a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01004a7:	8d 95 e4 fb ff ff    	lea    -0x41c(%ebp),%edx
f01004ad:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f01004b2:	b8 00 00 00 00       	mov    $0x0,%eax
f01004b7:	89 d7                	mov    %edx,%edi
f01004b9:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd8);
			}
			//TEST#3: FAULT HANDLER I [PARTIAL GRADING]
			{
				char cmd1[BUFLEN] = "run tia 15";
f01004bb:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01004c1:	bb ec ee 11 f0       	mov    $0xf011eeec,%ebx
f01004c6:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004cb:	89 c7                	mov    %eax,%edi
f01004cd:	89 de                	mov    %ebx,%esi
f01004cf:	89 d1                	mov    %edx,%ecx
f01004d1:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004d3:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01004d9:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01004de:	b0 00                	mov    $0x0,%al
f01004e0:	89 d7                	mov    %edx,%edi
f01004e2:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tpp 20";
f01004e4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01004ea:	bb ec f2 11 f0       	mov    $0xf011f2ec,%ebx
f01004ef:	ba 0b 00 00 00       	mov    $0xb,%edx
f01004f4:	89 c7                	mov    %eax,%edi
f01004f6:	89 de                	mov    %ebx,%esi
f01004f8:	89 d1                	mov    %edx,%ecx
f01004fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01004fc:	8d 95 db fb ff ff    	lea    -0x425(%ebp),%edx
f0100502:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100507:	b0 00                	mov    $0x0,%al
f0100509:	89 d7                	mov    %edx,%edi
f010050b:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd2);
			}
			//TEST: FAULT HANDLER II [OPTIMAL] 	[10 sec]
			{
				char cmd0[BUFLEN] = "optimal";
f010050d:	c7 85 d0 ef ff ff 6f 	movl   $0x6974706f,-0x1030(%ebp)
f0100514:	70 74 69 
f0100517:	c7 85 d4 ef ff ff 6d 	movl   $0x6c616d,-0x102c(%ebp)
f010051e:	61 6c 00 
f0100521:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f0100527:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f010052c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100531:	89 d7                	mov    %edx,%edi
f0100533:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run toptimal1 11";
f0100535:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010053b:	bb ec f6 11 f0       	mov    $0xf011f6ec,%ebx
f0100540:	ba 11 00 00 00       	mov    $0x11,%edx
f0100545:	89 c7                	mov    %eax,%edi
f0100547:	89 de                	mov    %ebx,%esi
f0100549:	89 d1                	mov    %edx,%ecx
f010054b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010054d:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100553:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100558:	b0 00                	mov    $0x0,%al
f010055a:	89 d7                	mov    %edx,%edi
f010055c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run toptimal2 11";
f010055e:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100564:	bb ec fa 11 f0       	mov    $0xf011faec,%ebx
f0100569:	ba 11 00 00 00       	mov    $0x11,%edx
f010056e:	89 c7                	mov    %eax,%edi
f0100570:	89 de                	mov    %ebx,%esi
f0100572:	89 d1                	mov    %edx,%ecx
f0100574:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100576:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f010057c:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100581:	b0 00                	mov    $0x0,%al
f0100583:	89 d7                	mov    %edx,%edi
f0100585:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run toptimal3 11";
f0100587:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010058d:	bb ec fe 11 f0       	mov    $0xf011feec,%ebx
f0100592:	ba 11 00 00 00       	mov    $0x11,%edx
f0100597:	89 c7                	mov    %eax,%edi
f0100599:	89 de                	mov    %ebx,%esi
f010059b:	89 d1                	mov    %edx,%ecx
f010059d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010059f:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f01005a5:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f01005aa:	b0 00                	mov    $0x0,%al
f01005ac:	89 d7                	mov    %edx,%edi
f01005ae:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: FAULT HANDLER II [CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "clock";
f01005b0:	c7 85 d0 eb ff ff 63 	movl   $0x636f6c63,-0x1430(%ebp)
f01005b7:	6c 6f 63 
f01005ba:	c7 85 d4 eb ff ff 6b 	movl   $0x6b,-0x142c(%ebp)
f01005c1:	00 00 00 
f01005c4:	8d 95 d8 eb ff ff    	lea    -0x1428(%ebp),%edx
f01005ca:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f01005cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01005d4:	89 d7                	mov    %edx,%edi
f01005d6:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01005d8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01005de:	bb ec 02 12 f0       	mov    $0xf01202ec,%ebx
f01005e3:	ba 03 00 00 00       	mov    $0x3,%edx
f01005e8:	89 c7                	mov    %eax,%edi
f01005ea:	89 de                	mov    %ebx,%esi
f01005ec:	89 d1                	mov    %edx,%ecx
f01005ee:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01005f0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01005f6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01005fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100600:	89 d7                	mov    %edx,%edi
f0100602:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f0100604:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f010060a:	bb ec 06 12 f0       	mov    $0xf01206ec,%ebx
f010060f:	ba 0b 00 00 00       	mov    $0xb,%edx
f0100614:	89 c7                	mov    %eax,%edi
f0100616:	89 de                	mov    %ebx,%esi
f0100618:	89 d1                	mov    %edx,%ecx
f010061a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010061c:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f0100622:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f0100627:	b0 00                	mov    $0x0,%al
f0100629:	89 d7                	mov    %edx,%edi
f010062b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tclock1 11";
f010062d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100633:	bb ec 0a 12 f0       	mov    $0xf0120aec,%ebx
f0100638:	ba 0f 00 00 00       	mov    $0xf,%edx
f010063d:	89 c7                	mov    %eax,%edi
f010063f:	89 de                	mov    %ebx,%esi
f0100641:	89 d1                	mov    %edx,%ecx
f0100643:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100645:	8d 95 df f7 ff ff    	lea    -0x821(%ebp),%edx
f010064b:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100650:	b0 00                	mov    $0x0,%al
f0100652:	89 d7                	mov    %edx,%edi
f0100654:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tclock2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100656:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010065c:	bb ec 0e 12 f0       	mov    $0xf0120eec,%ebx
f0100661:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100666:	89 c7                	mov    %eax,%edi
f0100668:	89 de                	mov    %ebx,%esi
f010066a:	89 d1                	mov    %edx,%ecx
f010066c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010066e:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100674:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100679:	b0 00                	mov    $0x0,%al
f010067b:	89 d7                	mov    %edx,%edi
f010067d:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [MODIFIED CLOCK] 	[10 sec]
			{
				char cmd0[BUFLEN] = "modclock";
f010067f:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100685:	bb ec 12 12 f0       	mov    $0xf01212ec,%ebx
f010068a:	ba 09 00 00 00       	mov    $0x9,%edx
f010068f:	89 c7                	mov    %eax,%edi
f0100691:	89 de                	mov    %ebx,%esi
f0100693:	89 d1                	mov    %edx,%ecx
f0100695:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100697:	8d 95 d9 eb ff ff    	lea    -0x1427(%ebp),%edx
f010069d:	b9 f7 03 00 00       	mov    $0x3f7,%ecx
f01006a2:	b0 00                	mov    $0x0,%al
f01006a4:	89 d7                	mov    %edx,%edi
f01006a6:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f01006a8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f01006ae:	bb ec 02 12 f0       	mov    $0xf01202ec,%ebx
f01006b3:	ba 03 00 00 00       	mov    $0x3,%edx
f01006b8:	89 c7                	mov    %eax,%edi
f01006ba:	89 de                	mov    %ebx,%esi
f01006bc:	89 d1                	mov    %edx,%ecx
f01006be:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01006c0:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f01006c6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01006cb:	b8 00 00 00 00       	mov    $0x0,%eax
f01006d0:	89 d7                	mov    %edx,%edi
f01006d2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01006d4:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01006da:	bb ec 06 12 f0       	mov    $0xf01206ec,%ebx
f01006df:	ba 0b 00 00 00       	mov    $0xb,%edx
f01006e4:	89 c7                	mov    %eax,%edi
f01006e6:	89 de                	mov    %ebx,%esi
f01006e8:	89 d1                	mov    %edx,%ecx
f01006ea:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01006ec:	8d 95 db f3 ff ff    	lea    -0xc25(%ebp),%edx
f01006f2:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01006f7:	b0 00                	mov    $0x0,%al
f01006f9:	89 d7                	mov    %edx,%edi
f01006fb:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tmodclk1 11";
f01006fd:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100703:	bb ec 16 12 f0       	mov    $0xf01216ec,%ebx
f0100708:	ba 04 00 00 00       	mov    $0x4,%edx
f010070d:	89 c7                	mov    %eax,%edi
f010070f:	89 de                	mov    %ebx,%esi
f0100711:	89 d1                	mov    %edx,%ecx
f0100713:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100715:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f010071b:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100720:	b8 00 00 00 00       	mov    $0x0,%eax
f0100725:	89 d7                	mov    %edx,%edi
f0100727:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd4[BUFLEN] = "run tmodclk2 11";	//depend on USER HEAP (allocate_user_mem, free_user_mem)
f0100729:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f010072f:	bb ec 1a 12 f0       	mov    $0xf0121aec,%ebx
f0100734:	ba 04 00 00 00       	mov    $0x4,%edx
f0100739:	89 c7                	mov    %eax,%edi
f010073b:	89 de                	mov    %ebx,%esi
f010073d:	89 d1                	mov    %edx,%ecx
f010073f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100741:	8d 95 e0 fb ff ff    	lea    -0x420(%ebp),%edx
f0100747:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f010074c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100751:	89 d7                	mov    %edx,%edi
f0100753:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd4);
			}
			//TEST: FAULT HANDLER II [LRU] 	[10 sec]
			{
				char cmd0[BUFLEN] = "lru 1";
f0100755:	c7 85 d0 ef ff ff 6c 	movl   $0x2075726c,-0x1030(%ebp)
f010075c:	72 75 20 
f010075f:	c7 85 d4 ef ff ff 31 	movl   $0x31,-0x102c(%ebp)
f0100766:	00 00 00 
f0100769:	8d 95 d8 ef ff ff    	lea    -0x1028(%ebp),%edx
f010076f:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100774:	b8 00 00 00 00       	mov    $0x0,%eax
f0100779:	89 d7                	mov    %edx,%edi
f010077b:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tpr1 11";
f010077d:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100783:	bb ec 02 12 f0       	mov    $0xf01202ec,%ebx
f0100788:	ba 03 00 00 00       	mov    $0x3,%edx
f010078d:	89 c7                	mov    %eax,%edi
f010078f:	89 de                	mov    %ebx,%esi
f0100791:	89 d1                	mov    %edx,%ecx
f0100793:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100795:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f010079b:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007a0:	b8 00 00 00 00       	mov    $0x0,%eax
f01007a5:	89 d7                	mov    %edx,%edi
f01007a7:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tpr2 6";
f01007a9:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01007af:	bb ec 06 12 f0       	mov    $0xf01206ec,%ebx
f01007b4:	ba 0b 00 00 00       	mov    $0xb,%edx
f01007b9:	89 c7                	mov    %eax,%edi
f01007bb:	89 de                	mov    %ebx,%esi
f01007bd:	89 d1                	mov    %edx,%ecx
f01007bf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01007c1:	8d 95 db f7 ff ff    	lea    -0x825(%ebp),%edx
f01007c7:	b9 f5 03 00 00       	mov    $0x3f5,%ecx
f01007cc:	b0 00                	mov    $0x0,%al
f01007ce:	89 d7                	mov    %edx,%edi
f01007d0:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tlru 11";
f01007d2:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01007d8:	bb ec 1e 12 f0       	mov    $0xf0121eec,%ebx
f01007dd:	ba 03 00 00 00       	mov    $0x3,%edx
f01007e2:	89 c7                	mov    %eax,%edi
f01007e4:	89 de                	mov    %ebx,%esi
f01007e6:	89 d1                	mov    %edx,%ecx
f01007e8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01007ea:	8d 95 dc fb ff ff    	lea    -0x424(%ebp),%edx
f01007f0:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f01007f5:	b8 00 00 00 00       	mov    $0x0,%eax
f01007fa:	89 d7                	mov    %edx,%edi
f01007fc:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd3);
			}
			//TEST: USER HEAP	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f01007fe:	8d 85 d0 e3 ff ff    	lea    -0x1c30(%ebp),%eax
f0100804:	bb ec 22 12 f0       	mov    $0xf01222ec,%ebx
f0100809:	ba 03 00 00 00       	mov    $0x3,%edx
f010080e:	89 c7                	mov    %eax,%edi
f0100810:	89 de                	mov    %ebx,%esi
f0100812:	89 d1                	mov    %edx,%ecx
f0100814:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100816:	8d 95 dc e3 ff ff    	lea    -0x1c24(%ebp),%edx
f010081c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100821:	b8 00 00 00 00       	mov    $0x0,%eax
f0100826:	89 d7                	mov    %edx,%edi
f0100828:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tm1 3000";
f010082a:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100830:	bb ec 26 12 f0       	mov    $0xf01226ec,%ebx
f0100835:	ba 0d 00 00 00       	mov    $0xd,%edx
f010083a:	89 c7                	mov    %eax,%edi
f010083c:	89 de                	mov    %ebx,%esi
f010083e:	89 d1                	mov    %edx,%ecx
f0100840:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100842:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100848:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010084d:	b0 00                	mov    $0x0,%al
f010084f:	89 d7                	mov    %edx,%edi
f0100851:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tm2 3000";
f0100853:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100859:	bb ec 2a 12 f0       	mov    $0xf0122aec,%ebx
f010085e:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100863:	89 c7                	mov    %eax,%edi
f0100865:	89 de                	mov    %ebx,%esi
f0100867:	89 d1                	mov    %edx,%ecx
f0100869:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010086b:	8d 95 dd eb ff ff    	lea    -0x1423(%ebp),%edx
f0100871:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100876:	b0 00                	mov    $0x0,%al
f0100878:	89 d7                	mov    %edx,%edi
f010087a:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tf1 3000";
f010087c:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100882:	bb ec 2e 12 f0       	mov    $0xf0122eec,%ebx
f0100887:	ba 0d 00 00 00       	mov    $0xd,%edx
f010088c:	89 c7                	mov    %eax,%edi
f010088e:	89 de                	mov    %ebx,%esi
f0100890:	89 d1                	mov    %edx,%ecx
f0100892:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100894:	8d 95 dd ef ff ff    	lea    -0x1023(%ebp),%edx
f010089a:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f010089f:	b0 00                	mov    $0x0,%al
f01008a1:	89 d7                	mov    %edx,%edi
f01008a3:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tf2 3000";
f01008a5:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01008ab:	bb ec 32 12 f0       	mov    $0xf01232ec,%ebx
f01008b0:	ba 0d 00 00 00       	mov    $0xd,%edx
f01008b5:	89 c7                	mov    %eax,%edi
f01008b7:	89 de                	mov    %ebx,%esi
f01008b9:	89 d1                	mov    %edx,%ecx
f01008bb:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008bd:	8d 95 dd f3 ff ff    	lea    -0xc23(%ebp),%edx
f01008c3:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f01008c8:	b0 00                	mov    $0x0,%al
f01008ca:	89 d7                	mov    %edx,%edi
f01008cc:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tcf1 3000";
f01008ce:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01008d4:	bb ec 36 12 f0       	mov    $0xf01236ec,%ebx
f01008d9:	ba 0e 00 00 00       	mov    $0xe,%edx
f01008de:	89 c7                	mov    %eax,%edi
f01008e0:	89 de                	mov    %ebx,%esi
f01008e2:	89 d1                	mov    %edx,%ecx
f01008e4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01008e6:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01008ec:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01008f1:	b0 00                	mov    $0x0,%al
f01008f3:	89 d7                	mov    %edx,%edi
f01008f5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd6[BUFLEN] = "run tcf2 10000";
f01008f7:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01008fd:	bb ec 3a 12 f0       	mov    $0xf0123aec,%ebx
f0100902:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100907:	89 c7                	mov    %eax,%edi
f0100909:	89 de                	mov    %ebx,%esi
f010090b:	89 d1                	mov    %edx,%ecx
f010090d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010090f:	8d 95 df fb ff ff    	lea    -0x421(%ebp),%edx
f0100915:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010091a:	b0 00                	mov    $0x0,%al
f010091c:	89 d7                	mov    %edx,%edi
f010091e:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd6);
			}
			//TEST: SHARED MEMORY	[PARTIAL GRADING]
			{
				char cmd0[BUFLEN] = "uhcustomfit";
f0100920:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100926:	bb ec 22 12 f0       	mov    $0xf01222ec,%ebx
f010092b:	ba 03 00 00 00       	mov    $0x3,%edx
f0100930:	89 c7                	mov    %eax,%edi
f0100932:	89 de                	mov    %ebx,%esi
f0100934:	89 d1                	mov    %edx,%ecx
f0100936:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100938:	8d 95 dc e7 ff ff    	lea    -0x1824(%ebp),%edx
f010093e:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100943:	b8 00 00 00 00       	mov    $0x0,%eax
f0100948:	89 d7                	mov    %edx,%edi
f010094a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "run tshr1 3000";
f010094c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100952:	bb ec 3e 12 f0       	mov    $0xf0123eec,%ebx
f0100957:	ba 0f 00 00 00       	mov    $0xf,%edx
f010095c:	89 c7                	mov    %eax,%edi
f010095e:	89 de                	mov    %ebx,%esi
f0100960:	89 d1                	mov    %edx,%ecx
f0100962:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100964:	8d 95 df eb ff ff    	lea    -0x1421(%ebp),%edx
f010096a:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f010096f:	b0 00                	mov    $0x0,%al
f0100971:	89 d7                	mov    %edx,%edi
f0100973:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd2[BUFLEN] = "run tshr2 3000";
f0100975:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f010097b:	bb ec 42 12 f0       	mov    $0xf01242ec,%ebx
f0100980:	ba 0f 00 00 00       	mov    $0xf,%edx
f0100985:	89 c7                	mov    %eax,%edi
f0100987:	89 de                	mov    %ebx,%esi
f0100989:	89 d1                	mov    %edx,%ecx
f010098b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f010098d:	8d 95 df ef ff ff    	lea    -0x1021(%ebp),%edx
f0100993:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f0100998:	b0 00                	mov    $0x0,%al
f010099a:	89 d7                	mov    %edx,%edi
f010099c:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd3[BUFLEN] = "run tshr3 3000";
f010099e:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f01009a4:	bb ec 46 12 f0       	mov    $0xf01246ec,%ebx
f01009a9:	ba 0f 00 00 00       	mov    $0xf,%edx
f01009ae:	89 c7                	mov    %eax,%edi
f01009b0:	89 de                	mov    %ebx,%esi
f01009b2:	89 d1                	mov    %edx,%ecx
f01009b4:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009b6:	8d 95 df f3 ff ff    	lea    -0xc21(%ebp),%edx
f01009bc:	b9 f1 03 00 00       	mov    $0x3f1,%ecx
f01009c1:	b0 00                	mov    $0x0,%al
f01009c3:	89 d7                	mov    %edx,%edi
f01009c5:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tcf3 3000";	//depend on USER HEAP (malloc, free)
f01009c7:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f01009cd:	bb ec 4a 12 f0       	mov    $0xf0124aec,%ebx
f01009d2:	ba 0e 00 00 00       	mov    $0xe,%edx
f01009d7:	89 c7                	mov    %eax,%edi
f01009d9:	89 de                	mov    %ebx,%esi
f01009db:	89 d1                	mov    %edx,%ecx
f01009dd:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01009df:	8d 95 de f7 ff ff    	lea    -0x822(%ebp),%edx
f01009e5:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f01009ea:	b0 00                	mov    $0x0,%al
f01009ec:	89 d7                	mov    %edx,%edi
f01009ee:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_protection 5000"; //[0/1 GRADING] [time limit: 3 mins]
f01009f0:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f01009f6:	bb ec 4e 12 f0       	mov    $0xf0124eec,%ebx
f01009fb:	ba 06 00 00 00       	mov    $0x6,%edx
f0100a00:	89 c7                	mov    %eax,%edi
f0100a02:	89 de                	mov    %ebx,%esi
f0100a04:	89 d1                	mov    %edx,%ecx
f0100a06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a08:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100a0e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100a13:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a18:	89 d7                	mov    %edx,%edi
f0100a1a:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);
			}
			//TEST: PRIORITY RR SCHEDULER
			{
				char cmd01[BUFLEN] = "schedPRIRR 10 40 1000";
f0100a1c:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100a22:	bb ec 52 12 f0       	mov    $0xf01252ec,%ebx
f0100a27:	ba 16 00 00 00       	mov    $0x16,%edx
f0100a2c:	89 c7                	mov    %eax,%edi
f0100a2e:	89 de                	mov    %ebx,%esi
f0100a30:	89 d1                	mov    %edx,%ecx
f0100a32:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a34:	8d 95 e6 eb ff ff    	lea    -0x141a(%ebp),%edx
f0100a3a:	b9 ea 03 00 00       	mov    $0x3ea,%ecx
f0100a3f:	b0 00                	mov    $0x0,%al
f0100a41:	89 d7                	mov    %edx,%edi
f0100a43:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd03[BUFLEN] = "schedPRIRR 10 40 20";
f0100a45:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100a4b:	bb ec 56 12 f0       	mov    $0xf01256ec,%ebx
f0100a50:	ba 05 00 00 00       	mov    $0x5,%edx
f0100a55:	89 c7                	mov    %eax,%edi
f0100a57:	89 de                	mov    %ebx,%esi
f0100a59:	89 d1                	mov    %edx,%ecx
f0100a5b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100a5d:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100a63:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100a68:	b8 00 00 00 00       	mov    $0x0,%eax
f0100a6d:	89 d7                	mov    %edx,%edi
f0100a6f:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd03);
				char cmdU1_1[BUFLEN] = "tst priorityRR 0";	//52 sec
f0100a71:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100a77:	bb ec 5a 12 f0       	mov    $0xf0125aec,%ebx
f0100a7c:	ba 11 00 00 00       	mov    $0x11,%edx
f0100a81:	89 c7                	mov    %eax,%edi
f0100a83:	89 de                	mov    %ebx,%esi
f0100a85:	89 d1                	mov    %edx,%ecx
f0100a87:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100a89:	8d 95 e1 f3 ff ff    	lea    -0xc1f(%ebp),%edx
f0100a8f:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100a94:	b0 00                	mov    $0x0,%al
f0100a96:	89 d7                	mov    %edx,%edi
f0100a98:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU2_1[BUFLEN] = "tst priorityRR 1";	//58 sec
f0100a9a:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100aa0:	bb ec 5e 12 f0       	mov    $0xf0125eec,%ebx
f0100aa5:	ba 11 00 00 00       	mov    $0x11,%edx
f0100aaa:	89 c7                	mov    %eax,%edi
f0100aac:	89 de                	mov    %ebx,%esi
f0100aae:	89 d1                	mov    %edx,%ecx
f0100ab0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100ab2:	8d 95 e1 f7 ff ff    	lea    -0x81f(%ebp),%edx
f0100ab8:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100abd:	b0 00                	mov    $0x0,%al
f0100abf:	89 d7                	mov    %edx,%edi
f0100ac1:	f3 aa                	rep stos %al,%es:(%edi)
				char cmdU3_1[BUFLEN] = "tst priorityRR 2";	//90 sec
f0100ac3:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100ac9:	bb ec 62 12 f0       	mov    $0xf01262ec,%ebx
f0100ace:	ba 11 00 00 00       	mov    $0x11,%edx
f0100ad3:	89 c7                	mov    %eax,%edi
f0100ad5:	89 de                	mov    %ebx,%esi
f0100ad7:	89 d1                	mov    %edx,%ecx
f0100ad9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100adb:	8d 95 e1 fb ff ff    	lea    -0x41f(%ebp),%edx
f0100ae1:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0100ae6:	b0 00                	mov    $0x0,%al
f0100ae8:	89 d7                	mov    %edx,%edi
f0100aea:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmdU3_1);
			}
			//TEST: PROTECTION
			{
				char cmd1[BUFLEN] = "run tst_chan_all 20";
f0100aec:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100af2:	bb ec 66 12 f0       	mov    $0xf01266ec,%ebx
f0100af7:	ba 05 00 00 00       	mov    $0x5,%edx
f0100afc:	89 c7                	mov    %eax,%edi
f0100afe:	89 de                	mov    %ebx,%esi
f0100b00:	89 d1                	mov    %edx,%ecx
f0100b02:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b04:	8d 95 e4 eb ff ff    	lea    -0x141c(%ebp),%edx
f0100b0a:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b0f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b14:	89 d7                	mov    %edx,%edi
f0100b16:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "run tst_chan_one 20";
f0100b18:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100b1e:	bb ec 6a 12 f0       	mov    $0xf0126aec,%ebx
f0100b23:	ba 05 00 00 00       	mov    $0x5,%edx
f0100b28:	89 c7                	mov    %eax,%edi
f0100b2a:	89 de                	mov    %ebx,%esi
f0100b2c:	89 d1                	mov    %edx,%ecx
f0100b2e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100b30:	8d 95 e4 ef ff ff    	lea    -0x101c(%ebp),%edx
f0100b36:	b9 fb 00 00 00       	mov    $0xfb,%ecx
f0100b3b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100b40:	89 d7                	mov    %edx,%edi
f0100b42:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "run tst_sleeplock 20";
f0100b44:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100b4a:	bb ec 6e 12 f0       	mov    $0xf0126eec,%ebx
f0100b4f:	ba 15 00 00 00       	mov    $0x15,%edx
f0100b54:	89 c7                	mov    %eax,%edi
f0100b56:	89 de                	mov    %ebx,%esi
f0100b58:	89 d1                	mov    %edx,%ecx
f0100b5a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b5c:	8d 95 e5 f3 ff ff    	lea    -0xc1b(%ebp),%edx
f0100b62:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100b67:	b0 00                	mov    $0x0,%al
f0100b69:	89 d7                	mov    %edx,%edi
f0100b6b:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd4[BUFLEN] = "run tst_ksem1 500";	//5 sec
f0100b6d:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100b73:	bb ec 72 12 f0       	mov    $0xf01272ec,%ebx
f0100b78:	ba 12 00 00 00       	mov    $0x12,%edx
f0100b7d:	89 c7                	mov    %eax,%edi
f0100b7f:	89 de                	mov    %ebx,%esi
f0100b81:	89 d1                	mov    %edx,%ecx
f0100b83:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100b85:	8d 95 e2 f7 ff ff    	lea    -0x81e(%ebp),%edx
f0100b8b:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100b90:	b0 00                	mov    $0x0,%al
f0100b92:	89 d7                	mov    %edx,%edi
f0100b94:	f3 aa                	rep stos %al,%es:(%edi)
				char cmd5[BUFLEN] = "run tst_ksem2 500";	//20 sec
f0100b96:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100b9c:	bb ec 76 12 f0       	mov    $0xf01276ec,%ebx
f0100ba1:	ba 12 00 00 00       	mov    $0x12,%edx
f0100ba6:	89 c7                	mov    %eax,%edi
f0100ba8:	89 de                	mov    %ebx,%esi
f0100baa:	89 d1                	mov    %edx,%ecx
f0100bac:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bae:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100bb4:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100bb9:	b0 00                	mov    $0x0,%al
f0100bbb:	89 d7                	mov    %edx,%edi
f0100bbd:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd5);
			}
			//TEST#X: BONUS - DA: BLOCK IF NO BLOCK
			{
				char cmd1[BUFLEN] = "run tst_da_block 500";
f0100bbf:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100bc5:	bb ec 7a 12 f0       	mov    $0xf0127aec,%ebx
f0100bca:	ba 15 00 00 00       	mov    $0x15,%edx
f0100bcf:	89 c7                	mov    %eax,%edi
f0100bd1:	89 de                	mov    %ebx,%esi
f0100bd3:	89 d1                	mov    %edx,%ecx
f0100bd5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100bd7:	8d 95 e5 fb ff ff    	lea    -0x41b(%ebp),%edx
f0100bdd:	b9 eb 03 00 00       	mov    $0x3eb,%ecx
f0100be2:	b0 00                	mov    $0x0,%al
f0100be4:	89 d7                	mov    %edx,%edi
f0100be6:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - KREALLOC
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100be8:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100bee:	bb ec 7e 12 f0       	mov    $0xf0127eec,%ebx
f0100bf3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100bf8:	89 c7                	mov    %eax,%edi
f0100bfa:	89 de                	mov    %ebx,%esi
f0100bfc:	89 d1                	mov    %edx,%ecx
f0100bfe:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c00:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100c06:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100c0b:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c10:	89 d7                	mov    %edx,%edi
f0100c12:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF krealloc 1";
f0100c14:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100c1a:	bb ec 82 12 f0       	mov    $0xf01282ec,%ebx
f0100c1f:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c24:	89 c7                	mov    %eax,%edi
f0100c26:	89 de                	mov    %ebx,%esi
f0100c28:	89 d1                	mov    %edx,%ecx
f0100c2a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c2c:	8d 95 e8 f3 ff ff    	lea    -0xc18(%ebp),%edx
f0100c32:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c37:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c3c:	89 d7                	mov    %edx,%edi
f0100c3e:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd2[BUFLEN] = "tst kheap CF krealloc 2";
f0100c40:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c46:	bb ec 86 12 f0       	mov    $0xf01286ec,%ebx
f0100c4b:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c50:	89 c7                	mov    %eax,%edi
f0100c52:	89 de                	mov    %ebx,%esi
f0100c54:	89 d1                	mov    %edx,%ecx
f0100c56:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c58:	8d 95 e8 f7 ff ff    	lea    -0x818(%ebp),%edx
f0100c5e:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c63:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c68:	89 d7                	mov    %edx,%edi
f0100c6a:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd3[BUFLEN] = "tst kheap CF krealloc 3";
f0100c6c:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100c72:	bb ec 8a 12 f0       	mov    $0xf0128aec,%ebx
f0100c77:	ba 06 00 00 00       	mov    $0x6,%edx
f0100c7c:	89 c7                	mov    %eax,%edi
f0100c7e:	89 de                	mov    %ebx,%esi
f0100c80:	89 d1                	mov    %edx,%ecx
f0100c82:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100c84:	8d 95 e8 fb ff ff    	lea    -0x418(%ebp),%edx
f0100c8a:	b9 fa 00 00 00       	mov    $0xfa,%ecx
f0100c8f:	b8 00 00 00 00       	mov    $0x0,%eax
f0100c94:	89 d7                	mov    %edx,%edi
f0100c96:	f3 ab                	rep stos %eax,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - FAST PAGE ALLOCATOR
			{
				char cmd0[BUFLEN] = "khcustomfit";
f0100c98:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100c9e:	bb ec 7e 12 f0       	mov    $0xf0127eec,%ebx
f0100ca3:	ba 03 00 00 00       	mov    $0x3,%edx
f0100ca8:	89 c7                	mov    %eax,%edi
f0100caa:	89 de                	mov    %ebx,%esi
f0100cac:	89 d1                	mov    %edx,%ecx
f0100cae:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100cb0:	8d 95 dc f7 ff ff    	lea    -0x824(%ebp),%edx
f0100cb6:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100cbb:	b8 00 00 00 00       	mov    $0x0,%eax
f0100cc0:	89 d7                	mov    %edx,%edi
f0100cc2:	f3 ab                	rep stos %eax,%es:(%edi)
				char cmd1[BUFLEN] = "tst kheap CF fast"; //[0/1 GRADING] [time limit: 10 secs]
f0100cc4:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100cca:	bb ec 8e 12 f0       	mov    $0xf0128eec,%ebx
f0100ccf:	ba 12 00 00 00       	mov    $0x12,%edx
f0100cd4:	89 c7                	mov    %eax,%edi
f0100cd6:	89 de                	mov    %ebx,%esi
f0100cd8:	89 d1                	mov    %edx,%ecx
f0100cda:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100cdc:	8d 95 e2 fb ff ff    	lea    -0x41e(%ebp),%edx
f0100ce2:	b9 ee 03 00 00       	mov    $0x3ee,%ecx
f0100ce7:	b0 00                	mov    $0x0,%al
f0100ce9:	89 d7                	mov    %edx,%edi
f0100ceb:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd1);
			}
			//TEST#X: BONUS - EXIT
			{
				char cmd0[BUFLEN] = "fifo";
f0100ced:	c7 85 d0 e3 ff ff 66 	movl   $0x6f666966,-0x1c30(%ebp)
f0100cf4:	69 66 6f 
f0100cf7:	c7 85 d4 e3 ff ff 00 	movl   $0x0,-0x1c2c(%ebp)
f0100cfe:	00 00 00 
f0100d01:	8d 95 d8 e3 ff ff    	lea    -0x1c28(%ebp),%edx
f0100d07:	b9 fe 00 00 00       	mov    $0xfe,%ecx
f0100d0c:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d11:	89 d7                	mov    %edx,%edi
f0100d13:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 1: without using dynamic allocation/de-allocation [PLACEMENT]
				char cmd1[BUFLEN] = "run tef1 100";
f0100d15:	8d 85 d0 e7 ff ff    	lea    -0x1830(%ebp),%eax
f0100d1b:	bb ec 92 12 f0       	mov    $0xf01292ec,%ebx
f0100d20:	ba 0d 00 00 00       	mov    $0xd,%edx
f0100d25:	89 c7                	mov    %eax,%edi
f0100d27:	89 de                	mov    %ebx,%esi
f0100d29:	89 d1                	mov    %edx,%ecx
f0100d2b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100d2d:	8d 95 dd e7 ff ff    	lea    -0x1823(%ebp),%edx
f0100d33:	b9 f3 03 00 00       	mov    $0x3f3,%ecx
f0100d38:	b0 00                	mov    $0x0,%al
f0100d3a:	89 d7                	mov    %edx,%edi
f0100d3c:	f3 aa                	rep stos %al,%es:(%edi)
				//Scenario 2: using dynamic allocation and free [REPLACEMENT]
				char cmd2[BUFLEN] = "run tef2 20";
f0100d3e:	8d 85 d0 eb ff ff    	lea    -0x1430(%ebp),%eax
f0100d44:	bb ec 96 12 f0       	mov    $0xf01296ec,%ebx
f0100d49:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d4e:	89 c7                	mov    %eax,%edi
f0100d50:	89 de                	mov    %ebx,%esi
f0100d52:	89 d1                	mov    %edx,%ecx
f0100d54:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d56:	8d 95 dc eb ff ff    	lea    -0x1424(%ebp),%edx
f0100d5c:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d61:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d66:	89 d7                	mov    %edx,%edi
f0100d68:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario3: using dynamic allocation and free [process kill itself] [REPLACEMENT]
				char cmd3[BUFLEN] = "run tef3 20";
f0100d6a:	8d 85 d0 ef ff ff    	lea    -0x1030(%ebp),%eax
f0100d70:	bb ec 9a 12 f0       	mov    $0xf0129aec,%ebx
f0100d75:	ba 03 00 00 00       	mov    $0x3,%edx
f0100d7a:	89 c7                	mov    %eax,%edi
f0100d7c:	89 de                	mov    %ebx,%esi
f0100d7e:	89 d1                	mov    %edx,%ecx
f0100d80:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100d82:	8d 95 dc ef ff ff    	lea    -0x1024(%ebp),%edx
f0100d88:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100d8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0100d92:	89 d7                	mov    %edx,%edi
f0100d94:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 4: using create & get of shared variables [REPLACEMENT]
				char cmd4[BUFLEN] = "run tef4 10";
f0100d96:	8d 85 d0 f3 ff ff    	lea    -0xc30(%ebp),%eax
f0100d9c:	bb ec 9e 12 f0       	mov    $0xf0129eec,%ebx
f0100da1:	ba 03 00 00 00       	mov    $0x3,%edx
f0100da6:	89 c7                	mov    %eax,%edi
f0100da8:	89 de                	mov    %ebx,%esi
f0100daa:	89 d1                	mov    %edx,%ecx
f0100dac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dae:	8d 95 dc f3 ff ff    	lea    -0xc24(%ebp),%edx
f0100db4:	b9 fd 00 00 00       	mov    $0xfd,%ecx
f0100db9:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dbe:	89 d7                	mov    %edx,%edi
f0100dc0:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 5: using create, get and free shared variables by the created environment itself before calling env_free [PLACEMENT]
				char cmd5[BUFLEN] = "run tef5_2 3000";
f0100dc2:	8d 85 d0 f7 ff ff    	lea    -0x830(%ebp),%eax
f0100dc8:	bb ec a2 12 f0       	mov    $0xf012a2ec,%ebx
f0100dcd:	ba 04 00 00 00       	mov    $0x4,%edx
f0100dd2:	89 c7                	mov    %eax,%edi
f0100dd4:	89 de                	mov    %ebx,%esi
f0100dd6:	89 d1                	mov    %edx,%ecx
f0100dd8:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0100dda:	8d 95 e0 f7 ff ff    	lea    -0x820(%ebp),%edx
f0100de0:	b9 fc 00 00 00       	mov    $0xfc,%ecx
f0100de5:	b8 00 00 00 00       	mov    $0x0,%eax
f0100dea:	89 d7                	mov    %edx,%edi
f0100dec:	f3 ab                	rep stos %eax,%es:(%edi)
				//Scenario 6: using shared variables and semaphores together [PLACEMENT]
				char cmd6[BUFLEN] = "run tef6 3000";
f0100dee:	8d 85 d0 fb ff ff    	lea    -0x430(%ebp),%eax
f0100df4:	bb ec a6 12 f0       	mov    $0xf012a6ec,%ebx
f0100df9:	ba 0e 00 00 00       	mov    $0xe,%edx
f0100dfe:	89 c7                	mov    %eax,%edi
f0100e00:	89 de                	mov    %ebx,%esi
f0100e02:	89 d1                	mov    %edx,%ecx
f0100e04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0100e06:	8d 95 de fb ff ff    	lea    -0x422(%ebp),%edx
f0100e0c:	b9 f2 03 00 00       	mov    $0x3f2,%ecx
f0100e11:	b0 00                	mov    $0x0,%al
f0100e13:	89 d7                	mov    %edx,%edi
f0100e15:	f3 aa                	rep stos %al,%es:(%edi)
				//execute_command(cmd0);
				//execute_command(cmd5);

			}

			cprintf("PROJECT Automatic testing is ENDED\n") ;
f0100e17:	83 ec 0c             	sub    $0xc,%esp
f0100e1a:	68 c8 be 11 f0       	push   $0xf011bec8
f0100e1f:	e8 38 0e 00 00       	call   f0101c5c <cprintf>
f0100e24:	83 c4 10             	add    $0x10,%esp
			__autograde__ = 0;
f0100e27:	c7 05 20 f0 17 f0 00 	movl   $0x0,0xf017f020
f0100e2e:	00 00 00 
		}
		get_into_prompt();
f0100e31:	e8 ac 0f 00 00       	call   f0101de2 <get_into_prompt>

f0100e36 <print_welcome_message>:
	}
}


void print_welcome_message()
{
f0100e36:	55                   	push   %ebp
f0100e37:	89 e5                	mov    %esp,%ebp
f0100e39:	83 ec 08             	sub    $0x8,%esp
    cprintf("\n\n\n");
f0100e3c:	83 ec 0c             	sub    $0xc,%esp
f0100e3f:	68 ec aa 12 f0       	push   $0xf012aaec
f0100e44:	e8 13 0e 00 00       	call   f0101c5c <cprintf>
f0100e49:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e4c:	83 ec 0c             	sub    $0xc,%esp
f0100e4f:	68 f0 aa 12 f0       	push   $0xf012aaf0
f0100e54:	e8 03 0e 00 00       	call   f0101c5c <cprintf>
f0100e59:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!                                                             !!\n");
f0100e5c:	83 ec 0c             	sub    $0xc,%esp
f0100e5f:	68 54 ab 12 f0       	push   $0xf012ab54
f0100e64:	e8 f3 0d 00 00       	call   f0101c5c <cprintf>
f0100e69:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!                   !! FCIS says HELLO !!                     !!\n");
f0100e6c:	83 ec 0c             	sub    $0xc,%esp
f0100e6f:	68 b8 ab 12 f0       	push   $0xf012abb8
f0100e74:	e8 e3 0d 00 00       	call   f0101c5c <cprintf>
f0100e79:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!                                                             !!\n");
f0100e7c:	83 ec 0c             	sub    $0xc,%esp
f0100e7f:	68 1c ac 12 f0       	push   $0xf012ac1c
f0100e84:	e8 d3 0d 00 00       	call   f0101c5c <cprintf>
f0100e89:	83 c4 10             	add    $0x10,%esp
    cprintf("\t\t!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
f0100e8c:	83 ec 0c             	sub    $0xc,%esp
f0100e8f:	68 80 ac 12 f0       	push   $0xf012ac80
f0100e94:	e8 c3 0d 00 00       	call   f0101c5c <cprintf>
f0100e99:	83 c4 10             	add    $0x10,%esp
    cprintf("\n\n\n\n");
f0100e9c:	83 ec 0c             	sub    $0xc,%esp
f0100e9f:	68 e4 ac 12 f0       	push   $0xf012ace4
f0100ea4:	e8 b3 0d 00 00       	call   f0101c5c <cprintf>
f0100ea9:	83 c4 10             	add    $0x10,%esp
}
f0100eac:	83 ec 0c             	sub    $0xc,%esp
f0100eaf:	68 48 ad 12 f0       	push   $0xf012ad48
f0100eb4:	e8 a3 0d 00 00       	call   f0101c5c <cprintf>
f0100eb9:	83 c4 10             	add    $0x10,%esp

f0100ebc:	83 ec 0c             	sub    $0xc,%esp
f0100ebf:	68 ac ad 12 f0       	push   $0xf012adac
f0100ec4:	e8 93 0d 00 00       	call   f0101c5c <cprintf>
f0100ec9:	83 c4 10             	add    $0x10,%esp

f0100ecc:	83 ec 0c             	sub    $0xc,%esp
f0100ecf:	68 10 ae 12 f0       	push   $0xf012ae10
f0100ed4:	e8 83 0d 00 00       	call   f0101c5c <cprintf>
f0100ed9:	83 c4 10             	add    $0x10,%esp
/*
f0100edc:	83 ec 0c             	sub    $0xc,%esp
f0100edf:	68 74 ae 12 f0       	push   $0xf012ae74
f0100ee4:	e8 73 0d 00 00       	call   f0101c5c <cprintf>
f0100ee9:	83 c4 10             	add    $0x10,%esp
 * Variable panicstr contains argument to first call to panic; used as flag
f0100eec:	83 ec 0c             	sub    $0xc,%esp
f0100eef:	68 d8 ae 12 f0       	push   $0xf012aed8
f0100ef4:	e8 63 0d 00 00       	call   f0101c5c <cprintf>
f0100ef9:	83 c4 10             	add    $0x10,%esp
 * to indicate that the kernel has already called panic.
f0100efc:	83 ec 0c             	sub    $0xc,%esp
f0100eff:	68 3c af 12 f0       	push   $0xf012af3c
f0100f04:	e8 53 0d 00 00       	call   f0101c5c <cprintf>
f0100f09:	83 c4 10             	add    $0x10,%esp
 */
f0100f0c:	83 ec 0c             	sub    $0xc,%esp
f0100f0f:	68 a0 af 12 f0       	push   $0xf012afa0
f0100f14:	e8 43 0d 00 00       	call   f0101c5c <cprintf>
f0100f19:	83 c4 10             	add    $0x10,%esp
static const char *panicstr;
f0100f1c:	83 ec 0c             	sub    $0xc,%esp
f0100f1f:	68 04 b0 12 f0       	push   $0xf012b004
f0100f24:	e8 33 0d 00 00       	call   f0101c5c <cprintf>
f0100f29:	83 c4 10             	add    $0x10,%esp

f0100f2c:	83 ec 0c             	sub    $0xc,%esp
f0100f2f:	68 68 b0 12 f0       	push   $0xf012b068
f0100f34:	e8 23 0d 00 00       	call   f0101c5c <cprintf>
f0100f39:	83 c4 10             	add    $0x10,%esp
/*
f0100f3c:	83 ec 0c             	sub    $0xc,%esp
f0100f3f:	68 cc b0 12 f0       	push   $0xf012b0cc
f0100f44:	e8 13 0d 00 00       	call   f0101c5c <cprintf>
f0100f49:	83 c4 10             	add    $0x10,%esp
 * Panic is called on unresolvable fatal errors.
f0100f4c:	83 ec 0c             	sub    $0xc,%esp
f0100f4f:	68 30 b1 12 f0       	push   $0xf012b130
f0100f54:	e8 03 0d 00 00       	call   f0101c5c <cprintf>
f0100f59:	83 c4 10             	add    $0x10,%esp
 * It prints "panic: mesg", exit the curenv and schedule the next environment.
f0100f5c:	83 ec 0c             	sub    $0xc,%esp
f0100f5f:	68 58 b1 12 f0       	push   $0xf012b158
f0100f64:	e8 f3 0c 00 00       	call   f0101c5c <cprintf>
f0100f69:	83 c4 10             	add    $0x10,%esp
 */
f0100f6c:	83 ec 0c             	sub    $0xc,%esp
f0100f6f:	68 80 b1 12 f0       	push   $0xf012b180
f0100f74:	e8 e3 0c 00 00       	call   f0101c5c <cprintf>
f0100f79:	83 c4 10             	add    $0x10,%esp
void _panic(const char *file, int line, const char *fmt,...)
f0100f7c:	83 ec 0c             	sub    $0xc,%esp
f0100f7f:	68 58 b1 12 f0       	push   $0xf012b158
f0100f84:	e8 d3 0c 00 00       	call   f0101c5c <cprintf>
f0100f89:	83 c4 10             	add    $0x10,%esp
{
f0100f8c:	83 ec 0c             	sub    $0xc,%esp
f0100f8f:	68 30 b1 12 f0       	push   $0xf012b130
f0100f94:	e8 c3 0c 00 00       	call   f0101c5c <cprintf>
f0100f99:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f0100f9c:	83 ec 0c             	sub    $0xc,%esp
f0100f9f:	68 a5 b1 12 f0       	push   $0xf012b1a5
f0100fa4:	e8 b3 0c 00 00       	call   f0101c5c <cprintf>
f0100fa9:	83 c4 10             	add    $0x10,%esp

f0100fac:	90                   	nop
f0100fad:	c9                   	leave  
f0100fae:	c3                   	ret    

f0100faf <_panic>:
	vcprintf(fmt, ap);
	cprintf("\n");
	va_end(ap);

	dead:
	/* break into the fos scheduler */
f0100faf:	55                   	push   %ebp
f0100fb0:	89 e5                	mov    %esp,%ebp
f0100fb2:	83 ec 18             	sub    $0x18,%esp
	//2013: Check if the panic occur when running an environment
f0100fb5:	e8 5e ab 00 00       	call   f010bb18 <get_cpu_proc>
f0100fba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
	{
		//cprintf("\n>>>>>>>>>>> exiting the cur env<<<<<<<<<<<<\n");
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
	}
f0100fbd:	8b 45 10             	mov    0x10(%ebp),%eax
f0100fc0:	a3 40 59 81 f0       	mov    %eax,0xf0815940
	//else //2024: panic from Kernel and no current running env
	{
f0100fc5:	8d 45 10             	lea    0x10(%ebp),%eax
f0100fc8:	83 c0 04             	add    $0x4,%eax
f0100fcb:	89 45 f0             	mov    %eax,-0x10(%ebp)
		char* esp = (char*)read_esp();
f0100fce:	ff 75 0c             	pushl  0xc(%ebp)
f0100fd1:	ff 75 08             	pushl  0x8(%ebp)
f0100fd4:	68 a8 b1 12 f0       	push   $0xf012b1a8
f0100fd9:	6a 74                	push   $0x74
f0100fdb:	e8 ac 0c 00 00       	call   f0101c8c <cprintf_colored>
f0100fe0:	83 c4 10             	add    $0x10,%esp
		cprintf("esp = %x\n", esp);
f0100fe3:	8b 45 10             	mov    0x10(%ebp),%eax
f0100fe6:	83 ec 08             	sub    $0x8,%esp
f0100fe9:	ff 75 f0             	pushl  -0x10(%ebp)
f0100fec:	50                   	push   %eax
f0100fed:	e8 41 0c 00 00       	call   f0101c33 <vcprintf>
f0100ff2:	83 c4 10             	add    $0x10,%esp
		//			//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
f0100ff5:	83 ec 0c             	sub    $0xc,%esp
f0100ff8:	68 a5 b1 12 f0       	push   $0xf012b1a5
f0100ffd:	e8 5a 0c 00 00       	call   f0101c5c <cprintf>
f0101002:	83 c4 10             	add    $0x10,%esp
		//			assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//					(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;

		get_into_prompt();
	}

f0101005:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101009:	74 10                	je     f010101b <_panic+0x6c>
f010100b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010100e:	8b 40 18             	mov    0x18(%eax),%eax
f0101011:	83 f8 02             	cmp    $0x2,%eax
f0101014:	75 05                	jne    f010101b <_panic+0x6c>
}

/*
 * Panic is called on unresolvable fatal errors.
f0101016:	e8 bb aa 00 00       	call   f010bad6 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f010101b:	89 e0                	mov    %esp,%eax
f010101d:	89 45 e8             	mov    %eax,-0x18(%ebp)
        return esp;
f0101020:	8b 45 e8             	mov    -0x18(%ebp),%eax
 * It prints "panic: mesg", exit all env's and then enters the kernel command prompt.
 */
void _panic_all(const char *file, int line, const char *fmt,...)
{
f0101023:	89 45 ec             	mov    %eax,-0x14(%ebp)
	va_list ap;
f0101026:	83 ec 08             	sub    $0x8,%esp
f0101029:	ff 75 ec             	pushl  -0x14(%ebp)
f010102c:	68 cd b1 12 f0       	push   $0xf012b1cd
f0101031:	e8 26 0c 00 00       	call   f0101c5c <cprintf>
f0101036:	83 c4 10             	add    $0x10,%esp

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;

f0101039:	e8 a4 0d 00 00       	call   f0101de2 <get_into_prompt>

f010103e <_panic_all>:
	va_end(ap);

	dead:
	/* break into the command prompt */
	pushcli();
	struct cpu *c = mycpu();
f010103e:	55                   	push   %ebp
f010103f:	89 e5                	mov    %esp,%ebp
f0101041:	83 ec 28             	sub    $0x28,%esp
	int sched_stat = c->scheduler_status;
	popcli();
	/*2022*///Check if the scheduler is successfully initialized or not
	if (sched_stat != SCH_UNINITIALIZED)
	{
f0101044:	8b 45 10             	mov    0x10(%ebp),%eax
f0101047:	a3 40 59 81 f0       	mov    %eax,0xf0815940
		//exit all ready env's
		sched_exit_all_ready_envs();
f010104c:	8d 45 10             	lea    0x10(%ebp),%eax
f010104f:	83 c0 04             	add    $0x4,%eax
f0101052:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* cur_env = get_cpu_proc();
f0101055:	ff 75 0c             	pushl  0xc(%ebp)
f0101058:	ff 75 08             	pushl  0x8(%ebp)
f010105b:	68 d7 b1 12 f0       	push   $0xf012b1d7
f0101060:	6a 74                	push   $0x74
f0101062:	e8 25 0c 00 00       	call   f0101c8c <cprintf_colored>
f0101067:	83 c4 10             	add    $0x10,%esp
		if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
f010106a:	8b 45 10             	mov    0x10(%ebp),%eax
f010106d:	83 ec 08             	sub    $0x8,%esp
f0101070:	ff 75 f4             	pushl  -0xc(%ebp)
f0101073:	50                   	push   %eax
f0101074:	e8 ba 0b 00 00       	call   f0101c33 <vcprintf>
f0101079:	83 c4 10             	add    $0x10,%esp
		{
f010107c:	83 ec 0c             	sub    $0xc,%esp
f010107f:	68 a5 b1 12 f0       	push   $0xf012b1a5
f0101084:	e8 d3 0b 00 00       	call   f0101c5c <cprintf>
f0101089:	83 c4 10             	add    $0x10,%esp
			//cprintf("exit curenv...........\n");
			//Place the running env into the exit queue then switch to the scheduler
			env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
		}
		//		cprintf("scheduler_status=%d\n", scheduler_status);
f010108c:	e8 9f 70 00 00       	call   f0108130 <pushcli>
		//		fos_scheduler();
f0101091:	e8 da 6f 00 00       	call   f0108070 <mycpu>
f0101096:	89 45 f0             	mov    %eax,-0x10(%ebp)
	}
f0101099:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010109c:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f01010a2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//else //2024: panic from Kernel and no current running env
f01010a5:	e8 d8 70 00 00       	call   f0108182 <popcli>
	{
		//2024: make sure that the SP points to the kernel stack (either the one above KERN_BASE or below it)
f01010aa:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
f01010ae:	74 23                	je     f01010d3 <_panic_all+0x95>
		char* esp = (char*)read_esp();
		//		assert((esp < ptr_stack_top && esp >= ptr_stack_bottom) ||
		//				(esp < (char*)SCHD_KERN_STACK_TOP && esp >= (char*)SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE)) ;
f01010b0:	e8 a1 64 00 00       	call   f0107556 <sched_exit_all_ready_envs>

f01010b5:	e8 5e aa 00 00       	call   f010bb18 <get_cpu_proc>
f01010ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
		get_into_prompt();
f01010bd:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01010c1:	74 10                	je     f01010d3 <_panic_all+0x95>
f01010c3:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01010c6:	8b 40 18             	mov    0x18(%eax),%eax
f01010c9:	83 f8 02             	cmp    $0x2,%eax
f01010cc:	75 05                	jne    f01010d3 <_panic_all+0x95>

	}
}

f01010ce:	e8 03 aa 00 00       	call   f010bad6 <env_exit>

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f01010d3:	89 e0                	mov    %esp,%eax
f01010d5:	89 45 e0             	mov    %eax,-0x20(%ebp)
        return esp;
f01010d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: mesg", exit the curenv (if any) and break into the command prompt.
 */
void _panic_into_prompt(const char *file, int line, const char *fmt,...)
{
	va_list ap;
f01010db:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	//if (panicstr)
	//	goto dead;
	panicstr = fmt;
f01010de:	e8 ff 0c 00 00       	call   f0101de2 <get_into_prompt>

f01010e3 <_panic_into_prompt>:
	va_end(ap);

	//	dead:
	/* break into the fos scheduler */
	//2013: Check if the panic occur when running an environment
	struct Env* cur_env = get_cpu_proc();
f01010e3:	55                   	push   %ebp
f01010e4:	89 e5                	mov    %esp,%ebp
f01010e6:	83 ec 18             	sub    $0x18,%esp
	if (cur_env != NULL && cur_env->env_status == ENV_RUNNING)
	{
		//Place the running env into the exit queue then switch to the scheduler
		env_exit(); //env_exit --> sched_exit_env --> sched --> context_switch into fos_scheduler
	}
f01010e9:	8b 45 10             	mov    0x10(%ebp),%eax
f01010ec:	a3 40 59 81 f0       	mov    %eax,0xf0815940

	get_into_prompt();
f01010f1:	8d 45 10             	lea    0x10(%ebp),%eax
f01010f4:	83 c0 04             	add    $0x4,%eax
f01010f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

f01010fa:	ff 75 0c             	pushl  0xc(%ebp)
f01010fd:	ff 75 08             	pushl  0x8(%ebp)
f0101100:	68 d7 b1 12 f0       	push   $0xf012b1d7
f0101105:	6a 74                	push   $0x74
f0101107:	e8 80 0b 00 00       	call   f0101c8c <cprintf_colored>
f010110c:	83 c4 10             	add    $0x10,%esp
}
f010110f:	8b 45 10             	mov    0x10(%ebp),%eax
f0101112:	83 ec 08             	sub    $0x8,%esp
f0101115:	ff 75 f4             	pushl  -0xc(%ebp)
f0101118:	50                   	push   %eax
f0101119:	e8 15 0b 00 00       	call   f0101c33 <vcprintf>
f010111e:	83 c4 10             	add    $0x10,%esp

f0101121:	83 ec 0c             	sub    $0xc,%esp
f0101124:	68 a5 b1 12 f0       	push   $0xf012b1a5
f0101129:	e8 2e 0b 00 00       	call   f0101c5c <cprintf>
f010112e:	83 c4 10             	add    $0x10,%esp
/* like panic, but don't enters the kernel command prompt*/
void _warn(const char *file, int line, const char *fmt,...)
{
	va_list ap;

	va_start(ap, fmt);
f0101131:	e8 e2 a9 00 00       	call   f010bb18 <get_cpu_proc>
f0101136:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf_colored(TEXT_WARN_CLR, "\nkernel warning at %s:%d: ", file, line);
f0101139:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010113d:	74 10                	je     f010114f <_panic_into_prompt+0x6c>
f010113f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101142:	8b 40 18             	mov    0x18(%eax),%eax
f0101145:	83 f8 02             	cmp    $0x2,%eax
f0101148:	75 05                	jne    f010114f <_panic_into_prompt+0x6c>
	vcprintf(fmt, ap);
	cprintf("\n");
	va_end(ap);
f010114a:	e8 87 a9 00 00       	call   f010bad6 <env_exit>
}


f010114f:	e8 8e 0c 00 00       	call   f0101de2 <get_into_prompt>

f0101154 <_warn>:
f0101154:	55                   	push   %ebp
f0101155:	89 e5                	mov    %esp,%ebp
f0101157:	83 ec 18             	sub    $0x18,%esp
f010115a:	8d 45 10             	lea    0x10(%ebp),%eax
f010115d:	83 c0 04             	add    $0x4,%eax
f0101160:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101163:	ff 75 0c             	pushl  0xc(%ebp)
f0101166:	ff 75 08             	pushl  0x8(%ebp)
f0101169:	68 f0 b1 12 f0       	push   $0xf012b1f0
f010116e:	6a 7e                	push   $0x7e
f0101170:	e8 17 0b 00 00       	call   f0101c8c <cprintf_colored>
f0101175:	83 c4 10             	add    $0x10,%esp
f0101178:	8b 45 10             	mov    0x10(%ebp),%eax
f010117b:	83 ec 08             	sub    $0x8,%esp
f010117e:	ff 75 f4             	pushl  -0xc(%ebp)
f0101181:	50                   	push   %eax
f0101182:	e8 ac 0a 00 00       	call   f0101c33 <vcprintf>
f0101187:	83 c4 10             	add    $0x10,%esp
f010118a:	83 ec 0c             	sub    $0xc,%esp
f010118d:	68 a5 b1 12 f0       	push   $0xf012b1a5
f0101192:	e8 c5 0a 00 00       	call   f0101c5c <cprintf>
f0101197:	83 c4 10             	add    $0x10,%esp
f010119a:	90                   	nop
f010119b:	c9                   	leave  
f010119c:	c3                   	ret    

f010119d <serial_proc_data>:

static bool serial_exists;

int
serial_proc_data(void)
{
f010119d:	55                   	push   %ebp
f010119e:	89 e5                	mov    %esp,%ebp
f01011a0:	83 ec 10             	sub    $0x10,%esp
f01011a3:	c7 45 f8 fd 03 00 00 	movl   $0x3fd,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011aa:	8b 45 f8             	mov    -0x8(%ebp),%eax
f01011ad:	89 c2                	mov    %eax,%edx
f01011af:	ec                   	in     (%dx),%al
f01011b0:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f01011b3:	8a 45 f7             	mov    -0x9(%ebp),%al
	if (!(inb(COM1+COM_LSR) & COM_LSR_DATA))
f01011b6:	0f b6 c0             	movzbl %al,%eax
f01011b9:	83 e0 01             	and    $0x1,%eax
f01011bc:	85 c0                	test   %eax,%eax
f01011be:	75 07                	jne    f01011c7 <serial_proc_data+0x2a>
		return -1;
f01011c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f01011c5:	eb 16                	jmp    f01011dd <serial_proc_data+0x40>
f01011c7:	c7 45 fc f8 03 00 00 	movl   $0x3f8,-0x4(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01011ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01011d1:	89 c2                	mov    %eax,%edx
f01011d3:	ec                   	in     (%dx),%al
f01011d4:	88 45 f6             	mov    %al,-0xa(%ebp)
	return data;
f01011d7:	8a 45 f6             	mov    -0xa(%ebp),%al
	return inb(COM1+COM_RX);
f01011da:	0f b6 c0             	movzbl %al,%eax
}
f01011dd:	c9                   	leave  
f01011de:	c3                   	ret    

f01011df <serial_intr>:

void
serial_intr(void)
{
f01011df:	55                   	push   %ebp
f01011e0:	89 e5                	mov    %esp,%ebp
f01011e2:	83 ec 08             	sub    $0x8,%esp
	if (serial_exists)
f01011e5:	a1 64 59 81 f0       	mov    0xf0815964,%eax
f01011ea:	85 c0                	test   %eax,%eax
f01011ec:	74 10                	je     f01011fe <serial_intr+0x1f>
		cons_intr(serial_proc_data);
f01011ee:	83 ec 0c             	sub    $0xc,%esp
f01011f1:	68 9d 11 10 f0       	push   $0xf010119d
f01011f6:	e8 ae 07 00 00       	call   f01019a9 <cons_intr>
f01011fb:	83 c4 10             	add    $0x10,%esp
}
f01011fe:	90                   	nop
f01011ff:	c9                   	leave  
f0101200:	c3                   	ret    

f0101201 <serial_interrupt_handler>:

void serial_interrupt_handler(struct Trapframe* tf)
{
f0101201:	55                   	push   %ebp
f0101202:	89 e5                	mov    %esp,%ebp
f0101204:	83 ec 08             	sub    $0x8,%esp
	cprintf("\nserial interrupt\n");
f0101207:	83 ec 0c             	sub    $0xc,%esp
f010120a:	68 0c b2 12 f0       	push   $0xf012b20c
f010120f:	e8 48 0a 00 00       	call   f0101c5c <cprintf>
f0101214:	83 c4 10             	add    $0x10,%esp
	serial_intr();
f0101217:	e8 c3 ff ff ff       	call   f01011df <serial_intr>
}
f010121c:	90                   	nop
f010121d:	c9                   	leave  
f010121e:	c3                   	ret    

f010121f <serial_init>:

void
serial_init(void)
{
f010121f:	55                   	push   %ebp
f0101220:	89 e5                	mov    %esp,%ebp
f0101222:	83 ec 48             	sub    $0x48,%esp
f0101225:	c7 45 f4 fa 03 00 00 	movl   $0x3fa,-0xc(%ebp)
f010122c:	c6 45 c6 00          	movb   $0x0,-0x3a(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101230:	8a 45 c6             	mov    -0x3a(%ebp),%al
f0101233:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101236:	ee                   	out    %al,(%dx)
f0101237:	c7 45 f0 fb 03 00 00 	movl   $0x3fb,-0x10(%ebp)
f010123e:	c6 45 c7 80          	movb   $0x80,-0x39(%ebp)
f0101242:	8a 45 c7             	mov    -0x39(%ebp),%al
f0101245:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0101248:	ee                   	out    %al,(%dx)
f0101249:	c7 45 ec f8 03 00 00 	movl   $0x3f8,-0x14(%ebp)
f0101250:	c6 45 c8 0c          	movb   $0xc,-0x38(%ebp)
f0101254:	8a 45 c8             	mov    -0x38(%ebp),%al
f0101257:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010125a:	ee                   	out    %al,(%dx)
f010125b:	c7 45 e8 f9 03 00 00 	movl   $0x3f9,-0x18(%ebp)
f0101262:	c6 45 c9 00          	movb   $0x0,-0x37(%ebp)
f0101266:	8a 45 c9             	mov    -0x37(%ebp),%al
f0101269:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010126c:	ee                   	out    %al,(%dx)
f010126d:	c7 45 e4 fb 03 00 00 	movl   $0x3fb,-0x1c(%ebp)
f0101274:	c6 45 ca 03          	movb   $0x3,-0x36(%ebp)
f0101278:	8a 45 ca             	mov    -0x36(%ebp),%al
f010127b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010127e:	ee                   	out    %al,(%dx)
f010127f:	c7 45 e0 fc 03 00 00 	movl   $0x3fc,-0x20(%ebp)
f0101286:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
f010128a:	8a 45 cb             	mov    -0x35(%ebp),%al
f010128d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0101290:	ee                   	out    %al,(%dx)
f0101291:	c7 45 dc f9 03 00 00 	movl   $0x3f9,-0x24(%ebp)
f0101298:	c6 45 cc 01          	movb   $0x1,-0x34(%ebp)
f010129c:	8a 45 cc             	mov    -0x34(%ebp),%al
f010129f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01012a2:	ee                   	out    %al,(%dx)
f01012a3:	c7 45 d8 fd 03 00 00 	movl   $0x3fd,-0x28(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01012aa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01012ad:	89 c2                	mov    %eax,%edx
f01012af:	ec                   	in     (%dx),%al
f01012b0:	88 45 cd             	mov    %al,-0x33(%ebp)
	return data;
f01012b3:	8a 45 cd             	mov    -0x33(%ebp),%al
	// Enable rcv interrupts
	outb(COM1+COM_IER, COM_IER_RDI);

	// Clear any preexisting overrun indications and interrupts
	// Serial port doesn't exist if COM_LSR returns 0xFF
	serial_exists = (inb(COM1+COM_LSR) != 0xFF);
f01012b6:	3c ff                	cmp    $0xff,%al
f01012b8:	0f 95 c0             	setne  %al
f01012bb:	0f b6 c0             	movzbl %al,%eax
f01012be:	a3 64 59 81 f0       	mov    %eax,0xf0815964
f01012c3:	c7 45 d4 fa 03 00 00 	movl   $0x3fa,-0x2c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f01012ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01012cd:	89 c2                	mov    %eax,%edx
f01012cf:	ec                   	in     (%dx),%al
f01012d0:	88 45 ce             	mov    %al,-0x32(%ebp)
f01012d3:	c7 45 d0 f8 03 00 00 	movl   $0x3f8,-0x30(%ebp)
f01012da:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01012dd:	89 c2                	mov    %eax,%edx
f01012df:	ec                   	in     (%dx),%al
f01012e0:	88 45 cf             	mov    %al,-0x31(%ebp)
	(void) inb(COM1+COM_IIR);
	(void) inb(COM1+COM_RX);

	irq_install_handler(4, &serial_interrupt_handler);
f01012e3:	83 ec 08             	sub    $0x8,%esp
f01012e6:	68 01 12 10 f0       	push   $0xf0101201
f01012eb:	6a 04                	push   $0x4
f01012ed:	e8 ce cf 00 00       	call   f010e2c0 <irq_install_handler>
f01012f2:	83 c4 10             	add    $0x10,%esp

}
f01012f5:	90                   	nop
f01012f6:	c9                   	leave  
f01012f7:	c3                   	ret    

f01012f8 <delay>:
// page.

// Stupid I/O delay routine necessitated by historical PC design flaws
static void
delay(void)
{
f01012f8:	55                   	push   %ebp
f01012f9:	89 e5                	mov    %esp,%ebp
f01012fb:	83 ec 20             	sub    $0x20,%esp
f01012fe:	c7 45 fc 84 00 00 00 	movl   $0x84,-0x4(%ebp)
f0101305:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101308:	89 c2                	mov    %eax,%edx
f010130a:	ec                   	in     (%dx),%al
f010130b:	88 45 ec             	mov    %al,-0x14(%ebp)
f010130e:	c7 45 f8 84 00 00 00 	movl   $0x84,-0x8(%ebp)
f0101315:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101318:	89 c2                	mov    %eax,%edx
f010131a:	ec                   	in     (%dx),%al
f010131b:	88 45 ed             	mov    %al,-0x13(%ebp)
f010131e:	c7 45 f4 84 00 00 00 	movl   $0x84,-0xc(%ebp)
f0101325:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101328:	89 c2                	mov    %eax,%edx
f010132a:	ec                   	in     (%dx),%al
f010132b:	88 45 ee             	mov    %al,-0x12(%ebp)
f010132e:	c7 45 f0 84 00 00 00 	movl   $0x84,-0x10(%ebp)
f0101335:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101338:	89 c2                	mov    %eax,%edx
f010133a:	ec                   	in     (%dx),%al
f010133b:	88 45 ef             	mov    %al,-0x11(%ebp)
	inb(0x84);
	inb(0x84);
	inb(0x84);
	inb(0x84);
}
f010133e:	90                   	nop
f010133f:	c9                   	leave  
f0101340:	c3                   	ret    

f0101341 <lpt_putc>:

static void
lpt_putc(int c)
{
f0101341:	55                   	push   %ebp
f0101342:	89 e5                	mov    %esp,%ebp
f0101344:	83 ec 20             	sub    $0x20,%esp
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101347:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010134e:	eb 08                	jmp    f0101358 <lpt_putc+0x17>
		delay();
f0101350:	e8 a3 ff ff ff       	call   f01012f8 <delay>
static void
lpt_putc(int c)
{
	int i;

	for (i = 0; !(inb(0x378+1) & 0x80) && i < 2800; i++) //12800
f0101355:	ff 45 fc             	incl   -0x4(%ebp)
f0101358:	c7 45 ec 79 03 00 00 	movl   $0x379,-0x14(%ebp)
f010135f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101362:	89 c2                	mov    %eax,%edx
f0101364:	ec                   	in     (%dx),%al
f0101365:	88 45 eb             	mov    %al,-0x15(%ebp)
	return data;
f0101368:	8a 45 eb             	mov    -0x15(%ebp),%al
f010136b:	84 c0                	test   %al,%al
f010136d:	78 09                	js     f0101378 <lpt_putc+0x37>
f010136f:	81 7d fc ef 0a 00 00 	cmpl   $0xaef,-0x4(%ebp)
f0101376:	7e d8                	jle    f0101350 <lpt_putc+0xf>
		delay();
	outb(0x378+0, c);
f0101378:	8b 45 08             	mov    0x8(%ebp),%eax
f010137b:	0f b6 c0             	movzbl %al,%eax
f010137e:	c7 45 f4 78 03 00 00 	movl   $0x378,-0xc(%ebp)
f0101385:	88 45 e8             	mov    %al,-0x18(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101388:	8a 45 e8             	mov    -0x18(%ebp),%al
f010138b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010138e:	ee                   	out    %al,(%dx)
f010138f:	c7 45 f0 7a 03 00 00 	movl   $0x37a,-0x10(%ebp)
f0101396:	c6 45 e9 0d          	movb   $0xd,-0x17(%ebp)
f010139a:	8a 45 e9             	mov    -0x17(%ebp),%al
f010139d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01013a0:	ee                   	out    %al,(%dx)
f01013a1:	c7 45 f8 7a 03 00 00 	movl   $0x37a,-0x8(%ebp)
f01013a8:	c6 45 ea 08          	movb   $0x8,-0x16(%ebp)
f01013ac:	8a 45 ea             	mov    -0x16(%ebp),%al
f01013af:	8b 55 f8             	mov    -0x8(%ebp),%edx
f01013b2:	ee                   	out    %al,(%dx)
	outb(0x378+2, 0x08|0x04|0x01);
	outb(0x378+2, 0x08);
}
f01013b3:	90                   	nop
f01013b4:	c9                   	leave  
f01013b5:	c3                   	ret    

f01013b6 <cga_init>:
static uint16 *crt_buf;
static uint16 crt_pos;

void
cga_init(void)
{
f01013b6:	55                   	push   %ebp
f01013b7:	89 e5                	mov    %esp,%ebp
f01013b9:	83 ec 20             	sub    $0x20,%esp
	volatile uint16 *cp;
	uint16 was;
	unsigned pos;

	cp = (uint16*) (KERNEL_BASE + CGA_BUF);
f01013bc:	c7 45 fc 00 80 0b f0 	movl   $0xf00b8000,-0x4(%ebp)
	was = *cp;
f01013c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01013c6:	66 8b 00             	mov    (%eax),%ax
f01013c9:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
	*cp = (uint16) 0xA55A;
f01013cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01013d0:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
	if (*cp != 0xA55A) {
f01013d5:	8b 45 fc             	mov    -0x4(%ebp),%eax
f01013d8:	66 8b 00             	mov    (%eax),%ax
f01013db:	66 3d 5a a5          	cmp    $0xa55a,%ax
f01013df:	74 13                	je     f01013f4 <cga_init+0x3e>
		cp = (uint16*) (KERNEL_BASE + MONO_BUF);
f01013e1:	c7 45 fc 00 00 0b f0 	movl   $0xf00b0000,-0x4(%ebp)
		addr_6845 = MONO_BASE;
f01013e8:	c7 05 68 59 81 f0 b4 	movl   $0x3b4,0xf0815968
f01013ef:	03 00 00 
f01013f2:	eb 14                	jmp    f0101408 <cga_init+0x52>
	} else {
		*cp = was;
f01013f4:	8b 55 fc             	mov    -0x4(%ebp),%edx
f01013f7:	66 8b 45 fa          	mov    -0x6(%ebp),%ax
f01013fb:	66 89 02             	mov    %ax,(%edx)
		addr_6845 = CGA_BASE;
f01013fe:	c7 05 68 59 81 f0 d4 	movl   $0x3d4,0xf0815968
f0101405:	03 00 00 
	}

	/* Extract cursor location */
	outb(addr_6845, 14);
f0101408:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f010140d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101410:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
f0101414:	8a 45 e0             	mov    -0x20(%ebp),%al
f0101417:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010141a:	ee                   	out    %al,(%dx)
	pos = inb(addr_6845 + 1) << 8;
f010141b:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f0101420:	40                   	inc    %eax
f0101421:	89 45 ec             	mov    %eax,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101424:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101427:	89 c2                	mov    %eax,%edx
f0101429:	ec                   	in     (%dx),%al
f010142a:	88 45 e1             	mov    %al,-0x1f(%ebp)
	return data;
f010142d:	8a 45 e1             	mov    -0x1f(%ebp),%al
f0101430:	0f b6 c0             	movzbl %al,%eax
f0101433:	c1 e0 08             	shl    $0x8,%eax
f0101436:	89 45 f0             	mov    %eax,-0x10(%ebp)
	outb(addr_6845, 15);
f0101439:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f010143e:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101441:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101445:	8a 45 e2             	mov    -0x1e(%ebp),%al
f0101448:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010144b:	ee                   	out    %al,(%dx)
	pos |= inb(addr_6845 + 1);
f010144c:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f0101451:	40                   	inc    %eax
f0101452:	89 45 e4             	mov    %eax,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101455:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101458:	89 c2                	mov    %eax,%edx
f010145a:	ec                   	in     (%dx),%al
f010145b:	88 45 e3             	mov    %al,-0x1d(%ebp)
	return data;
f010145e:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101461:	0f b6 c0             	movzbl %al,%eax
f0101464:	09 45 f0             	or     %eax,-0x10(%ebp)

	crt_buf = (uint16*) cp;
f0101467:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010146a:	a3 6c 59 81 f0       	mov    %eax,0xf081596c
	crt_pos = pos;
f010146f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101472:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
}
f0101478:	90                   	nop
f0101479:	c9                   	leave  
f010147a:	c3                   	ret    

f010147b <cga_putc>:

//2016: Preliminary backward and forward cursor movement was added to FOS
// 		Thanks to student Abdullah Mohammad Ma3en, 3rd year, and TA Ghada Hamed.
void
cga_putc(int c)
{
f010147b:	55                   	push   %ebp
f010147c:	89 e5                	mov    %esp,%ebp
f010147e:	53                   	push   %ebx
f010147f:	83 ec 24             	sub    $0x24,%esp
	// if no attribute given, then use the text color
	if (!(c & ~0xFF))
f0101482:	8b 45 08             	mov    0x8(%ebp),%eax
f0101485:	b0 00                	mov    $0x0,%al
f0101487:	85 c0                	test   %eax,%eax
f0101489:	75 18                	jne    f01014a3 <cga_putc+0x28>
	{
		c |= current_text_color == 0? 0x700 : current_text_color;
f010148b:	a1 f0 6a 85 f0       	mov    0xf0856af0,%eax
f0101490:	85 c0                	test   %eax,%eax
f0101492:	74 07                	je     f010149b <cga_putc+0x20>
f0101494:	a1 f0 6a 85 f0       	mov    0xf0856af0,%eax
f0101499:	eb 05                	jmp    f01014a0 <cga_putc+0x25>
f010149b:	b8 00 07 00 00       	mov    $0x700,%eax
f01014a0:	09 45 08             	or     %eax,0x8(%ebp)
		//c |= 0x700; /*black and white*/
	}
	switch (c & 0xff) {
f01014a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01014a6:	0f b6 c0             	movzbl %al,%eax
f01014a9:	83 f8 0a             	cmp    $0xa,%eax
f01014ac:	74 77                	je     f0101525 <cga_putc+0xaa>
f01014ae:	83 f8 0a             	cmp    $0xa,%eax
f01014b1:	7f 13                	jg     f01014c6 <cga_putc+0x4b>
f01014b3:	83 f8 08             	cmp    $0x8,%eax
f01014b6:	74 2e                	je     f01014e6 <cga_putc+0x6b>
f01014b8:	83 f8 09             	cmp    $0x9,%eax
f01014bb:	0f 84 a8 00 00 00    	je     f0101569 <cga_putc+0xee>
f01014c1:	e9 22 01 00 00       	jmp    f01015e8 <cga_putc+0x16d>
f01014c6:	3d e4 00 00 00       	cmp    $0xe4,%eax
f01014cb:	0f 84 de 00 00 00    	je     f01015af <cga_putc+0x134>
f01014d1:	3d e5 00 00 00       	cmp    $0xe5,%eax
f01014d6:	0f 84 f1 00 00 00    	je     f01015cd <cga_putc+0x152>
f01014dc:	83 f8 0d             	cmp    $0xd,%eax
f01014df:	74 5d                	je     f010153e <cga_putc+0xc3>
f01014e1:	e9 02 01 00 00       	jmp    f01015e8 <cga_putc+0x16d>
	case '\b':
		if (crt_pos > 0) {
f01014e6:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01014ec:	66 85 c0             	test   %ax,%ax
f01014ef:	0f 84 4f 01 00 00    	je     f0101644 <cga_putc+0x1c9>
			crt_pos--;
f01014f5:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01014fb:	48                   	dec    %eax
f01014fc:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
f0101502:	8b 15 6c 59 81 f0    	mov    0xf081596c,%edx
f0101508:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f010150e:	0f b7 c0             	movzwl %ax,%eax
f0101511:	01 c0                	add    %eax,%eax
f0101513:	01 c2                	add    %eax,%edx
f0101515:	8b 45 08             	mov    0x8(%ebp),%eax
f0101518:	b0 00                	mov    $0x0,%al
f010151a:	83 c8 20             	or     $0x20,%eax
f010151d:	66 89 02             	mov    %ax,(%edx)
		}
		break;
f0101520:	e9 1f 01 00 00       	jmp    f0101644 <cga_putc+0x1c9>
	case '\n':
		crt_pos += CRT_COLS;
f0101525:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f010152b:	83 c0 50             	add    $0x50,%eax
f010152e:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		text_length = 0;
f0101534:	c7 05 60 59 81 f0 00 	movl   $0x0,0xf0815960
f010153b:	00 00 00 
		/* fallthru */
	case '\r':
		crt_pos -= (crt_pos % CRT_COLS);
f010153e:	66 8b 0d 70 59 81 f0 	mov    0xf0815970,%cx
f0101545:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f010154b:	bb 50 00 00 00       	mov    $0x50,%ebx
f0101550:	ba 00 00 00 00       	mov    $0x0,%edx
f0101555:	66 f7 f3             	div    %bx
f0101558:	89 d0                	mov    %edx,%eax
f010155a:	29 c1                	sub    %eax,%ecx
f010155c:	89 c8                	mov    %ecx,%eax
f010155e:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		break;
f0101564:	e9 e5 00 00 00       	jmp    f010164e <cga_putc+0x1d3>
	case '\t':
		cons_putc(' ');
f0101569:	83 ec 0c             	sub    $0xc,%esp
f010156c:	6a 20                	push   $0x20
f010156e:	e8 30 05 00 00       	call   f0101aa3 <cons_putc>
f0101573:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101576:	83 ec 0c             	sub    $0xc,%esp
f0101579:	6a 20                	push   $0x20
f010157b:	e8 23 05 00 00       	call   f0101aa3 <cons_putc>
f0101580:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101583:	83 ec 0c             	sub    $0xc,%esp
f0101586:	6a 20                	push   $0x20
f0101588:	e8 16 05 00 00       	call   f0101aa3 <cons_putc>
f010158d:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f0101590:	83 ec 0c             	sub    $0xc,%esp
f0101593:	6a 20                	push   $0x20
f0101595:	e8 09 05 00 00       	call   f0101aa3 <cons_putc>
f010159a:	83 c4 10             	add    $0x10,%esp
		cons_putc(' ');
f010159d:	83 ec 0c             	sub    $0xc,%esp
f01015a0:	6a 20                	push   $0x20
f01015a2:	e8 fc 04 00 00       	call   f0101aa3 <cons_putc>
f01015a7:	83 c4 10             	add    $0x10,%esp
		break;
f01015aa:	e9 9f 00 00 00       	jmp    f010164e <cga_putc+0x1d3>
	case KEY_LF:
		if(crt_pos>0)
f01015af:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015b5:	66 85 c0             	test   %ax,%ax
f01015b8:	0f 84 89 00 00 00    	je     f0101647 <cga_putc+0x1cc>
			crt_pos--;
f01015be:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015c4:	48                   	dec    %eax
f01015c5:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		break;
f01015cb:	eb 7a                	jmp    f0101647 <cga_putc+0x1cc>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
f01015cd:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015d3:	66 3d cf 07          	cmp    $0x7cf,%ax
f01015d7:	77 71                	ja     f010164a <cga_putc+0x1cf>
			crt_pos++;
f01015d9:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01015df:	40                   	inc    %eax
f01015e0:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
		break;
f01015e6:	eb 62                	jmp    f010164a <cga_putc+0x1cf>
	default: {
		if (c != KEY_LF && c != KEY_RT) {
f01015e8:	81 7d 08 e4 00 00 00 	cmpl   $0xe4,0x8(%ebp)
f01015ef:	74 5c                	je     f010164d <cga_putc+0x1d2>
f01015f1:	81 7d 08 e5 00 00 00 	cmpl   $0xe5,0x8(%ebp)
f01015f8:	74 53                	je     f010164d <cga_putc+0x1d2>
			crt_buf[crt_pos++] = c;		/* write the character */
f01015fa:	8b 0d 6c 59 81 f0    	mov    0xf081596c,%ecx
f0101600:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101606:	8d 50 01             	lea    0x1(%eax),%edx
f0101609:	66 89 15 70 59 81 f0 	mov    %dx,0xf0815970
f0101610:	0f b7 c0             	movzwl %ax,%eax
f0101613:	01 c0                	add    %eax,%eax
f0101615:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0101618:	8b 45 08             	mov    0x8(%ebp),%eax
f010161b:	66 89 02             	mov    %ax,(%edx)
			if (crt_pos > 1920 + text_length)
f010161e:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101624:	0f b7 c0             	movzwl %ax,%eax
f0101627:	8b 15 60 59 81 f0    	mov    0xf0815960,%edx
f010162d:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101633:	39 d0                	cmp    %edx,%eax
f0101635:	7e 16                	jle    f010164d <cga_putc+0x1d2>
				text_length++;
f0101637:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f010163c:	40                   	inc    %eax
f010163d:	a3 60 59 81 f0       	mov    %eax,0xf0815960
		}
		break;
f0101642:	eb 09                	jmp    f010164d <cga_putc+0x1d2>
	case '\b':
		if (crt_pos > 0) {
			crt_pos--;
			crt_buf[crt_pos] = (c & ~0xff) | ' ';
		}
		break;
f0101644:	90                   	nop
f0101645:	eb 07                	jmp    f010164e <cga_putc+0x1d3>
		cons_putc(' ');
		break;
	case KEY_LF:
		if(crt_pos>0)
			crt_pos--;
		break;
f0101647:	90                   	nop
f0101648:	eb 04                	jmp    f010164e <cga_putc+0x1d3>
	case KEY_RT:
		if (crt_pos < CRT_SIZE)
			crt_pos++;
		break;
f010164a:	90                   	nop
f010164b:	eb 01                	jmp    f010164e <cga_putc+0x1d3>
		if (c != KEY_LF && c != KEY_RT) {
			crt_buf[crt_pos++] = c;		/* write the character */
			if (crt_pos > 1920 + text_length)
				text_length++;
		}
		break;
f010164d:	90                   	nop
	}
	}

	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
f010164e:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101654:	66 3d cf 07          	cmp    $0x7cf,%ax
f0101658:	76 58                	jbe    f01016b2 <cga_putc+0x237>
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
f010165a:	a1 6c 59 81 f0       	mov    0xf081596c,%eax
f010165f:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
f0101665:	a1 6c 59 81 f0       	mov    0xf081596c,%eax
f010166a:	83 ec 04             	sub    $0x4,%esp
f010166d:	68 00 0f 00 00       	push   $0xf00
f0101672:	52                   	push   %edx
f0101673:	50                   	push   %eax
f0101674:	e8 93 97 01 00       	call   f011ae0c <memcpy>
f0101679:	83 c4 10             	add    $0x10,%esp
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f010167c:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
f0101683:	eb 15                	jmp    f010169a <cga_putc+0x21f>
			crt_buf[i] = 0x0700 | ' ';
f0101685:	8b 15 6c 59 81 f0    	mov    0xf081596c,%edx
f010168b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010168e:	01 c0                	add    %eax,%eax
f0101690:	01 d0                	add    %edx,%eax
f0101692:	66 c7 00 20 07       	movw   $0x720,(%eax)
	// What is the purpose of this?
	if (crt_pos >= CRT_SIZE) {
		int i;

		memcpy(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16));
		for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
f0101697:	ff 45 f4             	incl   -0xc(%ebp)
f010169a:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
f01016a1:	7e e2                	jle    f0101685 <cga_putc+0x20a>
			crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
f01016a3:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01016a9:	83 e8 50             	sub    $0x50,%eax
f01016ac:	66 a3 70 59 81 f0    	mov    %ax,0xf0815970
	}

	/* move that little blinky thing */
	outb(addr_6845, 14);
f01016b2:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f01016b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01016ba:	c6 45 e0 0e          	movb   $0xe,-0x20(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f01016be:	8a 45 e0             	mov    -0x20(%ebp),%al
f01016c1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01016c4:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos >> 8);
f01016c5:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01016cb:	66 c1 e8 08          	shr    $0x8,%ax
f01016cf:	0f b6 c0             	movzbl %al,%eax
f01016d2:	8b 15 68 59 81 f0    	mov    0xf0815968,%edx
f01016d8:	42                   	inc    %edx
f01016d9:	89 55 ec             	mov    %edx,-0x14(%ebp)
f01016dc:	88 45 e1             	mov    %al,-0x1f(%ebp)
f01016df:	8a 45 e1             	mov    -0x1f(%ebp),%al
f01016e2:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01016e5:	ee                   	out    %al,(%dx)
	outb(addr_6845, 15);
f01016e6:	a1 68 59 81 f0       	mov    0xf0815968,%eax
f01016eb:	89 45 e8             	mov    %eax,-0x18(%ebp)
f01016ee:	c6 45 e2 0f          	movb   $0xf,-0x1e(%ebp)
f01016f2:	8a 45 e2             	mov    -0x1e(%ebp),%al
f01016f5:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01016f8:	ee                   	out    %al,(%dx)
	outb(addr_6845 + 1, crt_pos);
f01016f9:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f01016ff:	0f b6 c0             	movzbl %al,%eax
f0101702:	8b 15 68 59 81 f0    	mov    0xf0815968,%edx
f0101708:	42                   	inc    %edx
f0101709:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f010170c:	88 45 e3             	mov    %al,-0x1d(%ebp)
f010170f:	8a 45 e3             	mov    -0x1d(%ebp),%al
f0101712:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0101715:	ee                   	out    %al,(%dx)
}
f0101716:	90                   	nop
f0101717:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010171a:	c9                   	leave  
f010171b:	c3                   	ret    

f010171c <kbd_proc_data>:
 * Get data from the keyboard.  If we finish a character, return it.  Else 0.
 * Return -1 if no data.
 */
static int
kbd_proc_data(void)
{
f010171c:	55                   	push   %ebp
f010171d:	89 e5                	mov    %esp,%ebp
f010171f:	83 ec 28             	sub    $0x28,%esp
f0101722:	c7 45 dc 64 00 00 00 	movl   $0x64,-0x24(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101729:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010172c:	89 c2                	mov    %eax,%edx
f010172e:	ec                   	in     (%dx),%al
f010172f:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0101732:	8a 45 db             	mov    -0x25(%ebp),%al
	int c;
	uint8 data;
	static uint32 shift;

	if ((inb(KBSTATP) & KBS_DIB) == 0)
f0101735:	0f b6 c0             	movzbl %al,%eax
f0101738:	83 e0 01             	and    $0x1,%eax
f010173b:	85 c0                	test   %eax,%eax
f010173d:	75 0a                	jne    f0101749 <kbd_proc_data+0x2d>
		return -1;
f010173f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0101744:	e9 2a 02 00 00       	jmp    f0101973 <kbd_proc_data+0x257>
f0101749:	c7 45 e4 60 00 00 00 	movl   $0x60,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0101750:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101753:	89 c2                	mov    %eax,%edx
f0101755:	ec                   	in     (%dx),%al
f0101756:	88 45 da             	mov    %al,-0x26(%ebp)
	return data;
f0101759:	8a 45 da             	mov    -0x26(%ebp),%al

	data = inb(KBDATAP);
f010175c:	88 45 f3             	mov    %al,-0xd(%ebp)

	if (data == 0xE0) {
f010175f:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
f0101763:	75 17                	jne    f010177c <kbd_proc_data+0x60>
		// E0 escape character
		shift |= E0ESC;
f0101765:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010176a:	83 c8 40             	or     $0x40,%eax
f010176d:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
		return 0;
f0101772:	b8 00 00 00 00       	mov    $0x0,%eax
f0101777:	e9 f7 01 00 00       	jmp    f0101973 <kbd_proc_data+0x257>
	} else if (data & 0x80) {
f010177c:	8a 45 f3             	mov    -0xd(%ebp),%al
f010177f:	84 c0                	test   %al,%al
f0101781:	79 44                	jns    f01017c7 <kbd_proc_data+0xab>
		// Key released
		data = (shift & E0ESC ? data : data & 0x7F);
f0101783:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f0101788:	83 e0 40             	and    $0x40,%eax
f010178b:	85 c0                	test   %eax,%eax
f010178d:	75 08                	jne    f0101797 <kbd_proc_data+0x7b>
f010178f:	8a 45 f3             	mov    -0xd(%ebp),%al
f0101792:	83 e0 7f             	and    $0x7f,%eax
f0101795:	eb 03                	jmp    f010179a <kbd_proc_data+0x7e>
f0101797:	8a 45 f3             	mov    -0xd(%ebp),%al
f010179a:	88 45 f3             	mov    %al,-0xd(%ebp)
		shift &= ~(shiftcode[data] | E0ESC);
f010179d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01017a1:	8a 80 40 f0 17 f0    	mov    -0xfe80fc0(%eax),%al
f01017a7:	83 c8 40             	or     $0x40,%eax
f01017aa:	0f b6 c0             	movzbl %al,%eax
f01017ad:	f7 d0                	not    %eax
f01017af:	89 c2                	mov    %eax,%edx
f01017b1:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01017b6:	21 d0                	and    %edx,%eax
f01017b8:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
		return 0;
f01017bd:	b8 00 00 00 00       	mov    $0x0,%eax
f01017c2:	e9 ac 01 00 00       	jmp    f0101973 <kbd_proc_data+0x257>
	} else if (shift & E0ESC) {
f01017c7:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01017cc:	83 e0 40             	and    $0x40,%eax
f01017cf:	85 c0                	test   %eax,%eax
f01017d1:	74 11                	je     f01017e4 <kbd_proc_data+0xc8>
		// Last character was an E0 escape; or with 0x80
		data |= 0x80;
f01017d3:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
		shift &= ~E0ESC;
f01017d7:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01017dc:	83 e0 bf             	and    $0xffffffbf,%eax
f01017df:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
	}

	shift |= shiftcode[data];
f01017e4:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f01017e8:	8a 80 40 f0 17 f0    	mov    -0xfe80fc0(%eax),%al
f01017ee:	0f b6 d0             	movzbl %al,%edx
f01017f1:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01017f6:	09 d0                	or     %edx,%eax
f01017f8:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88
	shift ^= togglecode[data];
f01017fd:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101801:	8a 80 40 f1 17 f0    	mov    -0xfe80ec0(%eax),%al
f0101807:	0f b6 d0             	movzbl %al,%edx
f010180a:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010180f:	31 d0                	xor    %edx,%eax
f0101811:	a3 88 5b 81 f0       	mov    %eax,0xf0815b88

	c = charcode[shift & (CTL | SHIFT)][data];
f0101816:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010181b:	83 e0 03             	and    $0x3,%eax
f010181e:	8b 14 85 40 f5 17 f0 	mov    -0xfe80ac0(,%eax,4),%edx
f0101825:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0101829:	01 d0                	add    %edx,%eax
f010182b:	8a 00                	mov    (%eax),%al
f010182d:	0f b6 c0             	movzbl %al,%eax
f0101830:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (c == KEY_DEL) {
f0101833:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010183a:	0f 85 9c 00 00 00    	jne    f01018dc <kbd_proc_data+0x1c0>
		if (text_length > 0) {
f0101840:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f0101845:	85 c0                	test   %eax,%eax
f0101847:	0f 8e 85 00 00 00    	jle    f01018d2 <kbd_proc_data+0x1b6>
			if (crt_pos == 1920 + text_length)
f010184d:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101853:	0f b7 c0             	movzwl %ax,%eax
f0101856:	8b 15 60 59 81 f0    	mov    0xf0815960,%edx
f010185c:	81 c2 80 07 00 00    	add    $0x780,%edx
f0101862:	39 d0                	cmp    %edx,%eax
f0101864:	75 0a                	jne    f0101870 <kbd_proc_data+0x154>
				return 0;
f0101866:	b8 00 00 00 00       	mov    $0x0,%eax
f010186b:	e9 03 01 00 00       	jmp    f0101973 <kbd_proc_data+0x257>
			else {
				text_length--;
f0101870:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f0101875:	48                   	dec    %eax
f0101876:	a3 60 59 81 f0       	mov    %eax,0xf0815960
				int crt_pos_Length = crt_pos - 1925;
f010187b:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101881:	0f b7 c0             	movzwl %ax,%eax
f0101884:	2d 85 07 00 00       	sub    $0x785,%eax
f0101889:	89 45 ec             	mov    %eax,-0x14(%ebp)
				for (int i = crt_pos; crt_pos_Length <= text_length;
f010188c:	66 a1 70 59 81 f0    	mov    0xf0815970,%ax
f0101892:	0f b7 c0             	movzwl %ax,%eax
f0101895:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0101898:	eb 26                	jmp    f01018c0 <kbd_proc_data+0x1a4>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
f010189a:	8b 15 6c 59 81 f0    	mov    0xf081596c,%edx
f01018a0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01018a3:	01 c0                	add    %eax,%eax
f01018a5:	01 c2                	add    %eax,%edx
f01018a7:	a1 6c 59 81 f0       	mov    0xf081596c,%eax
f01018ac:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f01018af:	41                   	inc    %ecx
f01018b0:	01 c9                	add    %ecx,%ecx
f01018b2:	01 c8                	add    %ecx,%eax
f01018b4:	66 8b 00             	mov    (%eax),%ax
f01018b7:	66 89 02             	mov    %ax,(%edx)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
						++i, crt_pos_Length++) {
f01018ba:	ff 45 e8             	incl   -0x18(%ebp)
f01018bd:	ff 45 ec             	incl   -0x14(%ebp)
			if (crt_pos == 1920 + text_length)
				return 0;
			else {
				text_length--;
				int crt_pos_Length = crt_pos - 1925;
				for (int i = crt_pos; crt_pos_Length <= text_length;
f01018c0:	a1 60 59 81 f0       	mov    0xf0815960,%eax
f01018c5:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01018c8:	7e d0                	jle    f010189a <kbd_proc_data+0x17e>
						++i, crt_pos_Length++) {
					crt_buf[i] = crt_buf[i + 1];
				}
				return c;
f01018ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01018cd:	e9 a1 00 00 00       	jmp    f0101973 <kbd_proc_data+0x257>
			}
		}
		return 0;
f01018d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01018d7:	e9 97 00 00 00       	jmp    f0101973 <kbd_proc_data+0x257>
	}
	if (shift & CAPSLOCK) {
f01018dc:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f01018e1:	83 e0 08             	and    $0x8,%eax
f01018e4:	85 c0                	test   %eax,%eax
f01018e6:	74 22                	je     f010190a <kbd_proc_data+0x1ee>
		if ('a' <= c && c <= 'z')
f01018e8:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
f01018ec:	7e 0c                	jle    f01018fa <kbd_proc_data+0x1de>
f01018ee:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
f01018f2:	7f 06                	jg     f01018fa <kbd_proc_data+0x1de>
			c += 'A' - 'a';
f01018f4:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
f01018f8:	eb 10                	jmp    f010190a <kbd_proc_data+0x1ee>
		else if ('A' <= c && c <= 'Z')
f01018fa:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
f01018fe:	7e 0a                	jle    f010190a <kbd_proc_data+0x1ee>
f0101900:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
f0101904:	7f 04                	jg     f010190a <kbd_proc_data+0x1ee>
			c += 'a' - 'A';
f0101906:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
	}

	// Process special keys
	if ((int) shift == NUMLOCK && c >= '0' && c <= '9')
f010190a:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010190f:	83 f8 10             	cmp    $0x10,%eax
f0101912:	75 13                	jne    f0101927 <kbd_proc_data+0x20b>
f0101914:	83 7d f4 2f          	cmpl   $0x2f,-0xc(%ebp)
f0101918:	7e 0d                	jle    f0101927 <kbd_proc_data+0x20b>
f010191a:	83 7d f4 39          	cmpl   $0x39,-0xc(%ebp)
f010191e:	7f 07                	jg     f0101927 <kbd_proc_data+0x20b>
		return 0;
f0101920:	b8 00 00 00 00       	mov    $0x0,%eax
f0101925:	eb 4c                	jmp    f0101973 <kbd_proc_data+0x257>
	if (c == 255)
f0101927:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f010192e:	75 07                	jne    f0101937 <kbd_proc_data+0x21b>
		return 0;
f0101930:	b8 00 00 00 00       	mov    $0x0,%eax
f0101935:	eb 3c                	jmp    f0101973 <kbd_proc_data+0x257>
	// Ctrl-Alt-Del: reboot
	if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
f0101937:	a1 88 5b 81 f0       	mov    0xf0815b88,%eax
f010193c:	f7 d0                	not    %eax
f010193e:	83 e0 06             	and    $0x6,%eax
f0101941:	85 c0                	test   %eax,%eax
f0101943:	75 2b                	jne    f0101970 <kbd_proc_data+0x254>
f0101945:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
f010194c:	75 22                	jne    f0101970 <kbd_proc_data+0x254>
		cprintf("Rebooting!\n");
f010194e:	83 ec 0c             	sub    $0xc,%esp
f0101951:	68 1f b2 12 f0       	push   $0xf012b21f
f0101956:	e8 01 03 00 00       	call   f0101c5c <cprintf>
f010195b:	83 c4 10             	add    $0x10,%esp
f010195e:	c7 45 e0 92 00 00 00 	movl   $0x92,-0x20(%ebp)
f0101965:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0101969:	8a 45 d9             	mov    -0x27(%ebp),%al
f010196c:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010196f:	ee                   	out    %al,(%dx)
		outb(0x92, 0x3); // courtesy of Chris Frost
	}

	return c;
f0101970:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101973:	c9                   	leave  
f0101974:	c3                   	ret    

f0101975 <kbd_intr>:

void
kbd_intr(void)
{
f0101975:	55                   	push   %ebp
f0101976:	89 e5                	mov    %esp,%ebp
f0101978:	83 ec 08             	sub    $0x8,%esp
	cons_intr(kbd_proc_data);
f010197b:	83 ec 0c             	sub    $0xc,%esp
f010197e:	68 1c 17 10 f0       	push   $0xf010171c
f0101983:	e8 21 00 00 00       	call   f01019a9 <cons_intr>
f0101988:	83 c4 10             	add    $0x10,%esp
}
f010198b:	90                   	nop
f010198c:	c9                   	leave  
f010198d:	c3                   	ret    

f010198e <kbd_init>:

void
kbd_init(void)
{
f010198e:	55                   	push   %ebp
f010198f:	89 e5                	mov    %esp,%ebp
f0101991:	83 ec 08             	sub    $0x8,%esp
	irq_install_handler(1, &keyboard_interrupt_handler);
f0101994:	83 ec 08             	sub    $0x8,%esp
f0101997:	68 73 1b 10 f0       	push   $0xf0101b73
f010199c:	6a 01                	push   $0x1
f010199e:	e8 1d c9 00 00       	call   f010e2c0 <irq_install_handler>
f01019a3:	83 c4 10             	add    $0x10,%esp
	}
	else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&KBDsem, 0, "keyboard semaphore");
	}
}
f01019a6:	90                   	nop
f01019a7:	c9                   	leave  
f01019a8:	c3                   	ret    

f01019a9 <cons_intr>:

// called by device interrupt routines to feed input characters
// into the circular console input buffer.
void
cons_intr(int (*proc)(void))
{
f01019a9:	55                   	push   %ebp
f01019aa:	89 e5                	mov    %esp,%ebp
f01019ac:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = (*proc)()) != -1) {
f01019af:	eb 35                	jmp    f01019e6 <cons_intr+0x3d>
		if (c == 0)
f01019b1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01019b5:	75 02                	jne    f01019b9 <cons_intr+0x10>
			continue;
f01019b7:	eb 2d                	jmp    f01019e6 <cons_intr+0x3d>
		cons.buf[cons.wpos++] = c;
f01019b9:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f01019be:	8d 50 01             	lea    0x1(%eax),%edx
f01019c1:	89 15 84 5b 81 f0    	mov    %edx,0xf0815b84
f01019c7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01019ca:	88 90 80 59 81 f0    	mov    %dl,-0xf7ea680(%eax)
		if (cons.wpos == CONSBUFSIZE)
f01019d0:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f01019d5:	3d 00 02 00 00       	cmp    $0x200,%eax
f01019da:	75 0a                	jne    f01019e6 <cons_intr+0x3d>
			cons.wpos = 0;
f01019dc:	c7 05 84 5b 81 f0 00 	movl   $0x0,0xf0815b84
f01019e3:	00 00 00 
void
cons_intr(int (*proc)(void))
{
	int c;

	while ((c = (*proc)()) != -1) {
f01019e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01019e9:	ff d0                	call   *%eax
f01019eb:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01019ee:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
f01019f2:	75 bd                	jne    f01019b1 <cons_intr+0x8>
		if (cons.wpos == CONSBUFSIZE)
			cons.wpos = 0;

		//cprintf("\nCHAR %d is written into cons.buf\n", c);
	}
}
f01019f4:	90                   	nop
f01019f5:	c9                   	leave  
f01019f6:	c3                   	ret    

f01019f7 <cons_getc>:

// return the next input character from the console, or 0 if none waiting
int
cons_getc(void)
{
f01019f7:	55                   	push   %ebp
f01019f8:	89 e5                	mov    %esp,%ebp
f01019fa:	83 ec 18             	sub    $0x18,%esp
	int c;

	// poll for any pending input characters,
	// so that this function works even when interrupts are disabled
	// (e.g., when called from the kernel monitor).
	serial_intr();
f01019fd:	e8 dd f7 ff ff       	call   f01011df <serial_intr>
	kbd_intr();
f0101a02:	e8 6e ff ff ff       	call   f0101975 <kbd_intr>

	// grab the next character from the input buffer.
	if (cons.rpos != cons.wpos) {
f0101a07:	8b 15 80 5b 81 f0    	mov    0xf0815b80,%edx
f0101a0d:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f0101a12:	39 c2                	cmp    %eax,%edx
f0101a14:	74 35                	je     f0101a4b <cons_getc+0x54>
		c = cons.buf[cons.rpos++];
f0101a16:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f0101a1b:	8d 50 01             	lea    0x1(%eax),%edx
f0101a1e:	89 15 80 5b 81 f0    	mov    %edx,0xf0815b80
f0101a24:	8a 80 80 59 81 f0    	mov    -0xf7ea680(%eax),%al
f0101a2a:	0f b6 c0             	movzbl %al,%eax
f0101a2d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101a30:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f0101a35:	3d 00 02 00 00       	cmp    $0x200,%eax
f0101a3a:	75 0a                	jne    f0101a46 <cons_getc+0x4f>
			cons.rpos = 0;
f0101a3c:	c7 05 80 5b 81 f0 00 	movl   $0x0,0xf0815b80
f0101a43:	00 00 00 
		return c;
f0101a46:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101a49:	eb 05                	jmp    f0101a50 <cons_getc+0x59>
	}
	return 0;
f0101a4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101a50:	c9                   	leave  
f0101a51:	c3                   	ret    

f0101a52 <cons_getc2>:

//// return the next input character from the console buffer, or 0 if none
int
cons_getc2(void)
{
f0101a52:	55                   	push   %ebp
f0101a53:	89 e5                	mov    %esp,%ebp
f0101a55:	83 ec 10             	sub    $0x10,%esp
	int c;
	// grab the next character from the input buffer (if any).
	if (cons.rpos != cons.wpos) {
f0101a58:	8b 15 80 5b 81 f0    	mov    0xf0815b80,%edx
f0101a5e:	a1 84 5b 81 f0       	mov    0xf0815b84,%eax
f0101a63:	39 c2                	cmp    %eax,%edx
f0101a65:	74 35                	je     f0101a9c <cons_getc2+0x4a>
		c = cons.buf[cons.rpos++];
f0101a67:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f0101a6c:	8d 50 01             	lea    0x1(%eax),%edx
f0101a6f:	89 15 80 5b 81 f0    	mov    %edx,0xf0815b80
f0101a75:	8a 80 80 59 81 f0    	mov    -0xf7ea680(%eax),%al
f0101a7b:	0f b6 c0             	movzbl %al,%eax
f0101a7e:	89 45 fc             	mov    %eax,-0x4(%ebp)
		if (cons.rpos == CONSBUFSIZE)
f0101a81:	a1 80 5b 81 f0       	mov    0xf0815b80,%eax
f0101a86:	3d 00 02 00 00       	cmp    $0x200,%eax
f0101a8b:	75 0a                	jne    f0101a97 <cons_getc2+0x45>
			cons.rpos = 0;
f0101a8d:	c7 05 80 5b 81 f0 00 	movl   $0x0,0xf0815b80
f0101a94:	00 00 00 
		return c;
f0101a97:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101a9a:	eb 05                	jmp    f0101aa1 <cons_getc2+0x4f>
	}
	return 0;
f0101a9c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0101aa1:	c9                   	leave  
f0101aa2:	c3                   	ret    

f0101aa3 <cons_putc>:

// output a character to the console
void
cons_putc(int c)
{
f0101aa3:	55                   	push   %ebp
f0101aa4:	89 e5                	mov    %esp,%ebp
f0101aa6:	83 ec 08             	sub    $0x8,%esp
	lpt_putc(c);
f0101aa9:	ff 75 08             	pushl  0x8(%ebp)
f0101aac:	e8 90 f8 ff ff       	call   f0101341 <lpt_putc>
f0101ab1:	83 c4 04             	add    $0x4,%esp
	cga_putc(c);
f0101ab4:	83 ec 0c             	sub    $0xc,%esp
f0101ab7:	ff 75 08             	pushl  0x8(%ebp)
f0101aba:	e8 bc f9 ff ff       	call   f010147b <cga_putc>
f0101abf:	83 c4 10             	add    $0x10,%esp
}
f0101ac2:	90                   	nop
f0101ac3:	c9                   	leave  
f0101ac4:	c3                   	ret    

f0101ac5 <cons_init>:

// initialize the console devices
void
cons_init(void)
{
f0101ac5:	55                   	push   %ebp
f0101ac6:	89 e5                	mov    %esp,%ebp
f0101ac8:	83 ec 08             	sub    $0x8,%esp
	cga_init();
f0101acb:	e8 e6 f8 ff ff       	call   f01013b6 <cga_init>
	kbd_init();
f0101ad0:	e8 b9 fe ff ff       	call   f010198e <kbd_init>
	serial_init();
f0101ad5:	e8 45 f7 ff ff       	call   f010121f <serial_init>

	if (!serial_exists)
f0101ada:	a1 64 59 81 f0       	mov    0xf0815964,%eax
f0101adf:	85 c0                	test   %eax,%eax
f0101ae1:	75 10                	jne    f0101af3 <cons_init+0x2e>
		cprintf("Serial port does not exist!\n");
f0101ae3:	83 ec 0c             	sub    $0xc,%esp
f0101ae6:	68 2b b2 12 f0       	push   $0xf012b22b
f0101aeb:	e8 6c 01 00 00       	call   f0101c5c <cprintf>
f0101af0:	83 c4 10             	add    $0x10,%esp
	}
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		init_ksemaphore(&conssem, 1, "console semaphore");
	}
}
f0101af3:	90                   	nop
f0101af4:	c9                   	leave  
f0101af5:	c3                   	ret    

f0101af6 <cputchar>:

// `High'-level console I/O.  Used by readline and cprintf from KERNEL side

void
cputchar(int c)
{
f0101af6:	55                   	push   %ebp
f0101af7:	89 e5                	mov    %esp,%ebp
f0101af9:	83 ec 08             	sub    $0x8,%esp
	cons_putc(c);
f0101afc:	83 ec 0c             	sub    $0xc,%esp
f0101aff:	ff 75 08             	pushl  0x8(%ebp)
f0101b02:	e8 9c ff ff ff       	call   f0101aa3 <cons_putc>
f0101b07:	83 c4 10             	add    $0x10,%esp
}
f0101b0a:	90                   	nop
f0101b0b:	c9                   	leave  
f0101b0c:	c3                   	ret    

f0101b0d <getchar>:

int
getchar(void)
{
f0101b0d:	55                   	push   %ebp
f0101b0e:	89 e5                	mov    %esp,%ebp
f0101b10:	83 ec 18             	sub    $0x18,%esp
	int c;

	while ((c = cons_getc()) == 0)
f0101b13:	e8 df fe ff ff       	call   f01019f7 <cons_getc>
f0101b18:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0101b1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101b1f:	74 f2                	je     f0101b13 <getchar+0x6>
		/* do nothing */;
	return c;
f0101b21:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101b24:	c9                   	leave  
f0101b25:	c3                   	ret    

f0101b26 <iscons>:

int
iscons(int fdnum)
{
f0101b26:	55                   	push   %ebp
f0101b27:	89 e5                	mov    %esp,%ebp
	// used by readline
	return 1;
f0101b29:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0101b2e:	5d                   	pop    %ebp
f0101b2f:	c3                   	ret    

f0101b30 <clear_screen_buffer>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
void
clear_screen_buffer(void)
{
f0101b30:	55                   	push   %ebp
f0101b31:	89 e5                	mov    %esp,%ebp
f0101b33:	83 ec 10             	sub    $0x10,%esp
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
f0101b36:	c7 45 f8 00 80 0b f0 	movl   $0xf00b8000,-0x8(%ebp)
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101b3d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f0101b44:	eb 18                	jmp    f0101b5e <clear_screen_buffer+0x2e>
		crt_buf[i] = 0x0700 | ' ';
f0101b46:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0101b49:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0101b50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0101b53:	01 d0                	add    %edx,%eax
f0101b55:	c7 00 20 07 00 00    	movl   $0x720,(%eax)
clear_screen_buffer(void)
{
	// accessing the screen buffer in the memory
	uint32 *crt_buf = (uint32*)(KERNEL_BASE + CGA_BUF);
	// setting the screen buffer content to spaces with black background
	for (int i = 0; i < CRT_SIZE; i++)
f0101b5b:	ff 45 fc             	incl   -0x4(%ebp)
f0101b5e:	81 7d fc cf 07 00 00 	cmpl   $0x7cf,-0x4(%ebp)
f0101b65:	7e df                	jle    f0101b46 <clear_screen_buffer+0x16>
		crt_buf[i] = 0x0700 | ' ';
	crt_pos = 0; // reset_cursor_position
f0101b67:	66 c7 05 70 59 81 f0 	movw   $0x0,0xf0815970
f0101b6e:	00 00 
}
f0101b70:	90                   	nop
f0101b71:	c9                   	leave  
f0101b72:	c3                   	ret    

f0101b73 <keyboard_interrupt_handler>:

/*Keyboard Interrupt Service Routine */
void keyboard_interrupt_handler()
{
f0101b73:	55                   	push   %ebp
f0101b74:	89 e5                	mov    %esp,%ebp
f0101b76:	83 ec 08             	sub    $0x8,%esp
	//	char scanCode = inb(0x60) & 0x7F; //What key is pressed
	//	char press = inb(0x60) & 0x80; //Press down, or released
	//
	//	cprintf("Scan code: %d, Press: %d\n", scanCode, press);
	//cprintf("char is pressed\n");
	kbd_intr();
f0101b79:	e8 f7 fd ff ff       	call   f0101975 <kbd_intr>
		else if (KBD_INT_BLK_METHOD == LCK_SEMAPHORE)
		{
			signal_ksemaphore(&KBDsem);
		}
	}
}
f0101b7e:	90                   	nop
f0101b7f:	c9                   	leave  
f0101b80:	c3                   	ret    

f0101b81 <cons_lock>:

void cons_lock(void)
{
f0101b81:	55                   	push   %ebp
f0101b82:	89 e5                	mov    %esp,%ebp
f0101b84:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0101b87:	e8 8f 41 00 00       	call   f0105d1b <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101b8c:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0101b8d:	e8 86 9f 00 00       	call   f010bb18 <get_cpu_proc>
f0101b92:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0101b95:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101b99:	75 17                	jne    f0101bb2 <cons_lock+0x31>
		{
			panic("cons_lock: no running process to block");
f0101b9b:	83 ec 04             	sub    $0x4,%esp
f0101b9e:	68 48 b2 12 f0       	push   $0xf012b248
f0101ba3:	68 3b 02 00 00       	push   $0x23b
f0101ba8:	68 6f b2 12 f0       	push   $0xf012b26f
f0101bad:	e8 fd f3 ff ff       	call   f0100faf <_panic>
		}
		p->env_tf->tf_eflags &= ~FL_IF ;
f0101bb2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101bb5:	8b 00                	mov    (%eax),%eax
f0101bb7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101bba:	8b 12                	mov    (%edx),%edx
f0101bbc:	8b 52 38             	mov    0x38(%edx),%edx
f0101bbf:	80 e6 fd             	and    $0xfd,%dh
f0101bc2:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		wait_ksemaphore(&conssem);
	}

}
f0101bc5:	90                   	nop
f0101bc6:	c9                   	leave  
f0101bc7:	c3                   	ret    

f0101bc8 <cons_unlock>:

void cons_unlock(void)
{
f0101bc8:	55                   	push   %ebp
f0101bc9:	89 e5                	mov    %esp,%ebp
f0101bcb:	83 ec 18             	sub    $0x18,%esp
	if (CONS_LCK_METHOD == LCK_INT)
	{
		kclock_stop();
f0101bce:	e8 48 41 00 00       	call   f0105d1b <kclock_stop>
f0101bd3:	fa                   	cli    
		cli();
		struct Env * p = get_cpu_proc();
f0101bd4:	e8 3f 9f 00 00       	call   f010bb18 <get_cpu_proc>
f0101bd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (p == NULL)
f0101bdc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0101be0:	75 17                	jne    f0101bf9 <cons_unlock+0x31>
		{
			panic("cons_unlock: no running process to block");
f0101be2:	83 ec 04             	sub    $0x4,%esp
f0101be5:	68 84 b2 12 f0       	push   $0xf012b284
f0101bea:	68 54 02 00 00       	push   $0x254
f0101bef:	68 6f b2 12 f0       	push   $0xf012b26f
f0101bf4:	e8 b6 f3 ff ff       	call   f0100faf <_panic>
		}
		p->env_tf->tf_eflags |= FL_IF ;
f0101bf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101bfc:	8b 00                	mov    (%eax),%eax
f0101bfe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0101c01:	8b 12                	mov    (%edx),%edx
f0101c03:	8b 52 38             	mov    0x38(%edx),%edx
f0101c06:	80 ce 02             	or     $0x2,%dh
f0101c09:	89 50 38             	mov    %edx,0x38(%eax)
	else if (CONS_LCK_METHOD == LCK_SEMAPHORE)
	{
		signal_ksemaphore(&conssem);
	}

}
f0101c0c:	90                   	nop
f0101c0d:	c9                   	leave  
f0101c0e:	c3                   	ret    

f0101c0f <putch>:
#include <kern/cons/console.h>


static void
putch(int ch, int *cnt)
{
f0101c0f:	55                   	push   %ebp
f0101c10:	89 e5                	mov    %esp,%ebp
f0101c12:	83 ec 08             	sub    $0x8,%esp
	cputchar(ch);
f0101c15:	83 ec 0c             	sub    $0xc,%esp
f0101c18:	ff 75 08             	pushl  0x8(%ebp)
f0101c1b:	e8 d6 fe ff ff       	call   f0101af6 <cputchar>
f0101c20:	83 c4 10             	add    $0x10,%esp
	(*cnt)++;
f0101c23:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101c26:	8b 00                	mov    (%eax),%eax
f0101c28:	8d 50 01             	lea    0x1(%eax),%edx
f0101c2b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101c2e:	89 10                	mov    %edx,(%eax)
}
f0101c30:	90                   	nop
f0101c31:	c9                   	leave  
f0101c32:	c3                   	ret    

f0101c33 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
f0101c33:	55                   	push   %ebp
f0101c34:	89 e5                	mov    %esp,%ebp
f0101c36:	83 ec 18             	sub    $0x18,%esp
	int cnt = 0;
f0101c39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	vprintfmt((void*)putch, &cnt, fmt, ap);
f0101c40:	ff 75 0c             	pushl  0xc(%ebp)
f0101c43:	ff 75 08             	pushl  0x8(%ebp)
f0101c46:	8d 45 f4             	lea    -0xc(%ebp),%eax
f0101c49:	50                   	push   %eax
f0101c4a:	68 0f 1c 10 f0       	push   $0xf0101c0f
f0101c4f:	e8 65 88 01 00       	call   f011a4b9 <vprintfmt>
f0101c54:	83 c4 10             	add    $0x10,%esp
	return cnt;
f0101c57:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0101c5a:	c9                   	leave  
f0101c5b:	c3                   	ret    

f0101c5c <cprintf>:

int
cprintf(const char *fmt, ...)
{
f0101c5c:	55                   	push   %ebp
f0101c5d:	89 e5                	mov    %esp,%ebp
f0101c5f:	83 ec 18             	sub    $0x18,%esp
	int cnt;
	pushcli();	//disable interrupts
f0101c62:	e8 c9 64 00 00       	call   f0108130 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101c67:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101c6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101c6d:	8b 45 08             	mov    0x8(%ebp),%eax
f0101c70:	83 ec 08             	sub    $0x8,%esp
f0101c73:	ff 75 f4             	pushl  -0xc(%ebp)
f0101c76:	50                   	push   %eax
f0101c77:	e8 b7 ff ff ff       	call   f0101c33 <vcprintf>
f0101c7c:	83 c4 10             	add    $0x10,%esp
f0101c7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101c82:	e8 fb 64 00 00       	call   f0108182 <popcli>

	return cnt;
f0101c87:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101c8a:	c9                   	leave  
f0101c8b:	c3                   	ret    

f0101c8c <cprintf_colored>:

// *************** This text coloring feature is implemented by *************
// ********** Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int
cprintf_colored(int textClr, const char *fmt, ...)
{
f0101c8c:	55                   	push   %ebp
f0101c8d:	89 e5                	mov    %esp,%ebp
f0101c8f:	83 ec 18             	sub    $0x18,%esp
	current_text_color = (textClr << 8) ;
f0101c92:	8b 45 08             	mov    0x8(%ebp),%eax
f0101c95:	c1 e0 08             	shl    $0x8,%eax
f0101c98:	a3 f0 6a 85 f0       	mov    %eax,0xf0856af0
	int cnt;
	pushcli();	//disable interrupts
f0101c9d:	e8 8e 64 00 00       	call   f0108130 <pushcli>
	{
		va_list ap;

		va_start(ap, fmt);
f0101ca2:	8d 45 0c             	lea    0xc(%ebp),%eax
f0101ca5:	83 c0 04             	add    $0x4,%eax
f0101ca8:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cnt = vcprintf(fmt, ap);
f0101cab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0101cae:	83 ec 08             	sub    $0x8,%esp
f0101cb1:	ff 75 f4             	pushl  -0xc(%ebp)
f0101cb4:	50                   	push   %eax
f0101cb5:	e8 79 ff ff ff       	call   f0101c33 <vcprintf>
f0101cba:	83 c4 10             	add    $0x10,%esp
f0101cbd:	89 45 f0             	mov    %eax,-0x10(%ebp)
		va_end(ap);
	}
	popcli();	//enable interrupts
f0101cc0:	e8 bd 64 00 00       	call   f0108182 <popcli>
	current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f0101cc5:	c7 05 f0 6a 85 f0 00 	movl   $0x700,0xf0856af0
f0101ccc:	07 00 00 

	return cnt;
f0101ccf:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0101cd2:	c9                   	leave  
f0101cd3:	c3                   	ret    

f0101cd4 <run_command_prompt>:
#include "commands.h"

extern bool __autograde__ ;
extern void command_prompt_readline(const char *prompt, char* buf);
void run_command_prompt()
{
f0101cd4:	55                   	push   %ebp
f0101cd5:	89 e5                	mov    %esp,%ebp
f0101cd7:	57                   	push   %edi
f0101cd8:	56                   	push   %esi
f0101cd9:	53                   	push   %ebx
f0101cda:	81 ec 0c 10 00 00    	sub    $0x100c,%esp
	if (__autograde__)
f0101ce0:	a1 20 f0 17 f0       	mov    0xf017f020,%eax
f0101ce5:	85 c0                	test   %eax,%eax
f0101ce7:	0f 84 85 00 00 00    	je     f0101d72 <run_command_prompt+0x9e>
	{
		char cmdU1_2[BUFLEN] = "tst priorityRR 0";	//
f0101ced:	8d 85 e8 ef ff ff    	lea    -0x1018(%ebp),%eax
f0101cf3:	bb b6 b2 12 f0       	mov    $0xf012b2b6,%ebx
f0101cf8:	ba 11 00 00 00       	mov    $0x11,%edx
f0101cfd:	89 c7                	mov    %eax,%edi
f0101cff:	89 de                	mov    %ebx,%esi
f0101d01:	89 d1                	mov    %edx,%ecx
f0101d03:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d05:	8d 95 f9 ef ff ff    	lea    -0x1007(%ebp),%edx
f0101d0b:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101d10:	b0 00                	mov    $0x0,%al
f0101d12:	89 d7                	mov    %edx,%edi
f0101d14:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU2_2[BUFLEN] = "tst priorityRR 1";	//
f0101d16:	8d 85 e8 f3 ff ff    	lea    -0xc18(%ebp),%eax
f0101d1c:	bb b6 b6 12 f0       	mov    $0xf012b6b6,%ebx
f0101d21:	ba 11 00 00 00       	mov    $0x11,%edx
f0101d26:	89 c7                	mov    %eax,%edi
f0101d28:	89 de                	mov    %ebx,%esi
f0101d2a:	89 d1                	mov    %edx,%ecx
f0101d2c:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d2e:	8d 95 f9 f3 ff ff    	lea    -0xc07(%ebp),%edx
f0101d34:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101d39:	b0 00                	mov    $0x0,%al
f0101d3b:	89 d7                	mov    %edx,%edi
f0101d3d:	f3 aa                	rep stos %al,%es:(%edi)
		char cmdU3_2[BUFLEN] = "tst priorityRR 2";	//
f0101d3f:	8d 85 e8 f7 ff ff    	lea    -0x818(%ebp),%eax
f0101d45:	bb b6 ba 12 f0       	mov    $0xf012bab6,%ebx
f0101d4a:	ba 11 00 00 00       	mov    $0x11,%edx
f0101d4f:	89 c7                	mov    %eax,%edi
f0101d51:	89 de                	mov    %ebx,%esi
f0101d53:	89 d1                	mov    %edx,%ecx
f0101d55:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0101d57:	8d 95 f9 f7 ff ff    	lea    -0x807(%ebp),%edx
f0101d5d:	b9 ef 03 00 00       	mov    $0x3ef,%ecx
f0101d62:	b0 00                	mov    $0x0,%al
f0101d64:	89 d7                	mov    %edx,%edi
f0101d66:	f3 aa                	rep stos %al,%es:(%edi)
//		execute_command(cmdU3_2);
		__autograde__ = 0;
f0101d68:	c7 05 20 f0 17 f0 00 	movl   $0x0,0xf017f020
f0101d6f:	00 00 00 
	}
	/*2024*/
	LIST_INIT(&foundCommands);
f0101d72:	c7 05 6c 6d 85 f0 00 	movl   $0x0,0xf0856d6c
f0101d79:	00 00 00 
f0101d7c:	c7 05 70 6d 85 f0 00 	movl   $0x0,0xf0856d70
f0101d83:	00 00 00 
f0101d86:	c7 05 78 6d 85 f0 00 	movl   $0x0,0xf0856d78
f0101d8d:	00 00 00 
		//readline("FOS> ", command_line);

		// ********** This DosKey supported readline function is a combined implementation from **********
		// ********** 		Mohamed Raafat & Mohamed Yousry, 3rd year students, FCIS, 2017		**********
		// ********** 				Combined, edited and modified by TA\Ghada Hamed				**********
		memset(command_line, 0, sizeof(command_line));
f0101d90:	83 ec 04             	sub    $0x4,%esp
f0101d93:	68 00 04 00 00       	push   $0x400
f0101d98:	6a 00                	push   $0x0
f0101d9a:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101da0:	50                   	push   %eax
f0101da1:	e8 c3 8f 01 00       	call   f011ad69 <memset>
f0101da6:	83 c4 10             	add    $0x10,%esp
		command_prompt_readline("FOS> ", command_line);
f0101da9:	83 ec 08             	sub    $0x8,%esp
f0101dac:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101db2:	50                   	push   %eax
f0101db3:	68 b0 b2 12 f0       	push   $0xf012b2b0
f0101db8:	e8 42 06 00 00       	call   f01023ff <command_prompt_readline>
f0101dbd:	83 c4 10             	add    $0x10,%esp

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
f0101dc0:	83 ec 0c             	sub    $0xc,%esp
f0101dc3:	8d 85 e8 fb ff ff    	lea    -0x418(%ebp),%eax
f0101dc9:	50                   	push   %eax
f0101dca:	e8 4c 01 00 00       	call   f0101f1b <execute_command>
f0101dcf:	83 c4 10             	add    $0x10,%esp
f0101dd2:	85 c0                	test   %eax,%eax
f0101dd4:	78 02                	js     f0101dd8 <run_command_prompt+0x104>
				break;
	}
f0101dd6:	eb b8                	jmp    f0101d90 <run_command_prompt+0xbc>
		command_prompt_readline("FOS> ", command_line);

		//parse and execute the command
		if (command_line != NULL)
			if (execute_command(command_line) < 0)
				break;
f0101dd8:	90                   	nop
	}
}
f0101dd9:	90                   	nop
f0101dda:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0101ddd:	5b                   	pop    %ebx
f0101dde:	5e                   	pop    %esi
f0101ddf:	5f                   	pop    %edi
f0101de0:	5d                   	pop    %ebp
f0101de1:	c3                   	ret    

f0101de2 <get_into_prompt>:
 * They're placed globally (instead of locally) to avoid clearing them while they're in use [el7 :)]
 */
int m;
char *p ;
void get_into_prompt()
{
f0101de2:	55                   	push   %ebp
f0101de3:	89 e5                	mov    %esp,%ebp
f0101de5:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0101de8:	9c                   	pushf  
f0101de9:	58                   	pop    %eax
f0101dea:	89 45 d8             	mov    %eax,-0x28(%ebp)
        return eflags;
f0101ded:	8b 45 d8             	mov    -0x28(%ebp),%eax
	while (1)
	{
		//disable interrupt if it's already enabled
		if (read_eflags() & FL_IF)
f0101df0:	25 00 02 00 00       	and    $0x200,%eax
f0101df5:	85 c0                	test   %eax,%eax
f0101df7:	74 01                	je     f0101dfa <get_into_prompt+0x18>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0101df9:	fa                   	cli    
			cli();

		//Switch to the kernel virtual memory
		switchkvm();
f0101dfa:	e8 9f 9f 00 00       	call   f010bd9e <switchkvm>

		//Reset current CPU
		struct cpu *c = mycpu();
f0101dff:	e8 6c 62 00 00       	call   f0108070 <mycpu>
f0101e04:	89 45 f0             	mov    %eax,-0x10(%ebp)
		c->ncli = 0;
f0101e07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e0a:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f0101e11:	00 00 00 
		c->intena = 0;
f0101e14:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e17:	c7 80 ac 00 00 00 00 	movl   $0x0,0xac(%eax)
f0101e1e:	00 00 00 
		c->scheduler = NULL;
f0101e21:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e24:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
		c->scheduler_status = SCH_STOPPED ;
f0101e2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e2e:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0101e35:	00 00 00 
		c->proc = NULL;
f0101e38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e3b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0101e42:	00 00 00 

static __inline uint32
read_esp(void)
{
        uint32 esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
f0101e45:	89 e0                	mov    %esp,%eax
f0101e47:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return esp;
f0101e4a:	8b 45 dc             	mov    -0x24(%ebp),%eax

		//Read current ESP
		uint32 cur_esp = read_esp();
f0101e4d:	89 45 e8             	mov    %eax,-0x18(%ebp)

//		//Make sure it's in the correct stack (i.e. KERN STACK below KERN_BASE)
//		assert(cur_esp < SCHD_KERN_STACK_TOP && cur_esp >= SCHD_KERN_STACK_TOP - KERNEL_STACK_SIZE);

		//Reset ESP to the beginning of the SCHED KERNEL STACK of this CPU before getting into the cmd prmpt
		uint32 cpuStackTop = (uint32)c->stack + KERNEL_STACK_SIZE;
f0101e50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e53:	8b 40 08             	mov    0x8(%eax),%eax
f0101e56:	05 00 80 00 00       	add    $0x8000,%eax
f0101e5b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		uint32 cpuStackBottom = (uint32)c->stack + PAGE_SIZE/*GUARD Page*/;
f0101e5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0101e61:	8b 40 08             	mov    0x8(%eax),%eax
f0101e64:	05 00 10 00 00       	add    $0x1000,%eax
f0101e69:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0101e6c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e6f:	89 45 f4             	mov    %eax,-0xc(%ebp)
}

static __inline void
write_esp(uint32 esp)
{
	__asm __volatile("movl %0,%%esp" : : "r" (esp) );
f0101e72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0101e75:	89 c4                	mov    %eax,%esp
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101e77:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e7a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0101e7d:	73 44                	jae    f0101ec3 <get_into_prompt+0xe1>
f0101e7f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e82:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0101e85:	72 3c                	jb     f0101ec3 <get_into_prompt+0xe1>
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
f0101e87:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0101e8a:	a3 74 6e 85 f0       	mov    %eax,0xf0856e74
			m = cpuStackTop - cur_esp;
f0101e8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101e92:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0101e95:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
			while (--m >= 0)
f0101e9a:	eb 11                	jmp    f0101ead <get_into_prompt+0xcb>
				*p++ = 0;
f0101e9c:	a1 74 6e 85 f0       	mov    0xf0856e74,%eax
f0101ea1:	8d 50 01             	lea    0x1(%eax),%edx
f0101ea4:	89 15 74 6e 85 f0    	mov    %edx,0xf0856e74
f0101eaa:	c6 00 00             	movb   $0x0,(%eax)
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
		{
			//memset((char*)cur_esp, 0, SCHD_KERN_STACK_TOP - cur_esp);
			p = (char*)cur_esp;
			m = cpuStackTop - cur_esp;
			while (--m >= 0)
f0101ead:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101eb2:	48                   	dec    %eax
f0101eb3:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
f0101eb8:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101ebd:	85 c0                	test   %eax,%eax
f0101ebf:	79 db                	jns    f0101e9c <get_into_prompt+0xba>
		write_esp(cpuStackTop);

		//cprintf("AFTER RESIT = %x ***\n", read_esp());

		//Clear the stack content to avoid any garbage data on it when getting back into prompt
		if (cur_esp < cpuStackTop && cur_esp >= cpuStackBottom)
f0101ec1:	eb 3a                	jmp    f0101efd <get_into_prompt+0x11b>
				*p++ = 0;
		}
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
f0101ec3:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0101ec6:	a3 74 6e 85 f0       	mov    %eax,0xf0856e74
			m = cpuStackTop - cpuStackBottom;
f0101ecb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0101ece:	2b 45 e0             	sub    -0x20(%ebp),%eax
f0101ed1:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
			while (--m >= 0)
f0101ed6:	eb 11                	jmp    f0101ee9 <get_into_prompt+0x107>
				*p++ = 0;
f0101ed8:	a1 74 6e 85 f0       	mov    0xf0856e74,%eax
f0101edd:	8d 50 01             	lea    0x1(%eax),%edx
f0101ee0:	89 15 74 6e 85 f0    	mov    %edx,0xf0856e74
f0101ee6:	c6 00 00             	movb   $0x0,(%eax)
		else	//clear the ENTIRE SCHED KERN STACK
		{
			//memset((char*)schd_kern_stack_bottom, 0, SCHD_KERN_STACK_TOP - schd_kern_stack_bottom);
			p = (char*)cpuStackBottom;
			m = cpuStackTop - cpuStackBottom;
			while (--m >= 0)
f0101ee9:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101eee:	48                   	dec    %eax
f0101eef:	a3 78 6e 85 f0       	mov    %eax,0xf0856e78
f0101ef4:	a1 78 6e 85 f0       	mov    0xf0856e78,%eax
f0101ef9:	85 c0                	test   %eax,%eax
f0101efb:	79 db                	jns    f0101ed8 <get_into_prompt+0xf6>
f0101efd:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
}

static __inline void
write_ebp(uint32 ebp)
{
	__asm __volatile("movl %0,%%ebp" : : "r" (ebp) );
f0101f04:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0101f07:	89 c5                	mov    %eax,%ebp

		//Reset EBP to ZERO so that when calling the run_command_prompt() it pushes ZERO into the stack
		write_ebp(0);

		//Get into the prompt (should NOT return)
		run_command_prompt(NULL);
f0101f09:	83 ec 0c             	sub    $0xc,%esp
f0101f0c:	6a 00                	push   $0x0
f0101f0e:	e8 c1 fd ff ff       	call   f0101cd4 <run_command_prompt>
f0101f13:	83 c4 10             	add    $0x10,%esp
	}
f0101f16:	e9 cd fe ff ff       	jmp    f0101de8 <get_into_prompt+0x6>

f0101f1b <execute_command>:
#define WHITESPACE "\t\r\n "

//Function to parse any command and execute it
//(simply by calling its corresponding function)
int execute_command(char *command_string)
{
f0101f1b:	55                   	push   %ebp
f0101f1c:	89 e5                	mov    %esp,%ebp
f0101f1e:	83 ec 78             	sub    $0x78,%esp
	int number_of_arguments;
	//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
	char *arguments[MAX_ARGUMENTS];


	strsplit(command_string, WHITESPACE, arguments, &number_of_arguments) ;
f0101f21:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0101f24:	50                   	push   %eax
f0101f25:	8d 45 90             	lea    -0x70(%ebp),%eax
f0101f28:	50                   	push   %eax
f0101f29:	68 b6 be 12 f0       	push   $0xf012beb6
f0101f2e:	ff 75 08             	pushl  0x8(%ebp)
f0101f31:	e8 09 93 01 00       	call   f011b23f <strsplit>
f0101f36:	83 c4 10             	add    $0x10,%esp
	if (number_of_arguments == 0)
f0101f39:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f3c:	85 c0                	test   %eax,%eax
f0101f3e:	75 0a                	jne    f0101f4a <execute_command+0x2f>
		return 0;
f0101f40:	b8 00 00 00 00       	mov    $0x0,%eax
f0101f45:	e9 a4 02 00 00       	jmp    f01021ee <execute_command+0x2d3>

	int ret = process_command(number_of_arguments, arguments);
f0101f4a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0101f4d:	83 ec 08             	sub    $0x8,%esp
f0101f50:	8d 55 90             	lea    -0x70(%ebp),%edx
f0101f53:	52                   	push   %edx
f0101f54:	50                   	push   %eax
f0101f55:	e8 96 02 00 00       	call   f01021f0 <process_command>
f0101f5a:	83 c4 10             	add    $0x10,%esp
f0101f5d:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (ret == CMD_INVALID)
f0101f60:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0101f64:	75 19                	jne    f0101f7f <execute_command+0x64>
	{
		cprintf("Unknown command '%s'\n", arguments[0]);
f0101f66:	8b 45 90             	mov    -0x70(%ebp),%eax
f0101f69:	83 ec 08             	sub    $0x8,%esp
f0101f6c:	50                   	push   %eax
f0101f6d:	68 bb be 12 f0       	push   $0xf012bebb
f0101f72:	e8 e5 fc ff ff       	call   f0101c5c <cprintf>
f0101f77:	83 c4 10             	add    $0x10,%esp
f0101f7a:	e9 6a 02 00 00       	jmp    f01021e9 <execute_command+0x2ce>
	}
	else if (ret == CMD_INV_NUM_ARGS)
f0101f7f:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0101f83:	75 4f                	jne    f0101fd4 <execute_command+0xb9>
	{
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101f85:	a1 78 6d 85 f0       	mov    0xf0856d78,%eax
f0101f8a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (numOfFoundCmds != 1)
f0101f8d:	83 7d d8 01          	cmpl   $0x1,-0x28(%ebp)
f0101f91:	74 17                	je     f0101faa <execute_command+0x8f>
		{
			panic("command is found but the list is either empty or contains more than one command!");
f0101f93:	83 ec 04             	sub    $0x4,%esp
f0101f96:	68 d4 be 12 f0       	push   $0xf012bed4
f0101f9b:	68 90 00 00 00       	push   $0x90
f0101fa0:	68 25 bf 12 f0       	push   $0xf012bf25
f0101fa5:	e8 05 f0 ff ff       	call   f0100faf <_panic>
		}
		struct Command * cmd = LIST_FIRST(&foundCommands);
f0101faa:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0101faf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		cprintf("%s: invalid number of args.\nDescription: %s\n", cmd->name, cmd->description);
f0101fb2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101fb5:	8b 50 04             	mov    0x4(%eax),%edx
f0101fb8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0101fbb:	8b 00                	mov    (%eax),%eax
f0101fbd:	83 ec 04             	sub    $0x4,%esp
f0101fc0:	52                   	push   %edx
f0101fc1:	50                   	push   %eax
f0101fc2:	68 40 bf 12 f0       	push   $0xf012bf40
f0101fc7:	e8 90 fc ff ff       	call   f0101c5c <cprintf>
f0101fcc:	83 c4 10             	add    $0x10,%esp
f0101fcf:	e9 15 02 00 00       	jmp    f01021e9 <execute_command+0x2ce>
	}
	else if (ret == CMD_MATCHED)
f0101fd4:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0101fd8:	0f 85 e6 01 00 00    	jne    f01021c4 <execute_command+0x2a9>
	{
		int i = 1;
f0101fde:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		int numOfFoundCmds = LIST_SIZE(&foundCommands);
f0101fe5:	a1 78 6d 85 f0       	mov    0xf0856d78,%eax
f0101fea:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (numOfFoundCmds == 0)
f0101fed:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0101ff1:	75 17                	jne    f010200a <execute_command+0xef>
		{
			panic("command is matched but the list is empty!");
f0101ff3:	83 ec 04             	sub    $0x4,%esp
f0101ff6:	68 70 bf 12 f0       	push   $0xf012bf70
f0101ffb:	68 9b 00 00 00       	push   $0x9b
f0102000:	68 25 bf 12 f0       	push   $0xf012bf25
f0102005:	e8 a5 ef ff ff       	call   f0100faf <_panic>
		}
		struct Command * cmd = NULL;
f010200a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(cmd, &foundCommands)
f0102011:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0102016:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102019:	eb 28                	jmp    f0102043 <execute_command+0x128>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
f010201b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010201e:	8b 10                	mov    (%eax),%edx
f0102020:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102023:	8d 48 01             	lea    0x1(%eax),%ecx
f0102026:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f0102029:	83 ec 04             	sub    $0x4,%esp
f010202c:	52                   	push   %edx
f010202d:	50                   	push   %eax
f010202e:	68 9a bf 12 f0       	push   $0xf012bf9a
f0102033:	e8 24 fc ff ff       	call   f0101c5c <cprintf>
f0102038:	83 c4 10             	add    $0x10,%esp
		if (numOfFoundCmds == 0)
		{
			panic("command is matched but the list is empty!");
		}
		struct Command * cmd = NULL;
		LIST_FOREACH(cmd, &foundCommands)
f010203b:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0102040:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102043:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102047:	74 08                	je     f0102051 <execute_command+0x136>
f0102049:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010204c:	8b 40 10             	mov    0x10(%eax),%eax
f010204f:	eb 05                	jmp    f0102056 <execute_command+0x13b>
f0102051:	b8 00 00 00 00       	mov    $0x0,%eax
f0102056:	a3 74 6d 85 f0       	mov    %eax,0xf0856d74
f010205b:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0102060:	85 c0                	test   %eax,%eax
f0102062:	75 b7                	jne    f010201b <execute_command+0x100>
f0102064:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102068:	75 b1                	jne    f010201b <execute_command+0x100>
		{
			cprintf("[%d] %s\n", i++, cmd->name);
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
f010206a:	83 ec 08             	sub    $0x8,%esp
f010206d:	ff 75 dc             	pushl  -0x24(%ebp)
f0102070:	68 a4 bf 12 f0       	push   $0xf012bfa4
f0102075:	e8 e2 fb ff ff       	call   f0101c5c <cprintf>
f010207a:	83 c4 10             	add    $0x10,%esp
		char Chose = getchar();
f010207d:	e8 8b fa ff ff       	call   f0101b0d <getchar>
f0102082:	88 45 ef             	mov    %al,-0x11(%ebp)
		cputchar(Chose);
f0102085:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f0102089:	83 ec 0c             	sub    $0xc,%esp
f010208c:	50                   	push   %eax
f010208d:	e8 64 fa ff ff       	call   f0101af6 <cputchar>
f0102092:	83 c4 10             	add    $0x10,%esp
		int selection = 0;
f0102095:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		while (Chose >= '0' && Chose <= '9')
f010209c:	eb 40                	jmp    f01020de <execute_command+0x1c3>
		{
			selection = selection*10 + (Chose - '0') ;
f010209e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01020a1:	89 d0                	mov    %edx,%eax
f01020a3:	c1 e0 02             	shl    $0x2,%eax
f01020a6:	01 d0                	add    %edx,%eax
f01020a8:	01 c0                	add    %eax,%eax
f01020aa:	89 c2                	mov    %eax,%edx
f01020ac:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020b0:	83 e8 30             	sub    $0x30,%eax
f01020b3:	01 d0                	add    %edx,%eax
f01020b5:	89 45 e8             	mov    %eax,-0x18(%ebp)
			if (selection < 1 || selection > numOfFoundCmds)
f01020b8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020bc:	7e 2c                	jle    f01020ea <execute_command+0x1cf>
f01020be:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01020c1:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01020c4:	7f 24                	jg     f01020ea <execute_command+0x1cf>
				break;

			Chose = getchar();
f01020c6:	e8 42 fa ff ff       	call   f0101b0d <getchar>
f01020cb:	88 45 ef             	mov    %al,-0x11(%ebp)
			cputchar(Chose);
f01020ce:	0f be 45 ef          	movsbl -0x11(%ebp),%eax
f01020d2:	83 ec 0c             	sub    $0xc,%esp
f01020d5:	50                   	push   %eax
f01020d6:	e8 1b fa ff ff       	call   f0101af6 <cputchar>
f01020db:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("Please select the required command [1] to [%d] and press enter? or press any other key to cancel: ", numOfFoundCmds);
		char Chose = getchar();
		cputchar(Chose);
		int selection = 0;
		while (Chose >= '0' && Chose <= '9')
f01020de:	80 7d ef 2f          	cmpb   $0x2f,-0x11(%ebp)
f01020e2:	7e 06                	jle    f01020ea <execute_command+0x1cf>
f01020e4:	80 7d ef 39          	cmpb   $0x39,-0x11(%ebp)
f01020e8:	7e b4                	jle    f010209e <execute_command+0x183>
				break;

			Chose = getchar();
			cputchar(Chose);
		}
		cputchar('\n');
f01020ea:	83 ec 0c             	sub    $0xc,%esp
f01020ed:	6a 0a                	push   $0xa
f01020ef:	e8 02 fa ff ff       	call   f0101af6 <cputchar>
f01020f4:	83 c4 10             	add    $0x10,%esp
		if (selection >= 1 && selection <= numOfFoundCmds)
f01020f7:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01020fb:	0f 8e e8 00 00 00    	jle    f01021e9 <execute_command+0x2ce>
f0102101:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0102104:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0102107:	0f 8f dc 00 00 00    	jg     f01021e9 <execute_command+0x2ce>
		{
			int c = 1;
f010210d:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
			LIST_FOREACH(cmd, &foundCommands)
f0102114:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0102119:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010211c:	eb 75                	jmp    f0102193 <execute_command+0x278>
			{
				if (c++ == selection)
f010211e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0102121:	8d 50 01             	lea    0x1(%eax),%edx
f0102124:	89 55 e4             	mov    %edx,-0x1c(%ebp)
f0102127:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010212a:	75 5f                	jne    f010218b <execute_command+0x270>
				{
					if (cmd->num_of_args == 0)
f010212c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010212f:	8b 40 0c             	mov    0xc(%eax),%eax
f0102132:	85 c0                	test   %eax,%eax
f0102134:	75 31                	jne    f0102167 <execute_command+0x24c>
					{
						cprintf("FOS> %s\n", cmd->name);
f0102136:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102139:	8b 00                	mov    (%eax),%eax
f010213b:	83 ec 08             	sub    $0x8,%esp
f010213e:	50                   	push   %eax
f010213f:	68 07 c0 12 f0       	push   $0xf012c007
f0102144:	e8 13 fb ff ff       	call   f0101c5c <cprintf>
f0102149:	83 c4 10             	add    $0x10,%esp
						return cmd->function_to_execute(number_of_arguments, arguments);
f010214c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010214f:	8b 40 08             	mov    0x8(%eax),%eax
f0102152:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102155:	83 ec 08             	sub    $0x8,%esp
f0102158:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f010215b:	51                   	push   %ecx
f010215c:	52                   	push   %edx
f010215d:	ff d0                	call   *%eax
f010215f:	83 c4 10             	add    $0x10,%esp
f0102162:	e9 87 00 00 00       	jmp    f01021ee <execute_command+0x2d3>
					}
					else
					{
						cprintf("%s: %s\n", cmd->name, cmd->description);
f0102167:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010216a:	8b 50 04             	mov    0x4(%eax),%edx
f010216d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102170:	8b 00                	mov    (%eax),%eax
f0102172:	83 ec 04             	sub    $0x4,%esp
f0102175:	52                   	push   %edx
f0102176:	50                   	push   %eax
f0102177:	68 10 c0 12 f0       	push   $0xf012c010
f010217c:	e8 db fa ff ff       	call   f0101c5c <cprintf>
f0102181:	83 c4 10             	add    $0x10,%esp
						return 0;
f0102184:	b8 00 00 00 00       	mov    $0x0,%eax
f0102189:	eb 63                	jmp    f01021ee <execute_command+0x2d3>
		}
		cputchar('\n');
		if (selection >= 1 && selection <= numOfFoundCmds)
		{
			int c = 1;
			LIST_FOREACH(cmd, &foundCommands)
f010218b:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0102190:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0102193:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0102197:	74 08                	je     f01021a1 <execute_command+0x286>
f0102199:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010219c:	8b 40 10             	mov    0x10(%eax),%eax
f010219f:	eb 05                	jmp    f01021a6 <execute_command+0x28b>
f01021a1:	b8 00 00 00 00       	mov    $0x0,%eax
f01021a6:	a3 74 6d 85 f0       	mov    %eax,0xf0856d74
f01021ab:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f01021b0:	85 c0                	test   %eax,%eax
f01021b2:	0f 85 66 ff ff ff    	jne    f010211e <execute_command+0x203>
f01021b8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01021bc:	0f 85 5c ff ff ff    	jne    f010211e <execute_command+0x203>
f01021c2:	eb 25                	jmp    f01021e9 <execute_command+0x2ce>
			}
		}
	}
	else
	{
		return commands[ret].function_to_execute(number_of_arguments, arguments);
f01021c4:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01021c7:	89 d0                	mov    %edx,%eax
f01021c9:	01 c0                	add    %eax,%eax
f01021cb:	01 d0                	add    %edx,%eax
f01021cd:	c1 e0 03             	shl    $0x3,%eax
f01021d0:	05 68 f5 17 f0       	add    $0xf017f568,%eax
f01021d5:	8b 00                	mov    (%eax),%eax
f01021d7:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01021da:	83 ec 08             	sub    $0x8,%esp
f01021dd:	8d 4d 90             	lea    -0x70(%ebp),%ecx
f01021e0:	51                   	push   %ecx
f01021e1:	52                   	push   %edx
f01021e2:	ff d0                	call   *%eax
f01021e4:	83 c4 10             	add    $0x10,%esp
f01021e7:	eb 05                	jmp    f01021ee <execute_command+0x2d3>
	}
	return 0;
f01021e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01021ee:	c9                   	leave  
f01021ef:	c3                   	ret    

f01021f0 <process_command>:


int process_command(int number_of_arguments, char** arguments)
{
f01021f0:	55                   	push   %ebp
f01021f1:	89 e5                	mov    %esp,%ebp
f01021f3:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f01021f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01021fd:	eb 31                	jmp    f0102230 <process_command+0x40>
	{
		if (strcmp(arguments[0], commands[i].name) == 0)
f01021ff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102202:	89 d0                	mov    %edx,%eax
f0102204:	01 c0                	add    %eax,%eax
f0102206:	01 d0                	add    %edx,%eax
f0102208:	c1 e0 03             	shl    $0x3,%eax
f010220b:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102210:	8b 10                	mov    (%eax),%edx
f0102212:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102215:	8b 00                	mov    (%eax),%eax
f0102217:	83 ec 08             	sub    $0x8,%esp
f010221a:	52                   	push   %edx
f010221b:	50                   	push   %eax
f010221c:	e8 66 8a 01 00       	call   f011ac87 <strcmp>
f0102221:	83 c4 10             	add    $0x10,%esp
f0102224:	85 c0                	test   %eax,%eax
f0102226:	75 05                	jne    f010222d <process_command+0x3d>
		{
			return i;
f0102228:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010222b:	eb 14                	jmp    f0102241 <process_command+0x51>
}


int process_command(int number_of_arguments, char** arguments)
{
	for (int i = 0; i < NUM_OF_COMMANDS; i++)
f010222d:	ff 45 f4             	incl   -0xc(%ebp)
f0102230:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102233:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102238:	39 c2                	cmp    %eax,%edx
f010223a:	72 c3                	jb     f01021ff <process_command+0xf>
		if (strcmp(arguments[0], commands[i].name) == 0)
		{
			return i;
		}
	}
	return CMD_INVALID;
f010223c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
f0102241:	c9                   	leave  
f0102242:	c3                   	ret    

f0102243 <clearandwritecommand>:
#define HISTORY_MAX 19
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
f0102243:	55                   	push   %ebp
f0102244:	89 e5                	mov    %esp,%ebp
f0102246:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < *i; j++) {
f0102249:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102250:	eb 10                	jmp    f0102262 <clearandwritecommand+0x1f>
		cputchar('\b');
f0102252:	83 ec 0c             	sub    $0xc,%esp
f0102255:	6a 08                	push   $0x8
f0102257:	e8 9a f8 ff ff       	call   f0101af6 <cputchar>
f010225c:	83 c4 10             	add    $0x10,%esp
int last_command_idx = -1;
char command_history[HISTORY_MAX+1][BUFLEN];
char empty_buf[BUFLEN];

void clearandwritecommand(int* i, int commandidx, char* buf, int *last_index) {
	for (int j = 0; j < *i; j++) {
f010225f:	ff 45 f4             	incl   -0xc(%ebp)
f0102262:	8b 45 08             	mov    0x8(%ebp),%eax
f0102265:	8b 00                	mov    (%eax),%eax
f0102267:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010226a:	7f e6                	jg     f0102252 <clearandwritecommand+0xf>
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
f010226c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010226f:	c1 e0 0a             	shl    $0xa,%eax
f0102272:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102277:	83 ec 0c             	sub    $0xc,%esp
f010227a:	50                   	push   %eax
f010227b:	e8 fb 88 01 00       	call   f011ab7b <strlen>
f0102280:	83 c4 10             	add    $0x10,%esp
f0102283:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102286:	83 ec 04             	sub    $0x4,%esp
f0102289:	68 00 04 00 00       	push   $0x400
f010228e:	68 80 4e 87 f0       	push   $0xf0874e80
f0102293:	ff 75 10             	pushl  0x10(%ebp)
f0102296:	e8 71 8b 01 00       	call   f011ae0c <memcpy>
f010229b:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f010229e:	8b 45 08             	mov    0x8(%ebp),%eax
f01022a1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01022a7:	eb 52                	jmp    f01022fb <clearandwritecommand+0xb8>
		cputchar(command_history[commandidx][*i]);
f01022a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01022ac:	8b 00                	mov    (%eax),%eax
f01022ae:	8b 55 0c             	mov    0xc(%ebp),%edx
f01022b1:	c1 e2 0a             	shl    $0xa,%edx
f01022b4:	01 d0                	add    %edx,%eax
f01022b6:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f01022bb:	8a 00                	mov    (%eax),%al
f01022bd:	0f be c0             	movsbl %al,%eax
f01022c0:	83 ec 0c             	sub    $0xc,%esp
f01022c3:	50                   	push   %eax
f01022c4:	e8 2d f8 ff ff       	call   f0101af6 <cputchar>
f01022c9:	83 c4 10             	add    $0x10,%esp
		buf[*i] = command_history[commandidx][*i];
f01022cc:	8b 45 08             	mov    0x8(%ebp),%eax
f01022cf:	8b 00                	mov    (%eax),%eax
f01022d1:	89 c2                	mov    %eax,%edx
f01022d3:	8b 45 10             	mov    0x10(%ebp),%eax
f01022d6:	01 c2                	add    %eax,%edx
f01022d8:	8b 45 08             	mov    0x8(%ebp),%eax
f01022db:	8b 00                	mov    (%eax),%eax
f01022dd:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f01022e0:	c1 e1 0a             	shl    $0xa,%ecx
f01022e3:	01 c8                	add    %ecx,%eax
f01022e5:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f01022ea:	8a 00                	mov    (%eax),%al
f01022ec:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < *i; j++) {
		cputchar('\b');
	}
	int len = strlen(command_history[commandidx]);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01022ee:	8b 45 08             	mov    0x8(%ebp),%eax
f01022f1:	8b 00                	mov    (%eax),%eax
f01022f3:	8d 50 01             	lea    0x1(%eax),%edx
f01022f6:	8b 45 08             	mov    0x8(%ebp),%eax
f01022f9:	89 10                	mov    %edx,(%eax)
f01022fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01022fe:	8b 00                	mov    (%eax),%eax
f0102300:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0102303:	7c a4                	jl     f01022a9 <clearandwritecommand+0x66>
		cputchar(command_history[commandidx][*i]);
		buf[*i] = command_history[commandidx][*i];
	}
	*last_index = len;
f0102305:	8b 45 14             	mov    0x14(%ebp),%eax
f0102308:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010230b:	89 10                	mov    %edx,(%eax)
}
f010230d:	90                   	nop
f010230e:	c9                   	leave  
f010230f:	c3                   	ret    

f0102310 <RoundAutoCompleteCommandWithTheSamePrefix>:

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
f0102310:	55                   	push   %ebp
f0102311:	89 e5                	mov    %esp,%ebp
f0102313:	83 ec 18             	sub    $0x18,%esp
	for (int j = 0; j < old_buf_len; j++) {
f0102316:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010231d:	eb 10                	jmp    f010232f <RoundAutoCompleteCommandWithTheSamePrefix+0x1f>
		cputchar('\b');
f010231f:	83 ec 0c             	sub    $0xc,%esp
f0102322:	6a 08                	push   $0x8
f0102324:	e8 cd f7 ff ff       	call   f0101af6 <cputchar>
f0102329:	83 c4 10             	add    $0x10,%esp
	*last_index = len;
}

void RoundAutoCompleteCommandWithTheSamePrefix(int old_buf_len, char* prefix_element,
		char* buf, int* i, int *last_index) {
	for (int j = 0; j < old_buf_len; j++) {
f010232c:	ff 45 f4             	incl   -0xc(%ebp)
f010232f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0102332:	3b 45 08             	cmp    0x8(%ebp),%eax
f0102335:	7c e8                	jl     f010231f <RoundAutoCompleteCommandWithTheSamePrefix+0xf>
		cputchar('\b');
	}
	int len = strlen(prefix_element);
f0102337:	83 ec 0c             	sub    $0xc,%esp
f010233a:	ff 75 0c             	pushl  0xc(%ebp)
f010233d:	e8 39 88 01 00       	call   f011ab7b <strlen>
f0102342:	83 c4 10             	add    $0x10,%esp
f0102345:	89 45 f0             	mov    %eax,-0x10(%ebp)
	memcpy(buf, empty_buf, BUFLEN);
f0102348:	83 ec 04             	sub    $0x4,%esp
f010234b:	68 00 04 00 00       	push   $0x400
f0102350:	68 80 4e 87 f0       	push   $0xf0874e80
f0102355:	ff 75 10             	pushl  0x10(%ebp)
f0102358:	e8 af 8a 01 00       	call   f011ae0c <memcpy>
f010235d:	83 c4 10             	add    $0x10,%esp
	for (*i = 0; *i < len; (*i)++) {
f0102360:	8b 45 14             	mov    0x14(%ebp),%eax
f0102363:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0102369:	eb 46                	jmp    f01023b1 <RoundAutoCompleteCommandWithTheSamePrefix+0xa1>
		cputchar(prefix_element[*i]);
f010236b:	8b 45 14             	mov    0x14(%ebp),%eax
f010236e:	8b 00                	mov    (%eax),%eax
f0102370:	89 c2                	mov    %eax,%edx
f0102372:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102375:	01 d0                	add    %edx,%eax
f0102377:	8a 00                	mov    (%eax),%al
f0102379:	0f be c0             	movsbl %al,%eax
f010237c:	83 ec 0c             	sub    $0xc,%esp
f010237f:	50                   	push   %eax
f0102380:	e8 71 f7 ff ff       	call   f0101af6 <cputchar>
f0102385:	83 c4 10             	add    $0x10,%esp
		buf[*i] = prefix_element[*i];
f0102388:	8b 45 14             	mov    0x14(%ebp),%eax
f010238b:	8b 00                	mov    (%eax),%eax
f010238d:	89 c2                	mov    %eax,%edx
f010238f:	8b 45 10             	mov    0x10(%ebp),%eax
f0102392:	01 c2                	add    %eax,%edx
f0102394:	8b 45 14             	mov    0x14(%ebp),%eax
f0102397:	8b 00                	mov    (%eax),%eax
f0102399:	89 c1                	mov    %eax,%ecx
f010239b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010239e:	01 c8                	add    %ecx,%eax
f01023a0:	8a 00                	mov    (%eax),%al
f01023a2:	88 02                	mov    %al,(%edx)
	for (int j = 0; j < old_buf_len; j++) {
		cputchar('\b');
	}
	int len = strlen(prefix_element);
	memcpy(buf, empty_buf, BUFLEN);
	for (*i = 0; *i < len; (*i)++) {
f01023a4:	8b 45 14             	mov    0x14(%ebp),%eax
f01023a7:	8b 00                	mov    (%eax),%eax
f01023a9:	8d 50 01             	lea    0x1(%eax),%edx
f01023ac:	8b 45 14             	mov    0x14(%ebp),%eax
f01023af:	89 10                	mov    %edx,(%eax)
f01023b1:	8b 45 14             	mov    0x14(%ebp),%eax
f01023b4:	8b 00                	mov    (%eax),%eax
f01023b6:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01023b9:	7c b0                	jl     f010236b <RoundAutoCompleteCommandWithTheSamePrefix+0x5b>
		cputchar(prefix_element[*i]);
		buf[*i] = prefix_element[*i];
	}
	*last_index = len;
f01023bb:	8b 45 18             	mov    0x18(%ebp),%eax
f01023be:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01023c1:	89 10                	mov    %edx,(%eax)
}
f01023c3:	90                   	nop
f01023c4:	c9                   	leave  
f01023c5:	c3                   	ret    

f01023c6 <clear_prefix_list>:

char PrefixList[100][1024];
void clear_prefix_list()
{
f01023c6:	55                   	push   %ebp
f01023c7:	89 e5                	mov    %esp,%ebp
f01023c9:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < 100; ++i) {
f01023cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01023d3:	eb 21                	jmp    f01023f6 <clear_prefix_list+0x30>
		memset(PrefixList[i], 0, 1024);}
f01023d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01023d8:	c1 e0 0a             	shl    $0xa,%eax
f01023db:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f01023e0:	83 ec 04             	sub    $0x4,%esp
f01023e3:	68 00 04 00 00       	push   $0x400
f01023e8:	6a 00                	push   $0x0
f01023ea:	50                   	push   %eax
f01023eb:	e8 79 89 01 00       	call   f011ad69 <memset>
f01023f0:	83 c4 10             	add    $0x10,%esp
}

char PrefixList[100][1024];
void clear_prefix_list()
{
	for (int i = 0; i < 100; ++i) {
f01023f3:	ff 45 f4             	incl   -0xc(%ebp)
f01023f6:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
f01023fa:	7e d9                	jle    f01023d5 <clear_prefix_list+0xf>
		memset(PrefixList[i], 0, 1024);}
}
f01023fc:	90                   	nop
f01023fd:	c9                   	leave  
f01023fe:	c3                   	ret    

f01023ff <command_prompt_readline>:

//Array of tests
extern struct Test tests[] ;
extern uint32 NUM_OF_TESTS;

void command_prompt_readline(const char *prompt, char* buf) {
f01023ff:	55                   	push   %ebp
f0102400:	89 e5                	mov    %esp,%ebp
f0102402:	57                   	push   %edi
f0102403:	53                   	push   %ebx
f0102404:	81 ec d0 08 00 00    	sub    $0x8d0,%esp
	int i, c, echoing, lastIndex;
	if (prompt != NULL)
f010240a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010240e:	74 13                	je     f0102423 <command_prompt_readline+0x24>
		cprintf("%s", prompt);
f0102410:	83 ec 08             	sub    $0x8,%esp
f0102413:	ff 75 08             	pushl  0x8(%ebp)
f0102416:	68 18 c0 12 f0       	push   $0xf012c018
f010241b:	e8 3c f8 ff ff       	call   f0101c5c <cprintf>
f0102420:	83 c4 10             	add    $0x10,%esp

	int commandidx = last_command_idx + 1;
f0102423:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102428:	40                   	inc    %eax
f0102429:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int prefix_list_idx = lastIndex = i = 0;
f010242c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0102433:	00 00 00 
f0102436:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010243c:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102442:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102448:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int prefix_list_size, last_c;
	echoing = iscons(0);
f010244b:	83 ec 0c             	sub    $0xc,%esp
f010244e:	6a 00                	push   $0x0
f0102450:	e8 d1 f6 ff ff       	call   f0101b26 <iscons>
f0102455:	83 c4 10             	add    $0x10,%esp
f0102458:	89 45 98             	mov    %eax,-0x68(%ebp)
	bool is_run_cmd = 0;
f010245b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	bool is_tst_cmd = 0;
f0102462:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)

	while (1) {
		c = getchar();
f0102469:	e8 9f f6 ff ff       	call   f0101b0d <getchar>
f010246e:	89 45 94             	mov    %eax,-0x6c(%ebp)
		if (i > lastIndex)
f0102471:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102477:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010247d:	39 c2                	cmp    %eax,%edx
f010247f:	7e 0c                	jle    f010248d <command_prompt_readline+0x8e>
			lastIndex = i;
f0102481:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102487:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
		if (c < 0) {
f010248d:	83 7d 94 00          	cmpl   $0x0,-0x6c(%ebp)
f0102491:	79 22                	jns    f01024b5 <command_prompt_readline+0xb6>

			if (c != -E_EOF)
f0102493:	83 7d 94 07          	cmpl   $0x7,-0x6c(%ebp)
f0102497:	0f 84 94 0a 00 00    	je     f0102f31 <command_prompt_readline+0xb32>
				cprintf("read error: %e\n", c);
f010249d:	83 ec 08             	sub    $0x8,%esp
f01024a0:	ff 75 94             	pushl  -0x6c(%ebp)
f01024a3:	68 1b c0 12 f0       	push   $0xf012c01b
f01024a8:	e8 af f7 ff ff       	call   f0101c5c <cprintf>
f01024ad:	83 c4 10             	add    $0x10,%esp
			return;
f01024b0:	e9 7c 0a 00 00       	jmp    f0102f31 <command_prompt_readline+0xb32>
		} else if (c == 226) { // Up arrow
f01024b5:	81 7d 94 e2 00 00 00 	cmpl   $0xe2,-0x6c(%ebp)
f01024bc:	75 2a                	jne    f01024e8 <command_prompt_readline+0xe9>
			if (commandidx)
f01024be:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01024c2:	74 03                	je     f01024c7 <command_prompt_readline+0xc8>
				commandidx--;
f01024c4:	ff 4d f4             	decl   -0xc(%ebp)
			clearandwritecommand(&i, commandidx, buf, &lastIndex);
f01024c7:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01024cd:	50                   	push   %eax
f01024ce:	ff 75 0c             	pushl  0xc(%ebp)
f01024d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01024d4:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f01024da:	50                   	push   %eax
f01024db:	e8 63 fd ff ff       	call   f0102243 <clearandwritecommand>
f01024e0:	83 c4 10             	add    $0x10,%esp
f01024e3:	e9 32 0a 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
		} else if (c == 227) { // Down arrow
f01024e8:	81 7d 94 e3 00 00 00 	cmpl   $0xe3,-0x6c(%ebp)
f01024ef:	75 3b                	jne    f010252c <command_prompt_readline+0x12d>
			if (commandidx < last_command_idx)
f01024f1:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f01024f6:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f01024f9:	7d 03                	jge    f01024fe <command_prompt_readline+0xff>
				commandidx++;
f01024fb:	ff 45 f4             	incl   -0xc(%ebp)
			if (last_command_idx >= 0)
f01024fe:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102503:	85 c0                	test   %eax,%eax
f0102505:	0f 88 0f 0a 00 00    	js     f0102f1a <command_prompt_readline+0xb1b>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
f010250b:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0102511:	50                   	push   %eax
f0102512:	ff 75 0c             	pushl  0xc(%ebp)
f0102515:	ff 75 f4             	pushl  -0xc(%ebp)
f0102518:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f010251e:	50                   	push   %eax
f010251f:	e8 1f fd ff ff       	call   f0102243 <clearandwritecommand>
f0102524:	83 c4 10             	add    $0x10,%esp
f0102527:	e9 ee 09 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
		} else if (c == 9) { // Tab button
f010252c:	83 7d 94 09          	cmpl   $0x9,-0x6c(%ebp)
f0102530:	0f 85 6d 07 00 00    	jne    f0102ca3 <command_prompt_readline+0x8a4>
			if (last_c != 9) {
f0102536:	83 7d e8 09          	cmpl   $0x9,-0x18(%ebp)
f010253a:	0f 84 fc 06 00 00    	je     f0102c3c <command_prompt_readline+0x83d>
				clear_prefix_list(PrefixList, 100);
f0102540:	83 ec 08             	sub    $0x8,%esp
f0102543:	6a 64                	push   $0x64
f0102545:	68 80 6e 85 f0       	push   $0xf0856e80
f010254a:	e8 77 fe ff ff       	call   f01023c6 <clear_prefix_list>
f010254f:	83 c4 10             	add    $0x10,%esp
				if (strlen(buf) == 0 || last_c == 255)
f0102552:	83 ec 0c             	sub    $0xc,%esp
f0102555:	ff 75 0c             	pushl  0xc(%ebp)
f0102558:	e8 1e 86 01 00       	call   f011ab7b <strlen>
f010255d:	83 c4 10             	add    $0x10,%esp
f0102560:	85 c0                	test   %eax,%eax
f0102562:	0f 84 bd 09 00 00    	je     f0102f25 <command_prompt_readline+0xb26>
f0102568:	81 7d e8 ff 00 00 00 	cmpl   $0xff,-0x18(%ebp)
f010256f:	0f 84 b0 09 00 00    	je     f0102f25 <command_prompt_readline+0xb26>
					continue;
				char *arguments[MAX_ARGUMENTS];
				int number_of_arguments = prefix_list_size = 0;
f0102575:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f010257c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010257f:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
				char temp_buf[1024];
				strcpy(temp_buf, buf);
f0102585:	83 ec 08             	sub    $0x8,%esp
f0102588:	ff 75 0c             	pushl  0xc(%ebp)
f010258b:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102591:	50                   	push   %eax
f0102592:	e8 33 86 01 00       	call   f011abca <strcpy>
f0102597:	83 c4 10             	add    $0x10,%esp
				int bufLength = strlen(buf);
f010259a:	83 ec 0c             	sub    $0xc,%esp
f010259d:	ff 75 0c             	pushl  0xc(%ebp)
f01025a0:	e8 d6 85 01 00       	call   f011ab7b <strlen>
f01025a5:	83 c4 10             	add    $0x10,%esp
f01025a8:	89 45 90             	mov    %eax,-0x70(%ebp)
				if (buf[bufLength - 1] == ' ')
f01025ab:	8b 45 90             	mov    -0x70(%ebp),%eax
f01025ae:	8d 50 ff             	lea    -0x1(%eax),%edx
f01025b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01025b4:	01 d0                	add    %edx,%eax
f01025b6:	8a 00                	mov    (%eax),%al
f01025b8:	3c 20                	cmp    $0x20,%al
f01025ba:	0f 84 6b 09 00 00    	je     f0102f2b <command_prompt_readline+0xb2c>
					continue;
				strsplit(temp_buf, WHITESPACE, arguments, &number_of_arguments);
f01025c0:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f01025c6:	50                   	push   %eax
f01025c7:	8d 85 30 f7 ff ff    	lea    -0x8d0(%ebp),%eax
f01025cd:	50                   	push   %eax
f01025ce:	68 2b c0 12 f0       	push   $0xf012c02b
f01025d3:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01025d9:	50                   	push   %eax
f01025da:	e8 60 8c 01 00       	call   f011b23f <strsplit>
f01025df:	83 c4 10             	add    $0x10,%esp
				int it_str = 0;
f01025e2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
				if (number_of_arguments > 1) {
f01025e9:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01025ef:	83 f8 01             	cmp    $0x1,%eax
f01025f2:	0f 8e 28 01 00 00    	jle    f0102720 <command_prompt_readline+0x321>
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
f01025f8:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f01025fe:	83 ec 08             	sub    $0x8,%esp
f0102601:	68 30 c0 12 f0       	push   $0xf012c030
f0102606:	50                   	push   %eax
f0102607:	e8 7b 86 01 00       	call   f011ac87 <strcmp>
f010260c:	83 c4 10             	add    $0x10,%esp
f010260f:	85 c0                	test   %eax,%eax
f0102611:	74 3c                	je     f010264f <command_prompt_readline+0x250>
f0102613:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102619:	83 ec 08             	sub    $0x8,%esp
f010261c:	68 34 c0 12 f0       	push   $0xf012c034
f0102621:	50                   	push   %eax
f0102622:	e8 60 86 01 00       	call   f011ac87 <strcmp>
f0102627:	83 c4 10             	add    $0x10,%esp
f010262a:	85 c0                	test   %eax,%eax
f010262c:	74 21                	je     f010264f <command_prompt_readline+0x250>
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
f010262e:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102634:	83 ec 08             	sub    $0x8,%esp
f0102637:	68 39 c0 12 f0       	push   $0xf012c039
f010263c:	50                   	push   %eax
f010263d:	e8 45 86 01 00       	call   f011ac87 <strcmp>
f0102642:	83 c4 10             	add    $0x10,%esp
f0102645:	85 c0                	test   %eax,%eax
f0102647:	74 06                	je     f010264f <command_prompt_readline+0x250>
						continue;
f0102649:	90                   	nop
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f010264a:	e9 d6 08 00 00       	jmp    f0102f25 <command_prompt_readline+0xb26>
				int it_str = 0;
				if (number_of_arguments > 1) {
					if((strcmp(arguments[0], "run") != 0) && (strcmp(arguments[0], "load") != 0)
							&& (strcmp(arguments[0], "tst") != 0)) // to autocomplete only in case that the command take arguments and defined arguments (run & load & tst) only
						continue;
					if ((strcmp(arguments[0], "tst") == 0))
f010264f:	8b 85 30 f7 ff ff    	mov    -0x8d0(%ebp),%eax
f0102655:	83 ec 08             	sub    $0x8,%esp
f0102658:	68 39 c0 12 f0       	push   $0xf012c039
f010265d:	50                   	push   %eax
f010265e:	e8 24 86 01 00       	call   f011ac87 <strcmp>
f0102663:	83 c4 10             	add    $0x10,%esp
f0102666:	85 c0                	test   %eax,%eax
f0102668:	75 09                	jne    f0102673 <command_prompt_readline+0x274>
					{
						is_tst_cmd = 1;
f010266a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
f0102671:	eb 07                	jmp    f010267a <command_prompt_readline+0x27b>
					}
					else
					{
						is_run_cmd = 1;
f0102673:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
					}
					char temp[1024] = "";
f010267a:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102681:	00 00 00 
f0102684:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f010268a:	b9 ff 00 00 00       	mov    $0xff,%ecx
f010268f:	b8 00 00 00 00       	mov    $0x0,%eax
f0102694:	89 d7                	mov    %edx,%edi
f0102696:	f3 ab                	rep stos %eax,%es:(%edi)
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
f0102698:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010269e:	48                   	dec    %eax
f010269f:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f01026a6:	83 ec 0c             	sub    $0xc,%esp
f01026a9:	50                   	push   %eax
f01026aa:	e8 cc 84 01 00       	call   f011ab7b <strlen>
f01026af:	83 c4 10             	add    $0x10,%esp
f01026b2:	8b 55 90             	mov    -0x70(%ebp),%edx
f01026b5:	29 c2                	sub    %eax,%edx
f01026b7:	89 d0                	mov    %edx,%eax
f01026b9:	89 45 8c             	mov    %eax,-0x74(%ebp)
					for (int var = 0; var < TotalLen; ++var) {
f01026bc:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f01026c3:	eb 1d                	jmp    f01026e2 <command_prompt_readline+0x2e3>
						temp[it_str++] = buf[var];
f01026c5:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01026c8:	8d 50 01             	lea    0x1(%eax),%edx
f01026cb:	89 55 dc             	mov    %edx,-0x24(%ebp)
f01026ce:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01026d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01026d4:	01 ca                	add    %ecx,%edx
f01026d6:	8a 12                	mov    (%edx),%dl
f01026d8:	88 94 05 70 fb ff ff 	mov    %dl,-0x490(%ebp,%eax,1)
					{
						is_run_cmd = 1;
					}
					char temp[1024] = "";
					int TotalLen = bufLength - strlen(arguments[number_of_arguments - 1]);
					for (int var = 0; var < TotalLen; ++var) {
f01026df:	ff 45 d8             	incl   -0x28(%ebp)
f01026e2:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01026e5:	3b 45 8c             	cmp    -0x74(%ebp),%eax
f01026e8:	7c db                	jl     f01026c5 <command_prompt_readline+0x2c6>
						temp[it_str++] = buf[var];
					}
					strcpy(buf, temp);   //buf contains all arguments except the last one
f01026ea:	83 ec 08             	sub    $0x8,%esp
f01026ed:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01026f3:	50                   	push   %eax
f01026f4:	ff 75 0c             	pushl  0xc(%ebp)
f01026f7:	e8 ce 84 01 00       	call   f011abca <strcpy>
f01026fc:	83 c4 10             	add    $0x10,%esp
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
f01026ff:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102705:	48                   	dec    %eax
f0102706:	8b 84 85 30 f7 ff ff 	mov    -0x8d0(%ebp,%eax,4),%eax
f010270d:	83 ec 08             	sub    $0x8,%esp
f0102710:	50                   	push   %eax
f0102711:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102717:	50                   	push   %eax
f0102718:	e8 ad 84 01 00       	call   f011abca <strcpy>
f010271d:	83 c4 10             	add    $0x10,%esp
				}
				int it_prefix_list = 0;
f0102720:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
				if(number_of_arguments == 1)
f0102727:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010272d:	83 f8 01             	cmp    $0x1,%eax
f0102730:	0f 85 30 01 00 00    	jne    f0102866 <command_prompt_readline+0x467>
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f0102736:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f010273d:	e9 0f 01 00 00       	jmp    f0102851 <command_prompt_readline+0x452>
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
f0102742:	83 ec 0c             	sub    $0xc,%esp
f0102745:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f010274b:	50                   	push   %eax
f010274c:	e8 2a 84 01 00       	call   f011ab7b <strlen>
f0102751:	83 c4 10             	add    $0x10,%esp
f0102754:	89 c1                	mov    %eax,%ecx
f0102756:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102759:	89 d0                	mov    %edx,%eax
f010275b:	01 c0                	add    %eax,%eax
f010275d:	01 d0                	add    %edx,%eax
f010275f:	c1 e0 03             	shl    $0x3,%eax
f0102762:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102767:	8b 00                	mov    (%eax),%eax
f0102769:	83 ec 04             	sub    $0x4,%esp
f010276c:	51                   	push   %ecx
f010276d:	50                   	push   %eax
f010276e:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102774:	50                   	push   %eax
f0102775:	e8 45 85 01 00       	call   f011acbf <strncmp>
f010277a:	83 c4 10             	add    $0x10,%esp
f010277d:	89 45 88             	mov    %eax,-0x78(%ebp)
						if (x == 0) {
f0102780:	83 7d 88 00          	cmpl   $0x0,-0x78(%ebp)
f0102784:	0f 85 c4 00 00 00    	jne    f010284e <command_prompt_readline+0x44f>
							it_str = -1;
f010278a:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
							char string[1024] = "";
f0102791:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102798:	00 00 00 
f010279b:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01027a1:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01027a6:	b8 00 00 00 00       	mov    $0x0,%eax
f01027ab:	89 d7                	mov    %edx,%edi
f01027ad:	f3 ab                	rep stos %eax,%es:(%edi)
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01027af:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f01027b6:	eb 2d                	jmp    f01027e5 <command_prompt_readline+0x3e6>
								string[++it_str] = commands[var].name[var3];
f01027b8:	ff 45 dc             	incl   -0x24(%ebp)
f01027bb:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01027be:	89 d0                	mov    %edx,%eax
f01027c0:	01 c0                	add    %eax,%eax
f01027c2:	01 d0                	add    %edx,%eax
f01027c4:	c1 e0 03             	shl    $0x3,%eax
f01027c7:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01027cc:	8b 10                	mov    (%eax),%edx
f01027ce:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01027d1:	01 d0                	add    %edx,%eax
f01027d3:	8a 00                	mov    (%eax),%al
f01027d5:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f01027db:	8b 55 dc             	mov    -0x24(%ebp),%edx
f01027de:	01 ca                	add    %ecx,%edx
f01027e0:	88 02                	mov    %al,(%edx)
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
						int x = strncmp(temp_buf, commands[var].name, strlen(temp_buf));
						if (x == 0) {
							it_str = -1;
							char string[1024] = "";
							for (int var3 = 0; var3 < strlen(commands[var].name); ++var3) {
f01027e2:	ff 45 cc             	incl   -0x34(%ebp)
f01027e5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01027e8:	89 d0                	mov    %edx,%eax
f01027ea:	01 c0                	add    %eax,%eax
f01027ec:	01 d0                	add    %edx,%eax
f01027ee:	c1 e0 03             	shl    $0x3,%eax
f01027f1:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01027f6:	8b 00                	mov    (%eax),%eax
f01027f8:	83 ec 0c             	sub    $0xc,%esp
f01027fb:	50                   	push   %eax
f01027fc:	e8 7a 83 01 00       	call   f011ab7b <strlen>
f0102801:	83 c4 10             	add    $0x10,%esp
f0102804:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0102807:	7f af                	jg     f01027b8 <command_prompt_readline+0x3b9>
								string[++it_str] = commands[var].name[var3];
							}
							memset(PrefixList[it_prefix_list], 0, 1024);
f0102809:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010280c:	c1 e0 0a             	shl    $0xa,%eax
f010280f:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102814:	83 ec 04             	sub    $0x4,%esp
f0102817:	68 00 04 00 00       	push   $0x400
f010281c:	6a 00                	push   $0x0
f010281e:	50                   	push   %eax
f010281f:	e8 45 85 01 00       	call   f011ad69 <memset>
f0102824:	83 c4 10             	add    $0x10,%esp
							strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102827:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010282a:	40                   	inc    %eax
f010282b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f010282e:	c1 e2 0a             	shl    $0xa,%edx
f0102831:	81 c2 80 6e 85 f0    	add    $0xf0856e80,%edx
f0102837:	83 ec 04             	sub    $0x4,%esp
f010283a:	50                   	push   %eax
f010283b:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102841:	50                   	push   %eax
f0102842:	52                   	push   %edx
f0102843:	e8 b0 83 01 00       	call   f011abf8 <strncpy>
f0102848:	83 c4 10             	add    $0x10,%esp
							it_prefix_list++;
f010284b:	ff 45 d4             	incl   -0x2c(%ebp)
					strcpy(temp_buf, arguments[number_of_arguments - 1]);   //temp_buf contains the last argument
				}
				int it_prefix_list = 0;
				if(number_of_arguments == 1)
				{
					for (int var = 0; var < NUM_OF_COMMANDS; ++var) {
f010284e:	ff 45 d0             	incl   -0x30(%ebp)
f0102851:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0102854:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0102859:	39 c2                	cmp    %eax,%edx
f010285b:	0f 82 e1 fe ff ff    	jb     f0102742 <command_prompt_readline+0x343>
f0102861:	e9 fe 02 00 00       	jmp    f0102b64 <command_prompt_readline+0x765>
						}
					}
				}
				else
				{
					if(is_run_cmd)
f0102866:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010286a:	0f 84 7b 01 00 00    	je     f01029eb <command_prompt_readline+0x5ec>
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f0102870:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
f0102877:	e9 5c 01 00 00       	jmp    f01029d8 <command_prompt_readline+0x5d9>
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
f010287c:	83 ec 0c             	sub    $0xc,%esp
f010287f:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102885:	50                   	push   %eax
f0102886:	e8 f0 82 01 00       	call   f011ab7b <strlen>
f010288b:	83 c4 10             	add    $0x10,%esp
f010288e:	89 c1                	mov    %eax,%ecx
f0102890:	8b 1d 9c 00 18 f0    	mov    0xf018009c,%ebx
f0102896:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102899:	89 d0                	mov    %edx,%eax
f010289b:	01 c0                	add    %eax,%eax
f010289d:	01 d0                	add    %edx,%eax
f010289f:	c1 e0 02             	shl    $0x2,%eax
f01028a2:	01 d8                	add    %ebx,%eax
f01028a4:	8b 00                	mov    (%eax),%eax
f01028a6:	83 ec 04             	sub    $0x4,%esp
f01028a9:	51                   	push   %ecx
f01028aa:	50                   	push   %eax
f01028ab:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f01028b1:	50                   	push   %eax
f01028b2:	e8 08 84 01 00       	call   f011acbf <strncmp>
f01028b7:	83 c4 10             	add    $0x10,%esp
f01028ba:	89 45 84             	mov    %eax,-0x7c(%ebp)
							if (x == 0) {
f01028bd:	83 7d 84 00          	cmpl   $0x0,-0x7c(%ebp)
f01028c1:	0f 85 0e 01 00 00    	jne    f01029d5 <command_prompt_readline+0x5d6>
								it_str = -1;
f01028c7:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f01028ce:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f01028d5:	00 00 00 
f01028d8:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f01028de:	b9 ff 00 00 00       	mov    $0xff,%ecx
f01028e3:	b8 00 00 00 00       	mov    $0x0,%eax
f01028e8:	89 d7                	mov    %edx,%edi
f01028ea:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f01028ec:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f01028f2:	83 f8 01             	cmp    $0x1,%eax
f01028f5:	7e 39                	jle    f0102930 <command_prompt_readline+0x531>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f01028f7:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
f01028fe:	eb 1d                	jmp    f010291d <command_prompt_readline+0x51e>
										string[++it_str] = buf[var2];
f0102900:	ff 45 dc             	incl   -0x24(%ebp)
f0102903:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0102906:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102909:	01 d0                	add    %edx,%eax
f010290b:	8a 00                	mov    (%eax),%al
f010290d:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102913:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102916:	01 ca                	add    %ecx,%edx
f0102918:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, ptr_UserPrograms[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f010291a:	ff 45 c4             	incl   -0x3c(%ebp)
f010291d:	83 ec 0c             	sub    $0xc,%esp
f0102920:	ff 75 0c             	pushl  0xc(%ebp)
f0102923:	e8 53 82 01 00       	call   f011ab7b <strlen>
f0102928:	83 c4 10             	add    $0x10,%esp
f010292b:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f010292e:	7f d0                	jg     f0102900 <command_prompt_readline+0x501>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102930:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%ebp)
f0102937:	eb 30                	jmp    f0102969 <command_prompt_readline+0x56a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
f0102939:	ff 45 dc             	incl   -0x24(%ebp)
f010293c:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f0102942:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102945:	89 d0                	mov    %edx,%eax
f0102947:	01 c0                	add    %eax,%eax
f0102949:	01 d0                	add    %edx,%eax
f010294b:	c1 e0 02             	shl    $0x2,%eax
f010294e:	01 c8                	add    %ecx,%eax
f0102950:	8b 10                	mov    (%eax),%edx
f0102952:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0102955:	01 d0                	add    %edx,%eax
f0102957:	8a 00                	mov    (%eax),%al
f0102959:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f010295f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102962:	01 ca                	add    %ecx,%edx
f0102964:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(ptr_UserPrograms[var].name) ; ++var3) {
f0102966:	ff 45 c0             	incl   -0x40(%ebp)
f0102969:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f010296f:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0102972:	89 d0                	mov    %edx,%eax
f0102974:	01 c0                	add    %eax,%eax
f0102976:	01 d0                	add    %edx,%eax
f0102978:	c1 e0 02             	shl    $0x2,%eax
f010297b:	01 c8                	add    %ecx,%eax
f010297d:	8b 00                	mov    (%eax),%eax
f010297f:	83 ec 0c             	sub    $0xc,%esp
f0102982:	50                   	push   %eax
f0102983:	e8 f3 81 01 00       	call   f011ab7b <strlen>
f0102988:	83 c4 10             	add    $0x10,%esp
f010298b:	3b 45 c0             	cmp    -0x40(%ebp),%eax
f010298e:	7f a9                	jg     f0102939 <command_prompt_readline+0x53a>
									string[++it_str] = ptr_UserPrograms[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102990:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102993:	c1 e0 0a             	shl    $0xa,%eax
f0102996:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f010299b:	83 ec 04             	sub    $0x4,%esp
f010299e:	68 00 04 00 00       	push   $0x400
f01029a3:	6a 00                	push   $0x0
f01029a5:	50                   	push   %eax
f01029a6:	e8 be 83 01 00       	call   f011ad69 <memset>
f01029ab:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f01029ae:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01029b1:	40                   	inc    %eax
f01029b2:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01029b5:	c1 e2 0a             	shl    $0xa,%edx
f01029b8:	81 c2 80 6e 85 f0    	add    $0xf0856e80,%edx
f01029be:	83 ec 04             	sub    $0x4,%esp
f01029c1:	50                   	push   %eax
f01029c2:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f01029c8:	50                   	push   %eax
f01029c9:	52                   	push   %edx
f01029ca:	e8 29 82 01 00       	call   f011abf8 <strncpy>
f01029cf:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f01029d2:	ff 45 d4             	incl   -0x2c(%ebp)
				}
				else
				{
					if(is_run_cmd)
					{
						for (int var = 0; var < NUM_USER_PROGS; ++var) {
f01029d5:	ff 45 c8             	incl   -0x38(%ebp)
f01029d8:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f01029dd:	39 45 c8             	cmp    %eax,-0x38(%ebp)
f01029e0:	0f 8c 96 fe ff ff    	jl     f010287c <command_prompt_readline+0x47d>
f01029e6:	e9 79 01 00 00       	jmp    f0102b64 <command_prompt_readline+0x765>
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
								it_prefix_list++;
							}
						}
					}
					else if(is_tst_cmd)
f01029eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01029ef:	0f 84 6f 01 00 00    	je     f0102b64 <command_prompt_readline+0x765>
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f01029f5:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f01029fc:	e9 53 01 00 00       	jmp    f0102b54 <command_prompt_readline+0x755>
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
f0102a01:	83 ec 0c             	sub    $0xc,%esp
f0102a04:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102a0a:	50                   	push   %eax
f0102a0b:	e8 6b 81 01 00       	call   f011ab7b <strlen>
f0102a10:	83 c4 10             	add    $0x10,%esp
f0102a13:	89 c1                	mov    %eax,%ecx
f0102a15:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102a18:	89 d0                	mov    %edx,%eax
f0102a1a:	01 c0                	add    %eax,%eax
f0102a1c:	01 d0                	add    %edx,%eax
f0102a1e:	c1 e0 02             	shl    $0x2,%eax
f0102a21:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f0102a26:	8b 00                	mov    (%eax),%eax
f0102a28:	83 ec 04             	sub    $0x4,%esp
f0102a2b:	51                   	push   %ecx
f0102a2c:	50                   	push   %eax
f0102a2d:	8d 85 70 f7 ff ff    	lea    -0x890(%ebp),%eax
f0102a33:	50                   	push   %eax
f0102a34:	e8 86 82 01 00       	call   f011acbf <strncmp>
f0102a39:	83 c4 10             	add    $0x10,%esp
f0102a3c:	89 45 80             	mov    %eax,-0x80(%ebp)
							if (x == 0) {
f0102a3f:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0102a43:	0f 85 08 01 00 00    	jne    f0102b51 <command_prompt_readline+0x752>
								it_str = -1;
f0102a49:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
								char string[1024] = "";
f0102a50:	c7 85 70 fb ff ff 00 	movl   $0x0,-0x490(%ebp)
f0102a57:	00 00 00 
f0102a5a:	8d 95 74 fb ff ff    	lea    -0x48c(%ebp),%edx
f0102a60:	b9 ff 00 00 00       	mov    $0xff,%ecx
f0102a65:	b8 00 00 00 00       	mov    $0x0,%eax
f0102a6a:	89 d7                	mov    %edx,%edi
f0102a6c:	f3 ab                	rep stos %eax,%es:(%edi)
								if (number_of_arguments > 1) {
f0102a6e:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f0102a74:	83 f8 01             	cmp    $0x1,%eax
f0102a77:	7e 39                	jle    f0102ab2 <command_prompt_readline+0x6b3>
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0102a79:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%ebp)
f0102a80:	eb 1d                	jmp    f0102a9f <command_prompt_readline+0x6a0>
										string[++it_str] = buf[var2];
f0102a82:	ff 45 dc             	incl   -0x24(%ebp)
f0102a85:	8b 55 b8             	mov    -0x48(%ebp),%edx
f0102a88:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102a8b:	01 d0                	add    %edx,%eax
f0102a8d:	8a 00                	mov    (%eax),%al
f0102a8f:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102a95:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102a98:	01 ca                	add    %ecx,%edx
f0102a9a:	88 02                	mov    %al,(%edx)
							int x = strncmp(temp_buf, tests[var].name, strlen(temp_buf));
							if (x == 0) {
								it_str = -1;
								char string[1024] = "";
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
f0102a9c:	ff 45 b8             	incl   -0x48(%ebp)
f0102a9f:	83 ec 0c             	sub    $0xc,%esp
f0102aa2:	ff 75 0c             	pushl  0xc(%ebp)
f0102aa5:	e8 d1 80 01 00       	call   f011ab7b <strlen>
f0102aaa:	83 c4 10             	add    $0x10,%esp
f0102aad:	3b 45 b8             	cmp    -0x48(%ebp),%eax
f0102ab0:	7f d0                	jg     f0102a82 <command_prompt_readline+0x683>
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f0102ab2:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
f0102ab9:	eb 2d                	jmp    f0102ae8 <command_prompt_readline+0x6e9>
									string[++it_str] = tests[var].name[var3];
f0102abb:	ff 45 dc             	incl   -0x24(%ebp)
f0102abe:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102ac1:	89 d0                	mov    %edx,%eax
f0102ac3:	01 c0                	add    %eax,%eax
f0102ac5:	01 d0                	add    %edx,%eax
f0102ac7:	c1 e0 02             	shl    $0x2,%eax
f0102aca:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f0102acf:	8b 10                	mov    (%eax),%edx
f0102ad1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0102ad4:	01 d0                	add    %edx,%eax
f0102ad6:	8a 00                	mov    (%eax),%al
f0102ad8:	8d 8d 70 fb ff ff    	lea    -0x490(%ebp),%ecx
f0102ade:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0102ae1:	01 ca                	add    %ecx,%edx
f0102ae3:	88 02                	mov    %al,(%edx)
								if (number_of_arguments > 1) {
									for (int var2 = 0; var2 < strlen(buf); ++var2) {
										string[++it_str] = buf[var2];
									}
								}
								for (int var3 = 0; var3 < strlen(tests[var].name) ; ++var3) {
f0102ae5:	ff 45 b4             	incl   -0x4c(%ebp)
f0102ae8:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102aeb:	89 d0                	mov    %edx,%eax
f0102aed:	01 c0                	add    %eax,%eax
f0102aef:	01 d0                	add    %edx,%eax
f0102af1:	c1 e0 02             	shl    $0x2,%eax
f0102af4:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f0102af9:	8b 00                	mov    (%eax),%eax
f0102afb:	83 ec 0c             	sub    $0xc,%esp
f0102afe:	50                   	push   %eax
f0102aff:	e8 77 80 01 00       	call   f011ab7b <strlen>
f0102b04:	83 c4 10             	add    $0x10,%esp
f0102b07:	3b 45 b4             	cmp    -0x4c(%ebp),%eax
f0102b0a:	7f af                	jg     f0102abb <command_prompt_readline+0x6bc>
									string[++it_str] = tests[var].name[var3];
								}
								memset(PrefixList[it_prefix_list], 0, 1024);
f0102b0c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b0f:	c1 e0 0a             	shl    $0xa,%eax
f0102b12:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102b17:	83 ec 04             	sub    $0x4,%esp
f0102b1a:	68 00 04 00 00       	push   $0x400
f0102b1f:	6a 00                	push   $0x0
f0102b21:	50                   	push   %eax
f0102b22:	e8 42 82 01 00       	call   f011ad69 <memset>
f0102b27:	83 c4 10             	add    $0x10,%esp
								strncpy(PrefixList[it_prefix_list], string, it_str + 1);
f0102b2a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102b2d:	40                   	inc    %eax
f0102b2e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0102b31:	c1 e2 0a             	shl    $0xa,%edx
f0102b34:	81 c2 80 6e 85 f0    	add    $0xf0856e80,%edx
f0102b3a:	83 ec 04             	sub    $0x4,%esp
f0102b3d:	50                   	push   %eax
f0102b3e:	8d 85 70 fb ff ff    	lea    -0x490(%ebp),%eax
f0102b44:	50                   	push   %eax
f0102b45:	52                   	push   %edx
f0102b46:	e8 ad 80 01 00       	call   f011abf8 <strncpy>
f0102b4b:	83 c4 10             	add    $0x10,%esp
								it_prefix_list++;
f0102b4e:	ff 45 d4             	incl   -0x2c(%ebp)
							}
						}
					}
					else if(is_tst_cmd)
					{
						for (int var = 0; var < NUM_OF_TESTS; ++var) {
f0102b51:	ff 45 bc             	incl   -0x44(%ebp)
f0102b54:	8b 55 bc             	mov    -0x44(%ebp),%edx
f0102b57:	a1 80 01 18 f0       	mov    0xf0180180,%eax
f0102b5c:	39 c2                	cmp    %eax,%edx
f0102b5e:	0f 82 9d fe ff ff    	jb     f0102a01 <command_prompt_readline+0x602>
								it_prefix_list++;
							}
						}
					}
				}
				prefix_list_size = it_prefix_list;
f0102b64:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0102b67:	89 45 ec             	mov    %eax,-0x14(%ebp)
				if (it_prefix_list) {
f0102b6a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0102b6e:	0f 84 a6 03 00 00    	je     f0102f1a <command_prompt_readline+0xb1b>
					prefix_list_idx = it_str = 0;
f0102b74:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
f0102b7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102b7e:	89 45 f0             	mov    %eax,-0x10(%ebp)
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102b81:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)
f0102b88:	eb 1f                	jmp    f0102ba9 <command_prompt_readline+0x7aa>
						buf[it_str++] = PrefixList[0][var2];}
f0102b8a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0102b8d:	8d 50 01             	lea    0x1(%eax),%edx
f0102b90:	89 55 dc             	mov    %edx,-0x24(%ebp)
f0102b93:	89 c2                	mov    %eax,%edx
f0102b95:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102b98:	01 c2                	add    %eax,%edx
f0102b9a:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0102b9d:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102ba2:	8a 00                	mov    (%eax),%al
f0102ba4:	88 02                	mov    %al,(%edx)
					}
				}
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
f0102ba6:	ff 45 b0             	incl   -0x50(%ebp)
f0102ba9:	83 ec 0c             	sub    $0xc,%esp
f0102bac:	68 80 6e 85 f0       	push   $0xf0856e80
f0102bb1:	e8 c5 7f 01 00       	call   f011ab7b <strlen>
f0102bb6:	83 c4 10             	add    $0x10,%esp
f0102bb9:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0102bbc:	7f cc                	jg     f0102b8a <command_prompt_readline+0x78b>
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102bbe:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%ebp)
f0102bc5:	eb 10                	jmp    f0102bd7 <command_prompt_readline+0x7d8>
						cputchar('\b');}
f0102bc7:	83 ec 0c             	sub    $0xc,%esp
f0102bca:	6a 08                	push   $0x8
f0102bcc:	e8 25 ef ff ff       	call   f0101af6 <cputchar>
f0102bd1:	83 c4 10             	add    $0x10,%esp
				prefix_list_size = it_prefix_list;
				if (it_prefix_list) {
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
f0102bd4:	ff 45 ac             	incl   -0x54(%ebp)
f0102bd7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0102bda:	3b 45 90             	cmp    -0x70(%ebp),%eax
f0102bdd:	7c e8                	jl     f0102bc7 <command_prompt_readline+0x7c8>
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102bdf:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%ebp)
f0102be6:	eb 1c                	jmp    f0102c04 <command_prompt_readline+0x805>
						cputchar(buf[j]);}
f0102be8:	8b 55 a8             	mov    -0x58(%ebp),%edx
f0102beb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102bee:	01 d0                	add    %edx,%eax
f0102bf0:	8a 00                	mov    (%eax),%al
f0102bf2:	0f be c0             	movsbl %al,%eax
f0102bf5:	83 ec 0c             	sub    $0xc,%esp
f0102bf8:	50                   	push   %eax
f0102bf9:	e8 f8 ee ff ff       	call   f0101af6 <cputchar>
f0102bfe:	83 c4 10             	add    $0x10,%esp
					prefix_list_idx = it_str = 0;
					for (int var2 = 0; var2 < strlen(PrefixList[0]); ++var2) {
						buf[it_str++] = PrefixList[0][var2];}
					for (int var = 0; var < bufLength; ++var) {
						cputchar('\b');}
					for (int j = 0; j < strlen(buf); ++j) {
f0102c01:	ff 45 a8             	incl   -0x58(%ebp)
f0102c04:	83 ec 0c             	sub    $0xc,%esp
f0102c07:	ff 75 0c             	pushl  0xc(%ebp)
f0102c0a:	e8 6c 7f 01 00       	call   f011ab7b <strlen>
f0102c0f:	83 c4 10             	add    $0x10,%esp
f0102c12:	3b 45 a8             	cmp    -0x58(%ebp),%eax
f0102c15:	7f d1                	jg     f0102be8 <command_prompt_readline+0x7e9>
						cputchar(buf[j]);}
					i = lastIndex = strlen(buf);
f0102c17:	83 ec 0c             	sub    $0xc,%esp
f0102c1a:	ff 75 0c             	pushl  0xc(%ebp)
f0102c1d:	e8 59 7f 01 00       	call   f011ab7b <strlen>
f0102c22:	83 c4 10             	add    $0x10,%esp
f0102c25:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102c2b:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102c31:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102c37:	e9 de 02 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
				}
			}
			else {
				if (prefix_list_size > 0) {	int prev = prefix_list_idx;
f0102c3c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0102c40:	0f 8e d4 02 00 00    	jle    f0102f1a <command_prompt_readline+0xb1b>
f0102c46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c49:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
				prefix_list_idx = (prefix_list_idx + 1) % prefix_list_size;
f0102c4f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c52:	40                   	inc    %eax
f0102c53:	99                   	cltd   
f0102c54:	f7 7d ec             	idivl  -0x14(%ebp)
f0102c57:	89 55 f0             	mov    %edx,-0x10(%ebp)
				RoundAutoCompleteCommandWithTheSamePrefix(strlen(PrefixList[prev]), PrefixList[prefix_list_idx], buf, &i, &lastIndex);
f0102c5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0102c5d:	c1 e0 0a             	shl    $0xa,%eax
f0102c60:	8d 98 80 6e 85 f0    	lea    -0xf7a9180(%eax),%ebx
f0102c66:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f0102c6c:	c1 e0 0a             	shl    $0xa,%eax
f0102c6f:	05 80 6e 85 f0       	add    $0xf0856e80,%eax
f0102c74:	83 ec 0c             	sub    $0xc,%esp
f0102c77:	50                   	push   %eax
f0102c78:	e8 fe 7e 01 00       	call   f011ab7b <strlen>
f0102c7d:	83 c4 10             	add    $0x10,%esp
f0102c80:	83 ec 0c             	sub    $0xc,%esp
f0102c83:	8d 95 74 ff ff ff    	lea    -0x8c(%ebp),%edx
f0102c89:	52                   	push   %edx
f0102c8a:	8d 95 78 ff ff ff    	lea    -0x88(%ebp),%edx
f0102c90:	52                   	push   %edx
f0102c91:	ff 75 0c             	pushl  0xc(%ebp)
f0102c94:	53                   	push   %ebx
f0102c95:	50                   	push   %eax
f0102c96:	e8 75 f6 ff ff       	call   f0102310 <RoundAutoCompleteCommandWithTheSamePrefix>
f0102c9b:	83 c4 20             	add    $0x20,%esp
f0102c9e:	e9 77 02 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
				}
			}
		}

		else if (c == 228) { // left arrow
f0102ca3:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102caa:	75 2e                	jne    f0102cda <command_prompt_readline+0x8db>
			if (i > 0) {
f0102cac:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cb2:	85 c0                	test   %eax,%eax
f0102cb4:	0f 8e 60 02 00 00    	jle    f0102f1a <command_prompt_readline+0xb1b>
				i--;
f0102cba:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cc0:	48                   	dec    %eax
f0102cc1:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102cc7:	83 ec 0c             	sub    $0xc,%esp
f0102cca:	ff 75 94             	pushl  -0x6c(%ebp)
f0102ccd:	e8 24 ee ff ff       	call   f0101af6 <cputchar>
f0102cd2:	83 c4 10             	add    $0x10,%esp
f0102cd5:	e9 40 02 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
			}
		} else if (c == 229) { // right arrow
f0102cda:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102ce1:	75 34                	jne    f0102d17 <command_prompt_readline+0x918>
			if (i < lastIndex) {
f0102ce3:	8b 95 78 ff ff ff    	mov    -0x88(%ebp),%edx
f0102ce9:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102cef:	39 c2                	cmp    %eax,%edx
f0102cf1:	0f 8d 23 02 00 00    	jge    f0102f1a <command_prompt_readline+0xb1b>
				i++;
f0102cf7:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102cfd:	40                   	inc    %eax
f0102cfe:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
				cputchar(c);
f0102d04:	83 ec 0c             	sub    $0xc,%esp
f0102d07:	ff 75 94             	pushl  -0x6c(%ebp)
f0102d0a:	e8 e7 ed ff ff       	call   f0101af6 <cputchar>
f0102d0f:	83 c4 10             	add    $0x10,%esp
f0102d12:	e9 03 02 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
f0102d17:	81 7d 94 e9 00 00 00 	cmpl   $0xe9,-0x6c(%ebp)
f0102d1e:	75 4c                	jne    f0102d6c <command_prompt_readline+0x96d>
f0102d20:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d26:	85 c0                	test   %eax,%eax
f0102d28:	7e 42                	jle    f0102d6c <command_prompt_readline+0x96d>
			for (int var = i; var <= lastIndex; ++var) {
f0102d2a:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d30:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f0102d33:	eb 1a                	jmp    f0102d4f <command_prompt_readline+0x950>
				buf[var] = buf[var + 1];
f0102d35:	8b 55 a4             	mov    -0x5c(%ebp),%edx
f0102d38:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d3b:	01 c2                	add    %eax,%edx
f0102d3d:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0102d40:	8d 48 01             	lea    0x1(%eax),%ecx
f0102d43:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102d46:	01 c8                	add    %ecx,%eax
f0102d48:	8a 00                	mov    (%eax),%al
f0102d4a:	88 02                	mov    %al,(%edx)
				i++;
				cputchar(c);
			}
		}
		else if (c == 0xE9 && i > 0) {		 // KEY_DEL
			for (int var = i; var <= lastIndex; ++var) {
f0102d4c:	ff 45 a4             	incl   -0x5c(%ebp)
f0102d4f:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102d55:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
f0102d58:	7e db                	jle    f0102d35 <command_prompt_readline+0x936>
				buf[var] = buf[var + 1];
			}
			lastIndex--;
f0102d5a:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102d60:	48                   	dec    %eax
f0102d61:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102d67:	e9 ae 01 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
		}
		else if (c >= ' ' && i < BUFLEN - 1 && c != 229 && c != 228) {
f0102d6c:	83 7d 94 1f          	cmpl   $0x1f,-0x6c(%ebp)
f0102d70:	7e 60                	jle    f0102dd2 <command_prompt_readline+0x9d3>
f0102d72:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102d78:	3d fe 03 00 00       	cmp    $0x3fe,%eax
f0102d7d:	7f 53                	jg     f0102dd2 <command_prompt_readline+0x9d3>
f0102d7f:	81 7d 94 e5 00 00 00 	cmpl   $0xe5,-0x6c(%ebp)
f0102d86:	74 4a                	je     f0102dd2 <command_prompt_readline+0x9d3>
f0102d88:	81 7d 94 e4 00 00 00 	cmpl   $0xe4,-0x6c(%ebp)
f0102d8f:	74 41                	je     f0102dd2 <command_prompt_readline+0x9d3>
			if (echoing)
f0102d91:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102d95:	74 0e                	je     f0102da5 <command_prompt_readline+0x9a6>
				cputchar(c);
f0102d97:	83 ec 0c             	sub    $0xc,%esp
f0102d9a:	ff 75 94             	pushl  -0x6c(%ebp)
f0102d9d:	e8 54 ed ff ff       	call   f0101af6 <cputchar>
f0102da2:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f0102da5:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102dab:	8d 50 01             	lea    0x1(%eax),%edx
f0102dae:	89 95 78 ff ff ff    	mov    %edx,-0x88(%ebp)
f0102db4:	89 c2                	mov    %eax,%edx
f0102db6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102db9:	01 d0                	add    %edx,%eax
f0102dbb:	8b 55 94             	mov    -0x6c(%ebp),%edx
f0102dbe:	88 10                	mov    %dl,(%eax)
			lastIndex++;
f0102dc0:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102dc6:	40                   	inc    %eax
f0102dc7:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0102dcd:	e9 48 01 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
		} else if (c == '\b' && i > 0) {
f0102dd2:	83 7d 94 08          	cmpl   $0x8,-0x6c(%ebp)
f0102dd6:	75 60                	jne    f0102e38 <command_prompt_readline+0xa39>
f0102dd8:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102dde:	85 c0                	test   %eax,%eax
f0102de0:	7e 56                	jle    f0102e38 <command_prompt_readline+0xa39>

			if (echoing)
f0102de2:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102de6:	74 0e                	je     f0102df6 <command_prompt_readline+0x9f7>
				cputchar(c);
f0102de8:	83 ec 0c             	sub    $0xc,%esp
f0102deb:	ff 75 94             	pushl  -0x6c(%ebp)
f0102dee:	e8 03 ed ff ff       	call   f0101af6 <cputchar>
f0102df3:	83 c4 10             	add    $0x10,%esp
			for (int var = i; var <= i; ++var) {
f0102df6:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102dfc:	89 45 a0             	mov    %eax,-0x60(%ebp)
f0102dff:	eb 1a                	jmp    f0102e1b <command_prompt_readline+0xa1c>
				buf[var - 1] = buf[var];
f0102e01:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0102e04:	8d 50 ff             	lea    -0x1(%eax),%edx
f0102e07:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e0a:	01 c2                	add    %eax,%edx
f0102e0c:	8b 4d a0             	mov    -0x60(%ebp),%ecx
f0102e0f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e12:	01 c8                	add    %ecx,%eax
f0102e14:	8a 00                	mov    (%eax),%al
f0102e16:	88 02                	mov    %al,(%edx)
			lastIndex++;
		} else if (c == '\b' && i > 0) {

			if (echoing)
				cputchar(c);
			for (int var = i; var <= i; ++var) {
f0102e18:	ff 45 a0             	incl   -0x60(%ebp)
f0102e1b:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102e21:	39 45 a0             	cmp    %eax,-0x60(%ebp)
f0102e24:	7e db                	jle    f0102e01 <command_prompt_readline+0xa02>
				buf[var - 1] = buf[var];
			}
			i--;
f0102e26:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f0102e2c:	48                   	dec    %eax
f0102e2d:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)
f0102e33:	e9 e2 00 00 00       	jmp    f0102f1a <command_prompt_readline+0xb1b>
		} else if (c == '\n' || c == '\r') {
f0102e38:	83 7d 94 0a          	cmpl   $0xa,-0x6c(%ebp)
f0102e3c:	74 0a                	je     f0102e48 <command_prompt_readline+0xa49>
f0102e3e:	83 7d 94 0d          	cmpl   $0xd,-0x6c(%ebp)
f0102e42:	0f 85 d2 00 00 00    	jne    f0102f1a <command_prompt_readline+0xb1b>

			if (echoing)
f0102e48:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0102e4c:	74 0e                	je     f0102e5c <command_prompt_readline+0xa5d>
				cputchar(c);
f0102e4e:	83 ec 0c             	sub    $0xc,%esp
f0102e51:	ff 75 94             	pushl  -0x6c(%ebp)
f0102e54:	e8 9d ec ff ff       	call   f0101af6 <cputchar>
f0102e59:	83 c4 10             	add    $0x10,%esp

			buf[lastIndex] = 0;
f0102e5c:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0102e62:	89 c2                	mov    %eax,%edx
f0102e64:	8b 45 0c             	mov    0xc(%ebp),%eax
f0102e67:	01 d0                	add    %edx,%eax
f0102e69:	c6 00 00             	movb   $0x0,(%eax)
			if (last_command_idx == HISTORY_MAX) {
f0102e6c:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102e71:	83 f8 13             	cmp    $0x13,%eax
f0102e74:	75 56                	jne    f0102ecc <command_prompt_readline+0xacd>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102e76:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%ebp)
f0102e7d:	eb 2d                	jmp    f0102eac <command_prompt_readline+0xaad>
					memcpy(command_history[idx], command_history[idx + 1],
f0102e7f:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102e82:	40                   	inc    %eax
f0102e83:	c1 e0 0a             	shl    $0xa,%eax
f0102e86:	8d 90 80 fe 86 f0    	lea    -0xf790180(%eax),%edx
f0102e8c:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0102e8f:	c1 e0 0a             	shl    $0xa,%eax
f0102e92:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102e97:	83 ec 04             	sub    $0x4,%esp
f0102e9a:	68 00 04 00 00       	push   $0x400
f0102e9f:	52                   	push   %edx
f0102ea0:	50                   	push   %eax
f0102ea1:	e8 66 7f 01 00       	call   f011ae0c <memcpy>
f0102ea6:	83 c4 10             	add    $0x10,%esp
			if (echoing)
				cputchar(c);

			buf[lastIndex] = 0;
			if (last_command_idx == HISTORY_MAX) {
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
f0102ea9:	ff 45 9c             	incl   -0x64(%ebp)
f0102eac:	83 7d 9c 12          	cmpl   $0x12,-0x64(%ebp)
f0102eb0:	7e cd                	jle    f0102e7f <command_prompt_readline+0xa80>
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
f0102eb2:	83 ec 04             	sub    $0x4,%esp
f0102eb5:	68 00 04 00 00       	push   $0x400
f0102eba:	ff 75 0c             	pushl  0xc(%ebp)
f0102ebd:	68 80 4a 87 f0       	push   $0xf0874a80
f0102ec2:	e8 45 7f 01 00       	call   f011ae0c <memcpy>
f0102ec7:	83 c4 10             	add    $0x10,%esp
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102eca:	eb 68                	jmp    f0102f34 <command_prompt_readline+0xb35>
				for (int idx = 0; idx < HISTORY_MAX; idx++) {
					memcpy(command_history[idx], command_history[idx + 1],
							BUFLEN);
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
f0102ecc:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102ed1:	c1 e0 0a             	shl    $0xa,%eax
f0102ed4:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102ed9:	83 ec 08             	sub    $0x8,%esp
f0102edc:	ff 75 0c             	pushl  0xc(%ebp)
f0102edf:	50                   	push   %eax
f0102ee0:	e8 a2 7d 01 00       	call   f011ac87 <strcmp>
f0102ee5:	83 c4 10             	add    $0x10,%esp
f0102ee8:	85 c0                	test   %eax,%eax
f0102eea:	74 48                	je     f0102f34 <command_prompt_readline+0xb35>
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
f0102eec:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102ef1:	40                   	inc    %eax
f0102ef2:	a3 50 f5 17 f0       	mov    %eax,0xf017f550
f0102ef7:	a1 50 f5 17 f0       	mov    0xf017f550,%eax
f0102efc:	c1 e0 0a             	shl    $0xa,%eax
f0102eff:	05 80 fe 86 f0       	add    $0xf086fe80,%eax
f0102f04:	83 ec 04             	sub    $0x4,%esp
f0102f07:	68 00 04 00 00       	push   $0x400
f0102f0c:	ff 75 0c             	pushl  0xc(%ebp)
f0102f0f:	50                   	push   %eax
f0102f10:	e8 f7 7e 01 00       	call   f011ae0c <memcpy>
f0102f15:	83 c4 10             	add    $0x10,%esp
			}
			return;
f0102f18:	eb 1a                	jmp    f0102f34 <command_prompt_readline+0xb35>

		}
		last_c = c;
f0102f1a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0102f1d:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0102f20:	e9 44 f5 ff ff       	jmp    f0102469 <command_prompt_readline+0x6a>
				clearandwritecommand(&i, commandidx, buf, &lastIndex);
		} else if (c == 9) { // Tab button
			if (last_c != 9) {
				clear_prefix_list(PrefixList, 100);
				if (strlen(buf) == 0 || last_c == 255)
					continue;
f0102f25:	90                   	nop
f0102f26:	e9 3e f5 ff ff       	jmp    f0102469 <command_prompt_readline+0x6a>
				int number_of_arguments = prefix_list_size = 0;
				char temp_buf[1024];
				strcpy(temp_buf, buf);
				int bufLength = strlen(buf);
				if (buf[bufLength - 1] == ' ')
					continue;
f0102f2b:	90                   	nop
			}
			return;

		}
		last_c = c;
	}
f0102f2c:	e9 38 f5 ff ff       	jmp    f0102469 <command_prompt_readline+0x6a>
			lastIndex = i;
		if (c < 0) {

			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			return;
f0102f31:	90                   	nop
f0102f32:	eb 01                	jmp    f0102f35 <command_prompt_readline+0xb36>
				}
				memcpy(command_history[HISTORY_MAX], buf, BUFLEN);
			} else if (strcmp(command_history[last_command_idx], buf) != 0) {
				memcpy(command_history[++last_command_idx], buf, BUFLEN);
			}
			return;
f0102f34:	90                   	nop

		}
		last_c = c;
	}
}
f0102f35:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0102f38:	5b                   	pop    %ebx
f0102f39:	5f                   	pop    %edi
f0102f3a:	5d                   	pop    %ebp
f0102f3b:	c3                   	ret    

f0102f3c <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0102f3c:	55                   	push   %ebp
f0102f3d:	89 e5                	mov    %esp,%ebp
f0102f3f:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f42:	a3 c4 69 85 f0       	mov    %eax,0xf08569c4
f0102f47:	90                   	nop
f0102f48:	5d                   	pop    %ebp
f0102f49:	c3                   	ret    

f0102f4a <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f0102f4a:	55                   	push   %ebp
f0102f4b:	89 e5                	mov    %esp,%ebp
f0102f4d:	a1 c4 69 85 f0       	mov    0xf08569c4,%eax
f0102f52:	5d                   	pop    %ebp
f0102f53:	c3                   	ret    

f0102f54 <set_uheap_strategy>:

//***********************************
/*2015*/ //USER HEAP STRATEGIES
uint32 _UHeapPlacementStrategy;
/*2025*/ //Replaced by setter & getter function
static inline void set_uheap_strategy(uint32 strategy){_UHeapPlacementStrategy = strategy;}
f0102f54:	55                   	push   %ebp
f0102f55:	89 e5                	mov    %esp,%ebp
f0102f57:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f5a:	a3 e8 6a 85 f0       	mov    %eax,0xf0856ae8
f0102f5f:	90                   	nop
f0102f60:	5d                   	pop    %ebp
f0102f61:	c3                   	ret    

f0102f62 <get_uheap_strategy>:
static inline uint32 get_uheap_strategy(){return _UHeapPlacementStrategy ;}
f0102f62:	55                   	push   %ebp
f0102f63:	89 e5                	mov    %esp,%ebp
f0102f65:	a1 e8 6a 85 f0       	mov    0xf0856ae8,%eax
f0102f6a:	5d                   	pop    %ebp
f0102f6b:	c3                   	ret    

f0102f6c <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0102f6c:	55                   	push   %ebp
f0102f6d:	89 e5                	mov    %esp,%ebp
f0102f6f:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0102f72:	8b 45 08             	mov    0x8(%ebp),%eax
f0102f75:	c1 e8 0c             	shr    $0xc,%eax
f0102f78:	89 c2                	mov    %eax,%edx
f0102f7a:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0102f7f:	39 c2                	cmp    %eax,%edx
f0102f81:	72 14                	jb     f0102f97 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0102f83:	83 ec 04             	sub    $0x4,%esp
f0102f86:	68 40 c0 12 f0       	push   $0xf012c040
f0102f8b:	6a 4e                	push   $0x4e
f0102f8d:	68 68 c0 12 f0       	push   $0xf012c068
f0102f92:	e8 18 e0 ff ff       	call   f0100faf <_panic>
	return &frames_info[PPN(physical_address)];
f0102f97:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0102f9d:	8b 45 08             	mov    0x8(%ebp),%eax
f0102fa0:	c1 e8 0c             	shr    $0xc,%eax
f0102fa3:	89 c1                	mov    %eax,%ecx
f0102fa5:	89 c8                	mov    %ecx,%eax
f0102fa7:	c1 e0 02             	shl    $0x2,%eax
f0102faa:	01 c8                	add    %ecx,%eax
f0102fac:	c1 e0 02             	shl    $0x2,%eax
f0102faf:	01 d0                	add    %edx,%eax
}
f0102fb1:	c9                   	leave  
f0102fb2:	c3                   	ret    

f0102fb3 <command_help>:

/***** Implementations of basic kernel command prompt commands *****/

//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{
f0102fb3:	55                   	push   %ebp
f0102fb4:	89 e5                	mov    %esp,%ebp
f0102fb6:	53                   	push   %ebx
f0102fb7:	83 ec 14             	sub    $0x14,%esp

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102fba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0102fc1:	eb 3b                	jmp    f0102ffe <command_help+0x4b>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);
f0102fc3:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0102fc6:	89 d0                	mov    %edx,%eax
f0102fc8:	01 c0                	add    %eax,%eax
f0102fca:	01 d0                	add    %edx,%eax
f0102fcc:	c1 e0 03             	shl    $0x3,%eax
f0102fcf:	05 64 f5 17 f0       	add    $0xf017f564,%eax
f0102fd4:	8b 10                	mov    (%eax),%edx
f0102fd6:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0102fd9:	89 c8                	mov    %ecx,%eax
f0102fdb:	01 c0                	add    %eax,%eax
f0102fdd:	01 c8                	add    %ecx,%eax
f0102fdf:	c1 e0 03             	shl    $0x3,%eax
f0102fe2:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f0102fe7:	8b 00                	mov    (%eax),%eax
f0102fe9:	83 ec 04             	sub    $0x4,%esp
f0102fec:	52                   	push   %edx
f0102fed:	50                   	push   %eax
f0102fee:	68 a3 cf 12 f0       	push   $0xf012cfa3
f0102ff3:	e8 64 ec ff ff       	call   f0101c5c <cprintf>
f0102ff8:	83 c4 10             	add    $0x10,%esp
//print name and description of each command
int command_help(int number_of_arguments, char **arguments)
{

	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0102ffb:	ff 45 f4             	incl   -0xc(%ebp)
f0102ffe:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0103001:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f0103006:	39 c2                	cmp    %eax,%edx
f0103008:	72 b9                	jb     f0102fc3 <command_help+0x10>
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");
f010300a:	83 ec 0c             	sub    $0xc,%esp
f010300d:	68 ac cf 12 f0       	push   $0xf012cfac
f0103012:	e8 45 ec ff ff       	call   f0101c5c <cprintf>
f0103017:	83 c4 10             	add    $0x10,%esp

	for (i = 0; i < NUM_USER_PROGS; i++)
f010301a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103021:	eb 42                	jmp    f0103065 <command_help+0xb2>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
f0103023:	8b 0d 9c 00 18 f0    	mov    0xf018009c,%ecx
f0103029:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010302c:	89 d0                	mov    %edx,%eax
f010302e:	01 c0                	add    %eax,%eax
f0103030:	01 d0                	add    %edx,%eax
f0103032:	c1 e0 02             	shl    $0x2,%eax
f0103035:	01 c8                	add    %ecx,%eax
f0103037:	8b 50 04             	mov    0x4(%eax),%edx
f010303a:	8b 1d 9c 00 18 f0    	mov    0xf018009c,%ebx
f0103040:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103043:	89 c8                	mov    %ecx,%eax
f0103045:	01 c0                	add    %eax,%eax
f0103047:	01 c8                	add    %ecx,%eax
f0103049:	c1 e0 02             	shl    $0x2,%eax
f010304c:	01 d8                	add    %ebx,%eax
f010304e:	8b 00                	mov    (%eax),%eax
f0103050:	83 ec 04             	sub    $0x4,%esp
f0103053:	52                   	push   %edx
f0103054:	50                   	push   %eax
f0103055:	68 c1 cf 12 f0       	push   $0xf012cfc1
f010305a:	e8 fd eb ff ff       	call   f0101c5c <cprintf>
f010305f:	83 c4 10             	add    $0x10,%esp
	for (i = 0; i < NUM_OF_COMMANDS; i++)
		cprintf("%s - %s\n", commands[i].name, commands[i].description);

	cprintf("-------------------\n");

	for (i = 0; i < NUM_USER_PROGS; i++)
f0103062:	ff 45 f4             	incl   -0xc(%ebp)
f0103065:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010306a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010306d:	7c b4                	jl     f0103023 <command_help+0x70>
		cprintf("run %s - %s [User Program]\n", ptr_UserPrograms[i].name, ptr_UserPrograms[i].desc);
	return 0;
f010306f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103074:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0103077:	c9                   	leave  
f0103078:	c3                   	ret    

f0103079 <command_kernel_info>:

//print information about kernel addresses and kernel size
int command_kernel_info(int number_of_arguments, char **arguments )
{
f0103079:	55                   	push   %ebp
f010307a:	89 e5                	mov    %esp,%ebp
f010307c:	83 ec 08             	sub    $0x8,%esp
	extern char start_of_kernel[], end_of_kernel_code_section[], start_of_uninitialized_data_section[], end_of_kernel[];

	cprintf("Special kernel symbols:\n");
f010307f:	83 ec 0c             	sub    $0xc,%esp
f0103082:	68 dd cf 12 f0       	push   $0xf012cfdd
f0103087:	e8 d0 eb ff ff       	call   f0101c5c <cprintf>
f010308c:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
f010308f:	b8 0c 00 10 00       	mov    $0x10000c,%eax
f0103094:	83 ec 04             	sub    $0x4,%esp
f0103097:	50                   	push   %eax
f0103098:	68 0c 00 10 f0       	push   $0xf010000c
f010309d:	68 f8 cf 12 f0       	push   $0xf012cff8
f01030a2:	e8 b5 eb ff ff       	call   f0101c5c <cprintf>
f01030a7:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
f01030aa:	b8 15 bc 11 00       	mov    $0x11bc15,%eax
f01030af:	83 ec 04             	sub    $0x4,%esp
f01030b2:	50                   	push   %eax
f01030b3:	68 15 bc 11 f0       	push   $0xf011bc15
f01030b8:	68 34 d0 12 f0       	push   $0xf012d034
f01030bd:	e8 9a eb ff ff       	call   f0101c5c <cprintf>
f01030c2:	83 c4 10             	add    $0x10,%esp
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
f01030c5:	b8 3c 59 81 00       	mov    $0x81593c,%eax
f01030ca:	83 ec 04             	sub    $0x4,%esp
f01030cd:	50                   	push   %eax
f01030ce:	68 3c 59 81 f0       	push   $0xf081593c
f01030d3:	68 70 d0 12 f0       	push   $0xf012d070
f01030d8:	e8 7f eb ff ff       	call   f0101c5c <cprintf>
f01030dd:	83 c4 10             	add    $0x10,%esp
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
f01030e0:	b8 d0 d6 87 00       	mov    $0x87d6d0,%eax
f01030e5:	83 ec 04             	sub    $0x4,%esp
f01030e8:	50                   	push   %eax
f01030e9:	68 d0 d6 87 f0       	push   $0xf087d6d0
f01030ee:	68 b8 d0 12 f0       	push   $0xf012d0b8
f01030f3:	e8 64 eb ff ff       	call   f0101c5c <cprintf>
f01030f8:	83 c4 10             	add    $0x10,%esp
	cprintf("Kernel executable memory footprint: %d KB\n",
			(end_of_kernel-start_of_kernel+1023)/1024);
f01030fb:	b8 d0 d6 87 f0       	mov    $0xf087d6d0,%eax
f0103100:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
f0103106:	b8 0c 00 10 f0       	mov    $0xf010000c,%eax
f010310b:	29 c2                	sub    %eax,%edx
f010310d:	89 d0                	mov    %edx,%eax
	cprintf("Special kernel symbols:\n");
	cprintf("  Start Address of the kernel 			%08x (virt)  %08x (phys)\n", start_of_kernel, start_of_kernel - KERNEL_BASE);
	cprintf("  End address of kernel code  			%08x (virt)  %08x (phys)\n", end_of_kernel_code_section, end_of_kernel_code_section - KERNEL_BASE);
	cprintf("  Start addr. of uninitialized data section 	%08x (virt)  %08x (phys)\n", start_of_uninitialized_data_section, start_of_uninitialized_data_section - KERNEL_BASE);
	cprintf("  End address of the kernel   			%08x (virt)  %08x (phys)\n", end_of_kernel, end_of_kernel - KERNEL_BASE);
	cprintf("Kernel executable memory footprint: %d KB\n",
f010310f:	85 c0                	test   %eax,%eax
f0103111:	79 05                	jns    f0103118 <command_kernel_info+0x9f>
f0103113:	05 ff 03 00 00       	add    $0x3ff,%eax
f0103118:	c1 f8 0a             	sar    $0xa,%eax
f010311b:	83 ec 08             	sub    $0x8,%esp
f010311e:	50                   	push   %eax
f010311f:	68 f4 d0 12 f0       	push   $0xf012d0f4
f0103124:	e8 33 eb ff ff       	call   f0101c5c <cprintf>
f0103129:	83 c4 10             	add    $0x10,%esp
			(end_of_kernel-start_of_kernel+1023)/1024);
	return 0;
f010312c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103131:	c9                   	leave  
f0103132:	c3                   	ret    

f0103133 <command_writemem_k>:
//*****************************************************************************************//
//===========================================================================
//Lab2.Examples
//=============
int command_writemem_k(int number_of_arguments, char **arguments)
{
f0103133:	55                   	push   %ebp
f0103134:	89 e5                	mov    %esp,%ebp
f0103136:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
f0103139:	8b 45 0c             	mov    0xc(%ebp),%eax
f010313c:	83 c0 04             	add    $0x4,%eax
f010313f:	8b 00                	mov    (%eax),%eax
f0103141:	83 ec 04             	sub    $0x4,%esp
f0103144:	6a 10                	push   $0x10
f0103146:	6a 00                	push   $0x0
f0103148:	50                   	push   %eax
f0103149:	e8 3c 7e 01 00       	call   f011af8a <strtol>
f010314e:	83 c4 10             	add    $0x10,%esp
f0103151:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0103156:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int stringLen = strlen(arguments[2]);
f0103159:	8b 45 0c             	mov    0xc(%ebp),%eax
f010315c:	83 c0 08             	add    $0x8,%eax
f010315f:	8b 00                	mov    (%eax),%eax
f0103161:	83 ec 0c             	sub    $0xc,%esp
f0103164:	50                   	push   %eax
f0103165:	e8 11 7a 01 00       	call   f011ab7b <strlen>
f010316a:	83 c4 10             	add    $0x10,%esp
f010316d:	89 45 ec             	mov    %eax,-0x14(%ebp)

	for(int i=0;i < stringLen; i++)
f0103170:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0103177:	eb 1c                	jmp    f0103195 <command_writemem_k+0x62>
	{
		*address = arguments[2][i];
f0103179:	8b 45 0c             	mov    0xc(%ebp),%eax
f010317c:	83 c0 08             	add    $0x8,%eax
f010317f:	8b 10                	mov    (%eax),%edx
f0103181:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103184:	01 d0                	add    %edx,%eax
f0103186:	8a 00                	mov    (%eax),%al
f0103188:	88 c2                	mov    %al,%dl
f010318a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010318d:	88 10                	mov    %dl,(%eax)
		address++;
f010318f:	ff 45 f4             	incl   -0xc(%ebp)
	//TODO: LAB2 Example: corresponding command name is "wm"

	unsigned char* address = (unsigned char*)strtol(arguments[1], NULL, 16)+KERNEL_BASE;
	int stringLen = strlen(arguments[2]);

	for(int i=0;i < stringLen; i++)
f0103192:	ff 45 f0             	incl   -0x10(%ebp)
f0103195:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103198:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010319b:	7c dc                	jl     f0103179 <command_writemem_k+0x46>
	{
		*address = arguments[2][i];
		address++;
	}
	return 0;
f010319d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031a2:	c9                   	leave  
f01031a3:	c3                   	ret    

f01031a4 <command_readmem_k>:

int command_readmem_k(int number_of_arguments, char **arguments)
{
f01031a4:	55                   	push   %ebp
f01031a5:	89 e5                	mov    %esp,%ebp
f01031a7:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB2 Example: corresponding command name is "rm"

	unsigned int address = strtol(arguments[1], NULL, 16);
f01031aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f01031ad:	83 c0 04             	add    $0x4,%eax
f01031b0:	8b 00                	mov    (%eax),%eax
f01031b2:	83 ec 04             	sub    $0x4,%esp
f01031b5:	6a 10                	push   $0x10
f01031b7:	6a 00                	push   $0x0
f01031b9:	50                   	push   %eax
f01031ba:	e8 cb 7d 01 00       	call   f011af8a <strtol>
f01031bf:	83 c4 10             	add    $0x10,%esp
f01031c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unsigned char *ptr = (unsigned char *)(address + KERNEL_BASE) ;
f01031c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01031c8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01031cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//Read value at the given address
	cprintf("value at virtual address %x = %c\n", ptr, *ptr);
f01031d0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01031d3:	8a 00                	mov    (%eax),%al
f01031d5:	0f b6 c0             	movzbl %al,%eax
f01031d8:	83 ec 04             	sub    $0x4,%esp
f01031db:	50                   	push   %eax
f01031dc:	ff 75 f0             	pushl  -0x10(%ebp)
f01031df:	68 20 d1 12 f0       	push   $0xf012d120
f01031e4:	e8 73 ea ff ff       	call   f0101c5c <cprintf>
f01031e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01031ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01031f1:	c9                   	leave  
f01031f2:	c3                   	ret    

f01031f3 <command_get_page_table>:

//===========================================================================
//Lab3.Examples
//=============
int command_get_page_table(int number_of_arguments, char **arguments)
{
f01031f3:	55                   	push   %ebp
f01031f4:	89 e5                	mov    %esp,%ebp
f01031f6:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#1,2: fill this function. corresponding command name is "gpt"
	//Comment the following line
	panic("Function is not implemented yet!");
f01031f9:	83 ec 04             	sub    $0x4,%esp
f01031fc:	68 44 d1 12 f0       	push   $0xf012d144
f0103201:	68 cd 00 00 00       	push   $0xcd
f0103206:	68 65 d1 12 f0       	push   $0xf012d165
f010320b:	e8 9f dd ff ff       	call   f0100faf <_panic>

f0103210 <command_kernel_base_info>:

	return 0;
}

int command_kernel_base_info(int number_of_arguments, char **arguments)
{
f0103210:	55                   	push   %ebp
f0103211:	89 e5                	mov    %esp,%ebp
f0103213:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#3: fill this function. corresponding command name is "ikb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103216:	83 ec 04             	sub    $0x4,%esp
f0103219:	68 44 d1 12 f0       	push   $0xf012d144
f010321e:	68 d6 00 00 00       	push   $0xd6
f0103223:	68 65 d1 12 f0       	push   $0xf012d165
f0103228:	e8 82 dd ff ff       	call   f0100faf <_panic>

f010322d <command_del_kernel_base>:

	return 0;
}

int command_del_kernel_base(int number_of_arguments, char **arguments)
{
f010322d:	55                   	push   %ebp
f010322e:	89 e5                	mov    %esp,%ebp
f0103230:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#4: fill this function. corresponding command name is "dkb"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103233:	83 ec 04             	sub    $0x4,%esp
f0103236:	68 44 d1 12 f0       	push   $0xf012d144
f010323b:	68 df 00 00 00       	push   $0xdf
f0103240:	68 65 d1 12 f0       	push   $0xf012d165
f0103245:	e8 65 dd ff ff       	call   f0100faf <_panic>

f010324a <command_share_page>:

	return 0;
}

int command_share_page(int number_of_arguments, char **arguments)
{
f010324a:	55                   	push   %ebp
f010324b:	89 e5                	mov    %esp,%ebp
f010324d:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB3 Example#5: fill this function. corresponding command name is "shr"
	//Comment the following line
	panic("Function is not implemented yet!");
f0103250:	83 ec 04             	sub    $0x4,%esp
f0103253:	68 44 d1 12 f0       	push   $0xf012d144
f0103258:	68 e8 00 00 00       	push   $0xe8
f010325d:	68 65 d1 12 f0       	push   $0xf012d165
f0103262:	e8 48 dd ff ff       	call   f0100faf <_panic>

f0103267 <command_nr>:
//===========================================================================
//Lab4.Examples
//==============
//[1] Number of references on the given physical address
int command_nr(int number_of_arguments, char **arguments)
{
f0103267:	55                   	push   %ebp
f0103268:	89 e5                	mov    %esp,%ebp
f010326a:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: corresponding command name is "nr"

	uint32 pa  = strtol(arguments[1], NULL, 16);
f010326d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103270:	83 c0 04             	add    $0x4,%eax
f0103273:	8b 00                	mov    (%eax),%eax
f0103275:	83 ec 04             	sub    $0x4,%esp
f0103278:	6a 10                	push   $0x10
f010327a:	6a 00                	push   $0x0
f010327c:	50                   	push   %eax
f010327d:	e8 08 7d 01 00       	call   f011af8a <strtol>
f0103282:	83 c4 10             	add    $0x10,%esp
f0103285:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int num_of_ref = num_of_references(pa);
f0103288:	83 ec 0c             	sub    $0xc,%esp
f010328b:	ff 75 f4             	pushl  -0xc(%ebp)
f010328e:	e8 99 6b 00 00       	call   f0109e2c <num_of_references>
f0103293:	83 c4 10             	add    $0x10,%esp
f0103296:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cprintf("Num of ref's @ pa %x = %d\n", pa, num_of_ref);
f0103299:	83 ec 04             	sub    $0x4,%esp
f010329c:	ff 75 f0             	pushl  -0x10(%ebp)
f010329f:	ff 75 f4             	pushl  -0xc(%ebp)
f01032a2:	68 79 d1 12 f0       	push   $0xf012d179
f01032a7:	e8 b0 e9 ff ff       	call   f0101c5c <cprintf>
f01032ac:	83 c4 10             	add    $0x10,%esp
	return 0;
f01032af:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01032b4:	c9                   	leave  
f01032b5:	c3                   	ret    

f01032b6 <command_ap>:

//[2] Allocate Page
int command_ap(int number_of_arguments, char **arguments)
{
f01032b6:	55                   	push   %ebp
f01032b7:	89 e5                	mov    %esp,%ebp
f01032b9:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: corresponding command name is "ap"

	uint32 va = strtol(arguments[1], NULL, 16);
f01032bc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032bf:	83 c0 04             	add    $0x4,%eax
f01032c2:	8b 00                	mov    (%eax),%eax
f01032c4:	83 ec 04             	sub    $0x4,%esp
f01032c7:	6a 10                	push   $0x10
f01032c9:	6a 00                	push   $0x0
f01032cb:	50                   	push   %eax
f01032cc:	e8 b9 7c 01 00       	call   f011af8a <strtol>
f01032d1:	83 c4 10             	add    $0x10,%esp
f01032d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
	bool set_to_zero = 0;
f01032d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 3)
f01032de:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01032e2:	75 15                	jne    f01032f9 <command_ap+0x43>
	{
		if (arguments[2][0] == '0')
f01032e4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01032e7:	83 c0 08             	add    $0x8,%eax
f01032ea:	8b 00                	mov    (%eax),%eax
f01032ec:	8a 00                	mov    (%eax),%al
f01032ee:	3c 30                	cmp    $0x30,%al
f01032f0:	75 07                	jne    f01032f9 <command_ap+0x43>
			set_to_zero = 1;
f01032f2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	int ret = alloc_page(ptr_page_directory, va, PERM_USER | PERM_WRITEABLE, set_to_zero);
f01032f9:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01032fe:	ff 75 f4             	pushl  -0xc(%ebp)
f0103301:	6a 06                	push   $0x6
f0103303:	ff 75 f0             	pushl  -0x10(%ebp)
f0103306:	50                   	push   %eax
f0103307:	e8 42 6b 00 00       	call   f0109e4e <alloc_page>
f010330c:	83 c4 10             	add    $0x10,%esp
f010330f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ret == 1)
f0103312:	83 7d ec 01          	cmpl   $0x1,-0x14(%ebp)
f0103316:	75 15                	jne    f010332d <command_ap+0x77>
	{
		cprintf("Page @ va %x already exists!\n", va);
f0103318:	83 ec 08             	sub    $0x8,%esp
f010331b:	ff 75 f0             	pushl  -0x10(%ebp)
f010331e:	68 94 d1 12 f0       	push   $0xf012d194
f0103323:	e8 34 e9 ff ff       	call   f0101c5c <cprintf>
f0103328:	83 c4 10             	add    $0x10,%esp
f010332b:	eb 41                	jmp    f010336e <command_ap+0xb8>
	}
	else if (ret == E_NO_MEM)
f010332d:	83 7d ec fc          	cmpl   $0xfffffffc,-0x14(%ebp)
f0103331:	75 12                	jne    f0103345 <command_ap+0x8f>
	{
		cprintf("No enough memory!\n");
f0103333:	83 ec 0c             	sub    $0xc,%esp
f0103336:	68 b2 d1 12 f0       	push   $0xf012d1b2
f010333b:	e8 1c e9 ff ff       	call   f0101c5c <cprintf>
f0103340:	83 c4 10             	add    $0x10,%esp
f0103343:	eb 29                	jmp    f010336e <command_ap+0xb8>
	}
	else
	{
		cprintf("New page is allocated @ va %x\n", va);
f0103345:	83 ec 08             	sub    $0x8,%esp
f0103348:	ff 75 f0             	pushl  -0x10(%ebp)
f010334b:	68 c8 d1 12 f0       	push   $0xf012d1c8
f0103350:	e8 07 e9 ff ff       	call   f0101c5c <cprintf>
f0103355:	83 c4 10             	add    $0x10,%esp
		if (set_to_zero)
f0103358:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010335c:	74 10                	je     f010336e <command_ap+0xb8>
			cprintf("and initialized by ZERO\n");
f010335e:	83 ec 0c             	sub    $0xc,%esp
f0103361:	68 e7 d1 12 f0       	push   $0xf012d1e7
f0103366:	e8 f1 e8 ff ff       	call   f0101c5c <cprintf>
f010336b:	83 c4 10             	add    $0x10,%esp
	}
	return 0 ;
f010336e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103373:	c9                   	leave  
f0103374:	c3                   	ret    

f0103375 <command_fp>:

//[3] Free Page: Un-map a single page at the given virtual address in the user space
int command_fp(int number_of_arguments, char **arguments)
{
f0103375:	55                   	push   %ebp
f0103376:	89 e5                	mov    %esp,%ebp
f0103378:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#3: corresponding command name is "fp"

	uint32 va = strtol(arguments[1], NULL, 16);
f010337b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010337e:	83 c0 04             	add    $0x4,%eax
f0103381:	8b 00                	mov    (%eax),%eax
f0103383:	83 ec 04             	sub    $0x4,%esp
f0103386:	6a 10                	push   $0x10
f0103388:	6a 00                	push   $0x0
f010338a:	50                   	push   %eax
f010338b:	e8 fa 7b 01 00       	call   f011af8a <strtol>
f0103390:	83 c4 10             	add    $0x10,%esp
f0103393:	89 45 f4             	mov    %eax,-0xc(%ebp)
	unmap_frame(ptr_page_directory, va);
f0103396:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010339b:	83 ec 08             	sub    $0x8,%esp
f010339e:	ff 75 f4             	pushl  -0xc(%ebp)
f01033a1:	50                   	push   %eax
f01033a2:	e8 a8 63 00 00       	call   f010974f <unmap_frame>
f01033a7:	83 c4 10             	add    $0x10,%esp

	return 0;
f01033aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01033af:	c9                   	leave  
f01033b0:	c3                   	ret    

f01033b1 <command_cfp>:
//===========================================================================
//Lab4.Hands-on
//==============
//Count Free Pages in Range
int command_cfp(int number_of_arguments, char **arguments)
{
f01033b1:	55                   	push   %ebp
f01033b2:	89 e5                	mov    %esp,%ebp
f01033b4:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Hands-on: corresponding command name is "cfp"

	uint32* dir_ptr = clone_kern_dir();
f01033b7:	e8 d8 6e 01 00       	call   f011a294 <clone_kern_dir>
f01033bc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 va1 = strtol(arguments[1], NULL, 16);
f01033bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033c2:	83 c0 04             	add    $0x4,%eax
f01033c5:	8b 00                	mov    (%eax),%eax
f01033c7:	83 ec 04             	sub    $0x4,%esp
f01033ca:	6a 10                	push   $0x10
f01033cc:	6a 00                	push   $0x0
f01033ce:	50                   	push   %eax
f01033cf:	e8 b6 7b 01 00       	call   f011af8a <strtol>
f01033d4:	83 c4 10             	add    $0x10,%esp
f01033d7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f01033da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01033dd:	83 c0 08             	add    $0x8,%eax
f01033e0:	8b 00                	mov    (%eax),%eax
f01033e2:	83 ec 04             	sub    $0x4,%esp
f01033e5:	6a 10                	push   $0x10
f01033e7:	6a 00                	push   $0x0
f01033e9:	50                   	push   %eax
f01033ea:	e8 9b 7b 01 00       	call   f011af8a <strtol>
f01033ef:	83 c4 10             	add    $0x10,%esp
f01033f2:	89 45 ec             	mov    %eax,-0x14(%ebp)

	uint32 num_of_free = calculate_free_space(dir_ptr, va1, va2);
f01033f5:	83 ec 04             	sub    $0x4,%esp
f01033f8:	ff 75 ec             	pushl  -0x14(%ebp)
f01033fb:	ff 75 f0             	pushl  -0x10(%ebp)
f01033fe:	ff 75 f4             	pushl  -0xc(%ebp)
f0103401:	e8 e1 78 00 00       	call   f010ace7 <calculate_free_space>
f0103406:	83 c4 10             	add    $0x10,%esp
f0103409:	89 45 e8             	mov    %eax,-0x18(%ebp)

	cprintf("Num of free pages in va range [%x, %x) = %d\n", va1, va2, num_of_free);
f010340c:	ff 75 e8             	pushl  -0x18(%ebp)
f010340f:	ff 75 ec             	pushl  -0x14(%ebp)
f0103412:	ff 75 f0             	pushl  -0x10(%ebp)
f0103415:	68 00 d2 12 f0       	push   $0xf012d200
f010341a:	e8 3d e8 ff ff       	call   f0101c5c <cprintf>
f010341f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103422:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103427:	c9                   	leave  
f0103428:	c3                   	ret    

f0103429 <command_asp>:

//===========================================================================
//Lab5.Hands.On
//=============
int command_asp(int number_of_arguments, char **arguments)
{
f0103429:	55                   	push   %ebp
f010342a:	89 e5                	mov    %esp,%ebp
f010342c:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "asp"

	uint32* dir_ptr = clone_kern_dir();
f010342f:	e8 60 6e 01 00       	call   f011a294 <clone_kern_dir>
f0103434:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va1 = strtol(arguments[1], NULL, 16);
f0103437:	8b 45 0c             	mov    0xc(%ebp),%eax
f010343a:	83 c0 04             	add    $0x4,%eax
f010343d:	8b 00                	mov    (%eax),%eax
f010343f:	83 ec 04             	sub    $0x4,%esp
f0103442:	6a 10                	push   $0x10
f0103444:	6a 00                	push   $0x0
f0103446:	50                   	push   %eax
f0103447:	e8 3e 7b 01 00       	call   f011af8a <strtol>
f010344c:	83 c4 10             	add    $0x10,%esp
f010344f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 va2 = strtol(arguments[2], NULL, 16);
f0103452:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103455:	83 c0 08             	add    $0x8,%eax
f0103458:	8b 00                	mov    (%eax),%eax
f010345a:	83 ec 04             	sub    $0x4,%esp
f010345d:	6a 10                	push   $0x10
f010345f:	6a 00                	push   $0x0
f0103461:	50                   	push   %eax
f0103462:	e8 23 7b 01 00       	call   f011af8a <strtol>
f0103467:	83 c4 10             	add    $0x10,%esp
f010346a:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int ret = alloc_shared_page(dir_ptr, va1, dir_ptr, va2, PERM_USER | PERM_WRITEABLE);
f010346d:	83 ec 0c             	sub    $0xc,%esp
f0103470:	6a 06                	push   $0x6
f0103472:	ff 75 ec             	pushl  -0x14(%ebp)
f0103475:	ff 75 f4             	pushl  -0xc(%ebp)
f0103478:	ff 75 f0             	pushl  -0x10(%ebp)
f010347b:	ff 75 f4             	pushl  -0xc(%ebp)
f010347e:	e8 6e 6a 00 00       	call   f0109ef1 <alloc_shared_page>
f0103483:	83 c4 20             	add    $0x20,%esp
f0103486:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0103489:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f010348d:	75 10                	jne    f010349f <command_asp+0x76>
	{
		cprintf("No enough memory!\n");
f010348f:	83 ec 0c             	sub    $0xc,%esp
f0103492:	68 b2 d1 12 f0       	push   $0xf012d1b2
f0103497:	e8 c0 e7 ff ff       	call   f0101c5c <cprintf>
f010349c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010349f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01034a4:	c9                   	leave  
f01034a5:	c3                   	ret    

f01034a6 <command_shmp>:

int command_shmp(int number_of_arguments, char **arguments)
{
f01034a6:	55                   	push   %ebp
f01034a7:	89 e5                	mov    %esp,%ebp
f01034a9:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sm"
	//Comment the following line
	panic("Function is not implemented yet!");
f01034ac:	83 ec 04             	sub    $0x4,%esp
f01034af:	68 44 d1 12 f0       	push   $0xf012d144
f01034b4:	68 4d 01 00 00       	push   $0x14d
f01034b9:	68 65 d1 12 f0       	push   $0xf012d165
f01034be:	e8 ec da ff ff       	call   f0100faf <_panic>

f01034c3 <command_scp>:

	return 0 ;
}

int command_scp(int number_of_arguments, char **arguments)
{
f01034c3:	55                   	push   %ebp
f01034c4:	89 e5                	mov    %esp,%ebp
f01034c6:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sp"
	//Comment the following line
	panic("Function is not implemented yet!");
f01034c9:	83 ec 04             	sub    $0x4,%esp
f01034cc:	68 44 d1 12 f0       	push   $0xf012d144
f01034d1:	68 56 01 00 00       	push   $0x156
f01034d6:	68 65 d1 12 f0       	push   $0xf012d165
f01034db:	e8 cf da ff ff       	call   f0100faf <_panic>

f01034e0 <command_shrr>:

	return 0 ;
}

int command_shrr(int number_of_arguments, char **arguments)
{
f01034e0:	55                   	push   %ebp
f01034e1:	89 e5                	mov    %esp,%ebp
f01034e3:	83 ec 08             	sub    $0x8,%esp
	//TODO: LAB5 Hands-on: fill this function. corresponding command name is "sr"
	//Comment the following line
	panic("Function is not implemented yet!");
f01034e6:	83 ec 04             	sub    $0x4,%esp
f01034e9:	68 44 d1 12 f0       	push   $0xf012d144
f01034ee:	68 5f 01 00 00       	push   $0x15f
f01034f3:	68 65 d1 12 f0       	push   $0xf012d165
f01034f8:	e8 b2 da ff ff       	call   f0100faf <_panic>

f01034fd <command_v2p>:

	return 0;
}

int command_v2p(int number_of_arguments, char **arguments)
{
f01034fd:	55                   	push   %ebp
f01034fe:	89 e5                	mov    %esp,%ebp
f0103500:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "v2p"

	uint32 va = strtol(arguments[1], NULL, 16);
f0103503:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103506:	83 c0 04             	add    $0x4,%eax
f0103509:	8b 00                	mov    (%eax),%eax
f010350b:	83 ec 04             	sub    $0x4,%esp
f010350e:	6a 10                	push   $0x10
f0103510:	6a 00                	push   $0x0
f0103512:	50                   	push   %eax
f0103513:	e8 72 7a 01 00       	call   f011af8a <strtol>
f0103518:	83 c4 10             	add    $0x10,%esp
f010351b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 pa = virtual_to_physical(ptr_page_directory, va);
f010351e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0103523:	83 ec 08             	sub    $0x8,%esp
f0103526:	ff 75 f4             	pushl  -0xc(%ebp)
f0103529:	50                   	push   %eax
f010352a:	e8 c9 68 00 00       	call   f0109df8 <virtual_to_physical>
f010352f:	83 c4 10             	add    $0x10,%esp
f0103532:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pa == -1)
f0103535:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0103539:	75 12                	jne    f010354d <command_v2p+0x50>
		cprintf("NOT FOUND\n");
f010353b:	83 ec 0c             	sub    $0xc,%esp
f010353e:	68 2d d2 12 f0       	push   $0xf012d22d
f0103543:	e8 14 e7 ff ff       	call   f0101c5c <cprintf>
f0103548:	83 c4 10             	add    $0x10,%esp
f010354b:	eb 16                	jmp    f0103563 <command_v2p+0x66>
	else
		cprintf("PA of VA %x = %x\n", va, pa);
f010354d:	83 ec 04             	sub    $0x4,%esp
f0103550:	ff 75 f0             	pushl  -0x10(%ebp)
f0103553:	ff 75 f4             	pushl  -0xc(%ebp)
f0103556:	68 38 d2 12 f0       	push   $0xf012d238
f010355b:	e8 fc e6 ff ff       	call   f0101c5c <cprintf>
f0103560:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103563:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103568:	c9                   	leave  
f0103569:	c3                   	ret    

f010356a <command_p2v>:

int command_p2v(int number_of_arguments, char **arguments)
{
f010356a:	55                   	push   %ebp
f010356b:	89 e5                	mov    %esp,%ebp
f010356d:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB5 Hands-on: corresponding command name is "p2v"

	uint32 pa = strtol(arguments[1], NULL, 16);
f0103570:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103573:	83 c0 04             	add    $0x4,%eax
f0103576:	8b 00                	mov    (%eax),%eax
f0103578:	83 ec 04             	sub    $0x4,%esp
f010357b:	6a 10                	push   $0x10
f010357d:	6a 00                	push   $0x0
f010357f:	50                   	push   %eax
f0103580:	e8 05 7a 01 00       	call   f011af8a <strtol>
f0103585:	83 c4 10             	add    $0x10,%esp
f0103588:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 va = physical_to_virtual(ptr_page_directory, pa);
f010358b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0103590:	83 ec 08             	sub    $0x8,%esp
f0103593:	ff 75 f4             	pushl  -0xc(%ebp)
f0103596:	50                   	push   %eax
f0103597:	e8 76 68 00 00       	call   f0109e12 <physical_to_virtual>
f010359c:	83 c4 10             	add    $0x10,%esp
f010359f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (va == 0xFFFFFFFF)
f01035a2:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f01035a6:	75 12                	jne    f01035ba <command_p2v+0x50>
		cprintf("NOT FOUND\n");
f01035a8:	83 ec 0c             	sub    $0xc,%esp
f01035ab:	68 2d d2 12 f0       	push   $0xf012d22d
f01035b0:	e8 a7 e6 ff ff       	call   f0101c5c <cprintf>
f01035b5:	83 c4 10             	add    $0x10,%esp
f01035b8:	eb 16                	jmp    f01035d0 <command_p2v+0x66>
	else
		cprintf("VA of PA %x = %x\n", pa, va);
f01035ba:	83 ec 04             	sub    $0x4,%esp
f01035bd:	ff 75 f0             	pushl  -0x10(%ebp)
f01035c0:	ff 75 f4             	pushl  -0xc(%ebp)
f01035c3:	68 4a d2 12 f0       	push   $0xf012d24a
f01035c8:	e8 8f e6 ff ff       	call   f0101c5c <cprintf>
f01035cd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01035d0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01035d5:	c9                   	leave  
f01035d6:	c3                   	ret    

f01035d7 <command_ft>:

//===========================================================================
//Lab6.Examples
//=============
int command_ft(int number_of_arguments, char **arguments)
{
f01035d7:	55                   	push   %ebp
f01035d8:	89 e5                	mov    %esp,%ebp
f01035da:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB6 Example: corresponding command name is "ft"

	uint32 va = strtol(arguments[1], NULL, 16);
f01035dd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01035e0:	83 c0 04             	add    $0x4,%eax
f01035e3:	8b 00                	mov    (%eax),%eax
f01035e5:	83 ec 04             	sub    $0x4,%esp
f01035e8:	6a 10                	push   $0x10
f01035ea:	6a 00                	push   $0x0
f01035ec:	50                   	push   %eax
f01035ed:	e8 98 79 01 00       	call   f011af8a <strtol>
f01035f2:	83 c4 10             	add    $0x10,%esp
f01035f5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	del_page_table(ptr_page_directory, va);
f01035f8:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01035fd:	83 ec 08             	sub    $0x8,%esp
f0103600:	ff 75 f4             	pushl  -0xc(%ebp)
f0103603:	50                   	push   %eax
f0103604:	e8 05 69 00 00       	call   f0109f0e <del_page_table>
f0103609:	83 c4 10             	add    $0x10,%esp

	return 0;
f010360c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103611:	c9                   	leave  
f0103612:	c3                   	ret    

f0103613 <command_writeusermem>:

//*****************************************************************************************//
//***************************** UTILITY/TESING COMMANDS ***********************************//
//*****************************************************************************************//
int command_writeusermem(int number_of_arguments, char **arguments)
{
f0103613:	55                   	push   %ebp
f0103614:	89 e5                	mov    %esp,%ebp
f0103616:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 3)
f0103619:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f010361d:	75 37                	jne    f0103656 <command_writeusermem+0x43>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f010361f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103622:	83 c0 04             	add    $0x4,%eax
f0103625:	8b 00                	mov    (%eax),%eax
f0103627:	83 ec 04             	sub    $0x4,%esp
f010362a:	6a 10                	push   $0x10
f010362c:	6a 00                	push   $0x0
f010362e:	50                   	push   %eax
f010362f:	e8 56 79 01 00       	call   f011af8a <strtol>
f0103634:	83 c4 10             	add    $0x10,%esp
f0103637:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address) ;
f010363a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010363d:	89 45 d8             	mov    %eax,-0x28(%ebp)

		*ptr = arguments[2][0];
f0103640:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103643:	83 c0 08             	add    $0x8,%eax
f0103646:	8b 00                	mov    (%eax),%eax
f0103648:	8a 00                	mov    (%eax),%al
f010364a:	88 c2                	mov    %al,%dl
f010364c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010364f:	88 10                	mov    %dl,(%eax)
f0103651:	e9 b9 00 00 00       	jmp    f010370f <command_writeusermem+0xfc>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 4)
f0103656:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f010365a:	0f 85 9f 00 00 00    	jne    f01036ff <command_writeusermem+0xec>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f0103660:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103663:	83 c0 04             	add    $0x4,%eax
f0103666:	8b 00                	mov    (%eax),%eax
f0103668:	83 ec 04             	sub    $0x4,%esp
f010366b:	6a 0a                	push   $0xa
f010366d:	6a 00                	push   $0x0
f010366f:	50                   	push   %eax
f0103670:	e8 15 79 01 00       	call   f011af8a <strtol>
f0103675:	83 c4 10             	add    $0x10,%esp
f0103678:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f010367b:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0103682:	83 ec 04             	sub    $0x4,%esp
f0103685:	6a 00                	push   $0x0
f0103687:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010368a:	50                   	push   %eax
f010368b:	ff 75 f4             	pushl  -0xc(%ebp)
f010368e:	e8 d5 84 00 00       	call   f010bb68 <envid2env>
f0103693:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f0103696:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103699:	83 c0 08             	add    $0x8,%eax
f010369c:	8b 00                	mov    (%eax),%eax
f010369e:	83 ec 04             	sub    $0x4,%esp
f01036a1:	6a 10                	push   $0x10
f01036a3:	6a 00                	push   $0x0
f01036a5:	50                   	push   %eax
f01036a6:	e8 df 78 01 00       	call   f011af8a <strtol>
f01036ab:	83 c4 10             	add    $0x10,%esp
f01036ae:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01036b1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036b4:	85 c0                	test   %eax,%eax
f01036b6:	75 07                	jne    f01036bf <command_writeusermem+0xac>
f01036b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01036bd:	eb 55                	jmp    f0103714 <command_writeusermem+0x101>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01036bf:	0f 20 d8             	mov    %cr3,%eax
f01036c2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01036c5:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01036c8:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32) (env->env_cr3));
f01036cb:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01036ce:	8b 40 68             	mov    0x68(%eax),%eax
f01036d1:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01036d4:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01036d7:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01036da:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01036dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		*ptr = arguments[3][0];
f01036e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01036e3:	83 c0 0c             	add    $0xc,%eax
f01036e6:	8b 00                	mov    (%eax),%eax
f01036e8:	8a 00                	mov    (%eax),%al
f01036ea:	88 c2                	mov    %al,%dl
f01036ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01036ef:	88 10                	mov    %dl,(%eax)
f01036f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01036f4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01036f7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01036fa:	0f 22 d8             	mov    %eax,%cr3
f01036fd:	eb 10                	jmp    f010370f <command_writeusermem+0xfc>
		lcr3(oldDir);
	}
	else
	{
		cprintf("wum command: invalid number of arguments\n") ;
f01036ff:	83 ec 0c             	sub    $0xc,%esp
f0103702:	68 5c d2 12 f0       	push   $0xf012d25c
f0103707:	e8 50 e5 ff ff       	call   f0101c5c <cprintf>
f010370c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f010370f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103714:	c9                   	leave  
f0103715:	c3                   	ret    

f0103716 <command_readusermem>:


int command_readusermem(int number_of_arguments, char **arguments)
{
f0103716:	55                   	push   %ebp
f0103717:	89 e5                	mov    %esp,%ebp
f0103719:	83 ec 38             	sub    $0x38,%esp
	//deal with the kernel page directory
	if (number_of_arguments == 2)
f010371c:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0103720:	75 42                	jne    f0103764 <command_readusermem+0x4e>
	{
		unsigned int address = strtol(arguments[1], NULL, 16);
f0103722:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103725:	83 c0 04             	add    $0x4,%eax
f0103728:	8b 00                	mov    (%eax),%eax
f010372a:	83 ec 04             	sub    $0x4,%esp
f010372d:	6a 10                	push   $0x10
f010372f:	6a 00                	push   $0x0
f0103731:	50                   	push   %eax
f0103732:	e8 53 78 01 00       	call   f011af8a <strtol>
f0103737:	83 c4 10             	add    $0x10,%esp
f010373a:	89 45 dc             	mov    %eax,-0x24(%ebp)
		unsigned char *ptr = (unsigned char *)(address ) ;
f010373d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103740:	89 45 d8             	mov    %eax,-0x28(%ebp)

		cprintf("value at address %x = %c\n", ptr, *ptr);
f0103743:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103746:	8a 00                	mov    (%eax),%al
f0103748:	0f b6 c0             	movzbl %al,%eax
f010374b:	83 ec 04             	sub    $0x4,%esp
f010374e:	50                   	push   %eax
f010374f:	ff 75 d8             	pushl  -0x28(%ebp)
f0103752:	68 86 d2 12 f0       	push   $0xf012d286
f0103757:	e8 00 e5 ff ff       	call   f0101c5c <cprintf>
f010375c:	83 c4 10             	add    $0x10,%esp
f010375f:	e9 c4 00 00 00       	jmp    f0103828 <command_readusermem+0x112>
	}
	//deal with a page directory of specific environment
	else if (number_of_arguments == 3)
f0103764:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0103768:	0f 85 aa 00 00 00    	jne    f0103818 <command_readusermem+0x102>
	{
		int32 envId = strtol(arguments[1],NULL, 10);
f010376e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103771:	83 c0 04             	add    $0x4,%eax
f0103774:	8b 00                	mov    (%eax),%eax
f0103776:	83 ec 04             	sub    $0x4,%esp
f0103779:	6a 0a                	push   $0xa
f010377b:	6a 00                	push   $0x0
f010377d:	50                   	push   %eax
f010377e:	e8 07 78 01 00       	call   f011af8a <strtol>
f0103783:	83 c4 10             	add    $0x10,%esp
f0103786:	89 45 f4             	mov    %eax,-0xc(%ebp)
		struct Env* env = NULL;
f0103789:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
		envid2env(envId, &env, 0 );
f0103790:	83 ec 04             	sub    $0x4,%esp
f0103793:	6a 00                	push   $0x0
f0103795:	8d 45 d0             	lea    -0x30(%ebp),%eax
f0103798:	50                   	push   %eax
f0103799:	ff 75 f4             	pushl  -0xc(%ebp)
f010379c:	e8 c7 83 00 00       	call   f010bb68 <envid2env>
f01037a1:	83 c4 10             	add    $0x10,%esp

		int address = strtol(arguments[2], NULL, 16);
f01037a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01037a7:	83 c0 08             	add    $0x8,%eax
f01037aa:	8b 00                	mov    (%eax),%eax
f01037ac:	83 ec 04             	sub    $0x4,%esp
f01037af:	6a 10                	push   $0x10
f01037b1:	6a 00                	push   $0x0
f01037b3:	50                   	push   %eax
f01037b4:	e8 d1 77 01 00       	call   f011af8a <strtol>
f01037b9:	83 c4 10             	add    $0x10,%esp
f01037bc:	89 45 f0             	mov    %eax,-0x10(%ebp)

		if(env == NULL) return 0;
f01037bf:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037c2:	85 c0                	test   %eax,%eax
f01037c4:	75 07                	jne    f01037cd <command_readusermem+0xb7>
f01037c6:	b8 00 00 00 00       	mov    $0x0,%eax
f01037cb:	eb 60                	jmp    f010382d <command_readusermem+0x117>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01037cd:	0f 20 d8             	mov    %cr3,%eax
f01037d0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return val;
f01037d3:	8b 45 e8             	mov    -0x18(%ebp),%eax

		uint32 oldDir = rcr3();
f01037d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
		lcr3((uint32)( env->env_cr3));
f01037d9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01037dc:	8b 40 68             	mov    0x68(%eax),%eax
f01037df:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01037e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01037e5:	0f 22 d8             	mov    %eax,%cr3

		unsigned char *ptr = (unsigned char *)(address) ;
f01037e8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01037eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

		//Write the given Character
		cprintf("value at address %x = %c\n", address, *ptr);
f01037ee:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01037f1:	8a 00                	mov    (%eax),%al
f01037f3:	0f b6 c0             	movzbl %al,%eax
f01037f6:	83 ec 04             	sub    $0x4,%esp
f01037f9:	50                   	push   %eax
f01037fa:	ff 75 f0             	pushl  -0x10(%ebp)
f01037fd:	68 86 d2 12 f0       	push   $0xf012d286
f0103802:	e8 55 e4 ff ff       	call   f0101c5c <cprintf>
f0103807:	83 c4 10             	add    $0x10,%esp
f010380a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010380d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0103810:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0103813:	0f 22 d8             	mov    %eax,%cr3
f0103816:	eb 10                	jmp    f0103828 <command_readusermem+0x112>

		lcr3(oldDir);
	}
	else
	{
		cprintf("rum command: invalid number of arguments\n") ;
f0103818:	83 ec 0c             	sub    $0xc,%esp
f010381b:	68 a0 d2 12 f0       	push   $0xf012d2a0
f0103820:	e8 37 e4 ff ff       	call   f0101c5c <cprintf>
f0103825:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103828:	b8 00 00 00 00       	mov    $0x0,%eax

}
f010382d:	c9                   	leave  
f010382e:	c3                   	ret    

f010382f <command_readuserblock>:


int command_readuserblock(int number_of_arguments, char **arguments)
{
f010382f:	55                   	push   %ebp
f0103830:	89 e5                	mov    %esp,%ebp
f0103832:	83 ec 38             	sub    $0x38,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103835:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103838:	83 c0 04             	add    $0x4,%eax
f010383b:	8b 00                	mov    (%eax),%eax
f010383d:	83 ec 04             	sub    $0x4,%esp
f0103840:	6a 0a                	push   $0xa
f0103842:	6a 00                	push   $0x0
f0103844:	50                   	push   %eax
f0103845:	e8 40 77 01 00       	call   f011af8a <strtol>
f010384a:	83 c4 10             	add    $0x10,%esp
f010384d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct Env* env = NULL;
f0103850:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
	envid2env(envId, &env, 0 );
f0103857:	83 ec 04             	sub    $0x4,%esp
f010385a:	6a 00                	push   $0x0
f010385c:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010385f:	50                   	push   %eax
f0103860:	ff 75 ec             	pushl  -0x14(%ebp)
f0103863:	e8 00 83 00 00       	call   f010bb68 <envid2env>
f0103868:	83 c4 10             	add    $0x10,%esp

	int address = strtol(arguments[2], NULL, 16);
f010386b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010386e:	83 c0 08             	add    $0x8,%eax
f0103871:	8b 00                	mov    (%eax),%eax
f0103873:	83 ec 04             	sub    $0x4,%esp
f0103876:	6a 10                	push   $0x10
f0103878:	6a 00                	push   $0x0
f010387a:	50                   	push   %eax
f010387b:	e8 0a 77 01 00       	call   f011af8a <strtol>
f0103880:	83 c4 10             	add    $0x10,%esp
f0103883:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int nBytes = strtol(arguments[3], NULL, 10);
f0103886:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103889:	83 c0 0c             	add    $0xc,%eax
f010388c:	8b 00                	mov    (%eax),%eax
f010388e:	83 ec 04             	sub    $0x4,%esp
f0103891:	6a 0a                	push   $0xa
f0103893:	6a 00                	push   $0x0
f0103895:	50                   	push   %eax
f0103896:	e8 ef 76 01 00       	call   f011af8a <strtol>
f010389b:	83 c4 10             	add    $0x10,%esp
f010389e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	unsigned char *ptr = (unsigned char *)(address) ;
f01038a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01038a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//Write the given Character

	if(env == NULL) return 0;
f01038a7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01038aa:	85 c0                	test   %eax,%eax
f01038ac:	75 07                	jne    f01038b5 <command_readuserblock+0x86>
f01038ae:	b8 00 00 00 00       	mov    $0x0,%eax
f01038b3:	eb 65                	jmp    f010391a <command_readuserblock+0xeb>

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f01038b5:	0f 20 d8             	mov    %cr3,%eax
f01038b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f01038bb:	8b 45 d8             	mov    -0x28(%ebp),%eax

	uint32 oldDir = rcr3();
f01038be:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));
f01038c1:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01038c4:	8b 40 68             	mov    0x68(%eax),%eax
f01038c7:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f01038ca:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01038cd:	0f 22 d8             	mov    %eax,%cr3

	int i;
	for(i = 0;i<nBytes; i++)
f01038d0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01038d7:	eb 28                	jmp    f0103901 <command_readuserblock+0xd2>
	{
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
f01038d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01038dc:	8a 00                	mov    (%eax),%al
f01038de:	0f b6 d0             	movzbl %al,%edx
f01038e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01038e4:	8a 00                	mov    (%eax),%al
f01038e6:	0f b6 c0             	movzbl %al,%eax
f01038e9:	52                   	push   %edx
f01038ea:	50                   	push   %eax
f01038eb:	ff 75 f4             	pushl  -0xc(%ebp)
f01038ee:	68 ca d2 12 f0       	push   $0xf012d2ca
f01038f3:	e8 64 e3 ff ff       	call   f0101c5c <cprintf>
f01038f8:	83 c4 10             	add    $0x10,%esp
		ptr++;
f01038fb:	ff 45 f4             	incl   -0xc(%ebp)
	uint32 oldDir = rcr3();
	//lcr3((uint32) K_PHYSICAL_ADDRESS( env->env_pgdir));
	lcr3((uint32)( env->env_cr3));

	int i;
	for(i = 0;i<nBytes; i++)
f01038fe:	ff 45 f0             	incl   -0x10(%ebp)
f0103901:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103904:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0103907:	7c d0                	jl     f01038d9 <command_readuserblock+0xaa>
f0103909:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010390c:	89 45 e0             	mov    %eax,-0x20(%ebp)
f010390f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103912:	0f 22 d8             	mov    %eax,%cr3
		cprintf("%08x : %02x  %c\n", ptr, *ptr, *ptr);
		ptr++;
	}
	lcr3(oldDir);

	return 0;
f0103915:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010391a:	c9                   	leave  
f010391b:	c3                   	ret    

f010391c <command_remove_table>:

int command_remove_table(int number_of_arguments, char **arguments)
{
f010391c:	55                   	push   %ebp
f010391d:	89 e5                	mov    %esp,%ebp
f010391f:	83 ec 28             	sub    $0x28,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103922:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103925:	83 c0 04             	add    $0x4,%eax
f0103928:	8b 00                	mov    (%eax),%eax
f010392a:	83 ec 04             	sub    $0x4,%esp
f010392d:	6a 0a                	push   $0xa
f010392f:	6a 00                	push   $0x0
f0103931:	50                   	push   %eax
f0103932:	e8 53 76 01 00       	call   f011af8a <strtol>
f0103937:	83 c4 10             	add    $0x10,%esp
f010393a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct Env* env = NULL;
f010393d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	envid2env(envId, &env, 0 );
f0103944:	83 ec 04             	sub    $0x4,%esp
f0103947:	6a 00                	push   $0x0
f0103949:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010394c:	50                   	push   %eax
f010394d:	ff 75 f4             	pushl  -0xc(%ebp)
f0103950:	e8 13 82 00 00       	call   f010bb68 <envid2env>
f0103955:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103958:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010395b:	85 c0                	test   %eax,%eax
f010395d:	75 0a                	jne    f0103969 <command_remove_table+0x4d>
f010395f:	b8 00 00 00 00       	mov    $0x0,%eax
f0103964:	e9 c7 00 00 00       	jmp    f0103a30 <command_remove_table+0x114>

	uint32 address = strtol(arguments[2], NULL, 16);
f0103969:	8b 45 0c             	mov    0xc(%ebp),%eax
f010396c:	83 c0 08             	add    $0x8,%eax
f010396f:	8b 00                	mov    (%eax),%eax
f0103971:	83 ec 04             	sub    $0x4,%esp
f0103974:	6a 10                	push   $0x10
f0103976:	6a 00                	push   $0x0
f0103978:	50                   	push   %eax
f0103979:	e8 0c 76 01 00       	call   f011af8a <strtol>
f010397e:	83 c4 10             	add    $0x10,%esp
f0103981:	89 45 f0             	mov    %eax,-0x10(%ebp)
	unsigned char *va = (unsigned char *)(address) ;
f0103984:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0103987:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 table_pa = env->env_page_directory[PDX(address)] & 0xFFFFF000;
f010398a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010398d:	8b 40 64             	mov    0x64(%eax),%eax
f0103990:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103993:	c1 ea 16             	shr    $0x16,%edx
f0103996:	c1 e2 02             	shl    $0x2,%edx
f0103999:	01 d0                	add    %edx,%eax
f010399b:	8b 00                	mov    (%eax),%eax
f010399d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01039a2:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//remove the table
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(va))
f01039a5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01039a8:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f01039ad:	77 1c                	ja     f01039cb <command_remove_table+0xaf>
	{
		kfree((void*)kheap_virtual_address(table_pa));
f01039af:	83 ec 0c             	sub    $0xc,%esp
f01039b2:	ff 75 e8             	pushl  -0x18(%ebp)
f01039b5:	e8 b0 62 00 00       	call   f0109c6a <kheap_virtual_address>
f01039ba:	83 c4 10             	add    $0x10,%esp
f01039bd:	83 ec 0c             	sub    $0xc,%esp
f01039c0:	50                   	push   %eax
f01039c1:	e8 8a 62 00 00       	call   f0109c50 <kfree>
f01039c6:	83 c4 10             	add    $0x10,%esp
f01039c9:	eb 28                	jmp    f01039f3 <command_remove_table+0xd7>
	}
	else
	{
		// get the physical address and FrameInfo of the page table
		struct FrameInfo *table_FrameInfo = to_frame_info(table_pa);
f01039cb:	83 ec 0c             	sub    $0xc,%esp
f01039ce:	ff 75 e8             	pushl  -0x18(%ebp)
f01039d1:	e8 96 f5 ff ff       	call   f0102f6c <to_frame_info>
f01039d6:	83 c4 10             	add    $0x10,%esp
f01039d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		// set references of the table frame to 0 then free it by adding
		// to the free frame list
		table_FrameInfo->references = 0;
f01039dc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01039df:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
		free_frame(table_FrameInfo);
f01039e5:	83 ec 0c             	sub    $0xc,%esp
f01039e8:	ff 75 e4             	pushl  -0x1c(%ebp)
f01039eb:	e8 7a 58 00 00       	call   f010926a <free_frame>
f01039f0:	83 c4 10             	add    $0x10,%esp
	}

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f01039f3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01039f6:	c1 e8 16             	shr    $0x16,%eax
f01039f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	env->env_page_directory[dir_index] &= (~PERM_PRESENT);
f01039fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01039ff:	8b 40 64             	mov    0x64(%eax),%eax
f0103a02:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103a05:	c1 e2 02             	shl    $0x2,%edx
f0103a08:	01 c2                	add    %eax,%edx
f0103a0a:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0103a0d:	8b 40 64             	mov    0x64(%eax),%eax
f0103a10:	8b 4d e0             	mov    -0x20(%ebp),%ecx
f0103a13:	c1 e1 02             	shl    $0x2,%ecx
f0103a16:	01 c8                	add    %ecx,%eax
f0103a18:	8b 00                	mov    (%eax),%eax
f0103a1a:	83 e0 fe             	and    $0xfffffffe,%eax
f0103a1d:	89 02                	mov    %eax,(%edx)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0103a1f:	0f 20 d8             	mov    %cr3,%eax
f0103a22:	89 45 dc             	mov    %eax,-0x24(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0103a25:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0103a28:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
	return 0;
f0103a2b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103a30:	c9                   	leave  
f0103a31:	c3                   	ret    

f0103a32 <command_allocuserpage>:

int command_allocuserpage(int number_of_arguments, char **arguments)
{
f0103a32:	55                   	push   %ebp
f0103a33:	89 e5                	mov    %esp,%ebp
f0103a35:	83 ec 28             	sub    $0x28,%esp
	if (number_of_arguments < 3 || number_of_arguments > 4)
f0103a38:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0103a3c:	7e 06                	jle    f0103a44 <command_allocuserpage+0x12>
f0103a3e:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103a42:	7e 1a                	jle    f0103a5e <command_allocuserpage+0x2c>
	{
		cprintf("aup command: invalid number of arguments\n") ;
f0103a44:	83 ec 0c             	sub    $0xc,%esp
f0103a47:	68 dc d2 12 f0       	push   $0xf012d2dc
f0103a4c:	e8 0b e2 ff ff       	call   f0101c5c <cprintf>
f0103a51:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103a54:	b8 00 00 00 00       	mov    $0x0,%eax
f0103a59:	e9 46 01 00 00       	jmp    f0103ba4 <command_allocuserpage+0x172>
	}
	int32 envId = strtol(arguments[1],NULL, 10);
f0103a5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103a61:	83 c0 04             	add    $0x4,%eax
f0103a64:	8b 00                	mov    (%eax),%eax
f0103a66:	83 ec 04             	sub    $0x4,%esp
f0103a69:	6a 0a                	push   $0xa
f0103a6b:	6a 00                	push   $0x0
f0103a6d:	50                   	push   %eax
f0103a6e:	e8 17 75 01 00       	call   f011af8a <strtol>
f0103a73:	83 c4 10             	add    $0x10,%esp
f0103a76:	89 45 f0             	mov    %eax,-0x10(%ebp)
	struct Env* env = NULL;
f0103a79:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	envid2env(envId, &env, 0 );
f0103a80:	83 ec 04             	sub    $0x4,%esp
f0103a83:	6a 00                	push   $0x0
f0103a85:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f0103a88:	50                   	push   %eax
f0103a89:	ff 75 f0             	pushl  -0x10(%ebp)
f0103a8c:	e8 d7 80 00 00       	call   f010bb68 <envid2env>
f0103a91:	83 c4 10             	add    $0x10,%esp
	if(env == 0) return 0;
f0103a94:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103a97:	85 c0                	test   %eax,%eax
f0103a99:	75 0a                	jne    f0103aa5 <command_allocuserpage+0x73>
f0103a9b:	b8 00 00 00 00       	mov    $0x0,%eax
f0103aa0:	e9 ff 00 00 00       	jmp    f0103ba4 <command_allocuserpage+0x172>

	uint32 va = strtol(arguments[2], NULL, 16);
f0103aa5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103aa8:	83 c0 08             	add    $0x8,%eax
f0103aab:	8b 00                	mov    (%eax),%eax
f0103aad:	83 ec 04             	sub    $0x4,%esp
f0103ab0:	6a 10                	push   $0x10
f0103ab2:	6a 00                	push   $0x0
f0103ab4:	50                   	push   %eax
f0103ab5:	e8 d0 74 01 00       	call   f011af8a <strtol>
f0103aba:	83 c4 10             	add    $0x10,%esp
f0103abd:	89 45 ec             	mov    %eax,-0x14(%ebp)

	// Allocate a single frame from the free frame list
	struct FrameInfo * ptr_FrameInfo ;
	int ret = allocate_frame(&ptr_FrameInfo);
f0103ac0:	83 ec 0c             	sub    $0xc,%esp
f0103ac3:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0103ac6:	50                   	push   %eax
f0103ac7:	e8 76 56 00 00       	call   f0109142 <allocate_frame>
f0103acc:	83 c4 10             	add    $0x10,%esp
f0103acf:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret == E_NO_MEM)
f0103ad2:	83 7d e8 fc          	cmpl   $0xfffffffc,-0x18(%ebp)
f0103ad6:	75 1a                	jne    f0103af2 <command_allocuserpage+0xc0>
	{
		cprintf("ERROR: no enough memory\n");
f0103ad8:	83 ec 0c             	sub    $0xc,%esp
f0103adb:	68 06 d3 12 f0       	push   $0xf012d306
f0103ae0:	e8 77 e1 ff ff       	call   f0101c5c <cprintf>
f0103ae5:	83 c4 10             	add    $0x10,%esp
		return 0;
f0103ae8:	b8 00 00 00 00       	mov    $0x0,%eax
f0103aed:	e9 b2 00 00 00       	jmp    f0103ba4 <command_allocuserpage+0x172>
	}

	if (number_of_arguments == 3)
f0103af2:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0103af6:	75 1d                	jne    f0103b15 <command_allocuserpage+0xe3>
	{
		// Map this frame to the given user virtual address with PERM_WRITEABLE
		map_frame(env->env_page_directory, ptr_FrameInfo, va, PERM_WRITEABLE | PERM_USER);
f0103af8:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103afb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103afe:	8b 40 64             	mov    0x64(%eax),%eax
f0103b01:	6a 06                	push   $0x6
f0103b03:	ff 75 ec             	pushl  -0x14(%ebp)
f0103b06:	52                   	push   %edx
f0103b07:	50                   	push   %eax
f0103b08:	e8 d6 5a 00 00       	call   f01095e3 <map_frame>
f0103b0d:	83 c4 10             	add    $0x10,%esp
f0103b10:	e9 8a 00 00 00       	jmp    f0103b9f <command_allocuserpage+0x16d>
	}
	else if (number_of_arguments == 4)
f0103b15:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0103b19:	0f 85 80 00 00 00    	jne    f0103b9f <command_allocuserpage+0x16d>
	{
		// Map this frame to the given user virtual address with the given permission
		uint32 rw ;
		if (arguments[3][0] == 'r' || arguments[3][0] == 'R')
f0103b1f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b22:	83 c0 0c             	add    $0xc,%eax
f0103b25:	8b 00                	mov    (%eax),%eax
f0103b27:	8a 00                	mov    (%eax),%al
f0103b29:	3c 72                	cmp    $0x72,%al
f0103b2b:	74 0e                	je     f0103b3b <command_allocuserpage+0x109>
f0103b2d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b30:	83 c0 0c             	add    $0xc,%eax
f0103b33:	8b 00                	mov    (%eax),%eax
f0103b35:	8a 00                	mov    (%eax),%al
f0103b37:	3c 52                	cmp    $0x52,%al
f0103b39:	75 09                	jne    f0103b44 <command_allocuserpage+0x112>
			rw = 0 ;
f0103b3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0103b42:	eb 3c                	jmp    f0103b80 <command_allocuserpage+0x14e>
		else if (arguments[3][0] == 'w' || arguments[3][0] == 'W')
f0103b44:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b47:	83 c0 0c             	add    $0xc,%eax
f0103b4a:	8b 00                	mov    (%eax),%eax
f0103b4c:	8a 00                	mov    (%eax),%al
f0103b4e:	3c 77                	cmp    $0x77,%al
f0103b50:	74 0e                	je     f0103b60 <command_allocuserpage+0x12e>
f0103b52:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103b55:	83 c0 0c             	add    $0xc,%eax
f0103b58:	8b 00                	mov    (%eax),%eax
f0103b5a:	8a 00                	mov    (%eax),%al
f0103b5c:	3c 57                	cmp    $0x57,%al
f0103b5e:	75 09                	jne    f0103b69 <command_allocuserpage+0x137>
			rw = PERM_WRITEABLE ;
f0103b60:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0103b67:	eb 17                	jmp    f0103b80 <command_allocuserpage+0x14e>
		else
		{
			cprintf("aup command: wrong permission (r/w)... will continue as writable\n") ;
f0103b69:	83 ec 0c             	sub    $0xc,%esp
f0103b6c:	68 20 d3 12 f0       	push   $0xf012d320
f0103b71:	e8 e6 e0 ff ff       	call   f0101c5c <cprintf>
f0103b76:	83 c4 10             	add    $0x10,%esp
			rw = PERM_WRITEABLE ;
f0103b79:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
		}

		map_frame(env->env_page_directory, ptr_FrameInfo, va, rw | PERM_USER);
f0103b80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103b83:	83 c8 04             	or     $0x4,%eax
f0103b86:	89 c1                	mov    %eax,%ecx
f0103b88:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0103b8b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0103b8e:	8b 40 64             	mov    0x64(%eax),%eax
f0103b91:	51                   	push   %ecx
f0103b92:	ff 75 ec             	pushl  -0x14(%ebp)
f0103b95:	52                   	push   %edx
f0103b96:	50                   	push   %eax
f0103b97:	e8 47 5a 00 00       	call   f01095e3 <map_frame>
f0103b9c:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0103b9f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ba4:	c9                   	leave  
f0103ba5:	c3                   	ret    

f0103ba6 <command_meminfo>:
//*****************************************************************************************//
//***************************** PROJECT HELPERS COMMAND ***********************************//
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
f0103ba6:	55                   	push   %ebp
f0103ba7:	89 e5                	mov    %esp,%ebp
f0103ba9:	56                   	push   %esi
f0103baa:	53                   	push   %ebx
f0103bab:	83 ec 10             	sub    $0x10,%esp
	struct freeFramesCounters counters =calculate_available_frames();
f0103bae:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0103bb1:	83 ec 0c             	sub    $0xc,%esp
f0103bb4:	50                   	push   %eax
f0103bb5:	e8 17 5d 00 00       	call   f01098d1 <calculate_available_frames>
f0103bba:	83 c4 0c             	add    $0xc,%esp
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103bbd:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0103bc0:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0103bc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);
f0103bc6:	8b 75 ec             	mov    -0x14(%ebp),%esi
f0103bc9:	8b 5d f0             	mov    -0x10(%ebp),%ebx
f0103bcc:	01 de                	add    %ebx,%esi
f0103bce:	8b 5d f4             	mov    -0xc(%ebp),%ebx
//*****************************************************************************************//

int command_meminfo(int number_of_arguments, char **arguments)
{
	struct freeFramesCounters counters =calculate_available_frames();
	cprintf("Total available frames = %d\nFree Buffered = %d\nFree Not Buffered = %d\nModified = %d\n",
f0103bd1:	01 f3                	add    %esi,%ebx
f0103bd3:	83 ec 0c             	sub    $0xc,%esp
f0103bd6:	51                   	push   %ecx
f0103bd7:	52                   	push   %edx
f0103bd8:	50                   	push   %eax
f0103bd9:	53                   	push   %ebx
f0103bda:	68 64 d3 12 f0       	push   $0xf012d364
f0103bdf:	e8 78 e0 ff ff       	call   f0101c5c <cprintf>
f0103be4:	83 c4 20             	add    $0x20,%esp
			counters.freeBuffered+ counters.freeNotBuffered+ counters.modified, counters.freeBuffered, counters.freeNotBuffered, counters.modified);

	cprintf("Num of calls for kheap_virtual_address [in last run] = %d\n", numOfKheapVACalls);
f0103be7:	a1 30 6c 85 f0       	mov    0xf0856c30,%eax
f0103bec:	83 ec 08             	sub    $0x8,%esp
f0103bef:	50                   	push   %eax
f0103bf0:	68 bc d3 12 f0       	push   $0xf012d3bc
f0103bf5:	e8 62 e0 ff ff       	call   f0101c5c <cprintf>
f0103bfa:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103bfd:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103c02:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0103c05:	5b                   	pop    %ebx
f0103c06:	5e                   	pop    %esi
f0103c07:	5d                   	pop    %ebp
f0103c08:	c3                   	ret    

f0103c09 <CreateEnv>:

//2020
struct Env * CreateEnv(int number_of_arguments, char **arguments)
{
f0103c09:	55                   	push   %ebp
f0103c0a:	89 e5                	mov    %esp,%ebp
f0103c0c:	83 ec 28             	sub    $0x28,%esp
	struct Env* env;
	uint32 pageWSSize = __PWS_MAX_SIZE;		//arg#3 default
f0103c0f:	c7 45 f4 88 13 00 00 	movl   $0x1388,-0xc(%ebp)
	uint32 LRUSecondListSize = 0;			//arg#4 default
f0103c16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 percent_WS_pages_to_remove = 0;	//arg#5 default
f0103c1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int BSDSchedNiceVal = -100;				//arg#5 default
f0103c24:	c7 45 ec 9c ff ff ff 	movl   $0xffffff9c,-0x14(%ebp)
	int PRIRRSchedPriority = 0;				//arg#5 default
f0103c2b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

#if USE_KHEAP
	{
		switch (number_of_arguments)
f0103c32:	8b 45 08             	mov    0x8(%ebp),%eax
f0103c35:	83 f8 04             	cmp    $0x4,%eax
f0103c38:	0f 84 c3 00 00 00    	je     f0103d01 <CreateEnv+0xf8>
f0103c3e:	83 f8 05             	cmp    $0x5,%eax
f0103c41:	74 0e                	je     f0103c51 <CreateEnv+0x48>
f0103c43:	83 f8 03             	cmp    $0x3,%eax
f0103c46:	0f 84 4a 01 00 00    	je     f0103d96 <CreateEnv+0x18d>
f0103c4c:	e9 8d 01 00 00       	jmp    f0103dde <CreateEnv+0x1d5>
		{
		case 5:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103c51:	83 ec 0c             	sub    $0xc,%esp
f0103c54:	6a 02                	push   $0x2
f0103c56:	e8 c8 bc 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f0103c5b:	83 c4 10             	add    $0x10,%esp
f0103c5e:	85 c0                	test   %eax,%eax
f0103c60:	75 1a                	jne    f0103c7c <CreateEnv+0x73>
			{
				cprintf("ERROR: Current Replacement is NOT LRU LISTS, invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<BSD_Sched_Nice>]\naborting...\n");
f0103c62:	83 ec 0c             	sub    $0xc,%esp
f0103c65:	68 f8 d3 12 f0       	push   $0xf012d3f8
f0103c6a:	e8 ed df ff ff       	call   f0101c5c <cprintf>
f0103c6f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103c72:	b8 00 00 00 00       	mov    $0x0,%eax
f0103c77:	e9 7b 02 00 00       	jmp    f0103ef7 <CreateEnv+0x2ee>
			}
			//percent_WS_pages_to_remove = strtol(arguments[4], NULL, 10);
			if (isSchedMethodBSD())
f0103c7c:	e8 3c 3b 00 00       	call   f01077bd <isSchedMethodBSD>
f0103c81:	85 c0                	test   %eax,%eax
f0103c83:	74 1d                	je     f0103ca2 <CreateEnv+0x99>
				BSDSchedNiceVal = strtol(arguments[4], NULL, 10);
f0103c85:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103c88:	83 c0 10             	add    $0x10,%eax
f0103c8b:	8b 00                	mov    (%eax),%eax
f0103c8d:	83 ec 04             	sub    $0x4,%esp
f0103c90:	6a 0a                	push   $0xa
f0103c92:	6a 00                	push   $0x0
f0103c94:	50                   	push   %eax
f0103c95:	e8 f0 72 01 00       	call   f011af8a <strtol>
f0103c9a:	83 c4 10             	add    $0x10,%esp
f0103c9d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103ca0:	eb 24                	jmp    f0103cc6 <CreateEnv+0xbd>
			else if (isSchedMethodPRIRR())
f0103ca2:	e8 29 3b 00 00       	call   f01077d0 <isSchedMethodPRIRR>
f0103ca7:	85 c0                	test   %eax,%eax
f0103ca9:	74 1b                	je     f0103cc6 <CreateEnv+0xbd>
				PRIRRSchedPriority = strtol(arguments[4], NULL, 10);
f0103cab:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cae:	83 c0 10             	add    $0x10,%eax
f0103cb1:	8b 00                	mov    (%eax),%eax
f0103cb3:	83 ec 04             	sub    $0x4,%esp
f0103cb6:	6a 0a                	push   $0xa
f0103cb8:	6a 00                	push   $0x0
f0103cba:	50                   	push   %eax
f0103cbb:	e8 ca 72 01 00       	call   f011af8a <strtol>
f0103cc0:	83 c4 10             	add    $0x10,%esp
f0103cc3:	89 45 e8             	mov    %eax,-0x18(%ebp)

			LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103cc9:	83 c0 0c             	add    $0xc,%eax
f0103ccc:	8b 00                	mov    (%eax),%eax
f0103cce:	83 ec 04             	sub    $0x4,%esp
f0103cd1:	6a 0a                	push   $0xa
f0103cd3:	6a 00                	push   $0x0
f0103cd5:	50                   	push   %eax
f0103cd6:	e8 af 72 01 00       	call   f011af8a <strtol>
f0103cdb:	83 c4 10             	add    $0x10,%esp
f0103cde:	89 45 f0             	mov    %eax,-0x10(%ebp)
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103ce4:	83 c0 08             	add    $0x8,%eax
f0103ce7:	8b 00                	mov    (%eax),%eax
f0103ce9:	83 ec 04             	sub    $0x4,%esp
f0103cec:	6a 0a                	push   $0xa
f0103cee:	6a 00                	push   $0x0
f0103cf0:	50                   	push   %eax
f0103cf1:	e8 94 72 01 00       	call   f011af8a <strtol>
f0103cf6:	83 c4 10             	add    $0x10,%esp
f0103cf9:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103cfc:	e9 f7 00 00 00       	jmp    f0103df8 <CreateEnv+0x1ef>
		case 4:
			if(!isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103d01:	83 ec 0c             	sub    $0xc,%esp
f0103d04:	6a 02                	push   $0x2
f0103d06:	e8 18 bc 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f0103d0b:	83 c4 10             	add    $0x10,%esp
f0103d0e:	85 c0                	test   %eax,%eax
f0103d10:	75 4c                	jne    f0103d5e <CreateEnv+0x155>
			{
				//percent_WS_pages_to_remove = strtol(arguments[3], NULL, 10);
				if (isSchedMethodBSD())
f0103d12:	e8 a6 3a 00 00       	call   f01077bd <isSchedMethodBSD>
f0103d17:	85 c0                	test   %eax,%eax
f0103d19:	74 1d                	je     f0103d38 <CreateEnv+0x12f>
					BSDSchedNiceVal = strtol(arguments[3], NULL, 10);
f0103d1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d1e:	83 c0 0c             	add    $0xc,%eax
f0103d21:	8b 00                	mov    (%eax),%eax
f0103d23:	83 ec 04             	sub    $0x4,%esp
f0103d26:	6a 0a                	push   $0xa
f0103d28:	6a 00                	push   $0x0
f0103d2a:	50                   	push   %eax
f0103d2b:	e8 5a 72 01 00       	call   f011af8a <strtol>
f0103d30:	83 c4 10             	add    $0x10,%esp
f0103d33:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0103d36:	eb 41                	jmp    f0103d79 <CreateEnv+0x170>
				else if (isSchedMethodPRIRR())
f0103d38:	e8 93 3a 00 00       	call   f01077d0 <isSchedMethodPRIRR>
f0103d3d:	85 c0                	test   %eax,%eax
f0103d3f:	74 38                	je     f0103d79 <CreateEnv+0x170>
					PRIRRSchedPriority = strtol(arguments[3], NULL, 10);			}
f0103d41:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d44:	83 c0 0c             	add    $0xc,%eax
f0103d47:	8b 00                	mov    (%eax),%eax
f0103d49:	83 ec 04             	sub    $0x4,%esp
f0103d4c:	6a 0a                	push   $0xa
f0103d4e:	6a 00                	push   $0x0
f0103d50:	50                   	push   %eax
f0103d51:	e8 34 72 01 00       	call   f011af8a <strtol>
f0103d56:	83 c4 10             	add    $0x10,%esp
f0103d59:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0103d5c:	eb 1b                	jmp    f0103d79 <CreateEnv+0x170>
			else
			{
				LRUSecondListSize = strtol(arguments[3], NULL, 10);
f0103d5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d61:	83 c0 0c             	add    $0xc,%eax
f0103d64:	8b 00                	mov    (%eax),%eax
f0103d66:	83 ec 04             	sub    $0x4,%esp
f0103d69:	6a 0a                	push   $0xa
f0103d6b:	6a 00                	push   $0x0
f0103d6d:	50                   	push   %eax
f0103d6e:	e8 17 72 01 00       	call   f011af8a <strtol>
f0103d73:	83 c4 10             	add    $0x10,%esp
f0103d76:	89 45 f0             	mov    %eax,-0x10(%ebp)
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103d79:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103d7c:	83 c0 08             	add    $0x8,%eax
f0103d7f:	8b 00                	mov    (%eax),%eax
f0103d81:	83 ec 04             	sub    $0x4,%esp
f0103d84:	6a 0a                	push   $0xa
f0103d86:	6a 00                	push   $0x0
f0103d88:	50                   	push   %eax
f0103d89:	e8 fc 71 01 00       	call   f011af8a <strtol>
f0103d8e:	83 c4 10             	add    $0x10,%esp
f0103d91:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103d94:	eb 62                	jmp    f0103df8 <CreateEnv+0x1ef>
		case 3:
			if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103d96:	83 ec 0c             	sub    $0xc,%esp
f0103d99:	6a 02                	push   $0x2
f0103d9b:	e8 83 bb 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f0103da0:	83 c4 10             	add    $0x10,%esp
f0103da3:	85 c0                	test   %eax,%eax
f0103da5:	74 1a                	je     f0103dc1 <CreateEnv+0x1b8>
			{
				cprintf("ERROR: Current Replacement is LRU LISTS, Please specify a working set size in the 3rd arg and LRU second list size in the 4th arg, aborting.\n");
f0103da7:	83 ec 0c             	sub    $0xc,%esp
f0103daa:	68 a4 d4 12 f0       	push   $0xf012d4a4
f0103daf:	e8 a8 de ff ff       	call   f0101c5c <cprintf>
f0103db4:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103db7:	b8 00 00 00 00       	mov    $0x0,%eax
f0103dbc:	e9 36 01 00 00       	jmp    f0103ef7 <CreateEnv+0x2ee>
			}
			pageWSSize = strtol(arguments[2], NULL, 10);
f0103dc1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103dc4:	83 c0 08             	add    $0x8,%eax
f0103dc7:	8b 00                	mov    (%eax),%eax
f0103dc9:	83 ec 04             	sub    $0x4,%esp
f0103dcc:	6a 0a                	push   $0xa
f0103dce:	6a 00                	push   $0x0
f0103dd0:	50                   	push   %eax
f0103dd1:	e8 b4 71 01 00       	call   f011af8a <strtol>
f0103dd6:	83 c4 10             	add    $0x10,%esp
f0103dd9:	89 45 f4             	mov    %eax,-0xc(%ebp)
			break;
f0103ddc:	eb 1a                	jmp    f0103df8 <CreateEnv+0x1ef>
		default:
			cprintf("ERROR: invalid number of args\nUsage: <command> <prog_name> <page_WS_size> [<LRU_second_list_size>] [<DYN_LOC_SCOPE_percent_WS_to_remove>]\naborting...\n");
f0103dde:	83 ec 0c             	sub    $0xc,%esp
f0103de1:	68 34 d5 12 f0       	push   $0xf012d534
f0103de6:	e8 71 de ff ff       	call   f0101c5c <cprintf>
f0103deb:	83 c4 10             	add    $0x10,%esp
			return NULL;
f0103dee:	b8 00 00 00 00       	mov    $0x0,%eax
f0103df3:	e9 ff 00 00 00       	jmp    f0103ef7 <CreateEnv+0x2ee>
		{
			cprintf("ERROR: size of WS must be less than or equal to %d... aborting", __PWS_MAX_SIZE);
			return NULL;
		}
#endif
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f0103df8:	83 ec 0c             	sub    $0xc,%esp
f0103dfb:	6a 02                	push   $0x2
f0103dfd:	e8 21 bb 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f0103e02:	83 c4 10             	add    $0x10,%esp
f0103e05:	85 c0                	test   %eax,%eax
f0103e07:	74 23                	je     f0103e2c <CreateEnv+0x223>
		{
			if (LRUSecondListSize > pageWSSize - 1)
f0103e09:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103e0c:	48                   	dec    %eax
f0103e0d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0103e10:	73 1a                	jae    f0103e2c <CreateEnv+0x223>
			{
				cprintf("ERROR: size of LRU second list can't equal/exceed the size of the page WS... aborting\n");
f0103e12:	83 ec 0c             	sub    $0xc,%esp
f0103e15:	68 cc d5 12 f0       	push   $0xf012d5cc
f0103e1a:	e8 3d de ff ff       	call   f0101c5c <cprintf>
f0103e1f:	83 c4 10             	add    $0x10,%esp
				return NULL;
f0103e22:	b8 00 00 00 00       	mov    $0x0,%eax
f0103e27:	e9 cb 00 00 00       	jmp    f0103ef7 <CreateEnv+0x2ee>
			}
		}
		assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103e2c:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103e30:	76 19                	jbe    f0103e4b <CreateEnv+0x242>
f0103e32:	68 24 d6 12 f0       	push   $0xf012d624
f0103e37:	68 69 d6 12 f0       	push   $0xf012d669
f0103e3c:	68 a5 02 00 00       	push   $0x2a5
f0103e41:	68 65 d1 12 f0       	push   $0xf012d165
f0103e46:	e8 64 d1 ff ff       	call   f0100faf <_panic>
		{
			LRUSecondListSize = __LRU_SNDLST_SIZE;
		}
	}
#endif
	assert(percent_WS_pages_to_remove >= 0 && percent_WS_pages_to_remove <= 100);
f0103e4b:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0103e4f:	76 19                	jbe    f0103e6a <CreateEnv+0x261>
f0103e51:	68 24 d6 12 f0       	push   $0xf012d624
f0103e56:	68 69 d6 12 f0       	push   $0xf012d669
f0103e5b:	68 c3 02 00 00       	push   $0x2c3
f0103e60:	68 65 d1 12 f0       	push   $0xf012d165
f0103e65:	e8 45 d1 ff ff       	call   f0100faf <_panic>
	env = env_create(arguments[1], pageWSSize, LRUSecondListSize, percent_WS_pages_to_remove);
f0103e6a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103e6d:	83 c0 04             	add    $0x4,%eax
f0103e70:	8b 00                	mov    (%eax),%eax
f0103e72:	ff 75 e4             	pushl  -0x1c(%ebp)
f0103e75:	ff 75 f0             	pushl  -0x10(%ebp)
f0103e78:	ff 75 f4             	pushl  -0xc(%ebp)
f0103e7b:	50                   	push   %eax
f0103e7c:	e8 e0 70 00 00       	call   f010af61 <env_create>
f0103e81:	83 c4 10             	add    $0x10,%esp
f0103e84:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (BSDSchedNiceVal != -100)
f0103e87:	83 7d ec 9c          	cmpl   $0xffffff9c,-0x14(%ebp)
f0103e8b:	74 49                	je     f0103ed6 <CreateEnv+0x2cd>
	{
		cprintf("nice value = %d\n", BSDSchedNiceVal);
f0103e8d:	83 ec 08             	sub    $0x8,%esp
f0103e90:	ff 75 ec             	pushl  -0x14(%ebp)
f0103e93:	68 7e d6 12 f0       	push   $0xf012d67e
f0103e98:	e8 bf dd ff ff       	call   f0101c5c <cprintf>
f0103e9d:	83 c4 10             	add    $0x10,%esp
		assert(BSDSchedNiceVal >= -20 && BSDSchedNiceVal <= 20);
f0103ea0:	83 7d ec ec          	cmpl   $0xffffffec,-0x14(%ebp)
f0103ea4:	7c 06                	jl     f0103eac <CreateEnv+0x2a3>
f0103ea6:	83 7d ec 14          	cmpl   $0x14,-0x14(%ebp)
f0103eaa:	7e 19                	jle    f0103ec5 <CreateEnv+0x2bc>
f0103eac:	68 90 d6 12 f0       	push   $0xf012d690
f0103eb1:	68 69 d6 12 f0       	push   $0xf012d669
f0103eb6:	68 c8 02 00 00       	push   $0x2c8
f0103ebb:	68 65 d1 12 f0       	push   $0xf012d165
f0103ec0:	e8 ea d0 ff ff       	call   f0100faf <_panic>
		env_set_nice(env, BSDSchedNiceVal);
f0103ec5:	83 ec 08             	sub    $0x8,%esp
f0103ec8:	ff 75 ec             	pushl  -0x14(%ebp)
f0103ecb:	ff 75 e0             	pushl  -0x20(%ebp)
f0103ece:	e8 34 38 00 00       	call   f0107707 <env_set_nice>
f0103ed3:	83 c4 10             	add    $0x10,%esp
	}
	if (isSchedMethodPRIRR())
f0103ed6:	e8 f5 38 00 00       	call   f01077d0 <isSchedMethodPRIRR>
f0103edb:	85 c0                	test   %eax,%eax
f0103edd:	74 15                	je     f0103ef4 <CreateEnv+0x2eb>
		env_set_priority(env->env_id, PRIRRSchedPriority);
f0103edf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0103ee2:	8b 40 10             	mov    0x10(%eax),%eax
f0103ee5:	83 ec 08             	sub    $0x8,%esp
f0103ee8:	ff 75 e8             	pushl  -0x18(%ebp)
f0103eeb:	50                   	push   %eax
f0103eec:	e8 6d 38 00 00       	call   f010775e <env_set_priority>
f0103ef1:	83 c4 10             	add    $0x10,%esp

	return env;
f0103ef4:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f0103ef7:	c9                   	leave  
f0103ef8:	c3                   	ret    

f0103ef9 <command_run_program>:

int command_run_program(int number_of_arguments, char **arguments)
{
f0103ef9:	55                   	push   %ebp
f0103efa:	89 e5                	mov    %esp,%ebp
f0103efc:	83 ec 18             	sub    $0x18,%esp
	//[1] Create and initialize a new environment for the program to be run
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103eff:	83 ec 08             	sub    $0x8,%esp
f0103f02:	ff 75 0c             	pushl  0xc(%ebp)
f0103f05:	ff 75 08             	pushl  0x8(%ebp)
f0103f08:	e8 fc fc ff ff       	call   f0103c09 <CreateEnv>
f0103f0d:	83 c4 10             	add    $0x10,%esp
f0103f10:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(env == NULL) return 0;
f0103f13:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103f17:	75 07                	jne    f0103f20 <command_run_program+0x27>
f0103f19:	b8 00 00 00 00       	mov    $0x0,%eax
f0103f1e:	eb 46                	jmp    f0103f66 <command_run_program+0x6d>
	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103f20:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103f23:	8b 40 10             	mov    0x10(%eax),%eax
f0103f26:	83 ec 08             	sub    $0x8,%esp
f0103f29:	50                   	push   %eax
f0103f2a:	68 c0 d6 12 f0       	push   $0xf012d6c0
f0103f2f:	e8 28 dd ff ff       	call   f0101c5c <cprintf>
f0103f34:	83 c4 10             	add    $0x10,%esp

	//[2] Place it in the NEW queue
	sched_new_env(env);
f0103f37:	83 ec 0c             	sub    $0xc,%esp
f0103f3a:	ff 75 f4             	pushl  -0xc(%ebp)
f0103f3d:	e8 47 28 00 00       	call   f0106789 <sched_new_env>
f0103f42:	83 c4 10             	add    $0x10,%esp

	numOfKheapVACalls = 0;
f0103f45:	c7 05 30 6c 85 f0 00 	movl   $0x0,0xf0856c30
f0103f4c:	00 00 00 

	//[3] Run the created environment by adding it to the "ready" queue then invoke the scheduler to execute it
	sched_run_env(env->env_id);
f0103f4f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103f52:	8b 40 10             	mov    0x10(%eax),%eax
f0103f55:	83 ec 0c             	sub    $0xc,%esp
f0103f58:	50                   	push   %eax
f0103f59:	e8 81 28 00 00       	call   f01067df <sched_run_env>
f0103f5e:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103f61:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f66:	c9                   	leave  
f0103f67:	c3                   	ret    

f0103f68 <command_kill_program>:

int command_kill_program(int number_of_arguments, char **arguments)
{
f0103f68:	55                   	push   %ebp
f0103f69:	89 e5                	mov    %esp,%ebp
f0103f6b:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0103f6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0103f71:	83 c0 04             	add    $0x4,%eax
f0103f74:	8b 00                	mov    (%eax),%eax
f0103f76:	83 ec 04             	sub    $0x4,%esp
f0103f79:	6a 0a                	push   $0xa
f0103f7b:	6a 00                	push   $0x0
f0103f7d:	50                   	push   %eax
f0103f7e:	e8 07 70 01 00       	call   f011af8a <strtol>
f0103f83:	83 c4 10             	add    $0x10,%esp
f0103f86:	89 45 f4             	mov    %eax,-0xc(%ebp)

	sched_kill_env(envId);
f0103f89:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103f8c:	83 ec 0c             	sub    $0xc,%esp
f0103f8f:	50                   	push   %eax
f0103f90:	e8 90 2b 00 00       	call   f0106b25 <sched_kill_env>
f0103f95:	83 c4 10             	add    $0x10,%esp

	return 0;
f0103f98:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103f9d:	c9                   	leave  
f0103f9e:	c3                   	ret    

f0103f9f <commnad_load_env>:

int commnad_load_env(int number_of_arguments, char **arguments)
{
f0103f9f:	55                   	push   %ebp
f0103fa0:	89 e5                	mov    %esp,%ebp
f0103fa2:	83 ec 18             	sub    $0x18,%esp
	struct Env *env = CreateEnv(number_of_arguments, arguments);
f0103fa5:	83 ec 08             	sub    $0x8,%esp
f0103fa8:	ff 75 0c             	pushl  0xc(%ebp)
f0103fab:	ff 75 08             	pushl  0x8(%ebp)
f0103fae:	e8 56 fc ff ff       	call   f0103c09 <CreateEnv>
f0103fb3:	83 c4 10             	add    $0x10,%esp
f0103fb6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (env == NULL)
f0103fb9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0103fbd:	75 07                	jne    f0103fc6 <commnad_load_env+0x27>
		return 0 ;
f0103fbf:	b8 00 00 00 00       	mov    $0x0,%eax
f0103fc4:	eb 2a                	jmp    f0103ff0 <commnad_load_env+0x51>

	sched_new_env(env) ;
f0103fc6:	83 ec 0c             	sub    $0xc,%esp
f0103fc9:	ff 75 f4             	pushl  -0xc(%ebp)
f0103fcc:	e8 b8 27 00 00       	call   f0106789 <sched_new_env>
f0103fd1:	83 c4 10             	add    $0x10,%esp

	cprintf("\nEnvironment Id= %d\n",env->env_id);
f0103fd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0103fd7:	8b 40 10             	mov    0x10(%eax),%eax
f0103fda:	83 ec 08             	sub    $0x8,%esp
f0103fdd:	50                   	push   %eax
f0103fde:	68 c0 d6 12 f0       	push   $0xf012d6c0
f0103fe3:	e8 74 dc ff ff       	call   f0101c5c <cprintf>
f0103fe8:	83 c4 10             	add    $0x10,%esp
	return 0;
f0103feb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0103ff0:	c9                   	leave  
f0103ff1:	c3                   	ret    

f0103ff2 <command_run_all>:

int command_run_all(int number_of_arguments, char **arguments)
{
f0103ff2:	55                   	push   %ebp
f0103ff3:	89 e5                	mov    %esp,%ebp
f0103ff5:	83 ec 08             	sub    $0x8,%esp
	numOfKheapVACalls = 0;
f0103ff8:	c7 05 30 6c 85 f0 00 	movl   $0x0,0xf0856c30
f0103fff:	00 00 00 
	sched_run_all();
f0104002:	e8 ef 30 00 00       	call   f01070f6 <sched_run_all>

	return 0 ;
f0104007:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010400c:	c9                   	leave  
f010400d:	c3                   	ret    

f010400e <command_print_all>:

int command_print_all(int number_of_arguments, char **arguments)
{
f010400e:	55                   	push   %ebp
f010400f:	89 e5                	mov    %esp,%ebp
f0104011:	83 ec 08             	sub    $0x8,%esp
	sched_print_all();
f0104014:	e8 bc 2e 00 00       	call   f0106ed5 <sched_print_all>

	return 0 ;
f0104019:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010401e:	c9                   	leave  
f010401f:	c3                   	ret    

f0104020 <command_kill_all>:

int command_kill_all(int number_of_arguments, char **arguments)
{
f0104020:	55                   	push   %ebp
f0104021:	89 e5                	mov    %esp,%ebp
f0104023:	83 ec 08             	sub    $0x8,%esp
	sched_kill_all();
f0104026:	e8 60 31 00 00       	call   f010718b <sched_kill_all>

	return 0 ;
f010402b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104030:	c9                   	leave  
f0104031:	c3                   	ret    

f0104032 <command_set_page_rep_LRU>:

int command_set_page_rep_LRU(int number_of_arguments, char **arguments)
{
f0104032:	55                   	push   %ebp
f0104033:	89 e5                	mov    %esp,%ebp
f0104035:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments < 2)
f0104038:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010403c:	7f 1a                	jg     f0104058 <command_set_page_rep_LRU+0x26>
	{
		cprintf("ERROR: please specify the LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f010403e:	83 ec 0c             	sub    $0xc,%esp
f0104041:	68 d8 d6 12 f0       	push   $0xf012d6d8
f0104046:	e8 11 dc ff ff       	call   f0101c5c <cprintf>
f010404b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010404e:	b8 00 00 00 00       	mov    $0x0,%eax
f0104053:	e9 83 00 00 00       	jmp    f01040db <command_set_page_rep_LRU+0xa9>
	}
	int LRU_TYPE = strtol(arguments[1], NULL, 10) ;
f0104058:	8b 45 0c             	mov    0xc(%ebp),%eax
f010405b:	83 c0 04             	add    $0x4,%eax
f010405e:	8b 00                	mov    (%eax),%eax
f0104060:	83 ec 04             	sub    $0x4,%esp
f0104063:	6a 0a                	push   $0xa
f0104065:	6a 00                	push   $0x0
f0104067:	50                   	push   %eax
f0104068:	e8 1d 6f 01 00       	call   f011af8a <strtol>
f010406d:	83 c4 10             	add    $0x10,%esp
f0104070:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (LRU_TYPE == PG_REP_LRU_TIME_APPROX)
f0104073:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f0104077:	75 20                	jne    f0104099 <command_set_page_rep_LRU+0x67>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f0104079:	83 ec 0c             	sub    $0xc,%esp
f010407c:	ff 75 f4             	pushl  -0xc(%ebp)
f010407f:	e8 f6 b7 00 00       	call   f010f87a <setPageReplacmentAlgorithmLRU>
f0104084:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with TimeStamp approximation\n");
f0104087:	83 ec 0c             	sub    $0xc,%esp
f010408a:	68 38 d7 12 f0       	push   $0xf012d738
f010408f:	e8 c8 db ff ff       	call   f0101c5c <cprintf>
f0104094:	83 c4 10             	add    $0x10,%esp
f0104097:	eb 3d                	jmp    f01040d6 <command_set_page_rep_LRU+0xa4>
	}
	else if (LRU_TYPE == PG_REP_LRU_LISTS_APPROX)
f0104099:	83 7d f4 02          	cmpl   $0x2,-0xc(%ebp)
f010409d:	75 20                	jne    f01040bf <command_set_page_rep_LRU+0x8d>
	{
		setPageReplacmentAlgorithmLRU(LRU_TYPE);
f010409f:	83 ec 0c             	sub    $0xc,%esp
f01040a2:	ff 75 f4             	pushl  -0xc(%ebp)
f01040a5:	e8 d0 b7 00 00       	call   f010f87a <setPageReplacmentAlgorithmLRU>
f01040aa:	83 c4 10             	add    $0x10,%esp
		cprintf("Page replacement algorithm is now LRU with LISTS approximation\n");
f01040ad:	83 ec 0c             	sub    $0xc,%esp
f01040b0:	68 7c d7 12 f0       	push   $0xf012d77c
f01040b5:	e8 a2 db ff ff       	call   f0101c5c <cprintf>
f01040ba:	83 c4 10             	add    $0x10,%esp
f01040bd:	eb 17                	jmp    f01040d6 <command_set_page_rep_LRU+0xa4>
	}
	else
	{
		cprintf("ERROR: Invalid LRU Approx Type (1: TimeStamp Approx, 2: Lists Approx), aborting...\n");
f01040bf:	83 ec 0c             	sub    $0xc,%esp
f01040c2:	68 bc d7 12 f0       	push   $0xf012d7bc
f01040c7:	e8 90 db ff ff       	call   f0101c5c <cprintf>
f01040cc:	83 c4 10             	add    $0x10,%esp
		return 0;
f01040cf:	b8 00 00 00 00       	mov    $0x0,%eax
f01040d4:	eb 05                	jmp    f01040db <command_set_page_rep_LRU+0xa9>
	}
	return 0;
f01040d6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01040db:	c9                   	leave  
f01040dc:	c3                   	ret    

f01040dd <command_set_page_rep_nthCLOCK>:
//2021
int command_set_page_rep_nthCLOCK(int number_of_arguments, char **arguments)
{
f01040dd:	55                   	push   %ebp
f01040de:	89 e5                	mov    %esp,%ebp
f01040e0:	83 ec 18             	sub    $0x18,%esp
	uint32 PageWSMaxSweeps = strtol(arguments[1], NULL, 10);
f01040e3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01040e6:	83 c0 04             	add    $0x4,%eax
f01040e9:	8b 00                	mov    (%eax),%eax
f01040eb:	83 ec 04             	sub    $0x4,%esp
f01040ee:	6a 0a                	push   $0xa
f01040f0:	6a 00                	push   $0x0
f01040f2:	50                   	push   %eax
f01040f3:	e8 92 6e 01 00       	call   f011af8a <strtol>
f01040f8:	83 c4 10             	add    $0x10,%esp
f01040fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint8 type = strtol(arguments[2], NULL, 10);
f01040fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104101:	83 c0 08             	add    $0x8,%eax
f0104104:	8b 00                	mov    (%eax),%eax
f0104106:	83 ec 04             	sub    $0x4,%esp
f0104109:	6a 0a                	push   $0xa
f010410b:	6a 00                	push   $0x0
f010410d:	50                   	push   %eax
f010410e:	e8 77 6e 01 00       	call   f011af8a <strtol>
f0104113:	83 c4 10             	add    $0x10,%esp
f0104116:	88 45 f3             	mov    %al,-0xd(%ebp)
	if (PageWSMaxSweeps <= 0)
f0104119:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010411d:	75 17                	jne    f0104136 <command_set_page_rep_nthCLOCK+0x59>
	{
		cprintf("Invalid number of sweeps! it should be +ve.\n");
f010411f:	83 ec 0c             	sub    $0xc,%esp
f0104122:	68 10 d8 12 f0       	push   $0xf012d810
f0104127:	e8 30 db ff ff       	call   f0101c5c <cprintf>
f010412c:	83 c4 10             	add    $0x10,%esp
		return 0;
f010412f:	b8 00 00 00 00       	mov    $0x0,%eax
f0104134:	eb 4b                	jmp    f0104181 <command_set_page_rep_nthCLOCK+0xa4>
	}
	if (type == 1)		PageWSMaxSweeps = PageWSMaxSweeps * 1;
f0104136:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
f010413a:	74 22                	je     f010415e <command_set_page_rep_nthCLOCK+0x81>
	else if (type == 2)	PageWSMaxSweeps = PageWSMaxSweeps * -1;
f010413c:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
f0104140:	75 05                	jne    f0104147 <command_set_page_rep_nthCLOCK+0x6a>
f0104142:	f7 5d f4             	negl   -0xc(%ebp)
f0104145:	eb 17                	jmp    f010415e <command_set_page_rep_nthCLOCK+0x81>
	else
	{
		cprintf("Invalid type!\n	type=1: NORMAL Ver. type=2: MODIFIED Ver.\n");
f0104147:	83 ec 0c             	sub    $0xc,%esp
f010414a:	68 40 d8 12 f0       	push   $0xf012d840
f010414f:	e8 08 db ff ff       	call   f0101c5c <cprintf>
f0104154:	83 c4 10             	add    $0x10,%esp
		return 0;
f0104157:	b8 00 00 00 00       	mov    $0x0,%eax
f010415c:	eb 23                	jmp    f0104181 <command_set_page_rep_nthCLOCK+0xa4>
	}
	setPageReplacmentAlgorithmNchanceCLOCK(PageWSMaxSweeps);
f010415e:	83 ec 0c             	sub    $0xc,%esp
f0104161:	ff 75 f4             	pushl  -0xc(%ebp)
f0104164:	e8 84 b7 00 00       	call   f010f8ed <setPageReplacmentAlgorithmNchanceCLOCK>
f0104169:	83 c4 10             	add    $0x10,%esp
	cprintf("Page replacement algorithm is now N chance CLOCK\n");
f010416c:	83 ec 0c             	sub    $0xc,%esp
f010416f:	68 7c d8 12 f0       	push   $0xf012d87c
f0104174:	e8 e3 da ff ff       	call   f0101c5c <cprintf>
f0104179:	83 c4 10             	add    $0x10,%esp
	return 0;
f010417c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104181:	c9                   	leave  
f0104182:	c3                   	ret    

f0104183 <command_set_page_rep_CLOCK>:
int command_set_page_rep_CLOCK(int number_of_arguments, char **arguments)
{
f0104183:	55                   	push   %ebp
f0104184:	89 e5                	mov    %esp,%ebp
f0104186:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmCLOCK();
f0104189:	e8 1f b7 00 00       	call   f010f8ad <setPageReplacmentAlgorithmCLOCK>
	cprintf("Page replacement algorithm is now CLOCK\n");
f010418e:	83 ec 0c             	sub    $0xc,%esp
f0104191:	68 b0 d8 12 f0       	push   $0xf012d8b0
f0104196:	e8 c1 da ff ff       	call   f0101c5c <cprintf>
f010419b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010419e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01041a3:	c9                   	leave  
f01041a4:	c3                   	ret    

f01041a5 <command_set_page_rep_FIFO>:

int command_set_page_rep_FIFO(int number_of_arguments, char **arguments)
{
f01041a5:	55                   	push   %ebp
f01041a6:	89 e5                	mov    %esp,%ebp
f01041a8:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmFIFO();
f01041ab:	e8 0d b7 00 00       	call   f010f8bd <setPageReplacmentAlgorithmFIFO>
	cprintf("Page replacement algorithm is now FIFO\n");
f01041b0:	83 ec 0c             	sub    $0xc,%esp
f01041b3:	68 dc d8 12 f0       	push   $0xf012d8dc
f01041b8:	e8 9f da ff ff       	call   f0101c5c <cprintf>
f01041bd:	83 c4 10             	add    $0x10,%esp
	return 0;
f01041c0:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01041c5:	c9                   	leave  
f01041c6:	c3                   	ret    

f01041c7 <command_set_page_rep_ModifiedCLOCK>:

int command_set_page_rep_ModifiedCLOCK(int number_of_arguments, char **arguments)
{
f01041c7:	55                   	push   %ebp
f01041c8:	89 e5                	mov    %esp,%ebp
f01041ca:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmModifiedCLOCK();
f01041cd:	e8 fb b6 00 00       	call   f010f8cd <setPageReplacmentAlgorithmModifiedCLOCK>
	cprintf("Page replacement algorithm is now Modified CLOCK\n");
f01041d2:	83 ec 0c             	sub    $0xc,%esp
f01041d5:	68 04 d9 12 f0       	push   $0xf012d904
f01041da:	e8 7d da ff ff       	call   f0101c5c <cprintf>
f01041df:	83 c4 10             	add    $0x10,%esp
	return 0;
f01041e2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01041e7:	c9                   	leave  
f01041e8:	c3                   	ret    

f01041e9 <command_set_page_rep_OPTIMAL>:

int command_set_page_rep_OPTIMAL(int number_of_arguments, char **arguments)
{
f01041e9:	55                   	push   %ebp
f01041ea:	89 e5                	mov    %esp,%ebp
f01041ec:	83 ec 08             	sub    $0x8,%esp
	setPageReplacmentAlgorithmOPTIMAL();
f01041ef:	e8 1f b7 00 00       	call   f010f913 <setPageReplacmentAlgorithmOPTIMAL>
	cprintf("Page replacement algorithm is now OPTIMAL\n");
f01041f4:	83 ec 0c             	sub    $0xc,%esp
f01041f7:	68 38 d9 12 f0       	push   $0xf012d938
f01041fc:	e8 5b da ff ff       	call   f0101c5c <cprintf>
f0104201:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104204:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104209:	c9                   	leave  
f010420a:	c3                   	ret    

f010420b <command_sch_RR>:

/*2018*///BEGIN======================================================
int command_sch_RR(int number_of_arguments, char **arguments)
{
f010420b:	55                   	push   %ebp
f010420c:	89 e5                	mov    %esp,%ebp
f010420e:	83 ec 18             	sub    $0x18,%esp
	uint8 quantum = strtol(arguments[1], NULL, 10);
f0104211:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104214:	83 c0 04             	add    $0x4,%eax
f0104217:	8b 00                	mov    (%eax),%eax
f0104219:	83 ec 04             	sub    $0x4,%esp
f010421c:	6a 0a                	push   $0xa
f010421e:	6a 00                	push   $0x0
f0104220:	50                   	push   %eax
f0104221:	e8 64 6d 01 00       	call   f011af8a <strtol>
f0104226:	83 c4 10             	add    $0x10,%esp
f0104229:	88 45 f7             	mov    %al,-0x9(%ebp)

	sched_init_RR(quantum);
f010422c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104230:	83 ec 0c             	sub    $0xc,%esp
f0104233:	50                   	push   %eax
f0104234:	e8 09 38 00 00       	call   f0107a42 <sched_init_RR>
f0104239:	83 c4 10             	add    $0x10,%esp
	cprintf("Scheduler is now set to Round Robin with quantum %d ms\n", quantums[0]);
f010423c:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0104241:	8a 00                	mov    (%eax),%al
f0104243:	0f b6 c0             	movzbl %al,%eax
f0104246:	83 ec 08             	sub    $0x8,%esp
f0104249:	50                   	push   %eax
f010424a:	68 64 d9 12 f0       	push   $0xf012d964
f010424f:	e8 08 da ff ff       	call   f0101c5c <cprintf>
f0104254:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104257:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010425c:	c9                   	leave  
f010425d:	c3                   	ret    

f010425e <command_sch_MLFQ>:
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
f010425e:	55                   	push   %ebp
f010425f:	89 e5                	mov    %esp,%ebp
f0104261:	53                   	push   %ebx
f0104262:	83 ec 24             	sub    $0x24,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f0104265:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104268:	83 c0 04             	add    $0x4,%eax
f010426b:	8b 00                	mov    (%eax),%eax
f010426d:	83 ec 04             	sub    $0x4,%esp
f0104270:	6a 0a                	push   $0xa
f0104272:	6a 00                	push   $0x0
f0104274:	50                   	push   %eax
f0104275:	e8 10 6d 01 00       	call   f011af8a <strtol>
f010427a:	83 c4 10             	add    $0x10,%esp
f010427d:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f0104280:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0104287:	eb 2e                	jmp    f01042b7 <command_sch_MLFQ+0x59>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
f0104289:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010428c:	8d 58 fe             	lea    -0x2(%eax),%ebx
f010428f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104292:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0104299:	8b 45 0c             	mov    0xc(%ebp),%eax
f010429c:	01 d0                	add    %edx,%eax
f010429e:	8b 00                	mov    (%eax),%eax
f01042a0:	83 ec 04             	sub    $0x4,%esp
f01042a3:	6a 0a                	push   $0xa
f01042a5:	6a 00                	push   $0x0
f01042a7:	50                   	push   %eax
f01042a8:	e8 dd 6c 01 00       	call   f011af8a <strtol>
f01042ad:	83 c4 10             	add    $0x10,%esp
f01042b0:	88 44 1d e1          	mov    %al,-0x1f(%ebp,%ebx,1)
}
int command_sch_MLFQ(int number_of_arguments, char **arguments)
{
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
	uint8 quantumOfEachLevel[MAX_ARGUMENTS - 2] ;
	for (int i = 2 ; i < number_of_arguments ; i++)
f01042b4:	ff 45 f4             	incl   -0xc(%ebp)
f01042b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01042ba:	3b 45 08             	cmp    0x8(%ebp),%eax
f01042bd:	7c ca                	jl     f0104289 <command_sch_MLFQ+0x2b>
	{
		quantumOfEachLevel[i-2] = strtol(arguments[i], NULL, 10);
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);
f01042bf:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f01042c3:	83 ec 08             	sub    $0x8,%esp
f01042c6:	8d 55 e1             	lea    -0x1f(%ebp),%edx
f01042c9:	52                   	push   %edx
f01042ca:	50                   	push   %eax
f01042cb:	e8 20 38 00 00       	call   f0107af0 <sched_init_MLFQ>
f01042d0:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to MLFQ with quantums: ");
f01042d3:	83 ec 0c             	sub    $0xc,%esp
f01042d6:	68 9c d9 12 f0       	push   $0xf012d99c
f01042db:	e8 7c d9 ff ff       	call   f0101c5c <cprintf>
f01042e0:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues; i++)
f01042e3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01042ea:	eb 24                	jmp    f0104310 <command_sch_MLFQ+0xb2>
	{
		cprintf("%d   ", quantums[i]) ;
f01042ec:	8b 15 e4 6a 85 f0    	mov    0xf0856ae4,%edx
f01042f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01042f5:	01 d0                	add    %edx,%eax
f01042f7:	8a 00                	mov    (%eax),%al
f01042f9:	0f b6 c0             	movzbl %al,%eax
f01042fc:	83 ec 08             	sub    $0x8,%esp
f01042ff:	50                   	push   %eax
f0104300:	68 c9 d9 12 f0       	push   $0xf012d9c9
f0104305:	e8 52 d9 ff ff       	call   f0101c5c <cprintf>
f010430a:	83 c4 10             	add    $0x10,%esp
	}

	sched_init_MLFQ(numOfLevels, quantumOfEachLevel);

	cprintf("Scheduler is now set to MLFQ with quantums: ");
	for (int i = 0 ; i < num_of_ready_queues; i++)
f010430d:	ff 45 f0             	incl   -0x10(%ebp)
f0104310:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0104315:	0f b6 c0             	movzbl %al,%eax
f0104318:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010431b:	7f cf                	jg     f01042ec <command_sch_MLFQ+0x8e>
	{
		cprintf("%d   ", quantums[i]) ;
	}
	cprintf("\n");
f010431d:	83 ec 0c             	sub    $0xc,%esp
f0104320:	68 cf d9 12 f0       	push   $0xf012d9cf
f0104325:	e8 32 d9 ff ff       	call   f0101c5c <cprintf>
f010432a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010432d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104332:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104335:	c9                   	leave  
f0104336:	c3                   	ret    

f0104337 <command_sch_BSD>:
int command_sch_BSD(int number_of_arguments, char **arguments)
{
f0104337:	55                   	push   %ebp
f0104338:	89 e5                	mov    %esp,%ebp
f010433a:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f010433d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104340:	83 c0 04             	add    $0x4,%eax
f0104343:	8b 00                	mov    (%eax),%eax
f0104345:	83 ec 04             	sub    $0x4,%esp
f0104348:	6a 0a                	push   $0xa
f010434a:	6a 00                	push   $0x0
f010434c:	50                   	push   %eax
f010434d:	e8 38 6c 01 00       	call   f011af8a <strtol>
f0104352:	83 c4 10             	add    $0x10,%esp
f0104355:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f0104358:	8b 45 0c             	mov    0xc(%ebp),%eax
f010435b:	83 c0 08             	add    $0x8,%eax
f010435e:	8b 00                	mov    (%eax),%eax
f0104360:	83 ec 04             	sub    $0x4,%esp
f0104363:	6a 0a                	push   $0xa
f0104365:	6a 00                	push   $0x0
f0104367:	50                   	push   %eax
f0104368:	e8 1d 6c 01 00       	call   f011af8a <strtol>
f010436d:	83 c4 10             	add    $0x10,%esp
f0104370:	88 45 f6             	mov    %al,-0xa(%ebp)

	sched_init_BSD(numOfLevels, quantum);
f0104373:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104377:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f010437b:	83 ec 08             	sub    $0x8,%esp
f010437e:	52                   	push   %edx
f010437f:	50                   	push   %eax
f0104380:	e8 8e 37 00 00       	call   f0107b13 <sched_init_BSD>
f0104385:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", numOfLevels, quantum);
f0104388:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010438c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104390:	83 ec 04             	sub    $0x4,%esp
f0104393:	52                   	push   %edx
f0104394:	50                   	push   %eax
f0104395:	68 d4 d9 12 f0       	push   $0xf012d9d4
f010439a:	e8 bd d8 ff ff       	call   f0101c5c <cprintf>
f010439f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f01043a2:	83 ec 0c             	sub    $0xc,%esp
f01043a5:	68 cf d9 12 f0       	push   $0xf012d9cf
f01043aa:	e8 ad d8 ff ff       	call   f0101c5c <cprintf>
f01043af:	83 c4 10             	add    $0x10,%esp
	return 0;
f01043b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01043b7:	c9                   	leave  
f01043b8:	c3                   	ret    

f01043b9 <command_sch_PRIRR>:

int command_sch_PRIRR(int number_of_arguments, char **arguments)
{
f01043b9:	55                   	push   %ebp
f01043ba:	89 e5                	mov    %esp,%ebp
f01043bc:	83 ec 18             	sub    $0x18,%esp
	uint8 numOfLevels = strtol(arguments[1], NULL, 10);
f01043bf:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043c2:	83 c0 04             	add    $0x4,%eax
f01043c5:	8b 00                	mov    (%eax),%eax
f01043c7:	83 ec 04             	sub    $0x4,%esp
f01043ca:	6a 0a                	push   $0xa
f01043cc:	6a 00                	push   $0x0
f01043ce:	50                   	push   %eax
f01043cf:	e8 b6 6b 01 00       	call   f011af8a <strtol>
f01043d4:	83 c4 10             	add    $0x10,%esp
f01043d7:	88 45 f7             	mov    %al,-0x9(%ebp)
	uint8 quantum = strtol(arguments[2], NULL, 10);
f01043da:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043dd:	83 c0 08             	add    $0x8,%eax
f01043e0:	8b 00                	mov    (%eax),%eax
f01043e2:	83 ec 04             	sub    $0x4,%esp
f01043e5:	6a 0a                	push   $0xa
f01043e7:	6a 00                	push   $0x0
f01043e9:	50                   	push   %eax
f01043ea:	e8 9b 6b 01 00       	call   f011af8a <strtol>
f01043ef:	83 c4 10             	add    $0x10,%esp
f01043f2:	88 45 f6             	mov    %al,-0xa(%ebp)
	uint32 starvThresh = strtol(arguments[3], NULL, 10);
f01043f5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01043f8:	83 c0 0c             	add    $0xc,%eax
f01043fb:	8b 00                	mov    (%eax),%eax
f01043fd:	83 ec 04             	sub    $0x4,%esp
f0104400:	6a 0a                	push   $0xa
f0104402:	6a 00                	push   $0x0
f0104404:	50                   	push   %eax
f0104405:	e8 80 6b 01 00       	call   f011af8a <strtol>
f010440a:	83 c4 10             	add    $0x10,%esp
f010440d:	89 45 f0             	mov    %eax,-0x10(%ebp)

	sched_init_PRIRR(numOfLevels, quantum, starvThresh);
f0104410:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f0104414:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104418:	83 ec 04             	sub    $0x4,%esp
f010441b:	ff 75 f0             	pushl  -0x10(%ebp)
f010441e:	52                   	push   %edx
f010441f:	50                   	push   %eax
f0104420:	e8 17 37 00 00       	call   f0107b3c <sched_init_PRIRR>
f0104425:	83 c4 10             	add    $0x10,%esp

	cprintf("Scheduler is now set to PRIORITY RR with %d priorities, quantum = %d and starvation thresh %d\n", numOfLevels, quantum, starvThresh);
f0104428:	0f b6 55 f6          	movzbl -0xa(%ebp),%edx
f010442c:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0104430:	ff 75 f0             	pushl  -0x10(%ebp)
f0104433:	52                   	push   %edx
f0104434:	50                   	push   %eax
f0104435:	68 10 da 12 f0       	push   $0xf012da10
f010443a:	e8 1d d8 ff ff       	call   f0101c5c <cprintf>
f010443f:	83 c4 10             	add    $0x10,%esp
	cprintf("\n");
f0104442:	83 ec 0c             	sub    $0xc,%esp
f0104445:	68 cf d9 12 f0       	push   $0xf012d9cf
f010444a:	e8 0d d8 ff ff       	call   f0101c5c <cprintf>
f010444f:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104452:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104457:	c9                   	leave  
f0104458:	c3                   	ret    

f0104459 <command_set_starve_thresh>:
int command_set_starve_thresh(int number_of_arguments, char **arguments)
{
f0104459:	55                   	push   %ebp
f010445a:	89 e5                	mov    %esp,%ebp
f010445c:	83 ec 18             	sub    $0x18,%esp
	uint32 starvationThresh = strtol(arguments[1], NULL, 10);
f010445f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104462:	83 c0 04             	add    $0x4,%eax
f0104465:	8b 00                	mov    (%eax),%eax
f0104467:	83 ec 04             	sub    $0x4,%esp
f010446a:	6a 0a                	push   $0xa
f010446c:	6a 00                	push   $0x0
f010446e:	50                   	push   %eax
f010446f:	e8 16 6b 01 00       	call   f011af8a <strtol>
f0104474:	83 c4 10             	add    $0x10,%esp
f0104477:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sched_set_starv_thresh(starvationThresh);
f010447a:	83 ec 0c             	sub    $0xc,%esp
f010447d:	ff 75 f4             	pushl  -0xc(%ebp)
f0104480:	e8 f6 32 00 00       	call   f010777b <sched_set_starv_thresh>
f0104485:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104488:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010448d:	c9                   	leave  
f010448e:	c3                   	ret    

f010448f <command_set_priority>:
//*********************************************************************************//

int command_set_priority(int number_of_arguments, char **arguments)
{
f010448f:	55                   	push   %ebp
f0104490:	89 e5                	mov    %esp,%ebp
f0104492:	83 ec 18             	sub    $0x18,%esp
	int32 envId = strtol(arguments[1],NULL, 10);
f0104495:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104498:	83 c0 04             	add    $0x4,%eax
f010449b:	8b 00                	mov    (%eax),%eax
f010449d:	83 ec 04             	sub    $0x4,%esp
f01044a0:	6a 0a                	push   $0xa
f01044a2:	6a 00                	push   $0x0
f01044a4:	50                   	push   %eax
f01044a5:	e8 e0 6a 01 00       	call   f011af8a <strtol>
f01044aa:	83 c4 10             	add    $0x10,%esp
f01044ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int32 priority = strtol(arguments[2],NULL, 10);
f01044b0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01044b3:	83 c0 08             	add    $0x8,%eax
f01044b6:	8b 00                	mov    (%eax),%eax
f01044b8:	83 ec 04             	sub    $0x4,%esp
f01044bb:	6a 0a                	push   $0xa
f01044bd:	6a 00                	push   $0x0
f01044bf:	50                   	push   %eax
f01044c0:	e8 c5 6a 01 00       	call   f011af8a <strtol>
f01044c5:	83 c4 10             	add    $0x10,%esp
f01044c8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	env_set_priority(envId, priority);
f01044cb:	83 ec 08             	sub    $0x8,%esp
f01044ce:	ff 75 f0             	pushl  -0x10(%ebp)
f01044d1:	ff 75 f4             	pushl  -0xc(%ebp)
f01044d4:	e8 85 32 00 00       	call   f010775e <env_set_priority>
f01044d9:	83 c4 10             	add    $0x10,%esp

	return 0;
f01044dc:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01044e1:	c9                   	leave  
f01044e2:	c3                   	ret    

f01044e3 <command_print_sch_method>:
int command_print_sch_method(int number_of_arguments, char **arguments)
{
f01044e3:	55                   	push   %ebp
f01044e4:	89 e5                	mov    %esp,%ebp
f01044e6:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodMLFQ())
f01044e9:	e8 bc 32 00 00       	call   f01077aa <isSchedMethodMLFQ>
f01044ee:	85 c0                	test   %eax,%eax
f01044f0:	74 5f                	je     f0104551 <command_print_sch_method+0x6e>
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
f01044f2:	83 ec 0c             	sub    $0xc,%esp
f01044f5:	68 70 da 12 f0       	push   $0xf012da70
f01044fa:	e8 5d d7 ff ff       	call   f0101c5c <cprintf>
f01044ff:	83 c4 10             	add    $0x10,%esp
		for (int i = 0 ; i < num_of_ready_queues; i++)
f0104502:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0104509:	eb 24                	jmp    f010452f <command_print_sch_method+0x4c>
		{
			cprintf("%d   ", quantums[i]) ;
f010450b:	8b 15 e4 6a 85 f0    	mov    0xf0856ae4,%edx
f0104511:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104514:	01 d0                	add    %edx,%eax
f0104516:	8a 00                	mov    (%eax),%al
f0104518:	0f b6 c0             	movzbl %al,%eax
f010451b:	83 ec 08             	sub    $0x8,%esp
f010451e:	50                   	push   %eax
f010451f:	68 c9 d9 12 f0       	push   $0xf012d9c9
f0104524:	e8 33 d7 ff ff       	call   f0101c5c <cprintf>
f0104529:	83 c4 10             	add    $0x10,%esp
int command_print_sch_method(int number_of_arguments, char **arguments)
{
	if (isSchedMethodMLFQ())
	{
		cprintf("Current scheduler method is MLFQ with quantums: ");
		for (int i = 0 ; i < num_of_ready_queues; i++)
f010452c:	ff 45 f4             	incl   -0xc(%ebp)
f010452f:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0104534:	0f b6 c0             	movzbl %al,%eax
f0104537:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010453a:	7f cf                	jg     f010450b <command_print_sch_method+0x28>
		{
			cprintf("%d   ", quantums[i]) ;
		}
		cprintf("\n");
f010453c:	83 ec 0c             	sub    $0xc,%esp
f010453f:	68 cf d9 12 f0       	push   $0xf012d9cf
f0104544:	e8 13 d7 ff ff       	call   f0101c5c <cprintf>
f0104549:	83 c4 10             	add    $0x10,%esp
f010454c:	e9 94 00 00 00       	jmp    f01045e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodRR())
f0104551:	e8 42 32 00 00       	call   f0107798 <isSchedMethodRR>
f0104556:	85 c0                	test   %eax,%eax
f0104558:	74 1d                	je     f0104577 <command_print_sch_method+0x94>
	{
		cprintf("Current scheduler method is Round Robin with quantum %d ms\n", quantums[0]);
f010455a:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f010455f:	8a 00                	mov    (%eax),%al
f0104561:	0f b6 c0             	movzbl %al,%eax
f0104564:	83 ec 08             	sub    $0x8,%esp
f0104567:	50                   	push   %eax
f0104568:	68 a4 da 12 f0       	push   $0xf012daa4
f010456d:	e8 ea d6 ff ff       	call   f0101c5c <cprintf>
f0104572:	83 c4 10             	add    $0x10,%esp
f0104575:	eb 6e                	jmp    f01045e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodBSD())
f0104577:	e8 41 32 00 00       	call   f01077bd <isSchedMethodBSD>
f010457c:	85 c0                	test   %eax,%eax
f010457e:	74 26                	je     f01045a6 <command_print_sch_method+0xc3>
	{
		cprintf("Scheduler is now set to BSD with %d levels & quantum = %d\n", num_of_ready_queues, quantums[0]);
f0104580:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0104585:	8a 00                	mov    (%eax),%al
f0104587:	0f b6 d0             	movzbl %al,%edx
f010458a:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f010458f:	0f b6 c0             	movzbl %al,%eax
f0104592:	83 ec 04             	sub    $0x4,%esp
f0104595:	52                   	push   %edx
f0104596:	50                   	push   %eax
f0104597:	68 d4 d9 12 f0       	push   $0xf012d9d4
f010459c:	e8 bb d6 ff ff       	call   f0101c5c <cprintf>
f01045a1:	83 c4 10             	add    $0x10,%esp
f01045a4:	eb 3f                	jmp    f01045e5 <command_print_sch_method+0x102>
	}
	else if (isSchedMethodPRIRR())
f01045a6:	e8 25 32 00 00       	call   f01077d0 <isSchedMethodPRIRR>
f01045ab:	85 c0                	test   %eax,%eax
f01045ad:	74 26                	je     f01045d5 <command_print_sch_method+0xf2>
	{
		cprintf("Scheduler is now set to PRIORITY RR with %d priorities & quantum = %d\n", num_of_ready_queues, quantums[0]);
f01045af:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f01045b4:	8a 00                	mov    (%eax),%al
f01045b6:	0f b6 d0             	movzbl %al,%edx
f01045b9:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01045be:	0f b6 c0             	movzbl %al,%eax
f01045c1:	83 ec 04             	sub    $0x4,%esp
f01045c4:	52                   	push   %edx
f01045c5:	50                   	push   %eax
f01045c6:	68 e0 da 12 f0       	push   $0xf012dae0
f01045cb:	e8 8c d6 ff ff       	call   f0101c5c <cprintf>
f01045d0:	83 c4 10             	add    $0x10,%esp
f01045d3:	eb 10                	jmp    f01045e5 <command_print_sch_method+0x102>
	}
	else
		cprintf("Current scheduler method is UNDEFINED\n");
f01045d5:	83 ec 0c             	sub    $0xc,%esp
f01045d8:	68 28 db 12 f0       	push   $0xf012db28
f01045dd:	e8 7a d6 ff ff       	call   f0101c5c <cprintf>
f01045e2:	83 c4 10             	add    $0x10,%esp

	return 0;
f01045e5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01045ea:	c9                   	leave  
f01045eb:	c3                   	ret    

f01045ec <command_sch_test>:
int command_sch_test(int number_of_arguments, char **arguments)
{
f01045ec:	55                   	push   %ebp
f01045ed:	89 e5                	mov    %esp,%ebp
f01045ef:	83 ec 18             	sub    $0x18,%esp
	int status  = strtol(arguments[1], NULL, 10);
f01045f2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01045f5:	83 c0 04             	add    $0x4,%eax
f01045f8:	8b 00                	mov    (%eax),%eax
f01045fa:	83 ec 04             	sub    $0x4,%esp
f01045fd:	6a 0a                	push   $0xa
f01045ff:	6a 00                	push   $0x0
f0104601:	50                   	push   %eax
f0104602:	e8 83 69 01 00       	call   f011af8a <strtol>
f0104607:	83 c4 10             	add    $0x10,%esp
f010460a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	chksch(status);
f010460d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104610:	0f b6 c0             	movzbl %al,%eax
f0104613:	83 ec 0c             	sub    $0xc,%esp
f0104616:	50                   	push   %eax
f0104617:	e8 0b 56 01 00       	call   f0119c27 <chksch>
f010461c:	83 c4 10             	add    $0x10,%esp
	if (status == 0)
f010461f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0104623:	75 12                	jne    f0104637 <command_sch_test+0x4b>
		cprintf("Testing the scheduler is TURNED OFF\n");
f0104625:	83 ec 0c             	sub    $0xc,%esp
f0104628:	68 50 db 12 f0       	push   $0xf012db50
f010462d:	e8 2a d6 ff ff       	call   f0101c5c <cprintf>
f0104632:	83 c4 10             	add    $0x10,%esp
f0104635:	eb 16                	jmp    f010464d <command_sch_test+0x61>
	else if (status == 1)
f0104637:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
f010463b:	75 10                	jne    f010464d <command_sch_test+0x61>
		cprintf("Testing the scheduler is TURNED ON\n");
f010463d:	83 ec 0c             	sub    $0xc,%esp
f0104640:	68 78 db 12 f0       	push   $0xf012db78
f0104645:	e8 12 d6 ff ff       	call   f0101c5c <cprintf>
f010464a:	83 c4 10             	add    $0x10,%esp
	return 0;
f010464d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104652:	c9                   	leave  
f0104653:	c3                   	ret    

f0104654 <command_print_page_rep>:
/*2018*///END======================================================


/*2015*///BEGIN======================================================
int command_print_page_rep(int number_of_arguments, char **arguments)
{
f0104654:	55                   	push   %ebp
f0104655:	89 e5                	mov    %esp,%ebp
f0104657:	83 ec 08             	sub    $0x8,%esp
	if (isPageReplacmentAlgorithmCLOCK())
f010465a:	e8 da b2 00 00       	call   f010f939 <isPageReplacmentAlgorithmCLOCK>
f010465f:	85 c0                	test   %eax,%eax
f0104661:	74 15                	je     f0104678 <command_print_page_rep+0x24>
		cprintf("Page replacement algorithm is CLOCK\n");
f0104663:	83 ec 0c             	sub    $0xc,%esp
f0104666:	68 9c db 12 f0       	push   $0xf012db9c
f010466b:	e8 ec d5 ff ff       	call   f0101c5c <cprintf>
f0104670:	83 c4 10             	add    $0x10,%esp
f0104673:	e9 ff 00 00 00       	jmp    f0104777 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0104678:	83 ec 0c             	sub    $0xc,%esp
f010467b:	6a 01                	push   $0x1
f010467d:	e8 a1 b2 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f0104682:	83 c4 10             	add    $0x10,%esp
f0104685:	85 c0                	test   %eax,%eax
f0104687:	74 15                	je     f010469e <command_print_page_rep+0x4a>
		cprintf("Page replacement algorithm is LRU with TimeStamp approximation\n");
f0104689:	83 ec 0c             	sub    $0xc,%esp
f010468c:	68 c4 db 12 f0       	push   $0xf012dbc4
f0104691:	e8 c6 d5 ff ff       	call   f0101c5c <cprintf>
f0104696:	83 c4 10             	add    $0x10,%esp
f0104699:	e9 d9 00 00 00       	jmp    f0104777 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010469e:	83 ec 0c             	sub    $0xc,%esp
f01046a1:	6a 02                	push   $0x2
f01046a3:	e8 7b b2 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f01046a8:	83 c4 10             	add    $0x10,%esp
f01046ab:	85 c0                	test   %eax,%eax
f01046ad:	74 15                	je     f01046c4 <command_print_page_rep+0x70>
		cprintf("Page replacement algorithm is LRU with LISTS approximation\n");
f01046af:	83 ec 0c             	sub    $0xc,%esp
f01046b2:	68 04 dc 12 f0       	push   $0xf012dc04
f01046b7:	e8 a0 d5 ff ff       	call   f0101c5c <cprintf>
f01046bc:	83 c4 10             	add    $0x10,%esp
f01046bf:	e9 b3 00 00 00       	jmp    f0104777 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmFIFO())
f01046c4:	e8 8b b2 00 00       	call   f010f954 <isPageReplacmentAlgorithmFIFO>
f01046c9:	85 c0                	test   %eax,%eax
f01046cb:	74 15                	je     f01046e2 <command_print_page_rep+0x8e>
		cprintf("Page replacement algorithm is FIFO\n");
f01046cd:	83 ec 0c             	sub    $0xc,%esp
f01046d0:	68 40 dc 12 f0       	push   $0xf012dc40
f01046d5:	e8 82 d5 ff ff       	call   f0101c5c <cprintf>
f01046da:	83 c4 10             	add    $0x10,%esp
f01046dd:	e9 95 00 00 00       	jmp    f0104777 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmModifiedCLOCK())
f01046e2:	e8 88 b2 00 00       	call   f010f96f <isPageReplacmentAlgorithmModifiedCLOCK>
f01046e7:	85 c0                	test   %eax,%eax
f01046e9:	74 12                	je     f01046fd <command_print_page_rep+0xa9>
		cprintf("Page replacement algorithm is Modified CLOCK\n");
f01046eb:	83 ec 0c             	sub    $0xc,%esp
f01046ee:	68 64 dc 12 f0       	push   $0xf012dc64
f01046f3:	e8 64 d5 ff ff       	call   f0101c5c <cprintf>
f01046f8:	83 c4 10             	add    $0x10,%esp
f01046fb:	eb 7a                	jmp    f0104777 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmOPTIMAL())
f01046fd:	e8 be b2 00 00       	call   f010f9c0 <isPageReplacmentAlgorithmOPTIMAL>
f0104702:	85 c0                	test   %eax,%eax
f0104704:	74 12                	je     f0104718 <command_print_page_rep+0xc4>
		cprintf("Page replacement algorithm is OPTIMAL\n");
f0104706:	83 ec 0c             	sub    $0xc,%esp
f0104709:	68 94 dc 12 f0       	push   $0xf012dc94
f010470e:	e8 49 d5 ff ff       	call   f0101c5c <cprintf>
f0104713:	83 c4 10             	add    $0x10,%esp
f0104716:	eb 5f                	jmp    f0104777 <command_print_page_rep+0x123>
	else if (isPageReplacmentAlgorithmNchanceCLOCK())
f0104718:	e8 88 b2 00 00       	call   f010f9a5 <isPageReplacmentAlgorithmNchanceCLOCK>
f010471d:	85 c0                	test   %eax,%eax
f010471f:	74 46                	je     f0104767 <command_print_page_rep+0x113>
	{
		cprintf("Page replacement algorithm is Nth Chance CLOCK ");
f0104721:	83 ec 0c             	sub    $0xc,%esp
f0104724:	68 bc dc 12 f0       	push   $0xf012dcbc
f0104729:	e8 2e d5 ff ff       	call   f0101c5c <cprintf>
f010472e:	83 c4 10             	add    $0x10,%esp
		if (page_WS_max_sweeps > 0)			cprintf("[NORMAL ver]\n");
f0104731:	a1 b4 e7 83 f0       	mov    0xf083e7b4,%eax
f0104736:	85 c0                	test   %eax,%eax
f0104738:	7e 12                	jle    f010474c <command_print_page_rep+0xf8>
f010473a:	83 ec 0c             	sub    $0xc,%esp
f010473d:	68 ec dc 12 f0       	push   $0xf012dcec
f0104742:	e8 15 d5 ff ff       	call   f0101c5c <cprintf>
f0104747:	83 c4 10             	add    $0x10,%esp
f010474a:	eb 2b                	jmp    f0104777 <command_print_page_rep+0x123>
		else if (page_WS_max_sweeps < 0)	cprintf("[MODIFIED ver]\n");
f010474c:	a1 b4 e7 83 f0       	mov    0xf083e7b4,%eax
f0104751:	85 c0                	test   %eax,%eax
f0104753:	79 22                	jns    f0104777 <command_print_page_rep+0x123>
f0104755:	83 ec 0c             	sub    $0xc,%esp
f0104758:	68 fa dc 12 f0       	push   $0xf012dcfa
f010475d:	e8 fa d4 ff ff       	call   f0101c5c <cprintf>
f0104762:	83 c4 10             	add    $0x10,%esp
f0104765:	eb 10                	jmp    f0104777 <command_print_page_rep+0x123>
	}
	else
		cprintf("Page replacement algorithm is UNDEFINED\n");
f0104767:	83 ec 0c             	sub    $0xc,%esp
f010476a:	68 0c dd 12 f0       	push   $0xf012dd0c
f010476f:	e8 e8 d4 ff ff       	call   f0101c5c <cprintf>
f0104774:	83 c4 10             	add    $0x10,%esp

	return 0;
f0104777:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010477c:	c9                   	leave  
f010477d:	c3                   	ret    

f010477e <command_set_uheap_plac_FIRSTFIT>:


int command_set_uheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f010477e:	55                   	push   %ebp
f010477f:	89 e5                	mov    %esp,%ebp
f0104781:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_FIRSTFIT);
f0104784:	6a 01                	push   $0x1
f0104786:	e8 c9 e7 ff ff       	call   f0102f54 <set_uheap_strategy>
f010478b:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now FIRST FIT\n");
f010478e:	83 ec 0c             	sub    $0xc,%esp
f0104791:	68 38 dd 12 f0       	push   $0xf012dd38
f0104796:	e8 c1 d4 ff ff       	call   f0101c5c <cprintf>
f010479b:	83 c4 10             	add    $0x10,%esp
	return 0;
f010479e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047a3:	c9                   	leave  
f01047a4:	c3                   	ret    

f01047a5 <command_set_uheap_plac_BESTFIT>:

int command_set_uheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f01047a5:	55                   	push   %ebp
f01047a6:	89 e5                	mov    %esp,%ebp
f01047a8:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_BESTFIT);
f01047ab:	6a 02                	push   $0x2
f01047ad:	e8 a2 e7 ff ff       	call   f0102f54 <set_uheap_strategy>
f01047b2:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now BEST FIT\n");
f01047b5:	83 ec 0c             	sub    $0xc,%esp
f01047b8:	68 68 dd 12 f0       	push   $0xf012dd68
f01047bd:	e8 9a d4 ff ff       	call   f0101c5c <cprintf>
f01047c2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01047c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047ca:	c9                   	leave  
f01047cb:	c3                   	ret    

f01047cc <command_set_uheap_plac_NEXTFIT>:

int command_set_uheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f01047cc:	55                   	push   %ebp
f01047cd:	89 e5                	mov    %esp,%ebp
f01047cf:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_NEXTFIT);
f01047d2:	6a 03                	push   $0x3
f01047d4:	e8 7b e7 ff ff       	call   f0102f54 <set_uheap_strategy>
f01047d9:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now NEXT FIT\n");
f01047dc:	83 ec 0c             	sub    $0xc,%esp
f01047df:	68 98 dd 12 f0       	push   $0xf012dd98
f01047e4:	e8 73 d4 ff ff       	call   f0101c5c <cprintf>
f01047e9:	83 c4 10             	add    $0x10,%esp
	return 0;
f01047ec:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01047f1:	c9                   	leave  
f01047f2:	c3                   	ret    

f01047f3 <command_set_uheap_plac_WORSTFIT>:
int command_set_uheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f01047f3:	55                   	push   %ebp
f01047f4:	89 e5                	mov    %esp,%ebp
f01047f6:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_WORSTFIT);
f01047f9:	6a 04                	push   $0x4
f01047fb:	e8 54 e7 ff ff       	call   f0102f54 <set_uheap_strategy>
f0104800:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now WORST FIT\n");
f0104803:	83 ec 0c             	sub    $0xc,%esp
f0104806:	68 c8 dd 12 f0       	push   $0xf012ddc8
f010480b:	e8 4c d4 ff ff       	call   f0101c5c <cprintf>
f0104810:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104813:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104818:	c9                   	leave  
f0104819:	c3                   	ret    

f010481a <command_set_uheap_plac_CUSTOMFIT>:
int command_set_uheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f010481a:	55                   	push   %ebp
f010481b:	89 e5                	mov    %esp,%ebp
f010481d:	83 ec 08             	sub    $0x8,%esp
	set_uheap_strategy(UHP_PLACE_CUSTOMFIT);
f0104820:	6a 05                	push   $0x5
f0104822:	e8 2d e7 ff ff       	call   f0102f54 <set_uheap_strategy>
f0104827:	83 c4 04             	add    $0x4,%esp
	cprintf("User Heap placement strategy is now CUSTOM FIT\n");
f010482a:	83 ec 0c             	sub    $0xc,%esp
f010482d:	68 f8 dd 12 f0       	push   $0xf012ddf8
f0104832:	e8 25 d4 ff ff       	call   f0101c5c <cprintf>
f0104837:	83 c4 10             	add    $0x10,%esp
	return 0;
f010483a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010483f:	c9                   	leave  
f0104840:	c3                   	ret    

f0104841 <command_print_uheap_plac>:

int command_print_uheap_plac(int number_of_arguments, char **arguments)
{
f0104841:	55                   	push   %ebp
f0104842:	89 e5                	mov    %esp,%ebp
f0104844:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_uheap_strategy();
f0104847:	e8 16 e7 ff ff       	call   f0102f62 <get_uheap_strategy>
f010484c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f010484f:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f0104853:	77 69                	ja     f01048be <command_print_uheap_plac+0x7d>
f0104855:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0104858:	c1 e0 02             	shl    $0x2,%eax
f010485b:	05 30 df 12 f0       	add    $0xf012df30,%eax
f0104860:	8b 00                	mov    (%eax),%eax
f0104862:	ff e0                	jmp    *%eax
	{
	case UHP_PLACE_FIRSTFIT:
		cprintf("User Heap placement strategy is FIRST FIT\n");
f0104864:	83 ec 0c             	sub    $0xc,%esp
f0104867:	68 28 de 12 f0       	push   $0xf012de28
f010486c:	e8 eb d3 ff ff       	call   f0101c5c <cprintf>
f0104871:	83 c4 10             	add    $0x10,%esp
		break;
f0104874:	eb 58                	jmp    f01048ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_NEXTFIT:
		cprintf("User Heap placement strategy is NEXT FIT\n");
f0104876:	83 ec 0c             	sub    $0xc,%esp
f0104879:	68 54 de 12 f0       	push   $0xf012de54
f010487e:	e8 d9 d3 ff ff       	call   f0101c5c <cprintf>
f0104883:	83 c4 10             	add    $0x10,%esp
		break;
f0104886:	eb 46                	jmp    f01048ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_BESTFIT:
		cprintf("User Heap placement strategy is BEST FIT\n");
f0104888:	83 ec 0c             	sub    $0xc,%esp
f010488b:	68 80 de 12 f0       	push   $0xf012de80
f0104890:	e8 c7 d3 ff ff       	call   f0101c5c <cprintf>
f0104895:	83 c4 10             	add    $0x10,%esp
		break;
f0104898:	eb 34                	jmp    f01048ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_WORSTFIT:
		cprintf("User Heap placement strategy is WORST FIT\n");
f010489a:	83 ec 0c             	sub    $0xc,%esp
f010489d:	68 ac de 12 f0       	push   $0xf012deac
f01048a2:	e8 b5 d3 ff ff       	call   f0101c5c <cprintf>
f01048a7:	83 c4 10             	add    $0x10,%esp
		break;
f01048aa:	eb 22                	jmp    f01048ce <command_print_uheap_plac+0x8d>
	case UHP_PLACE_CUSTOMFIT:
		cprintf("User Heap placement strategy is CUSTOM FIT\n");
f01048ac:	83 ec 0c             	sub    $0xc,%esp
f01048af:	68 d8 de 12 f0       	push   $0xf012ded8
f01048b4:	e8 a3 d3 ff ff       	call   f0101c5c <cprintf>
f01048b9:	83 c4 10             	add    $0x10,%esp
		break;
f01048bc:	eb 10                	jmp    f01048ce <command_print_uheap_plac+0x8d>
	default:
		cprintf("User Heap placement strategy is UNDEFINED\n");
f01048be:	83 ec 0c             	sub    $0xc,%esp
f01048c1:	68 04 df 12 f0       	push   $0xf012df04
f01048c6:	e8 91 d3 ff ff       	call   f0101c5c <cprintf>
f01048cb:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f01048ce:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01048d3:	c9                   	leave  
f01048d4:	c3                   	ret    

f01048d5 <command_set_kheap_plac_CONTALLOC>:
/*2015*///END======================================================

/*2017*///BEGIN======================================================

int command_set_kheap_plac_CONTALLOC(int number_of_arguments, char **arguments)
{
f01048d5:	55                   	push   %ebp
f01048d6:	89 e5                	mov    %esp,%ebp
f01048d8:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CONTALLOC);
f01048db:	6a 00                	push   $0x0
f01048dd:	e8 5a e6 ff ff       	call   f0102f3c <set_kheap_strategy>
f01048e2:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f01048e5:	83 ec 0c             	sub    $0xc,%esp
f01048e8:	68 48 df 12 f0       	push   $0xf012df48
f01048ed:	e8 6a d3 ff ff       	call   f0101c5c <cprintf>
f01048f2:	83 c4 10             	add    $0x10,%esp
	return 0;
f01048f5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01048fa:	c9                   	leave  
f01048fb:	c3                   	ret    

f01048fc <command_set_kheap_plac_FIRSTFIT>:

int command_set_kheap_plac_FIRSTFIT(int number_of_arguments, char **arguments)
{
f01048fc:	55                   	push   %ebp
f01048fd:	89 e5                	mov    %esp,%ebp
f01048ff:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f0104902:	6a 01                	push   $0x1
f0104904:	e8 33 e6 ff ff       	call   f0102f3c <set_kheap_strategy>
f0104909:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now FIRST FIT\n");
f010490c:	83 ec 0c             	sub    $0xc,%esp
f010490f:	68 48 df 12 f0       	push   $0xf012df48
f0104914:	e8 43 d3 ff ff       	call   f0101c5c <cprintf>
f0104919:	83 c4 10             	add    $0x10,%esp
	return 0;
f010491c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104921:	c9                   	leave  
f0104922:	c3                   	ret    

f0104923 <command_set_kheap_plac_BESTFIT>:

int command_set_kheap_plac_BESTFIT(int number_of_arguments, char **arguments)
{
f0104923:	55                   	push   %ebp
f0104924:	89 e5                	mov    %esp,%ebp
f0104926:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_BESTFIT);
f0104929:	6a 02                	push   $0x2
f010492b:	e8 0c e6 ff ff       	call   f0102f3c <set_kheap_strategy>
f0104930:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now BEST FIT\n");
f0104933:	83 ec 0c             	sub    $0xc,%esp
f0104936:	68 7c df 12 f0       	push   $0xf012df7c
f010493b:	e8 1c d3 ff ff       	call   f0101c5c <cprintf>
f0104940:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104943:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104948:	c9                   	leave  
f0104949:	c3                   	ret    

f010494a <command_set_kheap_plac_NEXTFIT>:

int command_set_kheap_plac_NEXTFIT(int number_of_arguments, char **arguments)
{
f010494a:	55                   	push   %ebp
f010494b:	89 e5                	mov    %esp,%ebp
f010494d:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0104950:	6a 03                	push   $0x3
f0104952:	e8 e5 e5 ff ff       	call   f0102f3c <set_kheap_strategy>
f0104957:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now NEXT FIT\n");
f010495a:	83 ec 0c             	sub    $0xc,%esp
f010495d:	68 ac df 12 f0       	push   $0xf012dfac
f0104962:	e8 f5 d2 ff ff       	call   f0101c5c <cprintf>
f0104967:	83 c4 10             	add    $0x10,%esp
	return 0;
f010496a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010496f:	c9                   	leave  
f0104970:	c3                   	ret    

f0104971 <command_set_kheap_plac_WORSTFIT>:
int command_set_kheap_plac_WORSTFIT(int number_of_arguments, char **arguments)
{
f0104971:	55                   	push   %ebp
f0104972:	89 e5                	mov    %esp,%ebp
f0104974:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0104977:	6a 04                	push   $0x4
f0104979:	e8 be e5 ff ff       	call   f0102f3c <set_kheap_strategy>
f010497e:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now WORST FIT\n");
f0104981:	83 ec 0c             	sub    $0xc,%esp
f0104984:	68 dc df 12 f0       	push   $0xf012dfdc
f0104989:	e8 ce d2 ff ff       	call   f0101c5c <cprintf>
f010498e:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104991:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104996:	c9                   	leave  
f0104997:	c3                   	ret    

f0104998 <command_set_kheap_plac_CUSTOMFIT>:
int command_set_kheap_plac_CUSTOMFIT(int number_of_arguments, char **arguments)
{
f0104998:	55                   	push   %ebp
f0104999:	89 e5                	mov    %esp,%ebp
f010499b:	83 ec 08             	sub    $0x8,%esp
	set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f010499e:	6a 05                	push   $0x5
f01049a0:	e8 97 e5 ff ff       	call   f0102f3c <set_kheap_strategy>
f01049a5:	83 c4 04             	add    $0x4,%esp
	cprintf("Kernel Heap placement strategy is now CUSTOM FIT\n");
f01049a8:	83 ec 0c             	sub    $0xc,%esp
f01049ab:	68 10 e0 12 f0       	push   $0xf012e010
f01049b0:	e8 a7 d2 ff ff       	call   f0101c5c <cprintf>
f01049b5:	83 c4 10             	add    $0x10,%esp
	return 0;
f01049b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01049bd:	c9                   	leave  
f01049be:	c3                   	ret    

f01049bf <command_print_kheap_plac>:
int command_print_kheap_plac(int number_of_arguments, char **arguments)
{
f01049bf:	55                   	push   %ebp
f01049c0:	89 e5                	mov    %esp,%ebp
f01049c2:	83 ec 18             	sub    $0x18,%esp
	uint32 strategy = get_kheap_strategy();
f01049c5:	e8 80 e5 ff ff       	call   f0102f4a <get_kheap_strategy>
f01049ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (strategy)
f01049cd:	83 7d f4 05          	cmpl   $0x5,-0xc(%ebp)
f01049d1:	77 7b                	ja     f0104a4e <command_print_kheap_plac+0x8f>
f01049d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01049d6:	c1 e0 02             	shl    $0x2,%eax
f01049d9:	05 98 e1 12 f0       	add    $0xf012e198,%eax
f01049de:	8b 00                	mov    (%eax),%eax
f01049e0:	ff e0                	jmp    *%eax
	{
	case KHP_PLACE_CONTALLOC:
		cprintf("Kernel Heap placement strategy is CONTINUOUS ALLOCATION\n");
f01049e2:	83 ec 0c             	sub    $0xc,%esp
f01049e5:	68 44 e0 12 f0       	push   $0xf012e044
f01049ea:	e8 6d d2 ff ff       	call   f0101c5c <cprintf>
f01049ef:	83 c4 10             	add    $0x10,%esp
		break;
f01049f2:	eb 6a                	jmp    f0104a5e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_FIRSTFIT:
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f01049f4:	83 ec 0c             	sub    $0xc,%esp
f01049f7:	68 80 e0 12 f0       	push   $0xf012e080
f01049fc:	e8 5b d2 ff ff       	call   f0101c5c <cprintf>
f0104a01:	83 c4 10             	add    $0x10,%esp
		break;
f0104a04:	eb 58                	jmp    f0104a5e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_NEXTFIT:
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0104a06:	83 ec 0c             	sub    $0xc,%esp
f0104a09:	68 b0 e0 12 f0       	push   $0xf012e0b0
f0104a0e:	e8 49 d2 ff ff       	call   f0101c5c <cprintf>
f0104a13:	83 c4 10             	add    $0x10,%esp
		break;
f0104a16:	eb 46                	jmp    f0104a5e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_BESTFIT:
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0104a18:	83 ec 0c             	sub    $0xc,%esp
f0104a1b:	68 dc e0 12 f0       	push   $0xf012e0dc
f0104a20:	e8 37 d2 ff ff       	call   f0101c5c <cprintf>
f0104a25:	83 c4 10             	add    $0x10,%esp
		break;
f0104a28:	eb 34                	jmp    f0104a5e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_WORSTFIT:
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0104a2a:	83 ec 0c             	sub    $0xc,%esp
f0104a2d:	68 08 e1 12 f0       	push   $0xf012e108
f0104a32:	e8 25 d2 ff ff       	call   f0101c5c <cprintf>
f0104a37:	83 c4 10             	add    $0x10,%esp
		break;
f0104a3a:	eb 22                	jmp    f0104a5e <command_print_kheap_plac+0x9f>
	case KHP_PLACE_CUSTOMFIT:
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f0104a3c:	83 ec 0c             	sub    $0xc,%esp
f0104a3f:	68 38 e1 12 f0       	push   $0xf012e138
f0104a44:	e8 13 d2 ff ff       	call   f0101c5c <cprintf>
f0104a49:	83 c4 10             	add    $0x10,%esp
		break;
f0104a4c:	eb 10                	jmp    f0104a5e <command_print_kheap_plac+0x9f>
	default:
		cprintf("Kernel Heap placement strategy is UNDEFINED\n");
f0104a4e:	83 ec 0c             	sub    $0xc,%esp
f0104a51:	68 68 e1 12 f0       	push   $0xf012e168
f0104a56:	e8 01 d2 ff ff       	call   f0101c5c <cprintf>
f0104a5b:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0104a5e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104a63:	c9                   	leave  
f0104a64:	c3                   	ret    

f0104a65 <command_disable_modified_buffer>:

/*2017*///END======================================================

int command_disable_modified_buffer(int number_of_arguments, char **arguments)
{
f0104a65:	55                   	push   %ebp
f0104a66:	89 e5                	mov    %esp,%ebp
f0104a68:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104a6b:	e8 91 af 00 00       	call   f010fa01 <isBufferingEnabled>
f0104a70:	84 c0                	test   %al,%al
f0104a72:	75 12                	jne    f0104a86 <command_disable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0104a74:	83 ec 0c             	sub    $0xc,%esp
f0104a77:	68 b0 e1 12 f0       	push   $0xf012e1b0
f0104a7c:	e8 db d1 ff ff       	call   f0101c5c <cprintf>
f0104a81:	83 c4 10             	add    $0x10,%esp
f0104a84:	eb 1d                	jmp    f0104aa3 <command_disable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(0);
f0104a86:	83 ec 0c             	sub    $0xc,%esp
f0104a89:	6a 00                	push   $0x0
f0104a8b:	e8 4b af 00 00       	call   f010f9db <enableModifiedBuffer>
f0104a90:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now DISABLED\n");
f0104a93:	83 ec 0c             	sub    $0xc,%esp
f0104a96:	68 ec e1 12 f0       	push   $0xf012e1ec
f0104a9b:	e8 bc d1 ff ff       	call   f0101c5c <cprintf>
f0104aa0:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0104aa3:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104aa8:	c9                   	leave  
f0104aa9:	c3                   	ret    

f0104aaa <command_enable_modified_buffer>:


int command_enable_modified_buffer(int number_of_arguments, char **arguments)
{
f0104aaa:	55                   	push   %ebp
f0104aab:	89 e5                	mov    %esp,%ebp
f0104aad:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104ab0:	e8 4c af 00 00       	call   f010fa01 <isBufferingEnabled>
f0104ab5:	84 c0                	test   %al,%al
f0104ab7:	75 12                	jne    f0104acb <command_enable_modified_buffer+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering first.\n");
f0104ab9:	83 ec 0c             	sub    $0xc,%esp
f0104abc:	68 b0 e1 12 f0       	push   $0xf012e1b0
f0104ac1:	e8 96 d1 ff ff       	call   f0101c5c <cprintf>
f0104ac6:	83 c4 10             	add    $0x10,%esp
f0104ac9:	eb 1d                	jmp    f0104ae8 <command_enable_modified_buffer+0x3e>
	}
	else
	{
		enableModifiedBuffer(1);
f0104acb:	83 ec 0c             	sub    $0xc,%esp
f0104ace:	6a 01                	push   $0x1
f0104ad0:	e8 06 af 00 00       	call   f010f9db <enableModifiedBuffer>
f0104ad5:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified Buffer is now ENABLED\n");
f0104ad8:	83 ec 0c             	sub    $0xc,%esp
f0104adb:	68 10 e2 12 f0       	push   $0xf012e210
f0104ae0:	e8 77 d1 ff ff       	call   f0101c5c <cprintf>
f0104ae5:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
f0104ae8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104aed:	c9                   	leave  
f0104aee:	c3                   	ret    

f0104aef <command_disable_buffering>:

/*2016 ============================================================================*/

int command_disable_buffering(int number_of_arguments, char **arguments)
{
f0104aef:	55                   	push   %ebp
f0104af0:	89 e5                	mov    %esp,%ebp
f0104af2:	83 ec 08             	sub    $0x8,%esp
	enableBuffering(0);
f0104af5:	83 ec 0c             	sub    $0xc,%esp
f0104af8:	6a 00                	push   $0x0
f0104afa:	e8 f4 ae 00 00       	call   f010f9f3 <enableBuffering>
f0104aff:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(0);
f0104b02:	83 ec 0c             	sub    $0xc,%esp
f0104b05:	6a 00                	push   $0x0
f0104b07:	e8 cf ae 00 00       	call   f010f9db <enableModifiedBuffer>
f0104b0c:	83 c4 10             	add    $0x10,%esp
	cprintf("Buffering is now DISABLED\n");
f0104b0f:	83 ec 0c             	sub    $0xc,%esp
f0104b12:	68 30 e2 12 f0       	push   $0xf012e230
f0104b17:	e8 40 d1 ff ff       	call   f0101c5c <cprintf>
f0104b1c:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104b1f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104b24:	c9                   	leave  
f0104b25:	c3                   	ret    

f0104b26 <command_enable_buffering>:


int command_enable_buffering(int number_of_arguments, char **arguments)
{
f0104b26:	55                   	push   %ebp
f0104b27:	89 e5                	mov    %esp,%ebp
f0104b29:	83 ec 78             	sub    $0x78,%esp
	enableBuffering(1);
f0104b2c:	83 ec 0c             	sub    $0xc,%esp
f0104b2f:	6a 01                	push   $0x1
f0104b31:	e8 bd ae 00 00       	call   f010f9f3 <enableBuffering>
f0104b36:	83 c4 10             	add    $0x10,%esp
	enableModifiedBuffer(1);
f0104b39:	83 ec 0c             	sub    $0xc,%esp
f0104b3c:	6a 01                	push   $0x1
f0104b3e:	e8 98 ae 00 00       	call   f010f9db <enableModifiedBuffer>
f0104b43:	83 c4 10             	add    $0x10,%esp
	if(getModifiedBufferLength() == 0)
f0104b46:	e8 ce ae 00 00       	call   f010fa19 <getModifiedBufferLength>
f0104b4b:	85 c0                	test   %eax,%eax
f0104b4d:	75 59                	jne    f0104ba8 <command_enable_buffering+0x82>
	{
		cprintf("Modified buffer enabled but with length = 0\n");
f0104b4f:	83 ec 0c             	sub    $0xc,%esp
f0104b52:	68 4c e2 12 f0       	push   $0xf012e24c
f0104b57:	e8 00 d1 ff ff       	call   f0101c5c <cprintf>
f0104b5c:	83 c4 10             	add    $0x10,%esp
		char str[100];
		readline("Please enter the modified buff length = ", str);
f0104b5f:	83 ec 08             	sub    $0x8,%esp
f0104b62:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104b65:	50                   	push   %eax
f0104b66:	68 7c e2 12 f0       	push   $0xf012e27c
f0104b6b:	e8 03 5e 01 00       	call   f011a973 <readline>
f0104b70:	83 c4 10             	add    $0x10,%esp
		setModifiedBufferLength(strtol(str, NULL, 10));
f0104b73:	83 ec 04             	sub    $0x4,%esp
f0104b76:	6a 0a                	push   $0xa
f0104b78:	6a 00                	push   $0x0
f0104b7a:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0104b7d:	50                   	push   %eax
f0104b7e:	e8 07 64 01 00       	call   f011af8a <strtol>
f0104b83:	83 c4 10             	add    $0x10,%esp
f0104b86:	83 ec 0c             	sub    $0xc,%esp
f0104b89:	50                   	push   %eax
f0104b8a:	e8 7c ae 00 00       	call   f010fa0b <setModifiedBufferLength>
f0104b8f:	83 c4 10             	add    $0x10,%esp
		cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104b92:	e8 82 ae 00 00       	call   f010fa19 <getModifiedBufferLength>
f0104b97:	83 ec 08             	sub    $0x8,%esp
f0104b9a:	50                   	push   %eax
f0104b9b:	68 a8 e2 12 f0       	push   $0xf012e2a8
f0104ba0:	e8 b7 d0 ff ff       	call   f0101c5c <cprintf>
f0104ba5:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Buffering is now ENABLED\n");
f0104ba8:	83 ec 0c             	sub    $0xc,%esp
f0104bab:	68 cd e2 12 f0       	push   $0xf012e2cd
f0104bb0:	e8 a7 d0 ff ff       	call   f0101c5c <cprintf>
f0104bb5:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104bb8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104bbd:	c9                   	leave  
f0104bbe:	c3                   	ret    

f0104bbf <command_set_modified_buffer_length>:

int command_set_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104bbf:	55                   	push   %ebp
f0104bc0:	89 e5                	mov    %esp,%ebp
f0104bc2:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104bc5:	e8 37 ae 00 00       	call   f010fa01 <isBufferingEnabled>
f0104bca:	84 c0                	test   %al,%al
f0104bcc:	75 12                	jne    f0104be0 <command_set_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104bce:	83 ec 0c             	sub    $0xc,%esp
f0104bd1:	68 e8 e2 12 f0       	push   $0xf012e2e8
f0104bd6:	e8 81 d0 ff ff       	call   f0101c5c <cprintf>
f0104bdb:	83 c4 10             	add    $0x10,%esp
f0104bde:	eb 19                	jmp    f0104bf9 <command_set_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104be0:	e8 04 ae 00 00       	call   f010f9e9 <isModifiedBufferEnabled>
f0104be5:	84 c0                	test   %al,%al
f0104be7:	75 10                	jne    f0104bf9 <command_set_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104be9:	83 ec 0c             	sub    $0xc,%esp
f0104bec:	68 38 e3 12 f0       	push   $0xf012e338
f0104bf1:	e8 66 d0 ff ff       	call   f0101c5c <cprintf>
f0104bf6:	83 c4 10             	add    $0x10,%esp
	}
	setModifiedBufferLength(strtol(arguments[1], NULL, 10));
f0104bf9:	8b 45 0c             	mov    0xc(%ebp),%eax
f0104bfc:	83 c0 04             	add    $0x4,%eax
f0104bff:	8b 00                	mov    (%eax),%eax
f0104c01:	83 ec 04             	sub    $0x4,%esp
f0104c04:	6a 0a                	push   $0xa
f0104c06:	6a 00                	push   $0x0
f0104c08:	50                   	push   %eax
f0104c09:	e8 7c 63 01 00       	call   f011af8a <strtol>
f0104c0e:	83 c4 10             	add    $0x10,%esp
f0104c11:	83 ec 0c             	sub    $0xc,%esp
f0104c14:	50                   	push   %eax
f0104c15:	e8 f1 ad 00 00       	call   f010fa0b <setModifiedBufferLength>
f0104c1a:	83 c4 10             	add    $0x10,%esp
	cprintf("Modified buffer length updated = %d\n", getModifiedBufferLength());
f0104c1d:	e8 f7 ad 00 00       	call   f010fa19 <getModifiedBufferLength>
f0104c22:	83 ec 08             	sub    $0x8,%esp
f0104c25:	50                   	push   %eax
f0104c26:	68 a8 e2 12 f0       	push   $0xf012e2a8
f0104c2b:	e8 2c d0 ff ff       	call   f0101c5c <cprintf>
f0104c30:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104c33:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104c38:	c9                   	leave  
f0104c39:	c3                   	ret    

f0104c3a <command_get_modified_buffer_length>:

int command_get_modified_buffer_length(int number_of_arguments, char **arguments)
{
f0104c3a:	55                   	push   %ebp
f0104c3b:	89 e5                	mov    %esp,%ebp
f0104c3d:	83 ec 08             	sub    $0x8,%esp
	if(!isBufferingEnabled())
f0104c40:	e8 bc ad 00 00       	call   f010fa01 <isBufferingEnabled>
f0104c45:	84 c0                	test   %al,%al
f0104c47:	75 12                	jne    f0104c5b <command_get_modified_buffer_length+0x21>
	{
		cprintf("Buffering is not enabled. Please enable buffering to use the modified buffer.\n");
f0104c49:	83 ec 0c             	sub    $0xc,%esp
f0104c4c:	68 e8 e2 12 f0       	push   $0xf012e2e8
f0104c51:	e8 06 d0 ff ff       	call   f0101c5c <cprintf>
f0104c56:	83 c4 10             	add    $0x10,%esp
f0104c59:	eb 19                	jmp    f0104c74 <command_get_modified_buffer_length+0x3a>
	}
	else if (!isModifiedBufferEnabled())
f0104c5b:	e8 89 ad 00 00       	call   f010f9e9 <isModifiedBufferEnabled>
f0104c60:	84 c0                	test   %al,%al
f0104c62:	75 10                	jne    f0104c74 <command_get_modified_buffer_length+0x3a>
	{
		cprintf("Modified Buffering is not enabled. Please enable modified buffering.\n");
f0104c64:	83 ec 0c             	sub    $0xc,%esp
f0104c67:	68 38 e3 12 f0       	push   $0xf012e338
f0104c6c:	e8 eb cf ff ff       	call   f0101c5c <cprintf>
f0104c71:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("Modified buffer length = %d\n", getModifiedBufferLength());
f0104c74:	e8 a0 ad 00 00       	call   f010fa19 <getModifiedBufferLength>
f0104c79:	83 ec 08             	sub    $0x8,%esp
f0104c7c:	50                   	push   %eax
f0104c7d:	68 7e e3 12 f0       	push   $0xf012e37e
f0104c82:	e8 d5 cf ff ff       	call   f0101c5c <cprintf>
f0104c87:	83 c4 10             	add    $0x10,%esp
	return 0;
f0104c8a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104c8f:	c9                   	leave  
f0104c90:	c3                   	ret    

f0104c91 <command_tst>:

int command_tst(int number_of_arguments, char **arguments)
{
f0104c91:	55                   	push   %ebp
f0104c92:	89 e5                	mov    %esp,%ebp
f0104c94:	83 ec 08             	sub    $0x8,%esp
	return tst_handler(number_of_arguments, arguments);
f0104c97:	83 ec 08             	sub    $0x8,%esp
f0104c9a:	ff 75 0c             	pushl  0xc(%ebp)
f0104c9d:	ff 75 08             	pushl  0x8(%ebp)
f0104ca0:	e8 c1 b6 00 00       	call   f0110366 <tst_handler>
f0104ca5:	83 c4 10             	add    $0x10,%esp
}
f0104ca8:	c9                   	leave  
f0104ca9:	c3                   	ret    

f0104caa <command_cls>:

// *************** This clear screen feature is implemented by *************
// ********* Abd-Alrahman Zedan From Team Frozen-Bytes - FCIS'24-25 ********
int command_cls(int number_of_arguments, char **arguments)
{
f0104caa:	55                   	push   %ebp
f0104cab:	89 e5                	mov    %esp,%ebp
f0104cad:	83 ec 08             	sub    $0x8,%esp
	clear_screen_buffer();
f0104cb0:	e8 7b ce ff ff       	call   f0101b30 <clear_screen_buffer>
	return 0;
f0104cb5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0104cba:	c9                   	leave  
f0104cbb:	c3                   	ret    

f0104cbc <read_disk_page>:
void __pf_remove_env_all_tables(struct Env* ptr_env);
void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address);


int read_disk_page(uint32 dfn, void* va)
{
f0104cbc:	55                   	push   %ebp
f0104cbd:	89 e5                	mov    %esp,%ebp
f0104cbf:	83 ec 18             	sub    $0x18,%esp
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104cc2:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cc5:	05 00 14 00 00       	add    $0x1400,%eax
f0104cca:	c1 e0 03             	shl    $0x3,%eax
f0104ccd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf("reading from disk to mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_read(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104cd0:	83 ec 04             	sub    $0x4,%esp
f0104cd3:	6a 08                	push   $0x8
f0104cd5:	ff 75 0c             	pushl  0xc(%ebp)
f0104cd8:	ff 75 f4             	pushl  -0xc(%ebp)
f0104cdb:	e8 3d 67 01 00       	call   f011b41d <ide_read>
f0104ce0:	83 c4 10             	add    $0x10,%esp
f0104ce3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf("read from disk successuflly.\n");} else {cprintf("read from disk failed !!\n");} );

	return success;
f0104ce6:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104ce9:	c9                   	leave  
f0104cea:	c3                   	ret    

f0104ceb <write_disk_page>:


int write_disk_page(uint32 dfn, void* va)
{
f0104ceb:	55                   	push   %ebp
f0104cec:	89 e5                	mov    %esp,%ebp
f0104cee:	83 ec 18             	sub    $0x18,%esp
	//write disk at wanted frame
	uint32 df_start_sector = PAGE_FILE_START_SECTOR+dfn*SECTOR_PER_PAGE;
f0104cf1:	8b 45 08             	mov    0x8(%ebp),%eax
f0104cf4:	05 00 14 00 00       	add    $0x1400,%eax
f0104cf9:	c1 e0 03             	shl    $0x3,%eax
f0104cfc:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_STATMENT( cprintf(">>> writing to disk from mem addr %x at sector %d\n",va,df_start_sector);  );
	int success = ide_write(df_start_sector, (void*)va, SECTOR_PER_PAGE);
f0104cff:	83 ec 04             	sub    $0x4,%esp
f0104d02:	6a 08                	push   $0x8
f0104d04:	ff 75 0c             	pushl  0xc(%ebp)
f0104d07:	ff 75 f4             	pushl  -0xc(%ebp)
f0104d0a:	e8 65 68 01 00       	call   f011b574 <ide_write>
f0104d0f:	83 c4 10             	add    $0x10,%esp
f0104d12:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//LOG_STATMENT( if(success==0) {cprintf(">>> written to disk successfully.\n");} else {cprintf(">>> written to disk failed !!\n");} );

	if(success != 0)
f0104d15:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104d19:	74 14                	je     f0104d2f <write_disk_page+0x44>
		panic("Error writing on disk\n");
f0104d1b:	83 ec 04             	sub    $0x4,%esp
f0104d1e:	68 9c e3 12 f0       	push   $0xf012e39c
f0104d23:	6a 2f                	push   $0x2f
f0104d25:	68 b3 e3 12 f0       	push   $0xf012e3b3
f0104d2a:	e8 80 c2 ff ff       	call   f0100faf <_panic>
	return success;
f0104d2f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0104d32:	c9                   	leave  
f0104d33:	c3                   	ret    

f0104d34 <initialize_disk_page_file>:
// After this point, ONLY use the functions below
// to allocate and deallocate physical memory via the disk_free_frame_list,
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//
void initialize_disk_page_file()
{
f0104d34:	55                   	push   %ebp
f0104d35:	89 e5                	mov    %esp,%ebp
f0104d37:	53                   	push   %ebx
f0104d38:	83 ec 14             	sub    $0x14,%esp
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);
f0104d3b:	c7 05 e0 6c 85 f0 00 	movl   $0x0,0xf0856ce0
f0104d42:	00 00 00 
f0104d45:	c7 05 e4 6c 85 f0 00 	movl   $0x0,0xf0856ce4
f0104d4c:	00 00 00 
f0104d4f:	c7 05 ec 6c 85 f0 00 	movl   $0x0,0xf0856cec
f0104d56:	00 00 00 

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104d59:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0104d60:	e9 ef 00 00 00       	jmp    f0104e54 <initialize_disk_page_file+0x120>
	{
		initialize_frame_info(&(disk_frames_info[i]));
f0104d65:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104d6b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d6e:	89 d0                	mov    %edx,%eax
f0104d70:	c1 e0 02             	shl    $0x2,%eax
f0104d73:	01 d0                	add    %edx,%eax
f0104d75:	c1 e0 02             	shl    $0x2,%eax
f0104d78:	01 c8                	add    %ecx,%eax
f0104d7a:	83 ec 0c             	sub    $0xc,%esp
f0104d7d:	50                   	push   %eax
f0104d7e:	e8 a4 43 00 00       	call   f0109127 <initialize_frame_info>
f0104d83:	83 c4 10             	add    $0x10,%esp

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
f0104d86:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104d8c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104d8f:	89 d0                	mov    %edx,%eax
f0104d91:	c1 e0 02             	shl    $0x2,%eax
f0104d94:	01 d0                	add    %edx,%eax
f0104d96:	c1 e0 02             	shl    $0x2,%eax
f0104d99:	01 c8                	add    %ecx,%eax
f0104d9b:	85 c0                	test   %eax,%eax
f0104d9d:	75 14                	jne    f0104db3 <initialize_disk_page_file+0x7f>
f0104d9f:	83 ec 04             	sub    $0x4,%esp
f0104da2:	68 d0 e3 12 f0       	push   $0xf012e3d0
f0104da7:	6a 56                	push   $0x56
f0104da9:	68 b3 e3 12 f0       	push   $0xf012e3b3
f0104dae:	e8 fc c1 ff ff       	call   f0100faf <_panic>
f0104db3:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104db9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104dbc:	89 d0                	mov    %edx,%eax
f0104dbe:	c1 e0 02             	shl    $0x2,%eax
f0104dc1:	01 d0                	add    %edx,%eax
f0104dc3:	c1 e0 02             	shl    $0x2,%eax
f0104dc6:	01 c8                	add    %ecx,%eax
f0104dc8:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0104dce:	89 10                	mov    %edx,(%eax)
f0104dd0:	8b 00                	mov    (%eax),%eax
f0104dd2:	85 c0                	test   %eax,%eax
f0104dd4:	74 20                	je     f0104df6 <initialize_disk_page_file+0xc2>
f0104dd6:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0104ddc:	8b 1d 44 e5 83 f0    	mov    0xf083e544,%ebx
f0104de2:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0104de5:	89 c8                	mov    %ecx,%eax
f0104de7:	c1 e0 02             	shl    $0x2,%eax
f0104dea:	01 c8                	add    %ecx,%eax
f0104dec:	c1 e0 02             	shl    $0x2,%eax
f0104def:	01 d8                	add    %ebx,%eax
f0104df1:	89 42 04             	mov    %eax,0x4(%edx)
f0104df4:	eb 1a                	jmp    f0104e10 <initialize_disk_page_file+0xdc>
f0104df6:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104dfc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104dff:	89 d0                	mov    %edx,%eax
f0104e01:	c1 e0 02             	shl    $0x2,%eax
f0104e04:	01 d0                	add    %edx,%eax
f0104e06:	c1 e0 02             	shl    $0x2,%eax
f0104e09:	01 c8                	add    %ecx,%eax
f0104e0b:	a3 e4 6c 85 f0       	mov    %eax,0xf0856ce4
f0104e10:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104e16:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e19:	89 d0                	mov    %edx,%eax
f0104e1b:	c1 e0 02             	shl    $0x2,%eax
f0104e1e:	01 d0                	add    %edx,%eax
f0104e20:	c1 e0 02             	shl    $0x2,%eax
f0104e23:	01 c8                	add    %ecx,%eax
f0104e25:	a3 e0 6c 85 f0       	mov    %eax,0xf0856ce0
f0104e2a:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104e30:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0104e33:	89 d0                	mov    %edx,%eax
f0104e35:	c1 e0 02             	shl    $0x2,%eax
f0104e38:	01 d0                	add    %edx,%eax
f0104e3a:	c1 e0 02             	shl    $0x2,%eax
f0104e3d:	01 c8                	add    %ecx,%eax
f0104e3f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104e46:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0104e4b:	40                   	inc    %eax
f0104e4c:	a3 ec 6c 85 f0       	mov    %eax,0xf0856cec
{
	int i;
	LIST_INIT(&DiskFrameLists.disk_free_frame_list);

	//LOG_STATMENT(cprintf("PAGES_PER_FILE = %d, PAGE_FILE_START_SECTOR = %d\n",PAGES_PER_FILE,PAGE_FILE_START_SECTOR););
	for (i = 1; i < PAGES_PER_FILE; i++)
f0104e51:	ff 45 f4             	incl   -0xc(%ebp)
f0104e54:	81 7d f4 ff 07 02 00 	cmpl   $0x207ff,-0xc(%ebp)
f0104e5b:	0f 8e 04 ff ff ff    	jle    f0104d65 <initialize_disk_page_file+0x31>

		//disk_frames_info[i].references = 0;
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[i]);
	}

	init_kspinlock(&DiskFrameLists.dfllock, "Disk FrameList Lock");
f0104e61:	83 ec 08             	sub    $0x8,%esp
f0104e64:	68 f3 e3 12 f0       	push   $0xf012e3f3
f0104e69:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104e6e:	e8 d7 af 00 00       	call   f010fe4a <init_kspinlock>
f0104e73:	83 c4 10             	add    $0x10,%esp
}
f0104e76:	90                   	nop
f0104e77:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0104e7a:	c9                   	leave  
f0104e7b:	c3                   	ret    

f0104e7c <to_disk_frame_number>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
static inline uint32 to_disk_frame_number(struct FrameInfo *ptr_frame_info)
{
f0104e7c:	55                   	push   %ebp
f0104e7d:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - disk_frames_info;
f0104e7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0104e82:	8b 15 44 e5 83 f0    	mov    0xf083e544,%edx
f0104e88:	29 d0                	sub    %edx,%eax
f0104e8a:	c1 f8 02             	sar    $0x2,%eax
f0104e8d:	89 c2                	mov    %eax,%edx
f0104e8f:	89 d0                	mov    %edx,%eax
f0104e91:	c1 e0 02             	shl    $0x2,%eax
f0104e94:	01 d0                	add    %edx,%eax
f0104e96:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0104e9d:	01 c8                	add    %ecx,%eax
f0104e9f:	01 c0                	add    %eax,%eax
f0104ea1:	01 d0                	add    %edx,%eax
f0104ea3:	89 c1                	mov    %eax,%ecx
f0104ea5:	c1 e1 08             	shl    $0x8,%ecx
f0104ea8:	01 c8                	add    %ecx,%eax
f0104eaa:	89 c1                	mov    %eax,%ecx
f0104eac:	c1 e1 10             	shl    $0x10,%ecx
f0104eaf:	01 c8                	add    %ecx,%eax
f0104eb1:	c1 e0 02             	shl    $0x2,%eax
f0104eb4:	01 d0                	add    %edx,%eax
}
f0104eb6:	5d                   	pop    %ebp
f0104eb7:	c3                   	ret    

f0104eb8 <allocate_disk_frame>:
// RETURNS
//   0 -- on success
//   E_NO_PAGE_FILE_SPACE -- otherwise
//
int allocate_disk_frame(uint32 *dfn)
{
f0104eb8:	55                   	push   %ebp
f0104eb9:	89 e5                	mov    %esp,%ebp
f0104ebb:	83 ec 18             	sub    $0x18,%esp
	int ret = 0;
f0104ebe:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104ec5:	83 ec 0c             	sub    $0xc,%esp
f0104ec8:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104ecd:	e8 a9 af 00 00       	call   f010fe7b <acquire_kspinlock>
f0104ed2:	83 c4 10             	add    $0x10,%esp
	{
		// Fill this function in
		struct FrameInfo *ptr_frame_info = LIST_FIRST(&DiskFrameLists.disk_free_frame_list);
f0104ed5:	a1 e0 6c 85 f0       	mov    0xf0856ce0,%eax
f0104eda:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if(ptr_frame_info == NULL)
f0104edd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104ee1:	75 0c                	jne    f0104eef <allocate_disk_frame+0x37>
		{
			ret = E_NO_PAGE_FILE_SPACE;
f0104ee3:	c7 45 f4 f8 ff ff ff 	movl   $0xfffffff8,-0xc(%ebp)
f0104eea:	e9 a2 00 00 00       	jmp    f0104f91 <allocate_disk_frame+0xd9>
		}
		else
		{
			LIST_REMOVE(&DiskFrameLists.disk_free_frame_list, ptr_frame_info);
f0104eef:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0104ef3:	75 14                	jne    f0104f09 <allocate_disk_frame+0x51>
f0104ef5:	83 ec 04             	sub    $0x4,%esp
f0104ef8:	68 07 e4 12 f0       	push   $0xf012e407
f0104efd:	6a 7d                	push   $0x7d
f0104eff:	68 b3 e3 12 f0       	push   $0xf012e3b3
f0104f04:	e8 a6 c0 ff ff       	call   f0100faf <_panic>
f0104f09:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f0c:	8b 00                	mov    (%eax),%eax
f0104f0e:	85 c0                	test   %eax,%eax
f0104f10:	74 10                	je     f0104f22 <allocate_disk_frame+0x6a>
f0104f12:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f15:	8b 00                	mov    (%eax),%eax
f0104f17:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104f1a:	8b 52 04             	mov    0x4(%edx),%edx
f0104f1d:	89 50 04             	mov    %edx,0x4(%eax)
f0104f20:	eb 0b                	jmp    f0104f2d <allocate_disk_frame+0x75>
f0104f22:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f25:	8b 40 04             	mov    0x4(%eax),%eax
f0104f28:	a3 e4 6c 85 f0       	mov    %eax,0xf0856ce4
f0104f2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f30:	8b 40 04             	mov    0x4(%eax),%eax
f0104f33:	85 c0                	test   %eax,%eax
f0104f35:	74 0f                	je     f0104f46 <allocate_disk_frame+0x8e>
f0104f37:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f3a:	8b 40 04             	mov    0x4(%eax),%eax
f0104f3d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0104f40:	8b 12                	mov    (%edx),%edx
f0104f42:	89 10                	mov    %edx,(%eax)
f0104f44:	eb 0a                	jmp    f0104f50 <allocate_disk_frame+0x98>
f0104f46:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f49:	8b 00                	mov    (%eax),%eax
f0104f4b:	a3 e0 6c 85 f0       	mov    %eax,0xf0856ce0
f0104f50:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f53:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0104f59:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0104f5c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0104f63:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0104f68:	48                   	dec    %eax
f0104f69:	a3 ec 6c 85 f0       	mov    %eax,0xf0856cec
			initialize_frame_info(ptr_frame_info);
f0104f6e:	83 ec 0c             	sub    $0xc,%esp
f0104f71:	ff 75 f0             	pushl  -0x10(%ebp)
f0104f74:	e8 ae 41 00 00       	call   f0109127 <initialize_frame_info>
f0104f79:	83 c4 10             	add    $0x10,%esp
			*dfn = to_disk_frame_number(ptr_frame_info);
f0104f7c:	83 ec 0c             	sub    $0xc,%esp
f0104f7f:	ff 75 f0             	pushl  -0x10(%ebp)
f0104f82:	e8 f5 fe ff ff       	call   f0104e7c <to_disk_frame_number>
f0104f87:	83 c4 10             	add    $0x10,%esp
f0104f8a:	89 c2                	mov    %eax,%edx
f0104f8c:	8b 45 08             	mov    0x8(%ebp),%eax
f0104f8f:	89 10                	mov    %edx,(%eax)
		}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0104f91:	83 ec 0c             	sub    $0xc,%esp
f0104f94:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104f99:	e8 82 af 00 00       	call   f010ff20 <release_kspinlock>
f0104f9e:	83 c4 10             	add    $0x10,%esp

	return ret;
f0104fa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0104fa4:	c9                   	leave  
f0104fa5:	c3                   	ret    

f0104fa6 <free_disk_frame>:

//
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
f0104fa6:	55                   	push   %ebp
f0104fa7:	89 e5                	mov    %esp,%ebp
f0104fa9:	53                   	push   %ebx
f0104faa:	83 ec 04             	sub    $0x4,%esp
	// Fill this function in
	if(dfn == 0) return;
f0104fad:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0104fb1:	0f 84 f0 00 00 00    	je     f01050a7 <free_disk_frame+0x101>
	acquire_kspinlock(&DiskFrameLists.dfllock);
f0104fb7:	83 ec 0c             	sub    $0xc,%esp
f0104fba:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0104fbf:	e8 b7 ae 00 00       	call   f010fe7b <acquire_kspinlock>
f0104fc4:	83 c4 10             	add    $0x10,%esp
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
f0104fc7:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104fcd:	8b 55 08             	mov    0x8(%ebp),%edx
f0104fd0:	89 d0                	mov    %edx,%eax
f0104fd2:	c1 e0 02             	shl    $0x2,%eax
f0104fd5:	01 d0                	add    %edx,%eax
f0104fd7:	c1 e0 02             	shl    $0x2,%eax
f0104fda:	01 c8                	add    %ecx,%eax
f0104fdc:	85 c0                	test   %eax,%eax
f0104fde:	75 17                	jne    f0104ff7 <free_disk_frame+0x51>
f0104fe0:	83 ec 04             	sub    $0x4,%esp
f0104fe3:	68 d0 e3 12 f0       	push   $0xf012e3d0
f0104fe8:	68 90 00 00 00       	push   $0x90
f0104fed:	68 b3 e3 12 f0       	push   $0xf012e3b3
f0104ff2:	e8 b8 bf ff ff       	call   f0100faf <_panic>
f0104ff7:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0104ffd:	8b 55 08             	mov    0x8(%ebp),%edx
f0105000:	89 d0                	mov    %edx,%eax
f0105002:	c1 e0 02             	shl    $0x2,%eax
f0105005:	01 d0                	add    %edx,%eax
f0105007:	c1 e0 02             	shl    $0x2,%eax
f010500a:	01 c8                	add    %ecx,%eax
f010500c:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0105012:	89 10                	mov    %edx,(%eax)
f0105014:	8b 00                	mov    (%eax),%eax
f0105016:	85 c0                	test   %eax,%eax
f0105018:	74 20                	je     f010503a <free_disk_frame+0x94>
f010501a:	8b 15 e0 6c 85 f0    	mov    0xf0856ce0,%edx
f0105020:	8b 1d 44 e5 83 f0    	mov    0xf083e544,%ebx
f0105026:	8b 4d 08             	mov    0x8(%ebp),%ecx
f0105029:	89 c8                	mov    %ecx,%eax
f010502b:	c1 e0 02             	shl    $0x2,%eax
f010502e:	01 c8                	add    %ecx,%eax
f0105030:	c1 e0 02             	shl    $0x2,%eax
f0105033:	01 d8                	add    %ebx,%eax
f0105035:	89 42 04             	mov    %eax,0x4(%edx)
f0105038:	eb 1a                	jmp    f0105054 <free_disk_frame+0xae>
f010503a:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0105040:	8b 55 08             	mov    0x8(%ebp),%edx
f0105043:	89 d0                	mov    %edx,%eax
f0105045:	c1 e0 02             	shl    $0x2,%eax
f0105048:	01 d0                	add    %edx,%eax
f010504a:	c1 e0 02             	shl    $0x2,%eax
f010504d:	01 c8                	add    %ecx,%eax
f010504f:	a3 e4 6c 85 f0       	mov    %eax,0xf0856ce4
f0105054:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f010505a:	8b 55 08             	mov    0x8(%ebp),%edx
f010505d:	89 d0                	mov    %edx,%eax
f010505f:	c1 e0 02             	shl    $0x2,%eax
f0105062:	01 d0                	add    %edx,%eax
f0105064:	c1 e0 02             	shl    $0x2,%eax
f0105067:	01 c8                	add    %ecx,%eax
f0105069:	a3 e0 6c 85 f0       	mov    %eax,0xf0856ce0
f010506e:	8b 0d 44 e5 83 f0    	mov    0xf083e544,%ecx
f0105074:	8b 55 08             	mov    0x8(%ebp),%edx
f0105077:	89 d0                	mov    %edx,%eax
f0105079:	c1 e0 02             	shl    $0x2,%eax
f010507c:	01 d0                	add    %edx,%eax
f010507e:	c1 e0 02             	shl    $0x2,%eax
f0105081:	01 c8                	add    %ecx,%eax
f0105083:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010508a:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f010508f:	40                   	inc    %eax
f0105090:	a3 ec 6c 85 f0       	mov    %eax,0xf0856cec
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0105095:	83 ec 0c             	sub    $0xc,%esp
f0105098:	68 f0 6c 85 f0       	push   $0xf0856cf0
f010509d:	e8 7e ae 00 00       	call   f010ff20 <release_kspinlock>
f01050a2:	83 c4 10             	add    $0x10,%esp
f01050a5:	eb 01                	jmp    f01050a8 <free_disk_frame+0x102>
// Return a frame to the disk_free_frame_list.
//
inline void free_disk_frame(uint32 dfn)
{
	// Fill this function in
	if(dfn == 0) return;
f01050a7:	90                   	nop
	acquire_kspinlock(&DiskFrameLists.dfllock);
	{
		LIST_INSERT_HEAD(&DiskFrameLists.disk_free_frame_list, &disk_frames_info[dfn]);
	}
	release_kspinlock(&DiskFrameLists.dfllock);
}
f01050a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01050ab:	c9                   	leave  
f01050ac:	c3                   	ret    

f01050ad <get_disk_page_table>:

int get_disk_page_table(uint32 *ptr_disk_page_directory, const uint32 virtual_address, int create, uint32 **ptr_disk_page_table)
{
f01050ad:	55                   	push   %ebp
f01050ae:	89 e5                	mov    %esp,%ebp
f01050b0:	53                   	push   %ebx
f01050b1:	83 ec 14             	sub    $0x14,%esp
	// Fill this function in
	uint32 disk_page_directory_entry = ptr_disk_page_directory[PDX(virtual_address)];
f01050b4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01050b7:	c1 e8 16             	shr    $0x16,%eax
f01050ba:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01050c1:	8b 45 08             	mov    0x8(%ebp),%eax
f01050c4:	01 d0                	add    %edx,%eax
f01050c6:	8b 00                	mov    (%eax),%eax
f01050c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f01050cb:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f01050d2:	77 1d                	ja     f01050f1 <get_disk_page_table+0x44>
	{
		*ptr_disk_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(disk_page_directory_entry));
f01050d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050d7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01050dc:	83 ec 0c             	sub    $0xc,%esp
f01050df:	50                   	push   %eax
f01050e0:	e8 85 4b 00 00       	call   f0109c6a <kheap_virtual_address>
f01050e5:	83 c4 10             	add    $0x10,%esp
f01050e8:	89 c2                	mov    %eax,%edx
f01050ea:	8b 45 14             	mov    0x14(%ebp),%eax
f01050ed:	89 10                	mov    %edx,(%eax)
f01050ef:	eb 44                	jmp    f0105135 <get_disk_page_table+0x88>
	}
	else
	{
		*ptr_disk_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(disk_page_directory_entry)) ;
f01050f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01050f4:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01050f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01050fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01050ff:	c1 e8 0c             	shr    $0xc,%eax
f0105102:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0105105:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f010510a:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f010510d:	72 17                	jb     f0105126 <get_disk_page_table+0x79>
f010510f:	ff 75 f0             	pushl  -0x10(%ebp)
f0105112:	68 28 e4 12 f0       	push   $0xf012e428
f0105117:	68 9f 00 00 00       	push   $0x9f
f010511c:	68 b3 e3 12 f0       	push   $0xf012e3b3
f0105121:	e8 89 be ff ff       	call   f0100faf <_panic>
f0105126:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105129:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010512e:	89 c2                	mov    %eax,%edx
f0105130:	8b 45 14             	mov    0x14(%ebp),%eax
f0105133:	89 10                	mov    %edx,(%eax)
	}

	if (disk_page_directory_entry == 0)
f0105135:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105139:	0f 85 80 00 00 00    	jne    f01051bf <get_disk_page_table+0x112>
	{
		//LOG_STATMENT(cprintf("get_disk_page_table: disk directory at %x",ptr_disk_page_directory));
		//LOG_STATMENT(cprintf("get_disk_page_table: page table not found "));
		if (create)
f010513f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0105143:	74 6a                	je     f01051af <get_disk_page_table+0x102>
		{

#if USE_KHEAP
			{
				*ptr_disk_page_table = (uint32*)kmalloc(PAGE_SIZE);
f0105145:	83 ec 0c             	sub    $0xc,%esp
f0105148:	68 00 10 00 00       	push   $0x1000
f010514d:	e8 e4 4a 00 00       	call   f0109c36 <kmalloc>
f0105152:	83 c4 10             	add    $0x10,%esp
f0105155:	89 c2                	mov    %eax,%edx
f0105157:	8b 45 14             	mov    0x14(%ebp),%eax
f010515a:	89 10                	mov    %edx,(%eax)
				if(*ptr_disk_page_table == NULL)
f010515c:	8b 45 14             	mov    0x14(%ebp),%eax
f010515f:	8b 00                	mov    (%eax),%eax
f0105161:	85 c0                	test   %eax,%eax
f0105163:	75 07                	jne    f010516c <get_disk_page_table+0xbf>
				{
					return E_NO_VM;
f0105165:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010516a:	eb 58                	jmp    f01051c4 <get_disk_page_table+0x117>
				}
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f010516c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010516f:	c1 e8 16             	shr    $0x16,%eax
f0105172:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105179:	8b 45 08             	mov    0x8(%ebp),%eax
f010517c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f010517f:	8b 45 14             	mov    0x14(%ebp),%eax
f0105182:	8b 00                	mov    (%eax),%eax
f0105184:	83 ec 0c             	sub    $0xc,%esp
f0105187:	50                   	push   %eax
f0105188:	e8 f7 4a 00 00       	call   f0109c84 <kheap_physical_address>
f010518d:	83 c4 10             	add    $0x10,%esp
f0105190:	83 c8 01             	or     $0x1,%eax
f0105193:	89 03                	mov    %eax,(%ebx)
				ptr_frame_info->references = 1;
				ptr_disk_page_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table,PERM_PRESENT);
			}
#endif
			//initialize new page table by 0's
			memset(*ptr_disk_page_table , 0, PAGE_SIZE);
f0105195:	8b 45 14             	mov    0x14(%ebp),%eax
f0105198:	8b 00                	mov    (%eax),%eax
f010519a:	83 ec 04             	sub    $0x4,%esp
f010519d:	68 00 10 00 00       	push   $0x1000
f01051a2:	6a 00                	push   $0x0
f01051a4:	50                   	push   %eax
f01051a5:	e8 bf 5b 01 00       	call   f011ad69 <memset>
f01051aa:	83 c4 10             	add    $0x10,%esp
f01051ad:	eb 10                	jmp    f01051bf <get_disk_page_table+0x112>
			//virtual_address, ptr_disk_page_directory[PDX(virtual_address)]));
		}
		else
		{
			//LOG_STATMENT(cprintf("NOT creating table ..."));
			*ptr_disk_page_table = 0;
f01051af:	8b 45 14             	mov    0x14(%ebp),%eax
f01051b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			return 0;
f01051b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01051bd:	eb 05                	jmp    f01051c4 <get_disk_page_table+0x117>
		}
	}
	//LOG_STATMENT(cprintf("found table at %x", *ptr_disk_page_table));
	return 0;
f01051bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01051c4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01051c7:	c9                   	leave  
f01051c8:	c3                   	ret    

f01051c9 <pf_add_empty_env_page>:

int pf_add_empty_env_page( struct Env* ptr_env, uint32 virtual_address, uint8 initializeByZero)
{
f01051c9:	55                   	push   %ebp
f01051ca:	89 e5                	mov    %esp,%ebp
f01051cc:	83 ec 28             	sub    $0x28,%esp
f01051cf:	8b 45 10             	mov    0x10(%ebp),%eax
f01051d2:	88 45 e4             	mov    %al,-0x1c(%ebp)
	//2016: FIX:
	if (initializeByZero)
f01051d5:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f01051d9:	74 72                	je     f010524d <pf_add_empty_env_page+0x84>
	{
		//2020
		if (virtual_address > USTACKBOTTOM && virtual_address < USTACKTOP - ptr_env->initNumStackPages * PAGE_SIZE)
f01051db:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f01051e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01051e5:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f01051ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01051ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01051f0:	ba 00 00 00 00       	mov    $0x0,%edx
f01051f5:	f7 75 f4             	divl   -0xc(%ebp)
f01051f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01051fb:	29 d0                	sub    %edx,%eax
f01051fd:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105200:	73 2f                	jae    f0105231 <pf_add_empty_env_page+0x68>
f0105202:	8b 45 08             	mov    0x8(%ebp),%eax
f0105205:	8b 50 6c             	mov    0x6c(%eax),%edx
f0105208:	b8 00 00 00 00       	mov    $0x0,%eax
f010520d:	29 d0                	sub    %edx,%eax
f010520f:	c1 e0 0c             	shl    $0xc,%eax
f0105212:	2d 00 20 40 11       	sub    $0x11402000,%eax
f0105217:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010521a:	76 15                	jbe    f0105231 <pf_add_empty_env_page+0x68>
			ptr_env->nNewPageAdded++ ;
f010521c:	8b 45 08             	mov    0x8(%ebp),%eax
f010521f:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f0105225:	8d 50 01             	lea    0x1(%eax),%edx
f0105228:	8b 45 08             	mov    0x8(%ebp),%eax
f010522b:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
		//======================
		return pf_add_env_page(ptr_env, virtual_address, ptr_zero_page);
f0105231:	a1 18 6b 85 f0       	mov    0xf0856b18,%eax
f0105236:	83 ec 04             	sub    $0x4,%esp
f0105239:	50                   	push   %eax
f010523a:	ff 75 0c             	pushl  0xc(%ebp)
f010523d:	ff 75 08             	pushl  0x8(%ebp)
f0105240:	e8 b2 00 00 00       	call   f01052f7 <pf_add_env_page>
f0105245:	83 c4 10             	add    $0x10,%esp
f0105248:	e9 a8 00 00 00       	jmp    f01052f5 <pf_add_empty_env_page+0x12c>
	}

	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f010524d:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0105254:	76 19                	jbe    f010526f <pf_add_empty_env_page+0xa6>
f0105256:	68 58 e4 12 f0       	push   $0xf012e458
f010525b:	68 7e e4 12 f0       	push   $0xf012e47e
f0105260:	68 de 00 00 00       	push   $0xde
f0105265:	68 b3 e3 12 f0       	push   $0xf012e3b3
f010526a:	e8 40 bd ff ff       	call   f0100faf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010526f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105272:	83 c0 74             	add    $0x74,%eax
f0105275:	83 ec 08             	sub    $0x8,%esp
f0105278:	50                   	push   %eax
f0105279:	ff 75 08             	pushl  0x8(%ebp)
f010527c:	e8 8f 05 00 00       	call   f0105810 <get_disk_page_directory>
f0105281:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0105284:	8b 45 08             	mov    0x8(%ebp),%eax
f0105287:	8b 40 74             	mov    0x74(%eax),%eax
f010528a:	8d 55 ec             	lea    -0x14(%ebp),%edx
f010528d:	52                   	push   %edx
f010528e:	6a 01                	push   $0x1
f0105290:	ff 75 0c             	pushl  0xc(%ebp)
f0105293:	50                   	push   %eax
f0105294:	e8 14 fe ff ff       	call   f01050ad <get_disk_page_table>
f0105299:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010529c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010529f:	8b 55 0c             	mov    0xc(%ebp),%edx
f01052a2:	c1 ea 0c             	shr    $0xc,%edx
f01052a5:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01052ab:	c1 e2 02             	shl    $0x2,%edx
f01052ae:	01 d0                	add    %edx,%eax
f01052b0:	8b 00                	mov    (%eax),%eax
f01052b2:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if( dfn == 0)
f01052b5:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01052b8:	85 c0                	test   %eax,%eax
f01052ba:	75 34                	jne    f01052f0 <pf_add_empty_env_page+0x127>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f01052bc:	83 ec 0c             	sub    $0xc,%esp
f01052bf:	8d 45 e8             	lea    -0x18(%ebp),%eax
f01052c2:	50                   	push   %eax
f01052c3:	e8 f0 fb ff ff       	call   f0104eb8 <allocate_disk_frame>
f01052c8:	83 c4 10             	add    $0x10,%esp
f01052cb:	83 f8 f8             	cmp    $0xfffffff8,%eax
f01052ce:	75 07                	jne    f01052d7 <pf_add_empty_env_page+0x10e>
f01052d0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f01052d5:	eb 1e                	jmp    f01052f5 <pf_add_empty_env_page+0x12c>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f01052d7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01052da:	8b 55 0c             	mov    0xc(%ebp),%edx
f01052dd:	c1 ea 0c             	shr    $0xc,%edx
f01052e0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01052e6:	c1 e2 02             	shl    $0x2,%edx
f01052e9:	01 c2                	add    %eax,%edx
f01052eb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01052ee:	89 02                	mov    %eax,(%edx)
	}

	return 0;
f01052f0:	b8 00 00 00 00       	mov    $0x0,%eax

}
f01052f5:	c9                   	leave  
f01052f6:	c3                   	ret    

f01052f7 <pf_add_env_page>:

int pf_add_env_page( struct Env* ptr_env, uint32 virtual_address, void* dataSrc)
{
f01052f7:	55                   	push   %ebp
f01052f8:	89 e5                	mov    %esp,%ebp
f01052fa:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	uint32 *ptr_disk_page_table;
	assert((uint32)virtual_address < KERNEL_BASE);
f01052fd:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f0105304:	76 19                	jbe    f010531f <pf_add_env_page+0x28>
f0105306:	68 58 e4 12 f0       	push   $0xf012e458
f010530b:	68 7e e4 12 f0       	push   $0xf012e47e
f0105310:	68 f3 00 00 00       	push   $0xf3
f0105315:	68 b3 e3 12 f0       	push   $0xf012e3b3
f010531a:	e8 90 bc ff ff       	call   f0100faf <_panic>

	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f010531f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105322:	83 c0 74             	add    $0x74,%eax
f0105325:	83 ec 08             	sub    $0x8,%esp
f0105328:	50                   	push   %eax
f0105329:	ff 75 08             	pushl  0x8(%ebp)
f010532c:	e8 df 04 00 00       	call   f0105810 <get_disk_page_directory>
f0105331:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir,  virtual_address, 1, &ptr_disk_page_table) ;
f0105334:	8b 45 08             	mov    0x8(%ebp),%eax
f0105337:	8b 40 74             	mov    0x74(%eax),%eax
f010533a:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010533d:	52                   	push   %edx
f010533e:	6a 01                	push   $0x1
f0105340:	ff 75 0c             	pushl  0xc(%ebp)
f0105343:	50                   	push   %eax
f0105344:	e8 64 fd ff ff       	call   f01050ad <get_disk_page_table>
f0105349:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f010534c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010534f:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105352:	c1 ea 0c             	shr    $0xc,%edx
f0105355:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010535b:	c1 e2 02             	shl    $0x2,%edx
f010535e:	01 d0                	add    %edx,%eax
f0105360:	8b 00                	mov    (%eax),%eax
f0105362:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if( dfn == 0)
f0105365:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105368:	85 c0                	test   %eax,%eax
f010536a:	75 34                	jne    f01053a0 <pf_add_env_page+0xa9>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f010536c:	83 ec 0c             	sub    $0xc,%esp
f010536f:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0105372:	50                   	push   %eax
f0105373:	e8 40 fb ff ff       	call   f0104eb8 <allocate_disk_frame>
f0105378:	83 c4 10             	add    $0x10,%esp
f010537b:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010537e:	75 07                	jne    f0105387 <pf_add_env_page+0x90>
f0105380:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0105385:	eb 31                	jmp    f01053b8 <pf_add_env_page+0xc1>
		ptr_disk_page_table[PTX(virtual_address)] = dfn;
f0105387:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010538a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010538d:	c1 ea 0c             	shr    $0xc,%edx
f0105390:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105396:	c1 e2 02             	shl    $0x2,%edx
f0105399:	01 c2                	add    %eax,%edx
f010539b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010539e:	89 02                	mov    %eax,(%edx)
	//	uint32 oldDir = rcr3();
	//	lcr3(K_PHYSICAL_ADDRESS(ptr_env->env_pgdir));
	//	int ret = write_disk_page(dfn, (void*)dataSrc);
	//	lcr3(oldDir);

	int ret = write_disk_page(dfn, (void*)dataSrc);
f01053a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01053a3:	83 ec 08             	sub    $0x8,%esp
f01053a6:	ff 75 10             	pushl  0x10(%ebp)
f01053a9:	50                   	push   %eax
f01053aa:	e8 3c f9 ff ff       	call   f0104ceb <write_disk_page>
f01053af:	83 c4 10             	add    $0x10,%esp
f01053b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ret;
f01053b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01053b8:	c9                   	leave  
f01053b9:	c3                   	ret    

f01053ba <pf_update_env_page>:

int pf_update_env_page(struct Env* ptr_env, uint32 virtual_address, struct FrameInfo* modified_page_frame_info)
{
f01053ba:	55                   	push   %ebp
f01053bb:	89 e5                	mov    %esp,%ebp
f01053bd:	83 ec 28             	sub    $0x28,%esp
	int ret;
	uint32 *ptr_disk_page_table;
	//ROUND DOWN it on 4 KB boundary in order to update the entire page starting from its first address.
	//virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);

	assert((uint32)virtual_address < KERNEL_BASE);
f01053c0:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01053c7:	76 19                	jbe    f01053e2 <pf_update_env_page+0x28>
f01053c9:	68 58 e4 12 f0       	push   $0xf012e458
f01053ce:	68 7e e4 12 f0       	push   $0xf012e47e
f01053d3:	68 15 01 00 00       	push   $0x115
f01053d8:	68 b3 e3 12 f0       	push   $0xf012e3b3
f01053dd:	e8 cd bb ff ff       	call   f0100faf <_panic>
	//char c = *((char*)virtual_address);
	//Get/Create the directory table
	get_disk_page_directory(ptr_env, &(ptr_env->disk_env_pgdir)) ;
f01053e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01053e5:	83 c0 74             	add    $0x74,%eax
f01053e8:	83 ec 08             	sub    $0x8,%esp
f01053eb:	50                   	push   %eax
f01053ec:	ff 75 08             	pushl  0x8(%ebp)
f01053ef:	e8 1c 04 00 00       	call   f0105810 <get_disk_page_directory>
f01053f4:	83 c4 10             	add    $0x10,%esp

	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01053f7:	8b 45 08             	mov    0x8(%ebp),%eax
f01053fa:	8b 40 74             	mov    0x74(%eax),%eax
f01053fd:	8d 55 e0             	lea    -0x20(%ebp),%edx
f0105400:	52                   	push   %edx
f0105401:	6a 00                	push   $0x0
f0105403:	ff 75 0c             	pushl  0xc(%ebp)
f0105406:	50                   	push   %eax
f0105407:	e8 a1 fc ff ff       	call   f01050ad <get_disk_page_table>
f010540c:	83 c4 10             	add    $0x10,%esp

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
f010540f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105412:	85 c0                	test   %eax,%eax
f0105414:	74 29                	je     f010543f <pf_update_env_page+0x85>
f0105416:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105419:	85 c0                	test   %eax,%eax
f010541b:	0f 84 bf 00 00 00    	je     f01054e0 <pf_update_env_page+0x126>
f0105421:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0105424:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105427:	c1 ea 0c             	shr    $0xc,%edx
f010542a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105430:	c1 e2 02             	shl    $0x2,%edx
f0105433:	01 d0                	add    %edx,%eax
f0105435:	8b 00                	mov    (%eax),%eax
f0105437:	85 c0                	test   %eax,%eax
f0105439:	0f 85 a1 00 00 00    	jne    f01054e0 <pf_update_env_page+0x126>
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f010543f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105442:	85 c0                	test   %eax,%eax
f0105444:	79 09                	jns    f010544f <pf_update_env_page+0x95>
f0105446:	81 7d 0c ff ff ff 9f 	cmpl   $0x9fffffff,0xc(%ebp)
f010544d:	76 30                	jbe    f010547f <pf_update_env_page+0xc5>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f010544f:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
f0105456:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105459:	2d 01 e0 f9 5f       	sub    $0x5ff9e001,%eax
f010545e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0105461:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105464:	ba 00 00 00 00       	mov    $0x0,%edx
f0105469:	f7 75 f4             	divl   -0xc(%ebp)
f010546c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010546f:	29 d0                	sub    %edx,%eax

	//2022
	if(ptr_disk_page_table == NULL || (ptr_disk_page_table != NULL && ptr_disk_page_table[PTX(virtual_address)]== 0))
	{

		if ((virtual_address >= USER_HEAP_START && virtual_address < USER_HEAP_MAX) ||
f0105471:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0105474:	77 53                	ja     f01054c9 <pf_update_env_page+0x10f>
				(virtual_address >= USTACKBOTTOM && virtual_address < USTACKTOP))
f0105476:	81 7d 0c ff df bf ee 	cmpl   $0xeebfdfff,0xc(%ebp)
f010547d:	77 4a                	ja     f01054c9 <pf_update_env_page+0x10f>
			//				return ret ;
			//			}
			//			//Else, just add a new empty page to the page file, then update it with the given modified_page_frame_info in the below code
			//			else
			{
				ret = pf_add_empty_env_page(ptr_env, virtual_address, 0);
f010547f:	83 ec 04             	sub    $0x4,%esp
f0105482:	6a 00                	push   $0x0
f0105484:	ff 75 0c             	pushl  0xc(%ebp)
f0105487:	ff 75 08             	pushl  0x8(%ebp)
f010548a:	e8 3a fd ff ff       	call   f01051c9 <pf_add_empty_env_page>
f010548f:	83 c4 10             	add    $0x10,%esp
f0105492:	89 45 ec             	mov    %eax,-0x14(%ebp)

				if (ret == E_NO_PAGE_FILE_SPACE)
f0105495:	83 7d ec f8          	cmpl   $0xfffffff8,-0x14(%ebp)
f0105499:	75 17                	jne    f01054b2 <pf_update_env_page+0xf8>
				{
					panic("pf_update_env_page: attempt to add a new page, but page file out of space!") ;
f010549b:	83 ec 04             	sub    $0x4,%esp
f010549e:	68 94 e4 12 f0       	push   $0xf012e494
f01054a3:	68 45 01 00 00       	push   $0x145
f01054a8:	68 b3 e3 12 f0       	push   $0xf012e3b3
f01054ad:	e8 fd ba ff ff       	call   f0100faf <_panic>
				}
				//cprintf("[%s] adding EMPTY page with content\n",ptr_env->prog_name);

				ptr_env->nNewPageAdded++ ;
f01054b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01054b5:	8b 80 bc 05 00 00    	mov    0x5bc(%eax),%eax
f01054bb:	8d 50 01             	lea    0x1(%eax),%edx
f01054be:	8b 45 08             	mov    0x8(%ebp),%eax
f01054c1:	89 90 bc 05 00 00    	mov    %edx,0x5bc(%eax)
f01054c7:	eb 17                	jmp    f01054e0 <pf_update_env_page+0x126>
			}
		}
		else
		{
			panic("pf_update_env_page: Invalid Access - Attempt to add a new page to page file that's outside the USER HEAP and USER STACK!");
f01054c9:	83 ec 04             	sub    $0x4,%esp
f01054cc:	68 e0 e4 12 f0       	push   $0xf012e4e0
f01054d1:	68 4e 01 00 00       	push   $0x14e
f01054d6:	68 b3 e3 12 f0       	push   $0xf012e3b3
f01054db:	e8 cf ba ff ff       	call   f0100faf <_panic>
		}
	}
	//2022 END========================================


	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f01054e0:	8b 45 08             	mov    0x8(%ebp),%eax
f01054e3:	8b 40 74             	mov    0x74(%eax),%eax
f01054e6:	8d 55 e0             	lea    -0x20(%ebp),%edx
f01054e9:	52                   	push   %edx
f01054ea:	6a 00                	push   $0x0
f01054ec:	ff 75 0c             	pushl  0xc(%ebp)
f01054ef:	50                   	push   %eax
f01054f0:	e8 b8 fb ff ff       	call   f01050ad <get_disk_page_table>
f01054f5:	83 c4 10             	add    $0x10,%esp
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01054f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01054fb:	8b 55 0c             	mov    0xc(%ebp),%edx
f01054fe:	c1 ea 0c             	shr    $0xc,%edx
f0105501:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105507:	c1 e2 02             	shl    $0x2,%edx
f010550a:	01 d0                	add    %edx,%eax
f010550c:	8b 00                	mov    (%eax),%eax
f010550e:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//FIX'24 (el7): due to concurrency issues in 1-1 thread model, using the USER_LIMIT as a temp loc
		//				will lead to concurrency problems since it's shared among processes.
		//				Instead, use PGFLTEMP as a local temporarily page at user space for this mapping
		//				to do temp initialization of a frame.
		map_frame(ptr_env->env_page_directory, modified_page_frame_info, (uint32)PGFLTEMP, 0);
f0105511:	8b 45 08             	mov    0x8(%ebp),%eax
f0105514:	8b 40 64             	mov    0x64(%eax),%eax
f0105517:	6a 00                	push   $0x0
f0105519:	68 00 f0 3f 00       	push   $0x3ff000
f010551e:	ff 75 10             	pushl  0x10(%ebp)
f0105521:	50                   	push   %eax
f0105522:	e8 bc 40 00 00       	call   f01095e3 <map_frame>
f0105527:	83 c4 10             	add    $0x10,%esp

		ret = write_disk_page(dfn, (void*)ROUNDDOWN((uint32)PGFLTEMP, PAGE_SIZE));
f010552a:	c7 45 e4 00 f0 3f 00 	movl   $0x3ff000,-0x1c(%ebp)
f0105531:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105534:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0105539:	83 ec 08             	sub    $0x8,%esp
f010553c:	50                   	push   %eax
f010553d:	ff 75 e8             	pushl  -0x18(%ebp)
f0105540:	e8 a6 f7 ff ff       	call   f0104ceb <write_disk_page>
f0105545:	83 c4 10             	add    $0x10,%esp
f0105548:	89 45 ec             	mov    %eax,-0x14(%ebp)

		// TEMPORARILY increase the references to prevent unmap_frame from removing the frame
		modified_page_frame_info->references += 1;
f010554b:	8b 45 10             	mov    0x10(%ebp),%eax
f010554e:	8b 40 08             	mov    0x8(%eax),%eax
f0105551:	40                   	inc    %eax
f0105552:	8b 55 10             	mov    0x10(%ebp),%edx
f0105555:	66 89 42 08          	mov    %ax,0x8(%edx)
		unmap_frame(ptr_env->env_page_directory, (uint32)PGFLTEMP);
f0105559:	8b 45 08             	mov    0x8(%ebp),%eax
f010555c:	8b 40 64             	mov    0x64(%eax),%eax
f010555f:	83 ec 08             	sub    $0x8,%esp
f0105562:	68 00 f0 3f 00       	push   $0x3ff000
f0105567:	50                   	push   %eax
f0105568:	e8 e2 41 00 00       	call   f010974f <unmap_frame>
f010556d:	83 c4 10             	add    $0x10,%esp
		// Return it to its original status
		modified_page_frame_info->references -= 1;
f0105570:	8b 45 10             	mov    0x10(%ebp),%eax
f0105573:	8b 40 08             	mov    0x8(%eax),%eax
f0105576:	48                   	dec    %eax
f0105577:	8b 55 10             	mov    0x10(%ebp),%edx
f010557a:	66 89 42 08          	mov    %ax,0x8(%edx)
		ret = write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(modified_page_frame_info)));
		//cprintf("[%s] finished updating page\n",ptr_env->prog_name);
	}
#endif
	//2020
	ptr_env->nPageOut++ ;
f010557e:	8b 45 08             	mov    0x8(%ebp),%eax
f0105581:	8b 80 b8 05 00 00    	mov    0x5b8(%eax),%eax
f0105587:	8d 50 01             	lea    0x1(%eax),%edx
f010558a:	8b 45 08             	mov    0x8(%ebp),%eax
f010558d:	89 90 b8 05 00 00    	mov    %edx,0x5b8(%eax)
	//======================

	return ret;
f0105593:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105596:	c9                   	leave  
f0105597:	c3                   	ret    

f0105598 <pf_read_env_page>:

	return write_disk_page(dfn, STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(page_modified_frame_info)));
}
 */
int pf_read_env_page(struct Env* ptr_env, void* virtual_address)
{
f0105598:	55                   	push   %ebp
f0105599:	89 e5                	mov    %esp,%ebp
f010559b:	83 ec 18             	sub    $0x18,%esp
	uint32 *ptr_disk_page_table;

	//ROUND DOWN it on 4 KB boundary in order to read the entire page starting from its first address.
	virtual_address = ROUNDDOWN(virtual_address, PAGE_SIZE);
f010559e:	8b 45 0c             	mov    0xc(%ebp),%eax
f01055a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01055a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01055a7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01055ac:	89 45 0c             	mov    %eax,0xc(%ebp)

	if( ptr_env->disk_env_pgdir == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01055af:	8b 45 08             	mov    0x8(%ebp),%eax
f01055b2:	8b 40 74             	mov    0x74(%eax),%eax
f01055b5:	85 c0                	test   %eax,%eax
f01055b7:	75 0a                	jne    f01055c3 <pf_read_env_page+0x2b>
f01055b9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01055be:	e9 90 00 00 00       	jmp    f0105653 <pf_read_env_page+0xbb>

	get_disk_page_table(ptr_env->disk_env_pgdir, (uint32) virtual_address, 0, &ptr_disk_page_table);
f01055c3:	8b 55 0c             	mov    0xc(%ebp),%edx
f01055c6:	8b 45 08             	mov    0x8(%ebp),%eax
f01055c9:	8b 40 74             	mov    0x74(%eax),%eax
f01055cc:	8d 4d e8             	lea    -0x18(%ebp),%ecx
f01055cf:	51                   	push   %ecx
f01055d0:	6a 00                	push   $0x0
f01055d2:	52                   	push   %edx
f01055d3:	50                   	push   %eax
f01055d4:	e8 d4 fa ff ff       	call   f01050ad <get_disk_page_table>
f01055d9:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return E_PAGE_NOT_EXIST_IN_PF;
f01055dc:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01055df:	85 c0                	test   %eax,%eax
f01055e1:	75 07                	jne    f01055ea <pf_read_env_page+0x52>
f01055e3:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f01055e8:	eb 69                	jmp    f0105653 <pf_read_env_page+0xbb>

	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f01055ea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01055ed:	8b 55 0c             	mov    0xc(%ebp),%edx
f01055f0:	c1 ea 0c             	shr    $0xc,%edx
f01055f3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01055f9:	c1 e2 02             	shl    $0x2,%edx
f01055fc:	01 d0                	add    %edx,%eax
f01055fe:	8b 00                	mov    (%eax),%eax
f0105600:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if( dfn == 0) return E_PAGE_NOT_EXIST_IN_PF;
f0105603:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0105607:	75 07                	jne    f0105610 <pf_read_env_page+0x78>
f0105609:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
f010560e:	eb 43                	jmp    f0105653 <pf_read_env_page+0xbb>

	int disk_read_error = read_disk_page(dfn, virtual_address);
f0105610:	83 ec 08             	sub    $0x8,%esp
f0105613:	ff 75 0c             	pushl  0xc(%ebp)
f0105616:	ff 75 f0             	pushl  -0x10(%ebp)
f0105619:	e8 9e f6 ff ff       	call   f0104cbc <read_disk_page>
f010561e:	83 c4 10             	add    $0x10,%esp
f0105621:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//reset modified bit to 0: because FOS copies the placed or replaced page from
	//HD to memory, the page modified bit is set to 1, but we want the modified bit to be
	// affected only by "user code" modifications, not our (FOS kernel) modifications
	pt_set_page_permissions(ptr_env->env_page_directory, (uint32)virtual_address, 0, PERM_MODIFIED);
f0105624:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105627:	8b 45 08             	mov    0x8(%ebp),%eax
f010562a:	8b 40 64             	mov    0x64(%eax),%eax
f010562d:	6a 40                	push   $0x40
f010562f:	6a 00                	push   $0x0
f0105631:	52                   	push   %edx
f0105632:	50                   	push   %eax
f0105633:	e8 c7 46 00 00       	call   f0109cff <pt_set_page_permissions>
f0105638:	83 c4 10             	add    $0x10,%esp

	//2020
	ptr_env->nPageIn++ ;
f010563b:	8b 45 08             	mov    0x8(%ebp),%eax
f010563e:	8b 80 b4 05 00 00    	mov    0x5b4(%eax),%eax
f0105644:	8d 50 01             	lea    0x1(%eax),%edx
f0105647:	8b 45 08             	mov    0x8(%ebp),%eax
f010564a:	89 90 b4 05 00 00    	mov    %edx,0x5b4(%eax)
	//======================

	return disk_read_error;
f0105650:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105653:	c9                   	leave  
f0105654:	c3                   	ret    

f0105655 <pf_remove_env_page>:

void pf_remove_env_page(struct Env* ptr_env, uint32 virtual_address)
{
f0105655:	55                   	push   %ebp
f0105656:	89 e5                	mov    %esp,%ebp
f0105658:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f010565b:	8b 45 08             	mov    0x8(%ebp),%eax
f010565e:	8b 40 74             	mov    0x74(%eax),%eax
f0105661:	85 c0                	test   %eax,%eax
f0105663:	74 62                	je     f01056c7 <pf_remove_env_page+0x72>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
f0105665:	8b 45 08             	mov    0x8(%ebp),%eax
f0105668:	8b 40 74             	mov    0x74(%eax),%eax
f010566b:	8d 55 f0             	lea    -0x10(%ebp),%edx
f010566e:	52                   	push   %edx
f010566f:	6a 00                	push   $0x0
f0105671:	ff 75 0c             	pushl  0xc(%ebp)
f0105674:	50                   	push   %eax
f0105675:	e8 33 fa ff ff       	call   f01050ad <get_disk_page_table>
f010567a:	83 c4 10             	add    $0x10,%esp
	if(ptr_disk_page_table == 0) return;
f010567d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105680:	85 c0                	test   %eax,%eax
f0105682:	74 46                	je     f01056ca <pf_remove_env_page+0x75>

	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
f0105684:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105687:	8b 55 0c             	mov    0xc(%ebp),%edx
f010568a:	c1 ea 0c             	shr    $0xc,%edx
f010568d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0105693:	c1 e2 02             	shl    $0x2,%edx
f0105696:	01 d0                	add    %edx,%eax
f0105698:	8b 00                	mov    (%eax),%eax
f010569a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_disk_page_table[PTX(virtual_address)] = 0;
f010569d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01056a0:	8b 55 0c             	mov    0xc(%ebp),%edx
f01056a3:	c1 ea 0c             	shr    $0xc,%edx
f01056a6:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01056ac:	c1 e2 02             	shl    $0x2,%edx
f01056af:	01 d0                	add    %edx,%eax
f01056b1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f01056b7:	83 ec 0c             	sub    $0xc,%esp
f01056ba:	ff 75 f4             	pushl  -0xc(%ebp)
f01056bd:	e8 e4 f8 ff ff       	call   f0104fa6 <free_disk_frame>
f01056c2:	83 c4 10             	add    $0x10,%esp
f01056c5:	eb 04                	jmp    f01056cb <pf_remove_env_page+0x76>
{
	//LOG_STRING("pf_remove_env_page: 0");
	uint32 *ptr_disk_page_table;

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_pgdir == 0) return;
f01056c7:	90                   	nop
f01056c8:	eb 01                	jmp    f01056cb <pf_remove_env_page+0x76>

	//LOG_STRING("pf_remove_env_page: 1");
	get_disk_page_table(ptr_env->disk_env_pgdir, virtual_address, 0, &ptr_disk_page_table);
	if(ptr_disk_page_table == 0) return;
f01056ca:	90                   	nop
	//LOG_STRING("pf_remove_env_page: 2");
	uint32 dfn=ptr_disk_page_table[PTX(virtual_address)];
	ptr_disk_page_table[PTX(virtual_address)] = 0;
	free_disk_frame(dfn);
	//LOG_STRING("pf_remove_env_page: 3");
}
f01056cb:	c9                   	leave  
f01056cc:	c3                   	ret    

f01056cd <pf_free_env>:

void pf_free_env(struct Env* ptr_env)
{
f01056cd:	55                   	push   %ebp
f01056ce:	89 e5                	mov    %esp,%ebp
f01056d0:	83 ec 28             	sub    $0x28,%esp
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f01056d3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01056da:	e9 b8 00 00 00       	jmp    f0105797 <pf_free_env+0xca>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
f01056df:	8b 45 08             	mov    0x8(%ebp),%eax
f01056e2:	8b 40 74             	mov    0x74(%eax),%eax
f01056e5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01056e8:	c1 e2 02             	shl    $0x2,%edx
f01056eb:	01 d0                	add    %edx,%eax
f01056ed:	8b 00                	mov    (%eax),%eax
f01056ef:	83 e0 01             	and    $0x1,%eax
f01056f2:	85 c0                	test   %eax,%eax
f01056f4:	0f 84 99 00 00 00    	je     f0105793 <pf_free_env+0xc6>
			continue;

		// find the pa and va of the page table
		uint32 pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdeno]);
f01056fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01056fd:	8b 40 74             	mov    0x74(%eax),%eax
f0105700:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105703:	c1 e2 02             	shl    $0x2,%edx
f0105706:	01 d0                	add    %edx,%eax
f0105708:	8b 00                	mov    (%eax),%eax
f010570a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010570f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		uint32 *pt;
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f0105712:	83 ec 0c             	sub    $0xc,%esp
f0105715:	ff 75 ec             	pushl  -0x14(%ebp)
f0105718:	e8 4d 45 00 00       	call   f0109c6a <kheap_virtual_address>
f010571d:	83 c4 10             	add    $0x10,%esp
f0105720:	89 45 e8             	mov    %eax,-0x18(%ebp)
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0105723:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010572a:	eb 3a                	jmp    f0105766 <pf_free_env+0x99>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[pteno];
f010572c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010572f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0105736:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105739:	01 d0                	add    %edx,%eax
f010573b:	8b 00                	mov    (%eax),%eax
f010573d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			pt[pteno] = 0;
f0105740:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105743:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010574a:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010574d:	01 d0                	add    %edx,%eax
f010574f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			// and declare it free
			free_disk_frame(dfn);
f0105755:	83 ec 0c             	sub    $0xc,%esp
f0105758:	ff 75 e4             	pushl  -0x1c(%ebp)
f010575b:	e8 46 f8 ff ff       	call   f0104fa6 <free_disk_frame>
f0105760:	83 c4 10             	add    $0x10,%esp
			pt = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(pa);
		}
#endif
		// unmap all PTEs in this page table
		uint32 pteno;
		for (pteno = 0; pteno < 1024; pteno++)
f0105763:	ff 45 f0             	incl   -0x10(%ebp)
f0105766:	81 7d f0 ff 03 00 00 	cmpl   $0x3ff,-0x10(%ebp)
f010576d:	76 bd                	jbe    f010572c <pf_free_env+0x5f>
			// and declare it free
			free_disk_frame(dfn);
		}

		// free the disk page table itself
		ptr_env->disk_env_pgdir[pdeno] = 0;
f010576f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105772:	8b 40 74             	mov    0x74(%eax),%eax
f0105775:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105778:	c1 e2 02             	shl    $0x2,%edx
f010577b:	01 d0                	add    %edx,%eax
f010577d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
#if USE_KHEAP
		{
			kfree(pt);
f0105783:	83 ec 0c             	sub    $0xc,%esp
f0105786:	ff 75 e8             	pushl  -0x18(%ebp)
f0105789:	e8 c2 44 00 00       	call   f0109c50 <kfree>
f010578e:	83 c4 10             	add    $0x10,%esp
f0105791:	eb 01                	jmp    f0105794 <pf_free_env+0xc7>

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdeno] & PERM_PRESENT))
			continue;
f0105793:	90                   	nop

void pf_free_env(struct Env* ptr_env)
{
	uint32 pdeno;

	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105794:	ff 45 f4             	incl   -0xc(%ebp)
f0105797:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010579e:	0f 86 3b ff ff ff    	jbe    f01056df <pf_free_env+0x12>
	}

	// free the disk page directory of the environment
#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_pgdir);
f01057a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01057a7:	8b 40 74             	mov    0x74(%eax),%eax
f01057aa:	83 ec 0c             	sub    $0xc,%esp
f01057ad:	50                   	push   %eax
f01057ae:	e8 9d 44 00 00       	call   f0109c50 <kfree>
f01057b3:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_pgdir_PA));
	}
#endif
	ptr_env->disk_env_pgdir = 0;
f01057b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01057b9:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	ptr_env->disk_env_pgdir_PA = 0;
f01057c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01057c3:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
f01057ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01057cd:	8b 40 7c             	mov    0x7c(%eax),%eax
f01057d0:	85 c0                	test   %eax,%eax
f01057d2:	74 39                	je     f010580d <pf_free_env+0x140>
		return;
	__pf_remove_env_all_tables(ptr_env);
f01057d4:	83 ec 0c             	sub    $0xc,%esp
f01057d7:	ff 75 08             	pushl  0x8(%ebp)
f01057da:	e8 f1 02 00 00       	call   f0105ad0 <__pf_remove_env_all_tables>
f01057df:	83 c4 10             	add    $0x10,%esp


#if USE_KHEAP
	{
		kfree(ptr_env->disk_env_tabledir);
f01057e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01057e5:	8b 40 7c             	mov    0x7c(%eax),%eax
f01057e8:	83 ec 0c             	sub    $0xc,%esp
f01057eb:	50                   	push   %eax
f01057ec:	e8 5f 44 00 00       	call   f0109c50 <kfree>
f01057f1:	83 c4 10             	add    $0x10,%esp
#else
	{
		decrement_references(to_frame_info(ptr_env->disk_env_tabledir_PA));
	}
#endif
	ptr_env->disk_env_tabledir = 0;
f01057f4:	8b 45 08             	mov    0x8(%ebp),%eax
f01057f7:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	ptr_env->disk_env_tabledir_PA = 0;
f01057fe:	8b 45 08             	mov    0x8(%ebp),%eax
f0105801:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f0105808:	00 00 00 
f010580b:	eb 01                	jmp    f010580e <pf_free_env+0x141>
	ptr_env->disk_env_pgdir_PA = 0;


	// remove all tables and the disk table
	if (ptr_env->disk_env_tabledir == 0)
		return;
f010580d:	90                   	nop
	}
#endif
	ptr_env->disk_env_tabledir = 0;
	ptr_env->disk_env_tabledir_PA = 0;

}
f010580e:	c9                   	leave  
f010580f:	c3                   	ret    

f0105810 <get_disk_page_directory>:


int get_disk_page_directory(struct Env* ptr_env, uint32** ptr_disk_page_directory)
{
f0105810:	55                   	push   %ebp
f0105811:	89 e5                	mov    %esp,%ebp
f0105813:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_page_directory = ptr_env->disk_env_pgdir;
f0105816:	8b 45 08             	mov    0x8(%ebp),%eax
f0105819:	8b 50 74             	mov    0x74(%eax),%edx
f010581c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010581f:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_page_directory == 0)
f0105821:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105824:	8b 00                	mov    (%eax),%eax
f0105826:	85 c0                	test   %eax,%eax
f0105828:	75 58                	jne    f0105882 <get_disk_page_directory+0x72>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_page_directory = kmalloc(PAGE_SIZE);
f010582a:	83 ec 0c             	sub    $0xc,%esp
f010582d:	68 00 10 00 00       	push   $0x1000
f0105832:	e8 ff 43 00 00       	call   f0109c36 <kmalloc>
f0105837:	83 c4 10             	add    $0x10,%esp
f010583a:	89 c2                	mov    %eax,%edx
f010583c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010583f:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_page_directory == NULL)
f0105841:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105844:	8b 00                	mov    (%eax),%eax
f0105846:	85 c0                	test   %eax,%eax
f0105848:	75 07                	jne    f0105851 <get_disk_page_directory+0x41>
			{
				return E_NO_VM;
f010584a:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010584f:	eb 36                	jmp    f0105887 <get_disk_page_directory+0x77>
			}
			ptr_env->disk_env_pgdir_PA = kheap_physical_address((unsigned int)*ptr_disk_page_directory);
f0105851:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105854:	8b 00                	mov    (%eax),%eax
f0105856:	83 ec 0c             	sub    $0xc,%esp
f0105859:	50                   	push   %eax
f010585a:	e8 25 44 00 00       	call   f0109c84 <kheap_physical_address>
f010585f:	83 c4 10             	add    $0x10,%esp
f0105862:	89 c2                	mov    %eax,%edx
f0105864:	8b 45 08             	mov    0x8(%ebp),%eax
f0105867:	89 50 78             	mov    %edx,0x78(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_page_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_pgdir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_page_directory , 0, PAGE_SIZE);
f010586a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010586d:	8b 00                	mov    (%eax),%eax
f010586f:	83 ec 04             	sub    $0x4,%esp
f0105872:	68 00 10 00 00       	push   $0x1000
f0105877:	6a 00                	push   $0x0
f0105879:	50                   	push   %eax
f010587a:	e8 ea 54 01 00       	call   f011ad69 <memset>
f010587f:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f0105882:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0105887:	c9                   	leave  
f0105888:	c3                   	ret    

f0105889 <pf_calculate_allocated_pages>:

int pf_calculate_allocated_pages(struct Env* ptr_env)
{
f0105889:	55                   	push   %ebp
f010588a:	89 e5                	mov    %esp,%ebp
f010588c:	83 ec 28             	sub    $0x28,%esp
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;
f010588f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0105896:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010589d:	eb 78                	jmp    f0105917 <pf_calculate_allocated_pages+0x8e>
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
f010589f:	8b 45 08             	mov    0x8(%ebp),%eax
f01058a2:	8b 40 74             	mov    0x74(%eax),%eax
f01058a5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058a8:	c1 e2 02             	shl    $0x2,%edx
f01058ab:	01 d0                	add    %edx,%eax
f01058ad:	8b 00                	mov    (%eax),%eax
f01058af:	83 e0 01             	and    $0x1,%eax
f01058b2:	85 c0                	test   %eax,%eax
f01058b4:	74 5d                	je     f0105913 <pf_calculate_allocated_pages+0x8a>
			continue;

		// find the pa and va of the page table
		pa = EXTRACT_ADDRESS(ptr_env->disk_env_pgdir[pdIndex]);
f01058b6:	8b 45 08             	mov    0x8(%ebp),%eax
f01058b9:	8b 40 74             	mov    0x74(%eax),%eax
f01058bc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01058bf:	c1 e2 02             	shl    $0x2,%edx
f01058c2:	01 d0                	add    %edx,%eax
f01058c4:	8b 00                	mov    (%eax),%eax
f01058c6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01058cb:	89 45 e8             	mov    %eax,-0x18(%ebp)
#if USE_KHEAP
		{
			pt = (uint32*) kheap_virtual_address(pa);
f01058ce:	83 ec 0c             	sub    $0xc,%esp
f01058d1:	ff 75 e8             	pushl  -0x18(%ebp)
f01058d4:	e8 91 43 00 00       	call   f0109c6a <kheap_virtual_address>
f01058d9:	83 c4 10             	add    $0x10,%esp
f01058dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f01058df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01058e6:	eb 20                	jmp    f0105908 <pf_calculate_allocated_pages+0x7f>
		{
			// remove the disk page from disk page table
			uint32 dfn=pt[ptIndex];
f01058e8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01058eb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01058f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01058f5:	01 d0                	add    %edx,%eax
f01058f7:	8b 00                	mov    (%eax),%eax
f01058f9:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if(dfn != 0)
f01058fc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0105900:	74 03                	je     f0105905 <pf_calculate_allocated_pages+0x7c>
				counter ++;
f0105902:	ff 45 f0             	incl   -0x10(%ebp)
		}
#endif

		// unmap all PTEs in this page table
		uint32 ptIndex;
		for (ptIndex = 0; ptIndex < 1024; ptIndex++)
f0105905:	ff 45 ec             	incl   -0x14(%ebp)
f0105908:	81 7d ec ff 03 00 00 	cmpl   $0x3ff,-0x14(%ebp)
f010590f:	76 d7                	jbe    f01058e8 <pf_calculate_allocated_pages+0x5f>
f0105911:	eb 01                	jmp    f0105914 <pf_calculate_allocated_pages+0x8b>

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
	{
		// only look at mapped page tables
		if (!(ptr_env->disk_env_pgdir[pdIndex] & PERM_PRESENT))
			continue;
f0105913:	90                   	nop
	uint32 *pt;
	uint32 pdIndex;
	uint32 pa;
	uint32 counter=0;

	for (pdIndex = 0; pdIndex < PDX(USER_TOP) ; pdIndex++)
f0105914:	ff 45 f4             	incl   -0xc(%ebp)
f0105917:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f010591e:	0f 86 7b ff ff ff    	jbe    f010589f <pf_calculate_allocated_pages+0x16>
			if(dfn != 0)
				counter ++;
		}
	}

	return counter;
f0105924:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0105927:	c9                   	leave  
f0105928:	c3                   	ret    

f0105929 <pf_calculate_free_frames>:

//2016:
//calculate the disk free frames from the disk free frame list
int pf_calculate_free_frames()
{
f0105929:	55                   	push   %ebp
f010592a:	89 e5                	mov    %esp,%ebp
f010592c:	83 ec 18             	sub    $0x18,%esp
	uint32 totalFreeDiskFrames ;
	acquire_kspinlock(&DiskFrameLists.dfllock);
f010592f:	83 ec 0c             	sub    $0xc,%esp
f0105932:	68 f0 6c 85 f0       	push   $0xf0856cf0
f0105937:	e8 3f a5 00 00       	call   f010fe7b <acquire_kspinlock>
f010593c:	83 c4 10             	add    $0x10,%esp
	{
		/*2023: UPDATE beased on suggestion from T112 2023.Term1*/
		totalFreeDiskFrames = LIST_SIZE(&DiskFrameLists.disk_free_frame_list);
f010593f:	a1 ec 6c 85 f0       	mov    0xf0856cec,%eax
f0105944:	89 45 f4             	mov    %eax,-0xc(%ebp)
		//	LIST_FOREACH(ptr, &disk_free_frame_list)
		//	{
		//		totalFreeDiskFrames++ ;
		//	}
	}
	release_kspinlock(&DiskFrameLists.dfllock);
f0105947:	83 ec 0c             	sub    $0xc,%esp
f010594a:	68 f0 6c 85 f0       	push   $0xf0856cf0
f010594f:	e8 cc a5 00 00       	call   f010ff20 <release_kspinlock>
f0105954:	83 c4 10             	add    $0x10,%esp
	return totalFreeDiskFrames;
f0105957:	8b 45 f4             	mov    -0xc(%ebp),%eax

}
f010595a:	c9                   	leave  
f010595b:	c3                   	ret    

f010595c <get_disk_table_directory>:



/*========================== TABLE FILE MANAGMENT ==============================*/
int get_disk_table_directory(struct Env* ptr_env, uint32** ptr_disk_table_directory)
{
f010595c:	55                   	push   %ebp
f010595d:	89 e5                	mov    %esp,%ebp
f010595f:	83 ec 08             	sub    $0x8,%esp
	*ptr_disk_table_directory = ptr_env->disk_env_tabledir;
f0105962:	8b 45 08             	mov    0x8(%ebp),%eax
f0105965:	8b 50 7c             	mov    0x7c(%eax),%edx
f0105968:	8b 45 0c             	mov    0xc(%ebp),%eax
f010596b:	89 10                	mov    %edx,(%eax)
	if(*ptr_disk_table_directory == 0)
f010596d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105970:	8b 00                	mov    (%eax),%eax
f0105972:	85 c0                	test   %eax,%eax
f0105974:	75 5b                	jne    f01059d1 <get_disk_table_directory+0x75>
	{
		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> disk directory not found, creating one ...\n"););
#if USE_KHEAP
		{
			*ptr_disk_table_directory = kmalloc(PAGE_SIZE);
f0105976:	83 ec 0c             	sub    $0xc,%esp
f0105979:	68 00 10 00 00       	push   $0x1000
f010597e:	e8 b3 42 00 00       	call   f0109c36 <kmalloc>
f0105983:	83 c4 10             	add    $0x10,%esp
f0105986:	89 c2                	mov    %eax,%edx
f0105988:	8b 45 0c             	mov    0xc(%ebp),%eax
f010598b:	89 10                	mov    %edx,(%eax)
			if(*ptr_disk_table_directory == NULL)
f010598d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105990:	8b 00                	mov    (%eax),%eax
f0105992:	85 c0                	test   %eax,%eax
f0105994:	75 07                	jne    f010599d <get_disk_table_directory+0x41>
			{
				return E_NO_VM;
f0105996:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
f010599b:	eb 39                	jmp    f01059d6 <get_disk_table_directory+0x7a>
			}
			ptr_env->disk_env_tabledir_PA = kheap_physical_address((uint32)*ptr_disk_table_directory);
f010599d:	8b 45 0c             	mov    0xc(%ebp),%eax
f01059a0:	8b 00                	mov    (%eax),%eax
f01059a2:	83 ec 0c             	sub    $0xc,%esp
f01059a5:	50                   	push   %eax
f01059a6:	e8 d9 42 00 00       	call   f0109c84 <kheap_physical_address>
f01059ab:	83 c4 10             	add    $0x10,%esp
f01059ae:	89 c2                	mov    %eax,%edx
f01059b0:	8b 45 08             	mov    0x8(%ebp),%eax
f01059b3:	89 90 80 00 00 00    	mov    %edx,0x80(%eax)
			// Hint: use "initialize_environment" function
			*ptr_disk_table_directory = STATIC_KERNEL_VIRTUAL_ADDRESS(to_physical_address(p));
			ptr_env->disk_env_tabledir_PA = to_physical_address(p);
		}
#endif
		memset(*ptr_disk_table_directory , 0, PAGE_SIZE);
f01059b9:	8b 45 0c             	mov    0xc(%ebp),%eax
f01059bc:	8b 00                	mov    (%eax),%eax
f01059be:	83 ec 04             	sub    $0x4,%esp
f01059c1:	68 00 10 00 00       	push   $0x1000
f01059c6:	6a 00                	push   $0x0
f01059c8:	50                   	push   %eax
f01059c9:	e8 9b 53 01 00       	call   f011ad69 <memset>
f01059ce:	83 c4 10             	add    $0x10,%esp

		//	LOG_STATMENT(cprintf(">>>>>>>>>>>>>> Disk directory created at %x", *ptr_disk_page_directory));
	}
	return 0;
f01059d1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01059d6:	c9                   	leave  
f01059d7:	c3                   	ret    

f01059d8 <__pf_write_env_table>:

int __pf_write_env_table( struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f01059d8:	55                   	push   %ebp
f01059d9:	89 e5                	mov    %esp,%ebp
f01059db:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("========================== create_env_page");
	assert((uint32)virtual_address < KERNEL_BASE);
f01059de:	81 7d 0c ff ff ff ef 	cmpl   $0xefffffff,0xc(%ebp)
f01059e5:	76 19                	jbe    f0105a00 <__pf_write_env_table+0x28>
f01059e7:	68 58 e4 12 f0       	push   $0xf012e458
f01059ec:	68 7e e4 12 f0       	push   $0xf012e47e
f01059f1:	68 98 02 00 00       	push   $0x298
f01059f6:	68 b3 e3 12 f0       	push   $0xf012e3b3
f01059fb:	e8 af b5 ff ff       	call   f0100faf <_panic>

	get_disk_table_directory(ptr_env, &(ptr_env->disk_env_tabledir)) ;
f0105a00:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a03:	83 c0 7c             	add    $0x7c,%eax
f0105a06:	83 ec 08             	sub    $0x8,%esp
f0105a09:	50                   	push   %eax
f0105a0a:	ff 75 08             	pushl  0x8(%ebp)
f0105a0d:	e8 4a ff ff ff       	call   f010595c <get_disk_table_directory>
f0105a12:	83 c4 10             	add    $0x10,%esp

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105a15:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a18:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a1b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a1e:	c1 ea 16             	shr    $0x16,%edx
f0105a21:	c1 e2 02             	shl    $0x2,%edx
f0105a24:	01 d0                	add    %edx,%eax
f0105a26:	8b 00                	mov    (%eax),%eax
f0105a28:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if( dfn == 0)
f0105a2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105a2e:	85 c0                	test   %eax,%eax
f0105a30:	75 31                	jne    f0105a63 <__pf_write_env_table+0x8b>
	{
		if( allocate_disk_frame(&dfn) == E_NO_PAGE_FILE_SPACE) return E_NO_PAGE_FILE_SPACE;
f0105a32:	83 ec 0c             	sub    $0xc,%esp
f0105a35:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0105a38:	50                   	push   %eax
f0105a39:	e8 7a f4 ff ff       	call   f0104eb8 <allocate_disk_frame>
f0105a3e:	83 c4 10             	add    $0x10,%esp
f0105a41:	83 f8 f8             	cmp    $0xfffffff8,%eax
f0105a44:	75 07                	jne    f0105a4d <__pf_write_env_table+0x75>
f0105a46:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
f0105a4b:	eb 2e                	jmp    f0105a7b <__pf_write_env_table+0xa3>
		ptr_env->disk_env_tabledir[PDX(virtual_address)] = dfn;
f0105a4d:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a50:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a53:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a56:	c1 ea 16             	shr    $0x16,%edx
f0105a59:	c1 e2 02             	shl    $0x2,%edx
f0105a5c:	01 c2                	add    %eax,%edx
f0105a5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105a61:	89 02                	mov    %eax,(%edx)
	//	lcr3(oldDir);

	//We already read it from the KERNEL mapping instead of the USER mapping

	//cprintf("[%s] writing table\n",ptr_env->prog_name);
	int ret = write_disk_page(dfn, (void*)tableKVirtualAddress);
f0105a63:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105a66:	83 ec 08             	sub    $0x8,%esp
f0105a69:	ff 75 10             	pushl  0x10(%ebp)
f0105a6c:	50                   	push   %eax
f0105a6d:	e8 79 f2 ff ff       	call   f0104ceb <write_disk_page>
f0105a72:	83 c4 10             	add    $0x10,%esp
f0105a75:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%s] finished writing table\n",ptr_env->prog_name);
	return ret;
f0105a78:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0105a7b:	c9                   	leave  
f0105a7c:	c3                   	ret    

f0105a7d <__pf_read_env_table>:

int __pf_read_env_table(struct Env* ptr_env, uint32 virtual_address, uint32* tableKVirtualAddress)
{
f0105a7d:	55                   	push   %ebp
f0105a7e:	89 e5                	mov    %esp,%ebp
f0105a80:	83 ec 18             	sub    $0x18,%esp
	if( ptr_env->disk_env_tabledir == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0105a83:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a86:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a89:	85 c0                	test   %eax,%eax
f0105a8b:	75 07                	jne    f0105a94 <__pf_read_env_table+0x17>
f0105a8d:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0105a92:	eb 3a                	jmp    f0105ace <__pf_read_env_table+0x51>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105a94:	8b 45 08             	mov    0x8(%ebp),%eax
f0105a97:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105a9a:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105a9d:	c1 ea 16             	shr    $0x16,%edx
f0105aa0:	c1 e2 02             	shl    $0x2,%edx
f0105aa3:	01 d0                	add    %edx,%eax
f0105aa5:	8b 00                	mov    (%eax),%eax
f0105aa7:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if( dfn == 0) return E_TABLE_NOT_EXIST_IN_PF;
f0105aaa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0105aae:	75 07                	jne    f0105ab7 <__pf_read_env_table+0x3a>
f0105ab0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
f0105ab5:	eb 17                	jmp    f0105ace <__pf_read_env_table+0x51>

	int disk_read_error = read_disk_page(dfn, tableKVirtualAddress);
f0105ab7:	83 ec 08             	sub    $0x8,%esp
f0105aba:	ff 75 10             	pushl  0x10(%ebp)
f0105abd:	ff 75 f4             	pushl  -0xc(%ebp)
f0105ac0:	e8 f7 f1 ff ff       	call   f0104cbc <read_disk_page>
f0105ac5:	83 c4 10             	add    $0x10,%esp
f0105ac8:	89 45 f0             	mov    %eax,-0x10(%ebp)

	return disk_read_error;
f0105acb:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f0105ace:	c9                   	leave  
f0105acf:	c3                   	ret    

f0105ad0 <__pf_remove_env_all_tables>:

void __pf_remove_env_all_tables(struct Env* ptr_env)
{
f0105ad0:	55                   	push   %ebp
f0105ad1:	89 e5                	mov    %esp,%ebp
f0105ad3:	83 ec 18             	sub    $0x18,%esp
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0105ad6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105ad9:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105adc:	85 c0                	test   %eax,%eax
f0105ade:	74 4c                	je     f0105b2c <__pf_remove_env_all_tables+0x5c>

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105ae0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0105ae7:	eb 38                	jmp    f0105b21 <__pf_remove_env_all_tables+0x51>
	{
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
f0105ae9:	8b 45 08             	mov    0x8(%ebp),%eax
f0105aec:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105aef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105af2:	c1 e2 02             	shl    $0x2,%edx
f0105af5:	01 d0                	add    %edx,%eax
f0105af7:	8b 00                	mov    (%eax),%eax
f0105af9:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_env->disk_env_tabledir[pdeno] = 0;
f0105afc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105aff:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b02:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105b05:	c1 e2 02             	shl    $0x2,%edx
f0105b08:	01 d0                	add    %edx,%eax
f0105b0a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		free_disk_frame(dfn);
f0105b10:	83 ec 0c             	sub    $0xc,%esp
f0105b13:	ff 75 f0             	pushl  -0x10(%ebp)
f0105b16:	e8 8b f4 ff ff       	call   f0104fa6 <free_disk_frame>
f0105b1b:	83 c4 10             	add    $0x10,%esp

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;

	uint32 pdeno;
	for (pdeno = 0; pdeno < PDX(USER_TOP) ; pdeno++)
f0105b1e:	ff 45 f4             	incl   -0xc(%ebp)
f0105b21:	81 7d f4 ba 03 00 00 	cmpl   $0x3ba,-0xc(%ebp)
f0105b28:	76 bf                	jbe    f0105ae9 <__pf_remove_env_all_tables+0x19>
f0105b2a:	eb 01                	jmp    f0105b2d <__pf_remove_env_all_tables+0x5d>
void __pf_remove_env_all_tables(struct Env* ptr_env)
{
	//LOG_STRING("pf_remove_env_page: 0");

	//LOG_STATMENT(cprintf("ptr_env = %x",ptr_env));
	if( ptr_env->disk_env_tabledir == 0) return;
f0105b2c:	90                   	nop
		uint32 dfn=ptr_env->disk_env_tabledir[pdeno];
		ptr_env->disk_env_tabledir[pdeno] = 0;
		free_disk_frame(dfn);
	}
	//LOG_STRING("pf_remove_env_page: 3");
}
f0105b2d:	c9                   	leave  
f0105b2e:	c3                   	ret    

f0105b2f <__pf_remove_env_table>:

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
f0105b2f:	55                   	push   %ebp
f0105b30:	89 e5                	mov    %esp,%ebp
f0105b32:	83 ec 18             	sub    $0x18,%esp
	if (virtual_address == 0)
f0105b35:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0105b39:	75 10                	jne    f0105b4b <__pf_remove_env_table+0x1c>
		cprintf("REMOVING table 0 from page file\n");
f0105b3b:	83 ec 0c             	sub    $0xc,%esp
f0105b3e:	68 5c e5 12 f0       	push   $0xf012e55c
f0105b43:	e8 14 c1 ff ff       	call   f0101c5c <cprintf>
f0105b48:	83 c4 10             	add    $0x10,%esp
	if( ptr_env->disk_env_tabledir == 0) return;
f0105b4b:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b4e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b51:	85 c0                	test   %eax,%eax
f0105b53:	74 3d                	je     f0105b92 <__pf_remove_env_table+0x63>

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
f0105b55:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b58:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b5b:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105b5e:	c1 ea 16             	shr    $0x16,%edx
f0105b61:	c1 e2 02             	shl    $0x2,%edx
f0105b64:	01 d0                	add    %edx,%eax
f0105b66:	8b 00                	mov    (%eax),%eax
f0105b68:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
f0105b6b:	8b 45 08             	mov    0x8(%ebp),%eax
f0105b6e:	8b 40 7c             	mov    0x7c(%eax),%eax
f0105b71:	8b 55 0c             	mov    0xc(%ebp),%edx
f0105b74:	c1 ea 16             	shr    $0x16,%edx
f0105b77:	c1 e2 02             	shl    $0x2,%edx
f0105b7a:	01 d0                	add    %edx,%eax
f0105b7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	free_disk_frame(dfn);
f0105b82:	83 ec 0c             	sub    $0xc,%esp
f0105b85:	ff 75 f4             	pushl  -0xc(%ebp)
f0105b88:	e8 19 f4 ff ff       	call   f0104fa6 <free_disk_frame>
f0105b8d:	83 c4 10             	add    $0x10,%esp
f0105b90:	eb 01                	jmp    f0105b93 <__pf_remove_env_table+0x64>

void __pf_remove_env_table(struct Env* ptr_env, uint32 virtual_address)
{
	if (virtual_address == 0)
		cprintf("REMOVING table 0 from page file\n");
	if( ptr_env->disk_env_tabledir == 0) return;
f0105b92:	90                   	nop

	uint32 dfn=ptr_env->disk_env_tabledir[PDX(virtual_address)];
	ptr_env->disk_env_tabledir[PDX(virtual_address)] = 0;
	free_disk_frame(dfn);
}
f0105b93:	c9                   	leave  
f0105b94:	c3                   	ret    

f0105b95 <test_disk_01>:
///========================== END OF TABLE FILE MANAGMENT =============================


void test_disk_01(void *virtual_address)
{
f0105b95:	55                   	push   %ebp
f0105b96:	89 e5                	mov    %esp,%ebp
f0105b98:	83 ec 18             	sub    $0x18,%esp
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
f0105b9b:	c7 45 f4 2d 60 01 00 	movl   $0x1602d,-0xc(%ebp)
	for(;i<140000;i += 500)
f0105ba2:	eb 1f                	jmp    f0105bc3 <test_disk_01+0x2e>
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
f0105ba4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105ba7:	83 ec 04             	sub    $0x4,%esp
f0105baa:	6a 08                	push   $0x8
f0105bac:	ff 75 08             	pushl  0x8(%ebp)
f0105baf:	50                   	push   %eax
f0105bb0:	e8 bf 59 01 00       	call   f011b574 <ide_write>
f0105bb5:	83 c4 10             	add    $0x10,%esp
f0105bb8:	85 c0                	test   %eax,%eax
f0105bba:	75 12                	jne    f0105bce <test_disk_01+0x39>

void test_disk_01(void *virtual_address)
{
	LOG_STATMENT(cprintf("doing tests for ide_write()\n"));
	int i=90157;
	for(;i<140000;i += 500)
f0105bbc:	81 45 f4 f4 01 00 00 	addl   $0x1f4,-0xc(%ebp)
f0105bc3:	81 7d f4 df 22 02 00 	cmpl   $0x222df,-0xc(%ebp)
f0105bca:	7e d8                	jle    f0105ba4 <test_disk_01+0xf>
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105bcc:	eb 01                	jmp    f0105bcf <test_disk_01+0x3a>
	for(;i<140000;i += 500)
	{
		if(ide_write(i,(void *)virtual_address,8) != 0)
		{
			LOG_STATMENT(cprintf("FAILURE to write sector %d\n",i););
			break;
f0105bce:	90                   	nop
		{
			//LOG_STATMENT(cprintf("written at sector %d\n",i););
		}
	}
	LOG_STATMENT(cprintf("ide_write() test done\n"););
}
f0105bcf:	90                   	nop
f0105bd0:	c9                   	leave  
f0105bd1:	c3                   	ret    

f0105bd2 <context_switch>:
# Switch stacks to new and pop previously-saved registers.

.globl context_switch
context_switch:
  # Save old callee-saved registers
  pushl %ebp
f0105bd2:	55                   	push   %ebp
  pushl %eax
f0105bd3:	50                   	push   %eax
  pushl %ebx
f0105bd4:	53                   	push   %ebx
  pushl %ecx
f0105bd5:	51                   	push   %ecx
  pushl %edx
f0105bd6:	52                   	push   %edx
  pushl %esi
f0105bd7:	56                   	push   %esi
  pushl %edi
f0105bd8:	57                   	push   %edi

  # Switch stacks
  movl 32(%esp), %eax
f0105bd9:	8b 44 24 20          	mov    0x20(%esp),%eax
  movl 36(%esp), %edx
f0105bdd:	8b 54 24 24          	mov    0x24(%esp),%edx
  movl %esp, (%eax)
f0105be1:	89 20                	mov    %esp,(%eax)
  movl %edx, %esp
f0105be3:	89 d4                	mov    %edx,%esp

  # Load new callee-saved registers
  popl %edi
f0105be5:	5f                   	pop    %edi
  popl %esi
f0105be6:	5e                   	pop    %esi
  popl %edx
f0105be7:	5a                   	pop    %edx
  popl %ecx
f0105be8:	59                   	pop    %ecx
  popl %ebx
f0105be9:	5b                   	pop    %ebx
  popl %eax
f0105bea:	58                   	pop    %eax
  popl %ebp
f0105beb:	5d                   	pop    %ebp
  ret
f0105bec:	c3                   	ret    

f0105bed <mc146818_read>:
#include <kern/trap/trap.h>


unsigned
mc146818_read(unsigned reg)
{
f0105bed:	55                   	push   %ebp
f0105bee:	89 e5                	mov    %esp,%ebp
f0105bf0:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105bf3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105bf6:	0f b6 c0             	movzbl %al,%eax
f0105bf9:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105c00:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105c03:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105c06:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105c09:	ee                   	out    %al,(%dx)
f0105c0a:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105c11:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105c14:	89 c2                	mov    %eax,%edx
f0105c16:	ec                   	in     (%dx),%al
f0105c17:	88 45 f7             	mov    %al,-0x9(%ebp)
	return data;
f0105c1a:	8a 45 f7             	mov    -0x9(%ebp),%al
	return inb(IO_RTC+1);
f0105c1d:	0f b6 c0             	movzbl %al,%eax
}
f0105c20:	c9                   	leave  
f0105c21:	c3                   	ret    

f0105c22 <mc146818_write>:

void
mc146818_write(unsigned reg, unsigned datum)
{
f0105c22:	55                   	push   %ebp
f0105c23:	89 e5                	mov    %esp,%ebp
f0105c25:	83 ec 10             	sub    $0x10,%esp
	outb(IO_RTC, reg);
f0105c28:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c2b:	0f b6 c0             	movzbl %al,%eax
f0105c2e:	c7 45 fc 70 00 00 00 	movl   $0x70,-0x4(%ebp)
f0105c35:	88 45 f6             	mov    %al,-0xa(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105c38:	8a 45 f6             	mov    -0xa(%ebp),%al
f0105c3b:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0105c3e:	ee                   	out    %al,(%dx)
	outb(IO_RTC+1, datum);
f0105c3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0105c42:	0f b6 c0             	movzbl %al,%eax
f0105c45:	c7 45 f8 71 00 00 00 	movl   $0x71,-0x8(%ebp)
f0105c4c:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105c4f:	8a 45 f7             	mov    -0x9(%ebp),%al
f0105c52:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0105c55:	ee                   	out    %al,(%dx)
}
f0105c56:	90                   	nop
f0105c57:	c9                   	leave  
f0105c58:	c3                   	ret    

f0105c59 <kclock_init>:
 * PIT channel is reset, and the output immediately goes to its initial state
 * (which depends on the mode).
 */

void kclock_init()
{
f0105c59:	55                   	push   %ebp
f0105c5a:	89 e5                	mov    %esp,%ebp
f0105c5c:	83 ec 08             	sub    $0x8,%esp
	ticks = 0;
f0105c5f:	c7 05 28 6c 85 f0 00 	movl   $0x0,0xf0856c28
f0105c66:	00 00 00 
f0105c69:	c7 05 2c 6c 85 f0 00 	movl   $0x0,0xf0856c2c
f0105c70:	00 00 00 
	irq_install_handler(0, &clock_interrupt_handler);
f0105c73:	83 ec 08             	sub    $0x8,%esp
f0105c76:	68 c6 7c 10 f0       	push   $0xf0107cc6
f0105c7b:	6a 00                	push   $0x0
f0105c7d:	e8 3e 86 00 00       	call   f010e2c0 <irq_install_handler>
f0105c82:	83 c4 10             	add    $0x10,%esp
}
f0105c85:	90                   	nop
f0105c86:	c9                   	leave  
f0105c87:	c3                   	ret    

f0105c88 <kclock_start>:
void
kclock_start(uint8 quantum_in_ms)
{
f0105c88:	55                   	push   %ebp
f0105c89:	89 e5                	mov    %esp,%ebp
f0105c8b:	53                   	push   %ebx
f0105c8c:	83 ec 24             	sub    $0x24,%esp
f0105c8f:	8b 45 08             	mov    0x8(%ebp),%eax
f0105c92:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105c95:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105c9c:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105ca0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105ca3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ca6:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);

	//2017
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) % 256);
//	outb(TIMER_CNTR0, TIMER_DIV((1000/CLOCK_INTERVAL_IN_MS)) / 256);
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105ca7:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105cab:	77 48                	ja     f0105cf5 <kclock_start+0x6d>
f0105cad:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105cb4:	c6 45 ee 34          	movb   $0x34,-0x12(%ebp)
f0105cb8:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105cbb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105cbe:	ee                   	out    %al,(%dx)
	{
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(TIMER_DIV((1000/quantum_in_ms))) ;
f0105cbf:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105cc3:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105cc8:	99                   	cltd   
f0105cc9:	f7 fb                	idiv   %ebx
f0105ccb:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105cd1:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105cd5:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105cda:	99                   	cltd   
f0105cdb:	f7 fb                	idiv   %ebx
f0105cdd:	89 c3                	mov    %eax,%ebx
f0105cdf:	89 c8                	mov    %ecx,%eax
f0105ce1:	99                   	cltd   
f0105ce2:	f7 fb                	idiv   %ebx
f0105ce4:	0f b7 c0             	movzwl %ax,%eax
f0105ce7:	83 ec 0c             	sub    $0xc,%esp
f0105cea:	50                   	push   %eax
f0105ceb:	e8 b3 01 00 00       	call   f0105ea3 <kclock_write_cnt0_LSB_first>
f0105cf0:	83 c4 10             	add    $0x10,%esp
f0105cf3:	eb 13                	jmp    f0105d08 <kclock_start+0x80>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105cf5:	6a 35                	push   $0x35
f0105cf7:	68 80 e5 12 f0       	push   $0xf012e580
f0105cfc:	6a 41                	push   $0x41
f0105cfe:	68 dc e5 12 f0       	push   $0xf012e5dc
f0105d03:	e8 a7 b2 ff ff       	call   f0100faf <_panic>
//	uint16 cnt0_after = kclock_read_cnt0() ;

	//cprintf("	Setup IRQ0 (timer interrupts) via 8259A\n");

	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105d08:	83 ec 0c             	sub    $0xc,%esp
f0105d0b:	6a 00                	push   $0x0
f0105d0d:	e8 46 22 00 00       	call   f0107f58 <irq_clear_mask>
f0105d12:	83 c4 10             	add    $0x10,%esp

	//cprintf("	unmasked timer interrupt\n");

	//cprintf("Timer STARTED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );

}
f0105d15:	90                   	nop
f0105d16:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0105d19:	c9                   	leave  
f0105d1a:	c3                   	ret    

f0105d1b <kclock_stop>:

void
kclock_stop(void)
{
f0105d1b:	55                   	push   %ebp
f0105d1c:	89 e5                	mov    %esp,%ebp
f0105d1e:	83 ec 18             	sub    $0x18,%esp
f0105d21:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105d28:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105d2c:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105d2f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105d32:	ee                   	out    %al,(%dx)
//		cprintf("STOP AFTER: cnt0 = %d\n",cnt0);
//	}

	/*Mask the IRQ0 (Timer Interrupt)*/
	//irq_setmask_8259A(0xFFFF);
	irq_set_mask(0);
f0105d33:	83 ec 0c             	sub    $0xc,%esp
f0105d36:	6a 00                	push   $0x0
f0105d38:	e8 a6 21 00 00       	call   f0107ee3 <irq_set_mask>
f0105d3d:	83 c4 10             	add    $0x10,%esp
//	uint16 cnt0 = kclock_read_cnt0() ;
//	cprintf("Timer STOPPED: Counter0 Value = %x\n", cnt0 );
	//cprintf("Timer STOPPED: Status Value = %x\n", status);


}
f0105d40:	90                   	nop
f0105d41:	c9                   	leave  
f0105d42:	c3                   	ret    

f0105d43 <kclock_resume>:

void
kclock_resume(void)
{
f0105d43:	55                   	push   %ebp
f0105d44:	89 e5                	mov    %esp,%ebp
f0105d46:	83 ec 18             	sub    $0x18,%esp
	/*2024: changed to latch
	 * the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.
	 * The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).
	 */
	//uint16 cnt0 = kclock_read_cnt0() ;
	uint16 cnt0 = kclock_read_cnt0_latch() ;
f0105d49:	e8 f5 01 00 00       	call   f0105f43 <kclock_read_cnt0_latch>
f0105d4e:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	//cprintf("CLOCK RESUMED: Counter0 Value = %d\n", cnt0 );
	//2017: if the remaining time is small, then increase it a bit to avoid invoking the CLOCK INT
	//		before returning back to the environment (this cause INT inside INT!!!) el7 :)
	if (cnt0 < 20)
f0105d52:	66 83 7d f6 13       	cmpw   $0x13,-0xa(%ebp)
f0105d57:	77 06                	ja     f0105d5f <kclock_resume+0x1c>
	{
		cnt0 = 20;
f0105d59:	66 c7 45 f6 14 00    	movw   $0x14,-0xa(%ebp)
	}

	if (cnt0 % 2 == 1)
f0105d5f:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105d63:	83 e0 01             	and    $0x1,%eax
f0105d66:	66 85 c0             	test   %ax,%ax
f0105d69:	74 09                	je     f0105d74 <kclock_resume+0x31>
		cnt0++;
f0105d6b:	66 8b 45 f6          	mov    -0xa(%ebp),%ax
f0105d6f:	40                   	inc    %eax
f0105d70:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
f0105d74:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105d7b:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105d7f:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105d82:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105d85:	ee                   	out    %al,(%dx)

	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105d86:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0105d8a:	83 ec 0c             	sub    $0xc,%esp
f0105d8d:	50                   	push   %eax
f0105d8e:	e8 10 01 00 00       	call   f0105ea3 <kclock_write_cnt0_LSB_first>
f0105d93:	83 c4 10             	add    $0x10,%esp
//	cprintf("Timer RESUMED: Counter0 Before Lag = %d, After lag = %d\n", cnt0_before, cnt0_after );


	//cprintf("	Setup IRQ0: timer interrupts via 8259A\n");
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105d96:	83 ec 0c             	sub    $0xc,%esp
f0105d99:	6a 00                	push   $0x0
f0105d9b:	e8 b8 21 00 00       	call   f0107f58 <irq_clear_mask>
f0105da0:	83 c4 10             	add    $0x10,%esp
	//cprintf("	unmasked timer interrupt\n");
}
f0105da3:	90                   	nop
f0105da4:	c9                   	leave  
f0105da5:	c3                   	ret    

f0105da6 <kclock_start_counter>:


//==============

void kclock_start_counter(uint8 cnt0)
{
f0105da6:	55                   	push   %ebp
f0105da7:	89 e5                	mov    %esp,%ebp
f0105da9:	83 ec 28             	sub    $0x28,%esp
f0105dac:	8b 45 08             	mov    0x8(%ebp),%eax
f0105daf:	88 45 e4             	mov    %al,-0x1c(%ebp)
f0105db2:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105db9:	c6 45 f3 34          	movb   $0x34,-0xd(%ebp)
f0105dbd:	8a 45 f3             	mov    -0xd(%ebp),%al
f0105dc0:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105dc3:	ee                   	out    %al,(%dx)
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
	kclock_write_cnt0_LSB_first(cnt0) ;
f0105dc4:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
f0105dc8:	83 ec 0c             	sub    $0xc,%esp
f0105dcb:	50                   	push   %eax
f0105dcc:	e8 d2 00 00 00       	call   f0105ea3 <kclock_write_cnt0_LSB_first>
f0105dd1:	83 c4 10             	add    $0x10,%esp
	//irq_setmask_8259A(irq_mask_8259A & ~(1<<0));
	irq_clear_mask(0);
f0105dd4:	83 ec 0c             	sub    $0xc,%esp
f0105dd7:	6a 00                	push   $0x0
f0105dd9:	e8 7a 21 00 00       	call   f0107f58 <irq_clear_mask>
f0105dde:	83 c4 10             	add    $0x10,%esp
}
f0105de1:	90                   	nop
f0105de2:	c9                   	leave  
f0105de3:	c3                   	ret    

f0105de4 <kclock_set_quantum>:

//2018
//Reset the CNT0 to the given quantum value without affecting the interrupt status
void kclock_set_quantum(uint8 quantum_in_ms)
{
f0105de4:	55                   	push   %ebp
f0105de5:	89 e5                	mov    %esp,%ebp
f0105de7:	56                   	push   %esi
f0105de8:	53                   	push   %ebx
f0105de9:	83 ec 20             	sub    $0x20,%esp
f0105dec:	8b 45 08             	mov    0x8(%ebp),%eax
f0105def:	88 45 e4             	mov    %al,-0x1c(%ebp)
	if (IS_VALID_QUANTUM(quantum_in_ms))
f0105df2:	80 7d e4 35          	cmpb   $0x35,-0x1c(%ebp)
f0105df6:	0f 87 8a 00 00 00    	ja     f0105e86 <kclock_set_quantum+0xa2>
	{
		/*2023*/
//		int cnt = TIMER_DIV((1000/quantum_in_ms));
//		if (cnt%2 == 1)
//			cnt++;
		int cnt = NUM_CLKS_PER_QUANTUM(quantum_in_ms);
f0105dfc:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105e00:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105e05:	99                   	cltd   
f0105e06:	f7 fe                	idiv   %esi
f0105e08:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105e0e:	0f b6 5d e4          	movzbl -0x1c(%ebp),%ebx
f0105e12:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105e17:	99                   	cltd   
f0105e18:	f7 fb                	idiv   %ebx
f0105e1a:	89 c6                	mov    %eax,%esi
f0105e1c:	89 c8                	mov    %ecx,%eax
f0105e1e:	99                   	cltd   
f0105e1f:	f7 fe                	idiv   %esi
f0105e21:	89 c3                	mov    %eax,%ebx
f0105e23:	0f b6 4d e4          	movzbl -0x1c(%ebp),%ecx
f0105e27:	b8 f4 01 00 00       	mov    $0x1f4,%eax
f0105e2c:	99                   	cltd   
f0105e2d:	f7 f9                	idiv   %ecx
f0105e2f:	8d 88 de 34 12 00    	lea    0x1234de(%eax),%ecx
f0105e35:	0f b6 75 e4          	movzbl -0x1c(%ebp),%esi
f0105e39:	b8 e8 03 00 00       	mov    $0x3e8,%eax
f0105e3e:	99                   	cltd   
f0105e3f:	f7 fe                	idiv   %esi
f0105e41:	89 c6                	mov    %eax,%esi
f0105e43:	89 c8                	mov    %ecx,%eax
f0105e45:	99                   	cltd   
f0105e46:	f7 fe                	idiv   %esi
f0105e48:	25 01 00 00 80       	and    $0x80000001,%eax
f0105e4d:	85 c0                	test   %eax,%eax
f0105e4f:	79 05                	jns    f0105e56 <kclock_set_quantum+0x72>
f0105e51:	48                   	dec    %eax
f0105e52:	83 c8 fe             	or     $0xfffffffe,%eax
f0105e55:	40                   	inc    %eax
f0105e56:	01 d8                	add    %ebx,%eax
f0105e58:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0105e5b:	c7 45 f0 43 00 00 00 	movl   $0x43,-0x10(%ebp)
f0105e62:	c6 45 ef 34          	movb   $0x34,-0x11(%ebp)
f0105e66:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105e69:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105e6c:	ee                   	out    %al,(%dx)


		//cprintf("QUANTUM is set to %d ms (%d)\n", quantum_in_ms, TIMER_DIV((1000/quantum_in_ms)));
		outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
		kclock_write_cnt0_LSB_first(cnt) ;
f0105e6d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0105e70:	0f b7 c0             	movzwl %ax,%eax
f0105e73:	83 ec 0c             	sub    $0xc,%esp
f0105e76:	50                   	push   %eax
f0105e77:	e8 27 00 00 00       	call   f0105ea3 <kclock_write_cnt0_LSB_first>
f0105e7c:	83 c4 10             	add    $0x10,%esp
		kclock_stop();
f0105e7f:	e8 97 fe ff ff       	call   f0105d1b <kclock_stop>
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
	}
}
f0105e84:	eb 16                	jmp    f0105e9c <kclock_set_quantum+0xb8>
		//uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
		//cprintf("\nkclock_set_quantum: clock after stop = %d\n",cnt0);
	}
	else
	{
		panic("attempt to set the CPU quantum by too large value. Quantum should be between 1 ms and %d ms", QUANTUM_LIMIT - 1);
f0105e86:	6a 35                	push   $0x35
f0105e88:	68 80 e5 12 f0       	push   $0xf012e580
f0105e8d:	68 ea 00 00 00       	push   $0xea
f0105e92:	68 dc e5 12 f0       	push   $0xf012e5dc
f0105e97:	e8 13 b1 ff ff       	call   f0100faf <_panic>
	}
}
f0105e9c:	8d 65 f8             	lea    -0x8(%ebp),%esp
f0105e9f:	5b                   	pop    %ebx
f0105ea0:	5e                   	pop    %esi
f0105ea1:	5d                   	pop    %ebp
f0105ea2:	c3                   	ret    

f0105ea3 <kclock_write_cnt0_LSB_first>:


//2017
void
kclock_write_cnt0_LSB_first(uint16 val)
{
f0105ea3:	55                   	push   %ebp
f0105ea4:	89 e5                	mov    %esp,%ebp
f0105ea6:	83 ec 28             	sub    $0x28,%esp
f0105ea9:	8b 45 08             	mov    0x8(%ebp),%eax
f0105eac:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
	/*You must prevent other code from setting the PIT channel's reload value or reading
	 * its current count once you've sent the lowest 8 bits. Disabling interrupts works
	 * for single CPU computers
	 * */
	pushcli();	//disable interrupt
f0105eb0:	e8 7b 22 00 00       	call   f0108130 <pushcli>
	outb(TIMER_CNTR0, (uint8)(val & 0x00FF));
f0105eb5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105eb8:	0f b6 c0             	movzbl %al,%eax
f0105ebb:	c7 45 f4 40 00 00 00 	movl   $0x40,-0xc(%ebp)
f0105ec2:	88 45 ee             	mov    %al,-0x12(%ebp)
f0105ec5:	8a 45 ee             	mov    -0x12(%ebp),%al
f0105ec8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105ecb:	ee                   	out    %al,(%dx)
	outb(TIMER_CNTR0, (uint8)((val>>8) & 0x00FF));
f0105ecc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105ecf:	66 c1 e8 08          	shr    $0x8,%ax
f0105ed3:	0f b6 c0             	movzbl %al,%eax
f0105ed6:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)
f0105edd:	88 45 ef             	mov    %al,-0x11(%ebp)
f0105ee0:	8a 45 ef             	mov    -0x11(%ebp),%al
f0105ee3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0105ee6:	ee                   	out    %al,(%dx)
	popcli();	//enable interrupt
f0105ee7:	e8 96 22 00 00       	call   f0108182 <popcli>

}
f0105eec:	90                   	nop
f0105eed:	c9                   	leave  
f0105eee:	c3                   	ret    

f0105eef <kclock_read_cnt0>:
//==============


uint16
kclock_read_cnt0(void)
{
f0105eef:	55                   	push   %ebp
f0105ef0:	89 e5                	mov    %esp,%ebp
f0105ef2:	83 ec 28             	sub    $0x28,%esp
	pushcli();	//disable interrupt
f0105ef5:	e8 36 22 00 00       	call   f0108130 <pushcli>
f0105efa:	c7 45 f0 40 00 00 00 	movl   $0x40,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f01:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0105f04:	89 c2                	mov    %eax,%edx
f0105f06:	ec                   	in     (%dx),%al
f0105f07:	88 45 e6             	mov    %al,-0x1a(%ebp)
	return data;
f0105f0a:	8a 45 e6             	mov    -0x1a(%ebp),%al
	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105f0d:	88 45 f7             	mov    %al,-0x9(%ebp)
f0105f10:	c7 45 e8 40 00 00 00 	movl   $0x40,-0x18(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f17:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0105f1a:	89 c2                	mov    %eax,%edx
f0105f1c:	ec                   	in     (%dx),%al
f0105f1d:	88 45 e7             	mov    %al,-0x19(%ebp)
	return data;
f0105f20:	8a 45 e7             	mov    -0x19(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105f23:	88 45 ef             	mov    %al,-0x11(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105f26:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
f0105f2a:	c1 e0 08             	shl    $0x8,%eax
f0105f2d:	89 c2                	mov    %eax,%edx
f0105f2f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
f0105f33:	09 d0                	or     %edx,%eax
f0105f35:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	popcli();	//enable interrupt
f0105f39:	e8 44 22 00 00       	call   f0108182 <popcli>
	return cnt0 ;
f0105f3e:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f0105f41:	c9                   	leave  
f0105f42:	c3                   	ret    

f0105f43 <kclock_read_cnt0_latch>:
 * instead of 0x0200 (or 0x01FF).
 * REF: OSDev Wiki
 */
uint16
kclock_read_cnt0_latch(void)
{
f0105f43:	55                   	push   %ebp
f0105f44:	89 e5                	mov    %esp,%ebp
f0105f46:	83 ec 30             	sub    $0x30,%esp
f0105f49:	c7 45 f8 43 00 00 00 	movl   $0x43,-0x8(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f50:	8b 45 f8             	mov    -0x8(%ebp),%eax
f0105f53:	89 c2                	mov    %eax,%edx
f0105f55:	ec                   	in     (%dx),%al
f0105f56:	88 45 db             	mov    %al,-0x25(%ebp)
	return data;
f0105f59:	8a 45 db             	mov    -0x25(%ebp),%al
	uint8 old_mode = inb(TIMER_MODE) ;
f0105f5c:	88 45 ff             	mov    %al,-0x1(%ebp)
f0105f5f:	c7 45 f4 43 00 00 00 	movl   $0x43,-0xc(%ebp)
f0105f66:	c6 45 dc 00          	movb   $0x0,-0x24(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105f6a:	8a 45 dc             	mov    -0x24(%ebp),%al
f0105f6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0105f70:	ee                   	out    %al,(%dx)
f0105f71:	c7 45 ec 40 00 00 00 	movl   $0x40,-0x14(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f78:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0105f7b:	89 c2                	mov    %eax,%edx
f0105f7d:	ec                   	in     (%dx),%al
f0105f7e:	88 45 dd             	mov    %al,-0x23(%ebp)
	return data;
f0105f81:	8a 45 dd             	mov    -0x23(%ebp),%al
	outb(TIMER_MODE, TIMER_SEL0 | TIMER_LATCH);

	uint8 cnt0_lo =  inb(TIMER_CNTR0);
f0105f84:	88 45 f3             	mov    %al,-0xd(%ebp)
f0105f87:	c7 45 e4 40 00 00 00 	movl   $0x40,-0x1c(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0105f8e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0105f91:	89 c2                	mov    %eax,%edx
f0105f93:	ec                   	in     (%dx),%al
f0105f94:	88 45 de             	mov    %al,-0x22(%ebp)
	return data;
f0105f97:	8a 45 de             	mov    -0x22(%ebp),%al
	uint8 cnt0_hi =  inb(TIMER_CNTR0);
f0105f9a:	88 45 eb             	mov    %al,-0x15(%ebp)
	uint16 cnt0 = (cnt0_hi << 8) | cnt0_lo ;
f0105f9d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
f0105fa1:	c1 e0 08             	shl    $0x8,%eax
f0105fa4:	89 c2                	mov    %eax,%edx
f0105fa6:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
f0105faa:	09 d0                	or     %edx,%eax
f0105fac:	66 89 45 e8          	mov    %ax,-0x18(%ebp)
	outb(TIMER_MODE, old_mode);
f0105fb0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
f0105fb4:	c7 45 e0 43 00 00 00 	movl   $0x43,-0x20(%ebp)
f0105fbb:	88 45 df             	mov    %al,-0x21(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0105fbe:	8a 45 df             	mov    -0x21(%ebp),%al
f0105fc1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0105fc4:	ee                   	out    %al,(%dx)

	return cnt0 ;
f0105fc5:	8b 45 e8             	mov    -0x18(%ebp),%eax
}
f0105fc8:	c9                   	leave  
f0105fc9:	c3                   	ret    

f0105fca <init_queue>:

//================================
// [1] Initialize the given queue:
//================================
void init_queue(struct Env_Queue* queue)
{
f0105fca:	55                   	push   %ebp
f0105fcb:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105fcd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105fd1:	74 1d                	je     f0105ff0 <init_queue+0x26>
	{
		LIST_INIT(queue);
f0105fd3:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fd6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0105fdc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fdf:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0105fe6:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fe9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	}
}
f0105ff0:	90                   	nop
f0105ff1:	5d                   	pop    %ebp
f0105ff2:	c3                   	ret    

f0105ff3 <queue_size>:

//================================
// [2] Get queue size:
//================================
int queue_size(struct Env_Queue* queue)
{
f0105ff3:	55                   	push   %ebp
f0105ff4:	89 e5                	mov    %esp,%ebp
	if(queue != NULL)
f0105ff6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0105ffa:	74 08                	je     f0106004 <queue_size+0x11>
	{
		return LIST_SIZE(queue);
f0105ffc:	8b 45 08             	mov    0x8(%ebp),%eax
f0105fff:	8b 40 0c             	mov    0xc(%eax),%eax
f0106002:	eb 05                	jmp    f0106009 <queue_size+0x16>
	}
	else
	{
		return 0;
f0106004:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0106009:	5d                   	pop    %ebp
f010600a:	c3                   	ret    

f010600b <enqueue>:

//====================================
// [3] Enqueue env in the given queue:
//====================================
void enqueue(struct Env_Queue* queue, struct Env* env)
{
f010600b:	55                   	push   %ebp
f010600c:	89 e5                	mov    %esp,%ebp
f010600e:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f0106011:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106015:	75 16                	jne    f010602d <enqueue+0x22>
f0106017:	68 f0 e5 12 f0       	push   $0xf012e5f0
f010601c:	68 fe e5 12 f0       	push   $0xf012e5fe
f0106021:	6a 34                	push   $0x34
f0106023:	68 13 e6 12 f0       	push   $0xf012e613
f0106028:	e8 82 af ff ff       	call   f0100faf <_panic>
	if(env != NULL)
f010602d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106031:	74 66                	je     f0106099 <enqueue+0x8e>
	{
		LIST_INSERT_HEAD(queue, env);
f0106033:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106037:	75 14                	jne    f010604d <enqueue+0x42>
f0106039:	83 ec 04             	sub    $0x4,%esp
f010603c:	68 2c e6 12 f0       	push   $0xf012e62c
f0106041:	6a 37                	push   $0x37
f0106043:	68 13 e6 12 f0       	push   $0xf012e613
f0106048:	e8 62 af ff ff       	call   f0100faf <_panic>
f010604d:	8b 45 08             	mov    0x8(%ebp),%eax
f0106050:	8b 10                	mov    (%eax),%edx
f0106052:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106055:	89 50 08             	mov    %edx,0x8(%eax)
f0106058:	8b 45 0c             	mov    0xc(%ebp),%eax
f010605b:	8b 40 08             	mov    0x8(%eax),%eax
f010605e:	85 c0                	test   %eax,%eax
f0106060:	74 0d                	je     f010606f <enqueue+0x64>
f0106062:	8b 45 08             	mov    0x8(%ebp),%eax
f0106065:	8b 00                	mov    (%eax),%eax
f0106067:	8b 55 0c             	mov    0xc(%ebp),%edx
f010606a:	89 50 0c             	mov    %edx,0xc(%eax)
f010606d:	eb 09                	jmp    f0106078 <enqueue+0x6d>
f010606f:	8b 45 08             	mov    0x8(%ebp),%eax
f0106072:	8b 55 0c             	mov    0xc(%ebp),%edx
f0106075:	89 50 04             	mov    %edx,0x4(%eax)
f0106078:	8b 45 08             	mov    0x8(%ebp),%eax
f010607b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010607e:	89 10                	mov    %edx,(%eax)
f0106080:	8b 45 0c             	mov    0xc(%ebp),%eax
f0106083:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010608a:	8b 45 08             	mov    0x8(%ebp),%eax
f010608d:	8b 40 0c             	mov    0xc(%eax),%eax
f0106090:	8d 50 01             	lea    0x1(%eax),%edx
f0106093:	8b 45 08             	mov    0x8(%ebp),%eax
f0106096:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f0106099:	90                   	nop
f010609a:	c9                   	leave  
f010609b:	c3                   	ret    

f010609c <dequeue>:

//======================================
// [4] Dequeue env from the given queue:
//======================================
struct Env* dequeue(struct Env_Queue* queue)
{
f010609c:	55                   	push   %ebp
f010609d:	89 e5                	mov    %esp,%ebp
f010609f:	83 ec 18             	sub    $0x18,%esp
	if (queue == NULL) return NULL;
f01060a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01060a6:	75 0a                	jne    f01060b2 <dequeue+0x16>
f01060a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01060ad:	e9 a0 00 00 00       	jmp    f0106152 <dequeue+0xb6>
	struct Env* envItem = LIST_LAST(queue);
f01060b2:	8b 45 08             	mov    0x8(%ebp),%eax
f01060b5:	8b 40 04             	mov    0x4(%eax),%eax
f01060b8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (envItem != NULL)
f01060bb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01060bf:	0f 84 8a 00 00 00    	je     f010614f <dequeue+0xb3>
	{
		LIST_REMOVE(queue, envItem);
f01060c5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01060c9:	75 14                	jne    f01060df <dequeue+0x43>
f01060cb:	83 ec 04             	sub    $0x4,%esp
f01060ce:	68 4f e6 12 f0       	push   $0xf012e64f
f01060d3:	6a 44                	push   $0x44
f01060d5:	68 13 e6 12 f0       	push   $0xf012e613
f01060da:	e8 d0 ae ff ff       	call   f0100faf <_panic>
f01060df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060e2:	8b 40 08             	mov    0x8(%eax),%eax
f01060e5:	85 c0                	test   %eax,%eax
f01060e7:	74 11                	je     f01060fa <dequeue+0x5e>
f01060e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060ec:	8b 40 08             	mov    0x8(%eax),%eax
f01060ef:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01060f2:	8b 52 0c             	mov    0xc(%edx),%edx
f01060f5:	89 50 0c             	mov    %edx,0xc(%eax)
f01060f8:	eb 0c                	jmp    f0106106 <dequeue+0x6a>
f01060fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01060fd:	8b 50 0c             	mov    0xc(%eax),%edx
f0106100:	8b 45 08             	mov    0x8(%ebp),%eax
f0106103:	89 50 04             	mov    %edx,0x4(%eax)
f0106106:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106109:	8b 40 0c             	mov    0xc(%eax),%eax
f010610c:	85 c0                	test   %eax,%eax
f010610e:	74 11                	je     f0106121 <dequeue+0x85>
f0106110:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106113:	8b 40 0c             	mov    0xc(%eax),%eax
f0106116:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106119:	8b 52 08             	mov    0x8(%edx),%edx
f010611c:	89 50 08             	mov    %edx,0x8(%eax)
f010611f:	eb 0b                	jmp    f010612c <dequeue+0x90>
f0106121:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106124:	8b 50 08             	mov    0x8(%eax),%edx
f0106127:	8b 45 08             	mov    0x8(%ebp),%eax
f010612a:	89 10                	mov    %edx,(%eax)
f010612c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010612f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106136:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106139:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106140:	8b 45 08             	mov    0x8(%ebp),%eax
f0106143:	8b 40 0c             	mov    0xc(%eax),%eax
f0106146:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106149:	8b 45 08             	mov    0x8(%ebp),%eax
f010614c:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	return envItem;
f010614f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0106152:	c9                   	leave  
f0106153:	c3                   	ret    

f0106154 <remove_from_queue>:

//====================================
// [5] Remove env from the given queue:
//====================================
void remove_from_queue(struct Env_Queue* queue, struct Env* e)
{
f0106154:	55                   	push   %ebp
f0106155:	89 e5                	mov    %esp,%ebp
f0106157:	83 ec 08             	sub    $0x8,%esp
	assert(queue != NULL)	;
f010615a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010615e:	75 16                	jne    f0106176 <remove_from_queue+0x22>
f0106160:	68 f0 e5 12 f0       	push   $0xf012e5f0
f0106165:	68 fe e5 12 f0       	push   $0xf012e5fe
f010616a:	6a 4e                	push   $0x4e
f010616c:	68 13 e6 12 f0       	push   $0xf012e613
f0106171:	e8 39 ae ff ff       	call   f0100faf <_panic>

	if (e != NULL)
f0106176:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010617a:	0f 84 8a 00 00 00    	je     f010620a <remove_from_queue+0xb6>
	{
		LIST_REMOVE(queue, e);
f0106180:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0106184:	75 14                	jne    f010619a <remove_from_queue+0x46>
f0106186:	83 ec 04             	sub    $0x4,%esp
f0106189:	68 4f e6 12 f0       	push   $0xf012e64f
f010618e:	6a 52                	push   $0x52
f0106190:	68 13 e6 12 f0       	push   $0xf012e613
f0106195:	e8 15 ae ff ff       	call   f0100faf <_panic>
f010619a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010619d:	8b 40 08             	mov    0x8(%eax),%eax
f01061a0:	85 c0                	test   %eax,%eax
f01061a2:	74 11                	je     f01061b5 <remove_from_queue+0x61>
f01061a4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061a7:	8b 40 08             	mov    0x8(%eax),%eax
f01061aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01061ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01061b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01061b3:	eb 0c                	jmp    f01061c1 <remove_from_queue+0x6d>
f01061b5:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061b8:	8b 50 0c             	mov    0xc(%eax),%edx
f01061bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01061be:	89 50 04             	mov    %edx,0x4(%eax)
f01061c1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061c4:	8b 40 0c             	mov    0xc(%eax),%eax
f01061c7:	85 c0                	test   %eax,%eax
f01061c9:	74 11                	je     f01061dc <remove_from_queue+0x88>
f01061cb:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061ce:	8b 40 0c             	mov    0xc(%eax),%eax
f01061d1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01061d4:	8b 52 08             	mov    0x8(%edx),%edx
f01061d7:	89 50 08             	mov    %edx,0x8(%eax)
f01061da:	eb 0b                	jmp    f01061e7 <remove_from_queue+0x93>
f01061dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061df:	8b 50 08             	mov    0x8(%eax),%edx
f01061e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01061e5:	89 10                	mov    %edx,(%eax)
f01061e7:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061ea:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01061f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01061f4:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01061fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01061fe:	8b 40 0c             	mov    0xc(%eax),%eax
f0106201:	8d 50 ff             	lea    -0x1(%eax),%edx
f0106204:	8b 45 08             	mov    0x8(%ebp),%eax
f0106207:	89 50 0c             	mov    %edx,0xc(%eax)
	}
}
f010620a:	90                   	nop
f010620b:	c9                   	leave  
f010620c:	c3                   	ret    

f010620d <find_env_in_queue>:

//========================================
// [6] Search by envID in the given queue:
//========================================
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
f010620d:	55                   	push   %ebp
f010620e:	89 e5                	mov    %esp,%ebp
f0106210:	83 ec 10             	sub    $0x10,%esp
	if (queue == NULL) return NULL;
f0106213:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106217:	75 07                	jne    f0106220 <find_env_in_queue+0x13>
f0106219:	b8 00 00 00 00       	mov    $0x0,%eax
f010621e:	eb 58                	jmp    f0106278 <find_env_in_queue+0x6b>

	struct Env * ptr_env=NULL;
f0106220:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	LIST_FOREACH(ptr_env, queue)
f0106227:	8b 45 08             	mov    0x8(%ebp),%eax
f010622a:	8b 00                	mov    (%eax),%eax
f010622c:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010622f:	eb 19                	jmp    f010624a <find_env_in_queue+0x3d>
	{
		if(ptr_env->env_id == envID)
f0106231:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106234:	8b 40 10             	mov    0x10(%eax),%eax
f0106237:	3b 45 0c             	cmp    0xc(%ebp),%eax
f010623a:	75 05                	jne    f0106241 <find_env_in_queue+0x34>
		{
			return ptr_env;
f010623c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010623f:	eb 37                	jmp    f0106278 <find_env_in_queue+0x6b>
struct Env* find_env_in_queue(struct Env_Queue* queue, uint32 envID)
{
	if (queue == NULL) return NULL;

	struct Env * ptr_env=NULL;
	LIST_FOREACH(ptr_env, queue)
f0106241:	8b 45 08             	mov    0x8(%ebp),%eax
f0106244:	8b 40 08             	mov    0x8(%eax),%eax
f0106247:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010624a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f010624e:	74 08                	je     f0106258 <find_env_in_queue+0x4b>
f0106250:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0106253:	8b 40 08             	mov    0x8(%eax),%eax
f0106256:	eb 05                	jmp    f010625d <find_env_in_queue+0x50>
f0106258:	b8 00 00 00 00       	mov    $0x0,%eax
f010625d:	8b 55 08             	mov    0x8(%ebp),%edx
f0106260:	89 42 08             	mov    %eax,0x8(%edx)
f0106263:	8b 45 08             	mov    0x8(%ebp),%eax
f0106266:	8b 40 08             	mov    0x8(%eax),%eax
f0106269:	85 c0                	test   %eax,%eax
f010626b:	75 c4                	jne    f0106231 <find_env_in_queue+0x24>
f010626d:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f0106271:	75 be                	jne    f0106231 <find_env_in_queue+0x24>
		if(ptr_env->env_id == envID)
		{
			return ptr_env;
		}
	}
	return NULL;
f0106273:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0106278:	c9                   	leave  
f0106279:	c3                   	ret    

f010627a <sched_delete_ready_queues>:

//========================================
// [1] Delete all ready queues:
//========================================
void sched_delete_ready_queues()
{
f010627a:	55                   	push   %ebp
f010627b:	89 e5                	mov    %esp,%ebp
f010627d:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	acquire_kspinlock(&ProcessQueues.qlock);
f0106280:	83 ec 0c             	sub    $0xc,%esp
f0106283:	68 20 e7 83 f0       	push   $0xf083e720
f0106288:	e8 ee 9b 00 00       	call   f010fe7b <acquire_kspinlock>
f010628d:	83 c4 10             	add    $0x10,%esp
	{
		if (ProcessQueues.env_ready_queues != NULL)
f0106290:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106295:	85 c0                	test   %eax,%eax
f0106297:	74 11                	je     f01062aa <sched_delete_ready_queues+0x30>
			kfree(ProcessQueues.env_ready_queues);
f0106299:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010629e:	83 ec 0c             	sub    $0xc,%esp
f01062a1:	50                   	push   %eax
f01062a2:	e8 a9 39 00 00       	call   f0109c50 <kfree>
f01062a7:	83 c4 10             	add    $0x10,%esp
		if (quantums != NULL)
f01062aa:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f01062af:	85 c0                	test   %eax,%eax
f01062b1:	74 11                	je     f01062c4 <sched_delete_ready_queues+0x4a>
			kfree(quantums);
f01062b3:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f01062b8:	83 ec 0c             	sub    $0xc,%esp
f01062bb:	50                   	push   %eax
f01062bc:	e8 8f 39 00 00       	call   f0109c50 <kfree>
f01062c1:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&ProcessQueues.qlock);
f01062c4:	83 ec 0c             	sub    $0xc,%esp
f01062c7:	68 20 e7 83 f0       	push   $0xf083e720
f01062cc:	e8 4f 9c 00 00       	call   f010ff20 <release_kspinlock>
f01062d1:	83 c4 10             	add    $0x10,%esp

#endif
}
f01062d4:	90                   	nop
f01062d5:	c9                   	leave  
f01062d6:	c3                   	ret    

f01062d7 <sched_insert_ready>:

//============================================================
// [2] Insert the given Env in the priority-based Ready Queue:
//============================================================
void sched_insert_ready(struct Env* env)
{
f01062d7:	55                   	push   %ebp
f01062d8:	89 e5                	mov    %esp,%ebp
f01062da:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01062dd:	83 ec 0c             	sub    $0xc,%esp
f01062e0:	68 20 e7 83 f0       	push   $0xf083e720
f01062e5:	e8 e6 9d 00 00       	call   f01100d0 <holding_kspinlock>
f01062ea:	83 c4 10             	add    $0x10,%esp
f01062ed:	85 c0                	test   %eax,%eax
f01062ef:	75 17                	jne    f0106308 <sched_insert_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01062f1:	83 ec 04             	sub    $0x4,%esp
f01062f4:	68 70 e6 12 f0       	push   $0xf012e670
f01062f9:	68 97 00 00 00       	push   $0x97
f01062fe:	68 13 e6 12 f0       	push   $0xf012e613
f0106303:	e8 a7 ac ff ff       	call   f0100faf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106308:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010630c:	75 19                	jne    f0106327 <sched_insert_ready+0x50>
f010630e:	68 b1 e6 12 f0       	push   $0xf012e6b1
f0106313:	68 fe e5 12 f0       	push   $0xf012e5fe
f0106318:	68 9a 00 00 00       	push   $0x9a
f010631d:	68 13 e6 12 f0       	push   $0xf012e613
f0106322:	e8 88 ac ff ff       	call   f0100faf <_panic>
	{
		//cprintf("\nInserting %d into ready queue 0\n", env->env_id);
		env->env_status = ENV_READY ;
f0106327:	8b 45 08             	mov    0x8(%ebp),%eax
f010632a:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		enqueue(&(ProcessQueues.env_ready_queues[env->priority]), env);
f0106331:	8b 15 b0 e7 83 f0    	mov    0xf083e7b0,%edx
f0106337:	8b 45 08             	mov    0x8(%ebp),%eax
f010633a:	8b 40 1c             	mov    0x1c(%eax),%eax
f010633d:	c1 e0 04             	shl    $0x4,%eax
f0106340:	01 d0                	add    %edx,%eax
f0106342:	83 ec 08             	sub    $0x8,%esp
f0106345:	ff 75 08             	pushl  0x8(%ebp)
f0106348:	50                   	push   %eax
f0106349:	e8 bd fc ff ff       	call   f010600b <enqueue>
f010634e:	83 c4 10             	add    $0x10,%esp
	}
}
f0106351:	90                   	nop
f0106352:	c9                   	leave  
f0106353:	c3                   	ret    

f0106354 <sched_remove_ready>:

//=================================================
// [3] Remove the given Env from the Ready Queue(s):
//=================================================
void sched_remove_ready(struct Env* env)
{
f0106354:	55                   	push   %ebp
f0106355:	89 e5                	mov    %esp,%ebp
f0106357:	83 ec 18             	sub    $0x18,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010635a:	83 ec 0c             	sub    $0xc,%esp
f010635d:	68 20 e7 83 f0       	push   $0xf083e720
f0106362:	e8 69 9d 00 00       	call   f01100d0 <holding_kspinlock>
f0106367:	83 c4 10             	add    $0x10,%esp
f010636a:	85 c0                	test   %eax,%eax
f010636c:	75 17                	jne    f0106385 <sched_remove_ready+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010636e:	83 ec 04             	sub    $0x4,%esp
f0106371:	68 70 e6 12 f0       	push   $0xf012e670
f0106376:	68 a9 00 00 00       	push   $0xa9
f010637b:	68 13 e6 12 f0       	push   $0xf012e613
f0106380:	e8 2a ac ff ff       	call   f0100faf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
f0106385:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106389:	74 0b                	je     f0106396 <sched_remove_ready+0x42>
f010638b:	8b 45 08             	mov    0x8(%ebp),%eax
f010638e:	8b 40 18             	mov    0x18(%eax),%eax
f0106391:	83 f8 01             	cmp    $0x1,%eax
f0106394:	74 19                	je     f01063af <sched_remove_ready+0x5b>
f0106396:	68 c0 e6 12 f0       	push   $0xf012e6c0
f010639b:	68 fe e5 12 f0       	push   $0xf012e5fe
f01063a0:	68 ac 00 00 00       	push   $0xac
f01063a5:	68 13 e6 12 f0       	push   $0xf012e613
f01063aa:	e8 00 ac ff ff       	call   f0100faf <_panic>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f01063af:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01063b6:	e9 e4 00 00 00       	jmp    f010649f <sched_remove_ready+0x14b>
		{
			struct Env * ptr_env = find_env_in_queue(&(ProcessQueues.env_ready_queues[i]), env->env_id);
f01063bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01063be:	8b 40 10             	mov    0x10(%eax),%eax
f01063c1:	89 c2                	mov    %eax,%edx
f01063c3:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01063c8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f01063cb:	c1 e1 04             	shl    $0x4,%ecx
f01063ce:	01 c8                	add    %ecx,%eax
f01063d0:	83 ec 08             	sub    $0x8,%esp
f01063d3:	52                   	push   %edx
f01063d4:	50                   	push   %eax
f01063d5:	e8 33 fe ff ff       	call   f010620d <find_env_in_queue>
f01063da:	83 c4 10             	add    $0x10,%esp
f01063dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_env != NULL)
f01063e0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01063e4:	0f 84 b2 00 00 00    	je     f010649c <sched_remove_ready+0x148>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), env);
f01063ea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01063ee:	75 17                	jne    f0106407 <sched_remove_ready+0xb3>
f01063f0:	83 ec 04             	sub    $0x4,%esp
f01063f3:	68 4f e6 12 f0       	push   $0xf012e64f
f01063f8:	68 b3 00 00 00       	push   $0xb3
f01063fd:	68 13 e6 12 f0       	push   $0xf012e613
f0106402:	e8 a8 ab ff ff       	call   f0100faf <_panic>
f0106407:	8b 45 08             	mov    0x8(%ebp),%eax
f010640a:	8b 40 08             	mov    0x8(%eax),%eax
f010640d:	85 c0                	test   %eax,%eax
f010640f:	74 11                	je     f0106422 <sched_remove_ready+0xce>
f0106411:	8b 45 08             	mov    0x8(%ebp),%eax
f0106414:	8b 40 08             	mov    0x8(%eax),%eax
f0106417:	8b 55 08             	mov    0x8(%ebp),%edx
f010641a:	8b 52 0c             	mov    0xc(%edx),%edx
f010641d:	89 50 0c             	mov    %edx,0xc(%eax)
f0106420:	eb 16                	jmp    f0106438 <sched_remove_ready+0xe4>
f0106422:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106427:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010642a:	c1 e2 04             	shl    $0x4,%edx
f010642d:	01 c2                	add    %eax,%edx
f010642f:	8b 45 08             	mov    0x8(%ebp),%eax
f0106432:	8b 40 0c             	mov    0xc(%eax),%eax
f0106435:	89 42 04             	mov    %eax,0x4(%edx)
f0106438:	8b 45 08             	mov    0x8(%ebp),%eax
f010643b:	8b 40 0c             	mov    0xc(%eax),%eax
f010643e:	85 c0                	test   %eax,%eax
f0106440:	74 11                	je     f0106453 <sched_remove_ready+0xff>
f0106442:	8b 45 08             	mov    0x8(%ebp),%eax
f0106445:	8b 40 0c             	mov    0xc(%eax),%eax
f0106448:	8b 55 08             	mov    0x8(%ebp),%edx
f010644b:	8b 52 08             	mov    0x8(%edx),%edx
f010644e:	89 50 08             	mov    %edx,0x8(%eax)
f0106451:	eb 15                	jmp    f0106468 <sched_remove_ready+0x114>
f0106453:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106458:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010645b:	c1 e2 04             	shl    $0x4,%edx
f010645e:	01 c2                	add    %eax,%edx
f0106460:	8b 45 08             	mov    0x8(%ebp),%eax
f0106463:	8b 40 08             	mov    0x8(%eax),%eax
f0106466:	89 02                	mov    %eax,(%edx)
f0106468:	8b 45 08             	mov    0x8(%ebp),%eax
f010646b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106472:	8b 45 08             	mov    0x8(%ebp),%eax
f0106475:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010647c:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106481:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106484:	c1 e2 04             	shl    $0x4,%edx
f0106487:	01 d0                	add    %edx,%eax
f0106489:	8b 50 0c             	mov    0xc(%eax),%edx
f010648c:	4a                   	dec    %edx
f010648d:	89 50 0c             	mov    %edx,0xc(%eax)
				env->env_status = ENV_UNKNOWN;
f0106490:	8b 45 08             	mov    0x8(%ebp),%eax
f0106493:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
				return ;
f010649a:	eb 14                	jmp    f01064b0 <sched_remove_ready+0x15c>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_READY);
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010649c:	ff 45 f4             	incl   -0xc(%ebp)
f010649f:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01064a4:	0f b6 c0             	movzbl %al,%eax
f01064a7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01064aa:	0f 8f 0b ff ff ff    	jg     f01063bb <sched_remove_ready+0x67>
				env->env_status = ENV_UNKNOWN;
				return ;
			}
		}
	}
}
f01064b0:	c9                   	leave  
f01064b1:	c3                   	ret    

f01064b2 <sched_insert_new>:

//=================================================
// [4] Insert the given Env in NEW Queue:
//=================================================
void sched_insert_new(struct Env* env)
{
f01064b2:	55                   	push   %ebp
f01064b3:	89 e5                	mov    %esp,%ebp
f01064b5:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f01064b8:	83 ec 0c             	sub    $0xc,%esp
f01064bb:	68 20 e7 83 f0       	push   $0xf083e720
f01064c0:	e8 0b 9c 00 00       	call   f01100d0 <holding_kspinlock>
f01064c5:	83 c4 10             	add    $0x10,%esp
f01064c8:	85 c0                	test   %eax,%eax
f01064ca:	75 17                	jne    f01064e3 <sched_insert_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01064cc:	83 ec 04             	sub    $0x4,%esp
f01064cf:	68 70 e6 12 f0       	push   $0xf012e670
f01064d4:	68 c2 00 00 00       	push   $0xc2
f01064d9:	68 13 e6 12 f0       	push   $0xf012e613
f01064de:	e8 cc aa ff ff       	call   f0100faf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f01064e3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01064e7:	75 19                	jne    f0106502 <sched_insert_new+0x50>
f01064e9:	68 b1 e6 12 f0       	push   $0xf012e6b1
f01064ee:	68 fe e5 12 f0       	push   $0xf012e5fe
f01064f3:	68 c5 00 00 00       	push   $0xc5
f01064f8:	68 13 e6 12 f0       	push   $0xf012e613
f01064fd:	e8 ad aa ff ff       	call   f0100faf <_panic>
	{
		env->env_status = ENV_NEW ;
f0106502:	8b 45 08             	mov    0x8(%ebp),%eax
f0106505:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
		enqueue(&ProcessQueues.env_new_queue, env);
f010650c:	83 ec 08             	sub    $0x8,%esp
f010650f:	ff 75 08             	pushl  0x8(%ebp)
f0106512:	68 90 e7 83 f0       	push   $0xf083e790
f0106517:	e8 ef fa ff ff       	call   f010600b <enqueue>
f010651c:	83 c4 10             	add    $0x10,%esp
	}
}
f010651f:	90                   	nop
f0106520:	c9                   	leave  
f0106521:	c3                   	ret    

f0106522 <sched_remove_new>:

//=================================================
// [5] Remove the given Env from NEW Queue:
//=================================================
void sched_remove_new(struct Env* env)
{
f0106522:	55                   	push   %ebp
f0106523:	89 e5                	mov    %esp,%ebp
f0106525:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106528:	83 ec 0c             	sub    $0xc,%esp
f010652b:	68 20 e7 83 f0       	push   $0xf083e720
f0106530:	e8 9b 9b 00 00       	call   f01100d0 <holding_kspinlock>
f0106535:	83 c4 10             	add    $0x10,%esp
f0106538:	85 c0                	test   %eax,%eax
f010653a:	75 17                	jne    f0106553 <sched_remove_new+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010653c:	83 ec 04             	sub    $0x4,%esp
f010653f:	68 70 e6 12 f0       	push   $0xf012e670
f0106544:	68 d3 00 00 00       	push   $0xd3
f0106549:	68 13 e6 12 f0       	push   $0xf012e613
f010654e:	e8 5c aa ff ff       	call   f0100faf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_NEW);
f0106553:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106557:	74 0b                	je     f0106564 <sched_remove_new+0x42>
f0106559:	8b 45 08             	mov    0x8(%ebp),%eax
f010655c:	8b 40 18             	mov    0x18(%eax),%eax
f010655f:	83 f8 04             	cmp    $0x4,%eax
f0106562:	74 19                	je     f010657d <sched_remove_new+0x5b>
f0106564:	68 ec e6 12 f0       	push   $0xf012e6ec
f0106569:	68 fe e5 12 f0       	push   $0xf012e5fe
f010656e:	68 d6 00 00 00       	push   $0xd6
f0106573:	68 13 e6 12 f0       	push   $0xf012e613
f0106578:	e8 32 aa ff ff       	call   f0100faf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_new_queue, env) ;
f010657d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106581:	75 17                	jne    f010659a <sched_remove_new+0x78>
f0106583:	83 ec 04             	sub    $0x4,%esp
f0106586:	68 4f e6 12 f0       	push   $0xf012e64f
f010658b:	68 d8 00 00 00       	push   $0xd8
f0106590:	68 13 e6 12 f0       	push   $0xf012e613
f0106595:	e8 15 aa ff ff       	call   f0100faf <_panic>
f010659a:	8b 45 08             	mov    0x8(%ebp),%eax
f010659d:	8b 40 08             	mov    0x8(%eax),%eax
f01065a0:	85 c0                	test   %eax,%eax
f01065a2:	74 11                	je     f01065b5 <sched_remove_new+0x93>
f01065a4:	8b 45 08             	mov    0x8(%ebp),%eax
f01065a7:	8b 40 08             	mov    0x8(%eax),%eax
f01065aa:	8b 55 08             	mov    0x8(%ebp),%edx
f01065ad:	8b 52 0c             	mov    0xc(%edx),%edx
f01065b0:	89 50 0c             	mov    %edx,0xc(%eax)
f01065b3:	eb 0b                	jmp    f01065c0 <sched_remove_new+0x9e>
f01065b5:	8b 45 08             	mov    0x8(%ebp),%eax
f01065b8:	8b 40 0c             	mov    0xc(%eax),%eax
f01065bb:	a3 94 e7 83 f0       	mov    %eax,0xf083e794
f01065c0:	8b 45 08             	mov    0x8(%ebp),%eax
f01065c3:	8b 40 0c             	mov    0xc(%eax),%eax
f01065c6:	85 c0                	test   %eax,%eax
f01065c8:	74 11                	je     f01065db <sched_remove_new+0xb9>
f01065ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01065cd:	8b 40 0c             	mov    0xc(%eax),%eax
f01065d0:	8b 55 08             	mov    0x8(%ebp),%edx
f01065d3:	8b 52 08             	mov    0x8(%edx),%edx
f01065d6:	89 50 08             	mov    %edx,0x8(%eax)
f01065d9:	eb 0b                	jmp    f01065e6 <sched_remove_new+0xc4>
f01065db:	8b 45 08             	mov    0x8(%ebp),%eax
f01065de:	8b 40 08             	mov    0x8(%eax),%eax
f01065e1:	a3 90 e7 83 f0       	mov    %eax,0xf083e790
f01065e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01065e9:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f01065f0:	8b 45 08             	mov    0x8(%ebp),%eax
f01065f3:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f01065fa:	a1 9c e7 83 f0       	mov    0xf083e79c,%eax
f01065ff:	48                   	dec    %eax
f0106600:	a3 9c e7 83 f0       	mov    %eax,0xf083e79c
		env->env_status = ENV_UNKNOWN;
f0106605:	8b 45 08             	mov    0x8(%ebp),%eax
f0106608:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f010660f:	90                   	nop
f0106610:	c9                   	leave  
f0106611:	c3                   	ret    

f0106612 <sched_insert_exit>:

//=================================================
// [6] Insert the given Env in EXIT Queue:
//=================================================
void sched_insert_exit(struct Env* env)
{
f0106612:	55                   	push   %ebp
f0106613:	89 e5                	mov    %esp,%ebp
f0106615:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0106618:	83 ec 0c             	sub    $0xc,%esp
f010661b:	68 20 e7 83 f0       	push   $0xf083e720
f0106620:	e8 ab 9a 00 00       	call   f01100d0 <holding_kspinlock>
f0106625:	83 c4 10             	add    $0x10,%esp
f0106628:	85 c0                	test   %eax,%eax
f010662a:	75 17                	jne    f0106643 <sched_insert_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f010662c:	83 ec 04             	sub    $0x4,%esp
f010662f:	68 70 e6 12 f0       	push   $0xf012e670
f0106634:	68 e4 00 00 00       	push   $0xe4
f0106639:	68 13 e6 12 f0       	push   $0xf012e613
f010663e:	e8 6c a9 ff ff       	call   f0100faf <_panic>
	/*********************************************************************/

	assert(env != NULL);
f0106643:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0106647:	75 19                	jne    f0106662 <sched_insert_exit+0x50>
f0106649:	68 b1 e6 12 f0       	push   $0xf012e6b1
f010664e:	68 fe e5 12 f0       	push   $0xf012e5fe
f0106653:	68 e7 00 00 00       	push   $0xe7
f0106658:	68 13 e6 12 f0       	push   $0xf012e613
f010665d:	e8 4d a9 ff ff       	call   f0100faf <_panic>
	{
		if(isBufferingEnabled()) {cleanup_buffers(env);}
f0106662:	e8 9a 93 00 00       	call   f010fa01 <isBufferingEnabled>
f0106667:	84 c0                	test   %al,%al
f0106669:	74 0e                	je     f0106679 <sched_insert_exit+0x67>
f010666b:	83 ec 0c             	sub    $0xc,%esp
f010666e:	ff 75 08             	pushl  0x8(%ebp)
f0106671:	e8 30 66 00 00       	call   f010cca6 <cleanup_buffers>
f0106676:	83 c4 10             	add    $0x10,%esp
		env->env_status = ENV_EXIT ;
f0106679:	8b 45 08             	mov    0x8(%ebp),%eax
f010667c:	c7 40 18 05 00 00 00 	movl   $0x5,0x18(%eax)
		enqueue(&ProcessQueues.env_exit_queue, env);
f0106683:	83 ec 08             	sub    $0x8,%esp
f0106686:	ff 75 08             	pushl  0x8(%ebp)
f0106689:	68 a0 e7 83 f0       	push   $0xf083e7a0
f010668e:	e8 78 f9 ff ff       	call   f010600b <enqueue>
f0106693:	83 c4 10             	add    $0x10,%esp
	}
}
f0106696:	90                   	nop
f0106697:	c9                   	leave  
f0106698:	c3                   	ret    

f0106699 <sched_remove_exit>:
//=================================================
// [7] Remove the given Env from EXIT Queue:
//=================================================
void sched_remove_exit(struct Env* env)
{
f0106699:	55                   	push   %ebp
f010669a:	89 e5                	mov    %esp,%ebp
f010669c:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010669f:	83 ec 0c             	sub    $0xc,%esp
f01066a2:	68 20 e7 83 f0       	push   $0xf083e720
f01066a7:	e8 24 9a 00 00       	call   f01100d0 <holding_kspinlock>
f01066ac:	83 c4 10             	add    $0x10,%esp
f01066af:	85 c0                	test   %eax,%eax
f01066b1:	75 17                	jne    f01066ca <sched_remove_exit+0x31>
		panic("sched: q.lock is not held by this CPU while it's expected to be.");
f01066b3:	83 ec 04             	sub    $0x4,%esp
f01066b6:	68 70 e6 12 f0       	push   $0xf012e670
f01066bb:	68 f5 00 00 00       	push   $0xf5
f01066c0:	68 13 e6 12 f0       	push   $0xf012e613
f01066c5:	e8 e5 a8 ff ff       	call   f0100faf <_panic>
	/*********************************************************************/

	assert(env != NULL && env->env_status == ENV_EXIT);
f01066ca:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01066ce:	74 0b                	je     f01066db <sched_remove_exit+0x42>
f01066d0:	8b 45 08             	mov    0x8(%ebp),%eax
f01066d3:	8b 40 18             	mov    0x18(%eax),%eax
f01066d6:	83 f8 05             	cmp    $0x5,%eax
f01066d9:	74 19                	je     f01066f4 <sched_remove_exit+0x5b>
f01066db:	68 18 e7 12 f0       	push   $0xf012e718
f01066e0:	68 fe e5 12 f0       	push   $0xf012e5fe
f01066e5:	68 f8 00 00 00       	push   $0xf8
f01066ea:	68 13 e6 12 f0       	push   $0xf012e613
f01066ef:	e8 bb a8 ff ff       	call   f0100faf <_panic>
	{
		LIST_REMOVE(&ProcessQueues.env_exit_queue, env) ;
f01066f4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01066f8:	75 17                	jne    f0106711 <sched_remove_exit+0x78>
f01066fa:	83 ec 04             	sub    $0x4,%esp
f01066fd:	68 4f e6 12 f0       	push   $0xf012e64f
f0106702:	68 fa 00 00 00       	push   $0xfa
f0106707:	68 13 e6 12 f0       	push   $0xf012e613
f010670c:	e8 9e a8 ff ff       	call   f0100faf <_panic>
f0106711:	8b 45 08             	mov    0x8(%ebp),%eax
f0106714:	8b 40 08             	mov    0x8(%eax),%eax
f0106717:	85 c0                	test   %eax,%eax
f0106719:	74 11                	je     f010672c <sched_remove_exit+0x93>
f010671b:	8b 45 08             	mov    0x8(%ebp),%eax
f010671e:	8b 40 08             	mov    0x8(%eax),%eax
f0106721:	8b 55 08             	mov    0x8(%ebp),%edx
f0106724:	8b 52 0c             	mov    0xc(%edx),%edx
f0106727:	89 50 0c             	mov    %edx,0xc(%eax)
f010672a:	eb 0b                	jmp    f0106737 <sched_remove_exit+0x9e>
f010672c:	8b 45 08             	mov    0x8(%ebp),%eax
f010672f:	8b 40 0c             	mov    0xc(%eax),%eax
f0106732:	a3 a4 e7 83 f0       	mov    %eax,0xf083e7a4
f0106737:	8b 45 08             	mov    0x8(%ebp),%eax
f010673a:	8b 40 0c             	mov    0xc(%eax),%eax
f010673d:	85 c0                	test   %eax,%eax
f010673f:	74 11                	je     f0106752 <sched_remove_exit+0xb9>
f0106741:	8b 45 08             	mov    0x8(%ebp),%eax
f0106744:	8b 40 0c             	mov    0xc(%eax),%eax
f0106747:	8b 55 08             	mov    0x8(%ebp),%edx
f010674a:	8b 52 08             	mov    0x8(%edx),%edx
f010674d:	89 50 08             	mov    %edx,0x8(%eax)
f0106750:	eb 0b                	jmp    f010675d <sched_remove_exit+0xc4>
f0106752:	8b 45 08             	mov    0x8(%ebp),%eax
f0106755:	8b 40 08             	mov    0x8(%eax),%eax
f0106758:	a3 a0 e7 83 f0       	mov    %eax,0xf083e7a0
f010675d:	8b 45 08             	mov    0x8(%ebp),%eax
f0106760:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106767:	8b 45 08             	mov    0x8(%ebp),%eax
f010676a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106771:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0106776:	48                   	dec    %eax
f0106777:	a3 ac e7 83 f0       	mov    %eax,0xf083e7ac
		env->env_status = ENV_UNKNOWN;
f010677c:	8b 45 08             	mov    0x8(%ebp),%eax
f010677f:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	}
}
f0106786:	90                   	nop
f0106787:	c9                   	leave  
f0106788:	c3                   	ret    

f0106789 <sched_new_env>:

//=================================================
// [8] Sched the given Env in NEW Queue:
//=================================================
void sched_new_env(struct Env* e)
{
f0106789:	55                   	push   %ebp
f010678a:	89 e5                	mov    %esp,%ebp
f010678c:	83 ec 08             	sub    $0x8,%esp
	  //cprintf("\n[SCHED_NEW_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010678f:	83 ec 0c             	sub    $0xc,%esp
f0106792:	68 20 e7 83 f0       	push   $0xf083e720
f0106797:	e8 df 96 00 00       	call   f010fe7b <acquire_kspinlock>
f010679c:	83 c4 10             	add    $0x10,%esp

	//add the given env to the scheduler NEW queue
	assert (e!=NULL);
f010679f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01067a3:	75 19                	jne    f01067be <sched_new_env+0x35>
f01067a5:	68 43 e7 12 f0       	push   $0xf012e743
f01067aa:	68 fe e5 12 f0       	push   $0xf012e5fe
f01067af:	68 08 01 00 00       	push   $0x108
f01067b4:	68 13 e6 12 f0       	push   $0xf012e613
f01067b9:	e8 f1 a7 ff ff       	call   f0100faf <_panic>
	{
		sched_insert_new(e);
f01067be:	83 ec 0c             	sub    $0xc,%esp
f01067c1:	ff 75 08             	pushl  0x8(%ebp)
f01067c4:	e8 e9 fc ff ff       	call   f01064b2 <sched_insert_new>
f01067c9:	83 c4 10             	add    $0x10,%esp
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01067cc:	83 ec 0c             	sub    $0xc,%esp
f01067cf:	68 20 e7 83 f0       	push   $0xf083e720
f01067d4:	e8 47 97 00 00       	call   f010ff20 <release_kspinlock>
f01067d9:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_NEW_ENV] release: lock status after = %d\n", qlock.locked);
}
f01067dc:	90                   	nop
f01067dd:	c9                   	leave  
f01067de:	c3                   	ret    

f01067df <sched_run_env>:

//=================================================
// [9] Run the given EnvID:
//=================================================
void sched_run_env(uint32 envId)
{
f01067df:	55                   	push   %ebp
f01067e0:	89 e5                	mov    %esp,%ebp
f01067e2:	83 ec 18             	sub    $0x18,%esp
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01067e5:	83 ec 0c             	sub    $0xc,%esp
f01067e8:	68 20 e7 83 f0       	push   $0xf083e720
f01067ed:	e8 89 96 00 00       	call   f010fe7b <acquire_kspinlock>
f01067f2:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f01067f5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01067fc:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106801:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106804:	eb 53                	jmp    f0106859 <sched_run_env+0x7a>
	{
		if(ptr_env->env_id == envId)
f0106806:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106809:	8b 40 10             	mov    0x10(%eax),%eax
f010680c:	3b 45 08             	cmp    0x8(%ebp),%eax
f010680f:	75 40                	jne    f0106851 <sched_run_env+0x72>
		{
			sched_remove_new(ptr_env);
f0106811:	83 ec 0c             	sub    $0xc,%esp
f0106814:	ff 75 f4             	pushl  -0xc(%ebp)
f0106817:	e8 06 fd ff ff       	call   f0106522 <sched_remove_new>
f010681c:	83 c4 10             	add    $0x10,%esp
			sched_insert_ready(ptr_env);
f010681f:	83 ec 0c             	sub    $0xc,%esp
f0106822:	ff 75 f4             	pushl  -0xc(%ebp)
f0106825:	e8 ad fa ff ff       	call   f01062d7 <sched_insert_ready>
f010682a:	83 c4 10             	add    $0x10,%esp

			/*2015*///if scheduler not run yet, then invoke it!
			if (mycpu()->scheduler_status == SCH_STOPPED)
f010682d:	e8 3e 18 00 00       	call   f0108070 <mycpu>
f0106832:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f0106838:	85 c0                	test   %eax,%eax
f010683a:	75 46                	jne    f0106882 <sched_run_env+0xa3>
			{
				release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010683c:	83 ec 0c             	sub    $0xc,%esp
f010683f:	68 20 e7 83 f0       	push   $0xf083e720
f0106844:	e8 d7 96 00 00       	call   f010ff20 <release_kspinlock>
f0106849:	83 c4 10             	add    $0x10,%esp
				  //cprintf("\n[SCHED_RUN_ENV] release#1: lock status after = %d\n", qlock.locked);
				fos_scheduler();
f010684c:	e8 f6 0f 00 00       	call   f0107847 <fos_scheduler>
void sched_run_env(uint32 envId)
{
	  //cprintf("\n[SCHED_RUN_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106851:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106856:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106859:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010685d:	74 08                	je     f0106867 <sched_run_env+0x88>
f010685f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106862:	8b 40 08             	mov    0x8(%eax),%eax
f0106865:	eb 05                	jmp    f010686c <sched_run_env+0x8d>
f0106867:	b8 00 00 00 00       	mov    $0x0,%eax
f010686c:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106871:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106876:	85 c0                	test   %eax,%eax
f0106878:	75 8c                	jne    f0106806 <sched_run_env+0x27>
f010687a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010687e:	75 86                	jne    f0106806 <sched_run_env+0x27>
f0106880:	eb 01                	jmp    f0106883 <sched_run_env+0xa4>
			}
			else
			{
				//can be invoked from a running environment via sys_run_env(), so just release the lock and resume
			}
			break;
f0106882:	90                   	nop
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106883:	83 ec 0c             	sub    $0xc,%esp
f0106886:	68 20 e7 83 f0       	push   $0xf083e720
f010688b:	e8 90 96 00 00       	call   f010ff20 <release_kspinlock>
f0106890:	83 c4 10             	add    $0x10,%esp
	  //cprintf("\n[SCHED_RUN_ENV] release#2: lock status after = %d\n", qlock.locked);
}
f0106893:	90                   	nop
f0106894:	c9                   	leave  
f0106895:	c3                   	ret    

f0106896 <sched_exit_env>:

//=================================================
// [10] Exit the given EnvID:
//=================================================
void sched_exit_env(uint32 envId)
{
f0106896:	55                   	push   %ebp
f0106897:	89 e5                	mov    %esp,%ebp
f0106899:	83 ec 28             	sub    $0x28,%esp
	bool lock_already_held = holding_kspinlock(&ProcessQueues.qlock);
f010689c:	83 ec 0c             	sub    $0xc,%esp
f010689f:	68 20 e7 83 f0       	push   $0xf083e720
f01068a4:	e8 27 98 00 00       	call   f01100d0 <holding_kspinlock>
f01068a9:	83 c4 10             	add    $0x10,%esp
f01068ac:	89 45 e8             	mov    %eax,-0x18(%ebp)
	  //cprintf("\n[SCHED_EXIT_ENV] acquire: lock status before acquire = %d\n", qlock.locked);
	if (!lock_already_held)
f01068af:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01068b3:	75 10                	jne    f01068c5 <sched_exit_env+0x2f>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01068b5:	83 ec 0c             	sub    $0xc,%esp
f01068b8:	68 20 e7 83 f0       	push   $0xf083e720
f01068bd:	e8 b9 95 00 00       	call   f010fe7b <acquire_kspinlock>
f01068c2:	83 c4 10             	add    $0x10,%esp
	}
	struct Env* ptr_env=NULL;
f01068c5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f01068cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f01068d3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01068d7:	75 59                	jne    f0106932 <sched_exit_env+0x9c>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01068d9:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f01068de:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01068e1:	eb 28                	jmp    f010690b <sched_exit_env+0x75>
		{
			if(ptr_env->env_id == envId)
f01068e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01068e6:	8b 40 10             	mov    0x10(%eax),%eax
f01068e9:	3b 45 08             	cmp    0x8(%ebp),%eax
f01068ec:	75 15                	jne    f0106903 <sched_exit_env+0x6d>
			{
				sched_remove_new(ptr_env);
f01068ee:	83 ec 0c             	sub    $0xc,%esp
f01068f1:	ff 75 f4             	pushl  -0xc(%ebp)
f01068f4:	e8 29 fc ff ff       	call   f0106522 <sched_remove_new>
f01068f9:	83 c4 10             	add    $0x10,%esp
				found = 1;
f01068fc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	}
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106903:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106908:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010690b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010690f:	74 08                	je     f0106919 <sched_exit_env+0x83>
f0106911:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106914:	8b 40 08             	mov    0x8(%eax),%eax
f0106917:	eb 05                	jmp    f010691e <sched_exit_env+0x88>
f0106919:	b8 00 00 00 00       	mov    $0x0,%eax
f010691e:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106923:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106928:	85 c0                	test   %eax,%eax
f010692a:	75 b7                	jne    f01068e3 <sched_exit_env+0x4d>
f010692c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106930:	75 b1                	jne    f01068e3 <sched_exit_env+0x4d>
				found = 1;
				//			return;
			}
		}
	}
	if (!found)
f0106932:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106936:	0f 85 67 01 00 00    	jne    f0106aa3 <sched_exit_env+0x20d>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f010693c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106943:	e9 47 01 00 00       	jmp    f0106a8f <sched_exit_env+0x1f9>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106948:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010694d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106950:	c1 e2 04             	shl    $0x4,%edx
f0106953:	01 d0                	add    %edx,%eax
f0106955:	8b 00                	mov    (%eax),%eax
f0106957:	85 c0                	test   %eax,%eax
f0106959:	0f 84 27 01 00 00    	je     f0106a86 <sched_exit_env+0x1f0>
			{
				ptr_env=NULL;
f010695f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106966:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010696b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010696e:	c1 e2 04             	shl    $0x4,%edx
f0106971:	01 d0                	add    %edx,%eax
f0106973:	8b 00                	mov    (%eax),%eax
f0106975:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106978:	e9 d1 00 00 00       	jmp    f0106a4e <sched_exit_env+0x1b8>
				{
					if(ptr_env->env_id == envId)
f010697d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106980:	8b 40 10             	mov    0x10(%eax),%eax
f0106983:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106986:	0f 85 af 00 00 00    	jne    f0106a3b <sched_exit_env+0x1a5>
					{
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f010698c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106990:	75 17                	jne    f01069a9 <sched_exit_env+0x113>
f0106992:	83 ec 04             	sub    $0x4,%esp
f0106995:	68 4f e6 12 f0       	push   $0xf012e64f
f010699a:	68 56 01 00 00       	push   $0x156
f010699f:	68 13 e6 12 f0       	push   $0xf012e613
f01069a4:	e8 06 a6 ff ff       	call   f0100faf <_panic>
f01069a9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069ac:	8b 40 08             	mov    0x8(%eax),%eax
f01069af:	85 c0                	test   %eax,%eax
f01069b1:	74 11                	je     f01069c4 <sched_exit_env+0x12e>
f01069b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069b6:	8b 40 08             	mov    0x8(%eax),%eax
f01069b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01069bc:	8b 52 0c             	mov    0xc(%edx),%edx
f01069bf:	89 50 0c             	mov    %edx,0xc(%eax)
f01069c2:	eb 16                	jmp    f01069da <sched_exit_env+0x144>
f01069c4:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01069c9:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01069cc:	c1 e2 04             	shl    $0x4,%edx
f01069cf:	01 c2                	add    %eax,%edx
f01069d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069d4:	8b 40 0c             	mov    0xc(%eax),%eax
f01069d7:	89 42 04             	mov    %eax,0x4(%edx)
f01069da:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069dd:	8b 40 0c             	mov    0xc(%eax),%eax
f01069e0:	85 c0                	test   %eax,%eax
f01069e2:	74 11                	je     f01069f5 <sched_exit_env+0x15f>
f01069e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01069e7:	8b 40 0c             	mov    0xc(%eax),%eax
f01069ea:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01069ed:	8b 52 08             	mov    0x8(%edx),%edx
f01069f0:	89 50 08             	mov    %edx,0x8(%eax)
f01069f3:	eb 15                	jmp    f0106a0a <sched_exit_env+0x174>
f01069f5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01069fa:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01069fd:	c1 e2 04             	shl    $0x4,%edx
f0106a00:	01 c2                	add    %eax,%edx
f0106a02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a05:	8b 40 08             	mov    0x8(%eax),%eax
f0106a08:	89 02                	mov    %eax,(%edx)
f0106a0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a0d:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106a14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106a17:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106a1e:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106a23:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a26:	c1 e2 04             	shl    $0x4,%edx
f0106a29:	01 d0                	add    %edx,%eax
f0106a2b:	8b 50 0c             	mov    0xc(%eax),%edx
f0106a2e:	4a                   	dec    %edx
f0106a2f:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106a32:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106a39:	eb 4b                	jmp    f0106a86 <sched_exit_env+0x1f0>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106a3b:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106a40:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a43:	c1 e2 04             	shl    $0x4,%edx
f0106a46:	01 d0                	add    %edx,%eax
f0106a48:	8b 40 08             	mov    0x8(%eax),%eax
f0106a4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106a4e:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106a53:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106a56:	c1 e2 04             	shl    $0x4,%edx
f0106a59:	01 d0                	add    %edx,%eax
f0106a5b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106a5f:	74 08                	je     f0106a69 <sched_exit_env+0x1d3>
f0106a61:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106a64:	8b 52 08             	mov    0x8(%edx),%edx
f0106a67:	eb 05                	jmp    f0106a6e <sched_exit_env+0x1d8>
f0106a69:	ba 00 00 00 00       	mov    $0x0,%edx
f0106a6e:	89 50 08             	mov    %edx,0x8(%eax)
f0106a71:	8b 40 08             	mov    0x8(%eax),%eax
f0106a74:	85 c0                	test   %eax,%eax
f0106a76:	0f 85 01 ff ff ff    	jne    f010697d <sched_exit_env+0xe7>
f0106a7c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106a80:	0f 85 f7 fe ff ff    	jne    f010697d <sched_exit_env+0xe7>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0106a86:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106a8a:	75 16                	jne    f0106aa2 <sched_exit_env+0x20c>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106a8c:	ff 45 ec             	incl   -0x14(%ebp)
f0106a8f:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0106a94:	0f b6 c0             	movzbl %al,%eax
f0106a97:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106a9a:	0f 8f a8 fe ff ff    	jg     f0106948 <sched_exit_env+0xb2>
f0106aa0:	eb 01                	jmp    f0106aa3 <sched_exit_env+0x20d>
						found = 1;
						break;
					}
				}
			}
			if (found) break;
f0106aa2:	90                   	nop
		}
	}
	struct Env* cur_env = get_cpu_proc();
f0106aa3:	e8 70 50 00 00       	call   f010bb18 <get_cpu_proc>
f0106aa8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0106aab:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0106aaf:	75 19                	jne    f0106aca <sched_exit_env+0x234>
f0106ab1:	68 4b e7 12 f0       	push   $0xf012e74b
f0106ab6:	68 fe e5 12 f0       	push   $0xf012e5fe
f0106abb:	68 60 01 00 00       	push   $0x160
f0106ac0:	68 13 e6 12 f0       	push   $0xf012e613
f0106ac5:	e8 e5 a4 ff ff       	call   f0100faf <_panic>
	if (!found)
f0106aca:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106ace:	75 18                	jne    f0106ae8 <sched_exit_env+0x252>
	{
		if (cur_env->env_id == envId)
f0106ad0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106ad3:	8b 40 10             	mov    0x10(%eax),%eax
f0106ad6:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106ad9:	75 0d                	jne    f0106ae8 <sched_exit_env+0x252>
		{
			ptr_env = cur_env;
f0106adb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106ade:	89 45 f4             	mov    %eax,-0xc(%ebp)
			found = 1;
f0106ae1:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		}
	}

	if (found)
f0106ae8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106aec:	74 1e                	je     f0106b0c <sched_exit_env+0x276>
	{
		sched_insert_exit(ptr_env);
f0106aee:	83 ec 0c             	sub    $0xc,%esp
f0106af1:	ff 75 f4             	pushl  -0xc(%ebp)
f0106af4:	e8 19 fb ff ff       	call   f0106612 <sched_insert_exit>
f0106af9:	83 c4 10             	add    $0x10,%esp

		//If it's the curenv, then reinvoke the scheduler as there's no meaning to return back
		//to an exited env. Status already set to EXIT in the sched_insert_exit()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		if (cur_env->env_id == envId)
f0106afc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0106aff:	8b 40 10             	mov    0x10(%eax),%eax
f0106b02:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106b05:	75 05                	jne    f0106b0c <sched_exit_env+0x276>
		{
//			cprintf("\n[%d:%s] LAST WS BEFORE EXIT\n", cur_env->env_id,  cur_env->prog_name);
//			env_page_ws_print(cur_env);
			//2024: Replaced by sched() which call context switch
			//fos_scheduler();
			sched();
f0106b07:	e8 86 51 00 00       	call   f010bc92 <sched>
		}
	}
	if (!lock_already_held)
f0106b0c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106b10:	75 10                	jne    f0106b22 <sched_exit_env+0x28c>
	{
		release_kspinlock(&ProcessQueues.qlock);
f0106b12:	83 ec 0c             	sub    $0xc,%esp
f0106b15:	68 20 e7 83 f0       	push   $0xf083e720
f0106b1a:	e8 01 94 00 00       	call   f010ff20 <release_kspinlock>
f0106b1f:	83 c4 10             	add    $0x10,%esp
	}
	//cprintf("\n[SCHED_EXIT_ENV] release: lock status after = %d\n", qlock.locked);
}
f0106b22:	90                   	nop
f0106b23:	c9                   	leave  
f0106b24:	c3                   	ret    

f0106b25 <sched_kill_env>:
/*2015*/
//=================================================
// [11] KILL the given EnvID:
//=================================================
void sched_kill_env(uint32 envId)
{
f0106b25:	55                   	push   %ebp
f0106b26:	89 e5                	mov    %esp,%ebp
f0106b28:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106b2b:	83 ec 0c             	sub    $0xc,%esp
f0106b2e:	68 20 e7 83 f0       	push   $0xf083e720
f0106b33:	e8 43 93 00 00       	call   f010fe7b <acquire_kspinlock>
f0106b38:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f0106b3b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int found = 0;
f0106b42:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	if (!found)
f0106b49:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106b4d:	75 79                	jne    f0106bc8 <sched_kill_env+0xa3>
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106b4f:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106b54:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106b57:	eb 48                	jmp    f0106ba1 <sched_kill_env+0x7c>
		{
			if(ptr_env->env_id == envId)
f0106b59:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b5c:	8b 40 10             	mov    0x10(%eax),%eax
f0106b5f:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106b62:	75 35                	jne    f0106b99 <sched_kill_env+0x74>
			{
				cprintf("[BEGIN] killing[%d] %s from the NEW queue...", ptr_env->env_id, ptr_env->prog_name);
f0106b64:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b67:	8d 50 20             	lea    0x20(%eax),%edx
f0106b6a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106b6d:	8b 40 10             	mov    0x10(%eax),%eax
f0106b70:	83 ec 04             	sub    $0x4,%esp
f0106b73:	52                   	push   %edx
f0106b74:	50                   	push   %eax
f0106b75:	68 5c e7 12 f0       	push   $0xf012e75c
f0106b7a:	e8 dd b0 ff ff       	call   f0101c5c <cprintf>
f0106b7f:	83 c4 10             	add    $0x10,%esp
				sched_remove_new(ptr_env);
f0106b82:	83 ec 0c             	sub    $0xc,%esp
f0106b85:	ff 75 f4             	pushl  -0xc(%ebp)
f0106b88:	e8 95 f9 ff ff       	call   f0106522 <sched_remove_new>
f0106b8d:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106b90:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106b97:	eb 2f                	jmp    f0106bc8 <sched_kill_env+0xa3>
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	int found = 0;
	if (!found)
	{
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106b99:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106b9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ba1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ba5:	74 08                	je     f0106baf <sched_kill_env+0x8a>
f0106ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106baa:	8b 40 08             	mov    0x8(%eax),%eax
f0106bad:	eb 05                	jmp    f0106bb4 <sched_kill_env+0x8f>
f0106baf:	b8 00 00 00 00       	mov    $0x0,%eax
f0106bb4:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106bb9:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106bbe:	85 c0                	test   %eax,%eax
f0106bc0:	75 97                	jne    f0106b59 <sched_kill_env+0x34>
f0106bc2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106bc6:	75 91                	jne    f0106b59 <sched_kill_env+0x34>
				found = 1;
				break;
			}
		}
	}
	if (!found)
f0106bc8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106bcc:	0f 85 85 01 00 00    	jne    f0106d57 <sched_kill_env+0x232>
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106bd2:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0106bd9:	e9 65 01 00 00       	jmp    f0106d43 <sched_kill_env+0x21e>
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106bde:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106be3:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106be6:	c1 e2 04             	shl    $0x4,%edx
f0106be9:	01 d0                	add    %edx,%eax
f0106beb:	8b 00                	mov    (%eax),%eax
f0106bed:	85 c0                	test   %eax,%eax
f0106bef:	0f 84 45 01 00 00    	je     f0106d3a <sched_kill_env+0x215>
			{
				ptr_env=NULL;
f0106bf5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106bfc:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106c01:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c04:	c1 e2 04             	shl    $0x4,%edx
f0106c07:	01 d0                	add    %edx,%eax
f0106c09:	8b 00                	mov    (%eax),%eax
f0106c0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106c0e:	e9 ef 00 00 00       	jmp    f0106d02 <sched_kill_env+0x1dd>
				{
					if(ptr_env->env_id == envId)
f0106c13:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c16:	8b 40 10             	mov    0x10(%eax),%eax
f0106c19:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106c1c:	0f 85 cd 00 00 00    	jne    f0106cef <sched_kill_env+0x1ca>
					{
						cprintf("[BEGIN] killing[%d] %s from the READY queue #%d...", ptr_env->env_id, ptr_env->prog_name, i);
f0106c22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c25:	8d 50 20             	lea    0x20(%eax),%edx
f0106c28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c2b:	8b 40 10             	mov    0x10(%eax),%eax
f0106c2e:	ff 75 ec             	pushl  -0x14(%ebp)
f0106c31:	52                   	push   %edx
f0106c32:	50                   	push   %eax
f0106c33:	68 8c e7 12 f0       	push   $0xf012e78c
f0106c38:	e8 1f b0 ff ff       	call   f0101c5c <cprintf>
f0106c3d:	83 c4 10             	add    $0x10,%esp
						LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f0106c40:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106c44:	75 17                	jne    f0106c5d <sched_kill_env+0x138>
f0106c46:	83 ec 04             	sub    $0x4,%esp
f0106c49:	68 4f e6 12 f0       	push   $0xf012e64f
f0106c4e:	68 a5 01 00 00       	push   $0x1a5
f0106c53:	68 13 e6 12 f0       	push   $0xf012e613
f0106c58:	e8 52 a3 ff ff       	call   f0100faf <_panic>
f0106c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c60:	8b 40 08             	mov    0x8(%eax),%eax
f0106c63:	85 c0                	test   %eax,%eax
f0106c65:	74 11                	je     f0106c78 <sched_kill_env+0x153>
f0106c67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c6a:	8b 40 08             	mov    0x8(%eax),%eax
f0106c6d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106c70:	8b 52 0c             	mov    0xc(%edx),%edx
f0106c73:	89 50 0c             	mov    %edx,0xc(%eax)
f0106c76:	eb 16                	jmp    f0106c8e <sched_kill_env+0x169>
f0106c78:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106c7d:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106c80:	c1 e2 04             	shl    $0x4,%edx
f0106c83:	01 c2                	add    %eax,%edx
f0106c85:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c88:	8b 40 0c             	mov    0xc(%eax),%eax
f0106c8b:	89 42 04             	mov    %eax,0x4(%edx)
f0106c8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c91:	8b 40 0c             	mov    0xc(%eax),%eax
f0106c94:	85 c0                	test   %eax,%eax
f0106c96:	74 11                	je     f0106ca9 <sched_kill_env+0x184>
f0106c98:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106c9b:	8b 40 0c             	mov    0xc(%eax),%eax
f0106c9e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106ca1:	8b 52 08             	mov    0x8(%edx),%edx
f0106ca4:	89 50 08             	mov    %edx,0x8(%eax)
f0106ca7:	eb 15                	jmp    f0106cbe <sched_kill_env+0x199>
f0106ca9:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106cae:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cb1:	c1 e2 04             	shl    $0x4,%edx
f0106cb4:	01 c2                	add    %eax,%edx
f0106cb6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cb9:	8b 40 08             	mov    0x8(%eax),%eax
f0106cbc:	89 02                	mov    %eax,(%edx)
f0106cbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106cc1:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0106cc8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106ccb:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0106cd2:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106cd7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cda:	c1 e2 04             	shl    $0x4,%edx
f0106cdd:	01 d0                	add    %edx,%eax
f0106cdf:	8b 50 0c             	mov    0xc(%eax),%edx
f0106ce2:	4a                   	dec    %edx
f0106ce3:	89 50 0c             	mov    %edx,0xc(%eax)
						found = 1;
f0106ce6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
						break;
f0106ced:	eb 4b                	jmp    f0106d3a <sched_kill_env+0x215>
		for (int i = 0 ; i < num_of_ready_queues ; i++)
		{
			if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
			{
				ptr_env=NULL;
				LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106cef:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106cf4:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106cf7:	c1 e2 04             	shl    $0x4,%edx
f0106cfa:	01 d0                	add    %edx,%eax
f0106cfc:	8b 40 08             	mov    0x8(%eax),%eax
f0106cff:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106d02:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106d07:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0106d0a:	c1 e2 04             	shl    $0x4,%edx
f0106d0d:	01 d0                	add    %edx,%eax
f0106d0f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d13:	74 08                	je     f0106d1d <sched_kill_env+0x1f8>
f0106d15:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0106d18:	8b 52 08             	mov    0x8(%edx),%edx
f0106d1b:	eb 05                	jmp    f0106d22 <sched_kill_env+0x1fd>
f0106d1d:	ba 00 00 00 00       	mov    $0x0,%edx
f0106d22:	89 50 08             	mov    %edx,0x8(%eax)
f0106d25:	8b 40 08             	mov    0x8(%eax),%eax
f0106d28:	85 c0                	test   %eax,%eax
f0106d2a:	0f 85 e3 fe ff ff    	jne    f0106c13 <sched_kill_env+0xee>
f0106d30:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106d34:	0f 85 d9 fe ff ff    	jne    f0106c13 <sched_kill_env+0xee>
						found = 1;
						break;
					}
				}
			}
			if (found)
f0106d3a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106d3e:	75 16                	jne    f0106d56 <sched_kill_env+0x231>
			}
		}
	}
	if (!found)
	{
		for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106d40:	ff 45 ec             	incl   -0x14(%ebp)
f0106d43:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0106d48:	0f b6 c0             	movzbl %al,%eax
f0106d4b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0106d4e:	0f 8f 8a fe ff ff    	jg     f0106bde <sched_kill_env+0xb9>
f0106d54:	eb 01                	jmp    f0106d57 <sched_kill_env+0x232>
						break;
					}
				}
			}
			if (found)
				break;
f0106d56:	90                   	nop
		}
	}
	if (!found)
f0106d57:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106d5b:	0f 85 80 00 00 00    	jne    f0106de1 <sched_kill_env+0x2bc>
	{
		ptr_env=NULL;
f0106d61:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106d68:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0106d6d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106d70:	eb 48                	jmp    f0106dba <sched_kill_env+0x295>
		{
			if(ptr_env->env_id == envId)
f0106d72:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d75:	8b 40 10             	mov    0x10(%eax),%eax
f0106d78:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106d7b:	75 35                	jne    f0106db2 <sched_kill_env+0x28d>
			{
				cprintf("[BEGIN] killing[%d] %s from the EXIT queue...\n", ptr_env->env_id, ptr_env->prog_name);
f0106d7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d80:	8d 50 20             	lea    0x20(%eax),%edx
f0106d83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106d86:	8b 40 10             	mov    0x10(%eax),%eax
f0106d89:	83 ec 04             	sub    $0x4,%esp
f0106d8c:	52                   	push   %edx
f0106d8d:	50                   	push   %eax
f0106d8e:	68 c0 e7 12 f0       	push   $0xf012e7c0
f0106d93:	e8 c4 ae ff ff       	call   f0101c5c <cprintf>
f0106d98:	83 c4 10             	add    $0x10,%esp
				sched_remove_exit(ptr_env);
f0106d9b:	83 ec 0c             	sub    $0xc,%esp
f0106d9e:	ff 75 f4             	pushl  -0xc(%ebp)
f0106da1:	e8 f3 f8 ff ff       	call   f0106699 <sched_remove_exit>
f0106da6:	83 c4 10             	add    $0x10,%esp
				found = 1;
f0106da9:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
				break;
f0106db0:	eb 2f                	jmp    f0106de1 <sched_kill_env+0x2bc>
		}
	}
	if (!found)
	{
		ptr_env=NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0106db2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0106db7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106dba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106dbe:	74 08                	je     f0106dc8 <sched_kill_env+0x2a3>
f0106dc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106dc3:	8b 40 08             	mov    0x8(%eax),%eax
f0106dc6:	eb 05                	jmp    f0106dcd <sched_kill_env+0x2a8>
f0106dc8:	b8 00 00 00 00       	mov    $0x0,%eax
f0106dcd:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f0106dd2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0106dd7:	85 c0                	test   %eax,%eax
f0106dd9:	75 97                	jne    f0106d72 <sched_kill_env+0x24d>
f0106ddb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106ddf:	75 91                	jne    f0106d72 <sched_kill_env+0x24d>
				found = 1;
				break;
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106de1:	83 ec 0c             	sub    $0xc,%esp
f0106de4:	68 20 e7 83 f0       	push   $0xf083e720
f0106de9:	e8 32 91 00 00       	call   f010ff20 <release_kspinlock>
f0106dee:	83 c4 10             	add    $0x10,%esp

	if (found)
f0106df1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0106df5:	74 23                	je     f0106e1a <sched_kill_env+0x2f5>
	{
		env_free(ptr_env);
f0106df7:	83 ec 0c             	sub    $0xc,%esp
f0106dfa:	ff 75 f4             	pushl  -0xc(%ebp)
f0106dfd:	e8 b7 4c 00 00       	call   f010bab9 <env_free>
f0106e02:	83 c4 10             	add    $0x10,%esp
		cprintf("[END] DONE\n");
f0106e05:	83 ec 0c             	sub    $0xc,%esp
f0106e08:	68 ef e7 12 f0       	push   $0xf012e7ef
f0106e0d:	e8 4a ae ff ff       	call   f0101c5c <cprintf>
f0106e12:	83 c4 10             	add    $0x10,%esp
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
			sched();
		}
	}

}
f0106e15:	e9 b8 00 00 00       	jmp    f0106ed2 <sched_kill_env+0x3ad>
		env_free(ptr_env);
		cprintf("[END] DONE\n");
	}
	else
	{
		struct Env* cur_env = get_cpu_proc();
f0106e1a:	e8 f9 4c 00 00       	call   f010bb18 <get_cpu_proc>
f0106e1f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		assert(cur_env != NULL);
f0106e22:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0106e26:	75 19                	jne    f0106e41 <sched_kill_env+0x31c>
f0106e28:	68 4b e7 12 f0       	push   $0xf012e74b
f0106e2d:	68 fe e5 12 f0       	push   $0xf012e5fe
f0106e32:	68 c7 01 00 00       	push   $0x1c7
f0106e37:	68 13 e6 12 f0       	push   $0xf012e613
f0106e3c:	e8 6e a1 ff ff       	call   f0100faf <_panic>

		if (cur_env->env_id == envId)
f0106e41:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106e44:	8b 40 10             	mov    0x10(%eax),%eax
f0106e47:	3b 45 08             	cmp    0x8(%ebp),%eax
f0106e4a:	0f 85 82 00 00 00    	jne    f0106ed2 <sched_kill_env+0x3ad>
		{
			ptr_env = cur_env;
f0106e50:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0106e53:	89 45 f4             	mov    %eax,-0xc(%ebp)
			assert(ptr_env->env_status == ENV_RUNNING);
f0106e56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e59:	8b 40 18             	mov    0x18(%eax),%eax
f0106e5c:	83 f8 02             	cmp    $0x2,%eax
f0106e5f:	74 19                	je     f0106e7a <sched_kill_env+0x355>
f0106e61:	68 fc e7 12 f0       	push   $0xf012e7fc
f0106e66:	68 fe e5 12 f0       	push   $0xf012e5fe
f0106e6b:	68 cc 01 00 00       	push   $0x1cc
f0106e70:	68 13 e6 12 f0       	push   $0xf012e613
f0106e75:	e8 35 a1 ff ff       	call   f0100faf <_panic>
			cprintf("[BEGIN] killing a RUNNABLE environment [%d] %s...\n", ptr_env->env_id, ptr_env->prog_name);
f0106e7a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e7d:	8d 50 20             	lea    0x20(%eax),%edx
f0106e80:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106e83:	8b 40 10             	mov    0x10(%eax),%eax
f0106e86:	83 ec 04             	sub    $0x4,%esp
f0106e89:	52                   	push   %edx
f0106e8a:	50                   	push   %eax
f0106e8b:	68 20 e8 12 f0       	push   $0xf012e820
f0106e90:	e8 c7 ad ff ff       	call   f0101c5c <cprintf>
f0106e95:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0106e98:	83 ec 0c             	sub    $0xc,%esp
f0106e9b:	ff 75 f4             	pushl  -0xc(%ebp)
f0106e9e:	e8 16 4c 00 00       	call   f010bab9 <env_free>
f0106ea3:	83 c4 10             	add    $0x10,%esp
			cprintf("[END] DONE\n");
f0106ea6:	83 ec 0c             	sub    $0xc,%esp
f0106ea9:	68 ef e7 12 f0       	push   $0xf012e7ef
f0106eae:	e8 a9 ad ff ff       	call   f0101c5c <cprintf>
f0106eb3:	83 c4 10             	add    $0x10,%esp
			found = 1;
f0106eb6:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			//this process
			/*2024: replaced by sched() to apply context_switch*/
			//lcr3(phys_page_directory);
			//switchkvm();
			//fos_scheduler();
			acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106ebd:	83 ec 0c             	sub    $0xc,%esp
f0106ec0:	68 20 e7 83 f0       	push   $0xf083e720
f0106ec5:	e8 b1 8f 00 00       	call   f010fe7b <acquire_kspinlock>
f0106eca:	83 c4 10             	add    $0x10,%esp
			sched();
f0106ecd:	e8 c0 4d 00 00       	call   f010bc92 <sched>
		}
	}

}
f0106ed2:	90                   	nop
f0106ed3:	c9                   	leave  
f0106ed4:	c3                   	ret    

f0106ed5 <sched_print_all>:

//=================================================
// [12] PRINT ALL Envs from all queues:
//=================================================
void sched_print_all()
{
f0106ed5:	55                   	push   %ebp
f0106ed6:	89 e5                	mov    %esp,%ebp
f0106ed8:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0106edb:	83 ec 0c             	sub    $0xc,%esp
f0106ede:	68 20 e7 83 f0       	push   $0xf083e720
f0106ee3:	e8 93 8f 00 00       	call   f010fe7b <acquire_kspinlock>
f0106ee8:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f0106eeb:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106ef0:	85 c0                	test   %eax,%eax
f0106ef2:	74 69                	je     f0106f5d <sched_print_all+0x88>
	{
		cprintf("\nThe processes in NEW queue are:\n");
f0106ef4:	83 ec 0c             	sub    $0xc,%esp
f0106ef7:	68 54 e8 12 f0       	push   $0xf012e854
f0106efc:	e8 5b ad ff ff       	call   f0101c5c <cprintf>
f0106f01:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106f04:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f0106f09:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f0c:	eb 26                	jmp    f0106f34 <sched_print_all+0x5f>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106f0e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f11:	8d 50 20             	lea    0x20(%eax),%edx
f0106f14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f17:	8b 40 10             	mov    0x10(%eax),%eax
f0106f1a:	83 ec 04             	sub    $0x4,%esp
f0106f1d:	52                   	push   %edx
f0106f1e:	50                   	push   %eax
f0106f1f:	68 76 e8 12 f0       	push   $0xf012e876
f0106f24:	e8 33 ad ff ff       	call   f0101c5c <cprintf>
f0106f29:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nThe processes in NEW queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0106f2c:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106f31:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106f34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f38:	74 08                	je     f0106f42 <sched_print_all+0x6d>
f0106f3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106f3d:	8b 40 08             	mov    0x8(%eax),%eax
f0106f40:	eb 05                	jmp    f0106f47 <sched_print_all+0x72>
f0106f42:	b8 00 00 00 00       	mov    $0x0,%eax
f0106f47:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0106f4c:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0106f51:	85 c0                	test   %eax,%eax
f0106f53:	75 b9                	jne    f0106f0e <sched_print_all+0x39>
f0106f55:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0106f59:	75 b3                	jne    f0106f0e <sched_print_all+0x39>
f0106f5b:	eb 10                	jmp    f0106f6d <sched_print_all+0x98>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("\nNo processes in NEW queue\n");
f0106f5d:	83 ec 0c             	sub    $0xc,%esp
f0106f60:	68 80 e8 12 f0       	push   $0xf012e880
f0106f65:	e8 f2 ac ff ff       	call   f0101c5c <cprintf>
f0106f6a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0106f6d:	83 ec 0c             	sub    $0xc,%esp
f0106f70:	68 9c e8 12 f0       	push   $0xf012e89c
f0106f75:	e8 e2 ac ff ff       	call   f0101c5c <cprintf>
f0106f7a:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0106f7d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0106f84:	e9 c7 00 00 00       	jmp    f0107050 <sched_print_all+0x17b>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f0106f89:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106f8e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106f91:	c1 e2 04             	shl    $0x4,%edx
f0106f94:	01 d0                	add    %edx,%eax
f0106f96:	8b 00                	mov    (%eax),%eax
f0106f98:	85 c0                	test   %eax,%eax
f0106f9a:	0f 84 8a 00 00 00    	je     f010702a <sched_print_all+0x155>
		{
			cprintf("The processes in READY queue #%d are:\n", i);
f0106fa0:	83 ec 08             	sub    $0x8,%esp
f0106fa3:	ff 75 f0             	pushl  -0x10(%ebp)
f0106fa6:	68 d0 e8 12 f0       	push   $0xf012e8d0
f0106fab:	e8 ac ac ff ff       	call   f0101c5c <cprintf>
f0106fb0:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106fb3:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106fb8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fbb:	c1 e2 04             	shl    $0x4,%edx
f0106fbe:	01 d0                	add    %edx,%eax
f0106fc0:	8b 00                	mov    (%eax),%eax
f0106fc2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106fc5:	eb 31                	jmp    f0106ff8 <sched_print_all+0x123>
			{
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0106fc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fca:	8d 50 20             	lea    0x20(%eax),%edx
f0106fcd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0106fd0:	8b 40 10             	mov    0x10(%eax),%eax
f0106fd3:	83 ec 04             	sub    $0x4,%esp
f0106fd6:	52                   	push   %edx
f0106fd7:	50                   	push   %eax
f0106fd8:	68 76 e8 12 f0       	push   $0xf012e876
f0106fdd:	e8 7a ac ff ff       	call   f0101c5c <cprintf>
f0106fe2:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("The processes in READY queue #%d are:\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0106fe5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106fea:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0106fed:	c1 e2 04             	shl    $0x4,%edx
f0106ff0:	01 d0                	add    %edx,%eax
f0106ff2:	8b 40 08             	mov    0x8(%eax),%eax
f0106ff5:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0106ff8:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0106ffd:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107000:	c1 e2 04             	shl    $0x4,%edx
f0107003:	01 d0                	add    %edx,%eax
f0107005:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107009:	74 08                	je     f0107013 <sched_print_all+0x13e>
f010700b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010700e:	8b 52 08             	mov    0x8(%edx),%edx
f0107011:	eb 05                	jmp    f0107018 <sched_print_all+0x143>
f0107013:	ba 00 00 00 00       	mov    $0x0,%edx
f0107018:	89 50 08             	mov    %edx,0x8(%eax)
f010701b:	8b 40 08             	mov    0x8(%eax),%eax
f010701e:	85 c0                	test   %eax,%eax
f0107020:	75 a5                	jne    f0106fc7 <sched_print_all+0xf2>
f0107022:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107026:	75 9f                	jne    f0106fc7 <sched_print_all+0xf2>
f0107028:	eb 13                	jmp    f010703d <sched_print_all+0x168>
				cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n", i);
f010702a:	83 ec 08             	sub    $0x8,%esp
f010702d:	ff 75 f0             	pushl  -0x10(%ebp)
f0107030:	68 f8 e8 12 f0       	push   $0xf012e8f8
f0107035:	e8 22 ac ff ff       	call   f0101c5c <cprintf>
f010703a:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f010703d:	83 ec 0c             	sub    $0xc,%esp
f0107040:	68 9c e8 12 f0       	push   $0xf012e89c
f0107045:	e8 12 ac ff ff       	call   f0101c5c <cprintf>
f010704a:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("\nNo processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f010704d:	ff 45 f0             	incl   -0x10(%ebp)
f0107050:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0107055:	0f b6 c0             	movzbl %al,%eax
f0107058:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010705b:	0f 8f 28 ff ff ff    	jg     f0106f89 <sched_print_all+0xb4>
		{
			cprintf("No processes in READY queue #%d\n", i);
		}
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0107061:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0107066:	85 c0                	test   %eax,%eax
f0107068:	74 69                	je     f01070d3 <sched_print_all+0x1fe>
	{
		cprintf("The processes in EXIT queue are:\n");
f010706a:	83 ec 0c             	sub    $0xc,%esp
f010706d:	68 1c e9 12 f0       	push   $0xf012e91c
f0107072:	e8 e5 ab ff ff       	call   f0101c5c <cprintf>
f0107077:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f010707a:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f010707f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0107082:	eb 26                	jmp    f01070aa <sched_print_all+0x1d5>
		{
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
f0107084:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107087:	8d 50 20             	lea    0x20(%eax),%edx
f010708a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010708d:	8b 40 10             	mov    0x10(%eax),%eax
f0107090:	83 ec 04             	sub    $0x4,%esp
f0107093:	52                   	push   %edx
f0107094:	50                   	push   %eax
f0107095:	68 76 e8 12 f0       	push   $0xf012e876
f010709a:	e8 bd ab ff ff       	call   f0101c5c <cprintf>
f010709f:	83 c4 10             	add    $0x10,%esp
		cprintf("================================================\n");
	}
	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("The processes in EXIT queue are:\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f01070a2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01070a7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01070aa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01070ae:	74 08                	je     f01070b8 <sched_print_all+0x1e3>
f01070b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01070b3:	8b 40 08             	mov    0x8(%eax),%eax
f01070b6:	eb 05                	jmp    f01070bd <sched_print_all+0x1e8>
f01070b8:	b8 00 00 00 00       	mov    $0x0,%eax
f01070bd:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f01070c2:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01070c7:	85 c0                	test   %eax,%eax
f01070c9:	75 b9                	jne    f0107084 <sched_print_all+0x1af>
f01070cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01070cf:	75 b3                	jne    f0107084 <sched_print_all+0x1af>
f01070d1:	eb 10                	jmp    f01070e3 <sched_print_all+0x20e>
			cprintf("	[%d] %s\n", ptr_env->env_id, ptr_env->prog_name);
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01070d3:	83 ec 0c             	sub    $0xc,%esp
f01070d6:	68 3e e9 12 f0       	push   $0xf012e93e
f01070db:	e8 7c ab ff ff       	call   f0101c5c <cprintf>
f01070e0:	83 c4 10             	add    $0x10,%esp
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01070e3:	83 ec 0c             	sub    $0xc,%esp
f01070e6:	68 20 e7 83 f0       	push   $0xf083e720
f01070eb:	e8 30 8e 00 00       	call   f010ff20 <release_kspinlock>
f01070f0:	83 c4 10             	add    $0x10,%esp
}
f01070f3:	90                   	nop
f01070f4:	c9                   	leave  
f01070f5:	c3                   	ret    

f01070f6 <sched_run_all>:

//=================================================
// [13] MOVE ALL NEW Envs into READY Q:
//=================================================
void sched_run_all()
{
f01070f6:	55                   	push   %ebp
f01070f7:	89 e5                	mov    %esp,%ebp
f01070f9:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01070fc:	83 ec 0c             	sub    $0xc,%esp
f01070ff:	68 20 e7 83 f0       	push   $0xf083e720
f0107104:	e8 72 8d 00 00       	call   f010fe7b <acquire_kspinlock>
f0107109:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010710c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
f0107113:	a1 9c e7 83 f0       	mov    0xf083e79c,%eax
f0107118:	89 45 ec             	mov    %eax,-0x14(%ebp)
	for (int i = 0; i < q_size; ++i)
f010711b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0107122:	eb 24                	jmp    f0107148 <sched_run_all+0x52>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
f0107124:	83 ec 0c             	sub    $0xc,%esp
f0107127:	68 90 e7 83 f0       	push   $0xf083e790
f010712c:	e8 6b ef ff ff       	call   f010609c <dequeue>
f0107131:	83 c4 10             	add    $0x10,%esp
f0107134:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sched_insert_ready(ptr_env);
f0107137:	83 ec 0c             	sub    $0xc,%esp
f010713a:	ff 75 f0             	pushl  -0x10(%ebp)
f010713d:	e8 95 f1 ff ff       	call   f01062d7 <sched_insert_ready>
f0107142:	83 c4 10             	add    $0x10,%esp

	/*2023: Changed from LIST_FOREACH into DEQUEUE (based on suggestion from T52 & T73 2023.Term1)
	 * to move the processes in FIFO order instead of LIFO in case of LIST_FOREACH
	 * */
	int q_size = LIST_SIZE(&ProcessQueues.env_new_queue);
	for (int i = 0; i < q_size; ++i)
f0107145:	ff 45 f4             	incl   -0xc(%ebp)
f0107148:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010714b:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010714e:	7c d4                	jl     f0107124 <sched_run_all+0x2e>
	{
		ptr_env = dequeue(&ProcessQueues.env_new_queue);
		sched_insert_ready(ptr_env);
	}

	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107150:	83 ec 0c             	sub    $0xc,%esp
f0107153:	68 20 e7 83 f0       	push   $0xf083e720
f0107158:	e8 c3 8d 00 00       	call   f010ff20 <release_kspinlock>
f010715d:	83 c4 10             	add    $0x10,%esp
	/*2015*///if scheduler not run yet, then invoke it!
	if (mycpu()->scheduler_status == SCH_STOPPED)
f0107160:	e8 0b 0f 00 00       	call   f0108070 <mycpu>
f0107165:	8b 80 b4 00 00 00    	mov    0xb4(%eax),%eax
f010716b:	85 c0                	test   %eax,%eax
f010716d:	75 05                	jne    f0107174 <sched_run_all+0x7e>
		fos_scheduler();
f010716f:	e8 d3 06 00 00       	call   f0107847 <fos_scheduler>
	else
		panic("scheduler status is NOT STOPPED while it's expected to be!!");
f0107174:	83 ec 04             	sub    $0x4,%esp
f0107177:	68 5c e9 12 f0       	push   $0xf012e95c
f010717c:	68 2a 02 00 00       	push   $0x22a
f0107181:	68 13 e6 12 f0       	push   $0xf012e613
f0107186:	e8 24 9e ff ff       	call   f0100faf <_panic>

f010718b <sched_kill_all>:

//=================================================
// [14] KILL ALL Envs in the System:
//=================================================
void sched_kill_all()
{
f010718b:	55                   	push   %ebp
f010718c:	89 e5                	mov    %esp,%ebp
f010718e:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107191:	83 ec 0c             	sub    $0xc,%esp
f0107194:	68 20 e7 83 f0       	push   $0xf083e720
f0107199:	e8 dd 8c 00 00       	call   f010fe7b <acquire_kspinlock>
f010719e:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
f01071a1:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f01071a6:	85 c0                	test   %eax,%eax
f01071a8:	0f 84 95 00 00 00    	je     f0107243 <sched_kill_all+0xb8>
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
f01071ae:	83 ec 0c             	sub    $0xc,%esp
f01071b1:	68 98 e9 12 f0       	push   $0xf012e998
f01071b6:	e8 a1 aa ff ff       	call   f0101c5c <cprintf>
f01071bb:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f01071be:	a1 90 e7 83 f0       	mov    0xf083e790,%eax
f01071c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01071c6:	eb 52                	jmp    f010721a <sched_kill_all+0x8f>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01071c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071cb:	8d 50 20             	lea    0x20(%eax),%edx
f01071ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01071d1:	8b 40 10             	mov    0x10(%eax),%eax
f01071d4:	83 ec 04             	sub    $0x4,%esp
f01071d7:	52                   	push   %edx
f01071d8:	50                   	push   %eax
f01071d9:	68 c4 e9 12 f0       	push   $0xf012e9c4
f01071de:	e8 79 aa ff ff       	call   f0101c5c <cprintf>
f01071e3:	83 c4 10             	add    $0x10,%esp
			sched_remove_new(ptr_env);
f01071e6:	83 ec 0c             	sub    $0xc,%esp
f01071e9:	ff 75 f4             	pushl  -0xc(%ebp)
f01071ec:	e8 31 f3 ff ff       	call   f0106522 <sched_remove_new>
f01071f1:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f01071f4:	83 ec 0c             	sub    $0xc,%esp
f01071f7:	ff 75 f4             	pushl  -0xc(%ebp)
f01071fa:	e8 ba 48 00 00       	call   f010bab9 <env_free>
f01071ff:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107202:	83 ec 0c             	sub    $0xc,%esp
f0107205:	68 d7 e9 12 f0       	push   $0xf012e9d7
f010720a:	e8 4d aa ff ff       	call   f0101c5c <cprintf>
f010720f:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env ;
	if (!LIST_EMPTY(&ProcessQueues.env_new_queue))
	{
		cprintf("\nKILLING the processes in the NEW queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_new_queue)
f0107212:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0107217:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010721a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010721e:	74 08                	je     f0107228 <sched_kill_all+0x9d>
f0107220:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107223:	8b 40 08             	mov    0x8(%eax),%eax
f0107226:	eb 05                	jmp    f010722d <sched_kill_all+0xa2>
f0107228:	b8 00 00 00 00       	mov    $0x0,%eax
f010722d:	a3 98 e7 83 f0       	mov    %eax,0xf083e798
f0107232:	a1 98 e7 83 f0       	mov    0xf083e798,%eax
f0107237:	85 c0                	test   %eax,%eax
f0107239:	75 8d                	jne    f01071c8 <sched_kill_all+0x3d>
f010723b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010723f:	75 87                	jne    f01071c8 <sched_kill_all+0x3d>
f0107241:	eb 10                	jmp    f0107253 <sched_kill_all+0xc8>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in NEW queue\n");
f0107243:	83 ec 0c             	sub    $0xc,%esp
f0107246:	68 dd e9 12 f0       	push   $0xf012e9dd
f010724b:	e8 0c aa ff ff       	call   f0101c5c <cprintf>
f0107250:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("================================================\n");
f0107253:	83 ec 0c             	sub    $0xc,%esp
f0107256:	68 9c e8 12 f0       	push   $0xf012e89c
f010725b:	e8 fc a9 ff ff       	call   f0101c5c <cprintf>
f0107260:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107263:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010726a:	e9 96 01 00 00       	jmp    f0107405 <sched_kill_all+0x27a>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010726f:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107274:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107277:	c1 e2 04             	shl    $0x4,%edx
f010727a:	01 d0                	add    %edx,%eax
f010727c:	8b 00                	mov    (%eax),%eax
f010727e:	85 c0                	test   %eax,%eax
f0107280:	0f 84 59 01 00 00    	je     f01073df <sched_kill_all+0x254>
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
f0107286:	83 ec 08             	sub    $0x8,%esp
f0107289:	ff 75 f0             	pushl  -0x10(%ebp)
f010728c:	68 f8 e9 12 f0       	push   $0xf012e9f8
f0107291:	e8 c6 a9 ff ff       	call   f0101c5c <cprintf>
f0107296:	83 c4 10             	add    $0x10,%esp
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107299:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010729e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01072a1:	c1 e2 04             	shl    $0x4,%edx
f01072a4:	01 d0                	add    %edx,%eax
f01072a6:	8b 00                	mov    (%eax),%eax
f01072a8:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01072ab:	e9 f5 00 00 00       	jmp    f01073a5 <sched_kill_all+0x21a>
			{
				cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f01072b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072b3:	8d 50 20             	lea    0x20(%eax),%edx
f01072b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072b9:	8b 40 10             	mov    0x10(%eax),%eax
f01072bc:	83 ec 04             	sub    $0x4,%esp
f01072bf:	52                   	push   %edx
f01072c0:	50                   	push   %eax
f01072c1:	68 c4 e9 12 f0       	push   $0xf012e9c4
f01072c6:	e8 91 a9 ff ff       	call   f0101c5c <cprintf>
f01072cb:	83 c4 10             	add    $0x10,%esp
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01072ce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01072d2:	75 17                	jne    f01072eb <sched_kill_all+0x160>
f01072d4:	83 ec 04             	sub    $0x4,%esp
f01072d7:	68 4f e6 12 f0       	push   $0xf012e64f
f01072dc:	68 4c 02 00 00       	push   $0x24c
f01072e1:	68 13 e6 12 f0       	push   $0xf012e613
f01072e6:	e8 c4 9c ff ff       	call   f0100faf <_panic>
f01072eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072ee:	8b 40 08             	mov    0x8(%eax),%eax
f01072f1:	85 c0                	test   %eax,%eax
f01072f3:	74 11                	je     f0107306 <sched_kill_all+0x17b>
f01072f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01072f8:	8b 40 08             	mov    0x8(%eax),%eax
f01072fb:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01072fe:	8b 52 0c             	mov    0xc(%edx),%edx
f0107301:	89 50 0c             	mov    %edx,0xc(%eax)
f0107304:	eb 16                	jmp    f010731c <sched_kill_all+0x191>
f0107306:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010730b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010730e:	c1 e2 04             	shl    $0x4,%edx
f0107311:	01 c2                	add    %eax,%edx
f0107313:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107316:	8b 40 0c             	mov    0xc(%eax),%eax
f0107319:	89 42 04             	mov    %eax,0x4(%edx)
f010731c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010731f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107322:	85 c0                	test   %eax,%eax
f0107324:	74 11                	je     f0107337 <sched_kill_all+0x1ac>
f0107326:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107329:	8b 40 0c             	mov    0xc(%eax),%eax
f010732c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010732f:	8b 52 08             	mov    0x8(%edx),%edx
f0107332:	89 50 08             	mov    %edx,0x8(%eax)
f0107335:	eb 15                	jmp    f010734c <sched_kill_all+0x1c1>
f0107337:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010733c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010733f:	c1 e2 04             	shl    $0x4,%edx
f0107342:	01 c2                	add    %eax,%edx
f0107344:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107347:	8b 40 08             	mov    0x8(%eax),%eax
f010734a:	89 02                	mov    %eax,(%edx)
f010734c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010734f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f0107356:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107359:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107360:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107365:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107368:	c1 e2 04             	shl    $0x4,%edx
f010736b:	01 d0                	add    %edx,%eax
f010736d:	8b 50 0c             	mov    0xc(%eax),%edx
f0107370:	4a                   	dec    %edx
f0107371:	89 50 0c             	mov    %edx,0xc(%eax)
				env_free(ptr_env);
f0107374:	83 ec 0c             	sub    $0xc,%esp
f0107377:	ff 75 f4             	pushl  -0xc(%ebp)
f010737a:	e8 3a 47 00 00       	call   f010bab9 <env_free>
f010737f:	83 c4 10             	add    $0x10,%esp
				cprintf("DONE\n");
f0107382:	83 ec 0c             	sub    $0xc,%esp
f0107385:	68 d7 e9 12 f0       	push   $0xf012e9d7
f010738a:	e8 cd a8 ff ff       	call   f0101c5c <cprintf>
f010738f:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			cprintf("KILLING the processes in the READY queue #%d...\n", i);
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107392:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107397:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010739a:	c1 e2 04             	shl    $0x4,%edx
f010739d:	01 d0                	add    %edx,%eax
f010739f:	8b 40 08             	mov    0x8(%eax),%eax
f01073a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01073a5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01073aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01073ad:	c1 e2 04             	shl    $0x4,%edx
f01073b0:	01 d0                	add    %edx,%eax
f01073b2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073b6:	74 08                	je     f01073c0 <sched_kill_all+0x235>
f01073b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01073bb:	8b 52 08             	mov    0x8(%edx),%edx
f01073be:	eb 05                	jmp    f01073c5 <sched_kill_all+0x23a>
f01073c0:	ba 00 00 00 00       	mov    $0x0,%edx
f01073c5:	89 50 08             	mov    %edx,0x8(%eax)
f01073c8:	8b 40 08             	mov    0x8(%eax),%eax
f01073cb:	85 c0                	test   %eax,%eax
f01073cd:	0f 85 dd fe ff ff    	jne    f01072b0 <sched_kill_all+0x125>
f01073d3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01073d7:	0f 85 d3 fe ff ff    	jne    f01072b0 <sched_kill_all+0x125>
f01073dd:	eb 13                	jmp    f01073f2 <sched_kill_all+0x267>
				cprintf("DONE\n");
			}
		}
		else
		{
			cprintf("No processes in READY queue #%d\n",i);
f01073df:	83 ec 08             	sub    $0x8,%esp
f01073e2:	ff 75 f0             	pushl  -0x10(%ebp)
f01073e5:	68 f8 e8 12 f0       	push   $0xf012e8f8
f01073ea:	e8 6d a8 ff ff       	call   f0101c5c <cprintf>
f01073ef:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("================================================\n");
f01073f2:	83 ec 0c             	sub    $0xc,%esp
f01073f5:	68 9c e8 12 f0       	push   $0xf012e89c
f01073fa:	e8 5d a8 ff ff       	call   f0101c5c <cprintf>
f01073ff:	83 c4 10             	add    $0x10,%esp
	else
	{
		cprintf("No processes in NEW queue\n");
	}
	cprintf("================================================\n");
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107402:	ff 45 f0             	incl   -0x10(%ebp)
f0107405:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f010740a:	0f b6 c0             	movzbl %al,%eax
f010740d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f0107410:	0f 8f 59 fe ff ff    	jg     f010726f <sched_kill_all+0xe4>
			cprintf("No processes in READY queue #%d\n",i);
		}
		cprintf("================================================\n");
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
f0107416:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f010741b:	85 c0                	test   %eax,%eax
f010741d:	0f 84 95 00 00 00    	je     f01074b8 <sched_kill_all+0x32d>
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
f0107423:	83 ec 0c             	sub    $0xc,%esp
f0107426:	68 2c ea 12 f0       	push   $0xf012ea2c
f010742b:	e8 2c a8 ff ff       	call   f0101c5c <cprintf>
f0107430:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107433:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0107438:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010743b:	eb 52                	jmp    f010748f <sched_kill_all+0x304>
		{
			cprintf("	killing[%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f010743d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107440:	8d 50 20             	lea    0x20(%eax),%edx
f0107443:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107446:	8b 40 10             	mov    0x10(%eax),%eax
f0107449:	83 ec 04             	sub    $0x4,%esp
f010744c:	52                   	push   %edx
f010744d:	50                   	push   %eax
f010744e:	68 c4 e9 12 f0       	push   $0xf012e9c4
f0107453:	e8 04 a8 ff ff       	call   f0101c5c <cprintf>
f0107458:	83 c4 10             	add    $0x10,%esp
			sched_remove_exit(ptr_env);
f010745b:	83 ec 0c             	sub    $0xc,%esp
f010745e:	ff 75 f4             	pushl  -0xc(%ebp)
f0107461:	e8 33 f2 ff ff       	call   f0106699 <sched_remove_exit>
f0107466:	83 c4 10             	add    $0x10,%esp
			env_free(ptr_env);
f0107469:	83 ec 0c             	sub    $0xc,%esp
f010746c:	ff 75 f4             	pushl  -0xc(%ebp)
f010746f:	e8 45 46 00 00       	call   f010bab9 <env_free>
f0107474:	83 c4 10             	add    $0x10,%esp
			cprintf("DONE\n");
f0107477:	83 ec 0c             	sub    $0xc,%esp
f010747a:	68 d7 e9 12 f0       	push   $0xf012e9d7
f010747f:	e8 d8 a7 ff ff       	call   f0101c5c <cprintf>
f0107484:	83 c4 10             	add    $0x10,%esp
	}

	if (!LIST_EMPTY(&ProcessQueues.env_exit_queue))
	{
		cprintf("KILLING the processes in the EXIT queue...\n");
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0107487:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f010748c:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010748f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107493:	74 08                	je     f010749d <sched_kill_all+0x312>
f0107495:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107498:	8b 40 08             	mov    0x8(%eax),%eax
f010749b:	eb 05                	jmp    f01074a2 <sched_kill_all+0x317>
f010749d:	b8 00 00 00 00       	mov    $0x0,%eax
f01074a2:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f01074a7:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01074ac:	85 c0                	test   %eax,%eax
f01074ae:	75 8d                	jne    f010743d <sched_kill_all+0x2b2>
f01074b0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01074b4:	75 87                	jne    f010743d <sched_kill_all+0x2b2>
f01074b6:	eb 10                	jmp    f01074c8 <sched_kill_all+0x33d>
			cprintf("DONE\n");
		}
	}
	else
	{
		cprintf("No processes in EXIT queue\n");
f01074b8:	83 ec 0c             	sub    $0xc,%esp
f01074bb:	68 3e e9 12 f0       	push   $0xf012e93e
f01074c0:	e8 97 a7 ff ff       	call   f0101c5c <cprintf>
f01074c5:	83 c4 10             	add    $0x10,%esp
	}

	struct Env* cur_env = get_cpu_proc();
f01074c8:	e8 4b 46 00 00       	call   f010bb18 <get_cpu_proc>
f01074cd:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (cur_env)
f01074d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01074d4:	74 6b                	je     f0107541 <sched_kill_all+0x3b6>
	{
		ptr_env = cur_env;
f01074d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01074d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(ptr_env->env_status == ENV_RUNNING);
f01074dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01074df:	8b 40 18             	mov    0x18(%eax),%eax
f01074e2:	83 f8 02             	cmp    $0x2,%eax
f01074e5:	74 19                	je     f0107500 <sched_kill_all+0x375>
f01074e7:	68 fc e7 12 f0       	push   $0xf012e7fc
f01074ec:	68 fe e5 12 f0       	push   $0xf012e5fe
f01074f1:	68 6c 02 00 00       	push   $0x26c
f01074f6:	68 13 e6 12 f0       	push   $0xf012e613
f01074fb:	e8 af 9a ff ff       	call   f0100faf <_panic>
		cprintf("killing a RUNNABLE environment [%d] %s...", ptr_env->env_id, ptr_env->prog_name);
f0107500:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107503:	8d 50 20             	lea    0x20(%eax),%edx
f0107506:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107509:	8b 40 10             	mov    0x10(%eax),%eax
f010750c:	83 ec 04             	sub    $0x4,%esp
f010750f:	52                   	push   %edx
f0107510:	50                   	push   %eax
f0107511:	68 58 ea 12 f0       	push   $0xf012ea58
f0107516:	e8 41 a7 ff ff       	call   f0101c5c <cprintf>
f010751b:	83 c4 10             	add    $0x10,%esp
		env_free(ptr_env);
f010751e:	83 ec 0c             	sub    $0xc,%esp
f0107521:	ff 75 f4             	pushl  -0xc(%ebp)
f0107524:	e8 90 45 00 00       	call   f010bab9 <env_free>
f0107529:	83 c4 10             	add    $0x10,%esp
		cprintf("DONE\n");
f010752c:	83 ec 0c             	sub    $0xc,%esp
f010752f:	68 d7 e9 12 f0       	push   $0xf012e9d7
f0107534:	e8 23 a7 ff ff       	call   f0101c5c <cprintf>
f0107539:	83 c4 10             	add    $0x10,%esp
		//return back to a killed env. Status already set to EXIT in the env_free()
		//It's the fos_scheduler task to release the lock on the Qs after context_switch to it from
		//this process
		//reinvoke the scheduler since there're no env to return back to it
		/*2024: replaced by sched() to apply context_switch*/
		sched();
f010753c:	e8 51 47 00 00       	call   f010bc92 <sched>
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f0107541:	83 ec 0c             	sub    $0xc,%esp
f0107544:	68 20 e7 83 f0       	push   $0xf083e720
f0107549:	e8 d2 89 00 00       	call   f010ff20 <release_kspinlock>
f010754e:	83 c4 10             	add    $0x10,%esp
	//get into the command prompt since there're no env to return back to it
	//fos_scheduler(); //2024: commented
	get_into_prompt();
f0107551:	e8 8c a8 ff ff       	call   f0101de2 <get_into_prompt>

f0107556 <sched_exit_all_ready_envs>:
/*2018*/
//=================================================
// [14] EXIT ALL Ready Envs:
//=================================================
void sched_exit_all_ready_envs()
{
f0107556:	55                   	push   %ebp
f0107557:	89 e5                	mov    %esp,%ebp
f0107559:	83 ec 18             	sub    $0x18,%esp
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f010755c:	83 ec 0c             	sub    $0xc,%esp
f010755f:	68 20 e7 83 f0       	push   $0xf083e720
f0107564:	e8 12 89 00 00       	call   f010fe7b <acquire_kspinlock>
f0107569:	83 c4 10             	add    $0x10,%esp
	struct Env* ptr_env=NULL;
f010756c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f0107573:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010757a:	e9 37 01 00 00       	jmp    f01076b6 <sched_exit_all_ready_envs+0x160>
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
f010757f:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107584:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107587:	c1 e2 04             	shl    $0x4,%edx
f010758a:	01 d0                	add    %edx,%eax
f010758c:	8b 00                	mov    (%eax),%eax
f010758e:	85 c0                	test   %eax,%eax
f0107590:	0f 84 1d 01 00 00    	je     f01076b3 <sched_exit_all_ready_envs+0x15d>
		{
			ptr_env=NULL;
f0107596:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f010759d:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01075a2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01075a5:	c1 e2 04             	shl    $0x4,%edx
f01075a8:	01 d0                	add    %edx,%eax
f01075aa:	8b 00                	mov    (%eax),%eax
f01075ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01075af:	e9 c7 00 00 00       	jmp    f010767b <sched_exit_all_ready_envs+0x125>
			{
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
f01075b4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01075b8:	75 17                	jne    f01075d1 <sched_exit_all_ready_envs+0x7b>
f01075ba:	83 ec 04             	sub    $0x4,%esp
f01075bd:	68 4f e6 12 f0       	push   $0xf012e64f
f01075c2:	68 8e 02 00 00       	push   $0x28e
f01075c7:	68 13 e6 12 f0       	push   $0xf012e613
f01075cc:	e8 de 99 ff ff       	call   f0100faf <_panic>
f01075d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075d4:	8b 40 08             	mov    0x8(%eax),%eax
f01075d7:	85 c0                	test   %eax,%eax
f01075d9:	74 11                	je     f01075ec <sched_exit_all_ready_envs+0x96>
f01075db:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075de:	8b 40 08             	mov    0x8(%eax),%eax
f01075e1:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01075e4:	8b 52 0c             	mov    0xc(%edx),%edx
f01075e7:	89 50 0c             	mov    %edx,0xc(%eax)
f01075ea:	eb 16                	jmp    f0107602 <sched_exit_all_ready_envs+0xac>
f01075ec:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01075f1:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01075f4:	c1 e2 04             	shl    $0x4,%edx
f01075f7:	01 c2                	add    %eax,%edx
f01075f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01075fc:	8b 40 0c             	mov    0xc(%eax),%eax
f01075ff:	89 42 04             	mov    %eax,0x4(%edx)
f0107602:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107605:	8b 40 0c             	mov    0xc(%eax),%eax
f0107608:	85 c0                	test   %eax,%eax
f010760a:	74 11                	je     f010761d <sched_exit_all_ready_envs+0xc7>
f010760c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010760f:	8b 40 0c             	mov    0xc(%eax),%eax
f0107612:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107615:	8b 52 08             	mov    0x8(%edx),%edx
f0107618:	89 50 08             	mov    %edx,0x8(%eax)
f010761b:	eb 15                	jmp    f0107632 <sched_exit_all_ready_envs+0xdc>
f010761d:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107622:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107625:	c1 e2 04             	shl    $0x4,%edx
f0107628:	01 c2                	add    %eax,%edx
f010762a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010762d:	8b 40 08             	mov    0x8(%eax),%eax
f0107630:	89 02                	mov    %eax,(%edx)
f0107632:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107635:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010763c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010763f:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f0107646:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010764b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010764e:	c1 e2 04             	shl    $0x4,%edx
f0107651:	01 d0                	add    %edx,%eax
f0107653:	8b 50 0c             	mov    0xc(%eax),%edx
f0107656:	4a                   	dec    %edx
f0107657:	89 50 0c             	mov    %edx,0xc(%eax)
				sched_insert_exit(ptr_env);
f010765a:	83 ec 0c             	sub    $0xc,%esp
f010765d:	ff 75 f4             	pushl  -0xc(%ebp)
f0107660:	e8 ad ef ff ff       	call   f0106612 <sched_insert_exit>
f0107665:	83 c4 10             	add    $0x10,%esp
	for (int i = 0 ; i < num_of_ready_queues ; i++)
	{
		if (!LIST_EMPTY(&(ProcessQueues.env_ready_queues[i])))
		{
			ptr_env=NULL;
			LIST_FOREACH(ptr_env, &(ProcessQueues.env_ready_queues[i]))
f0107668:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f010766d:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107670:	c1 e2 04             	shl    $0x4,%edx
f0107673:	01 d0                	add    %edx,%eax
f0107675:	8b 40 08             	mov    0x8(%eax),%eax
f0107678:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010767b:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107680:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107683:	c1 e2 04             	shl    $0x4,%edx
f0107686:	01 d0                	add    %edx,%eax
f0107688:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010768c:	74 08                	je     f0107696 <sched_exit_all_ready_envs+0x140>
f010768e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107691:	8b 52 08             	mov    0x8(%edx),%edx
f0107694:	eb 05                	jmp    f010769b <sched_exit_all_ready_envs+0x145>
f0107696:	ba 00 00 00 00       	mov    $0x0,%edx
f010769b:	89 50 08             	mov    %edx,0x8(%eax)
f010769e:	8b 40 08             	mov    0x8(%eax),%eax
f01076a1:	85 c0                	test   %eax,%eax
f01076a3:	0f 85 0b ff ff ff    	jne    f01075b4 <sched_exit_all_ready_envs+0x5e>
f01076a9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01076ad:	0f 85 01 ff ff ff    	jne    f01075b4 <sched_exit_all_ready_envs+0x5e>
//=================================================
void sched_exit_all_ready_envs()
{
	acquire_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
	struct Env* ptr_env=NULL;
	for (int i = 0 ; i < num_of_ready_queues ; i++)
f01076b3:	ff 45 f0             	incl   -0x10(%ebp)
f01076b6:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01076bb:	0f b6 c0             	movzbl %al,%eax
f01076be:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01076c1:	0f 8f b8 fe ff ff    	jg     f010757f <sched_exit_all_ready_envs+0x29>
				LIST_REMOVE(&(ProcessQueues.env_ready_queues[i]), ptr_env);
				sched_insert_exit(ptr_env);
			}
		}
	}
	release_kspinlock(&(ProcessQueues.qlock)); 	//CS on Qs
f01076c7:	83 ec 0c             	sub    $0xc,%esp
f01076ca:	68 20 e7 83 f0       	push   $0xf083e720
f01076cf:	e8 4c 88 00 00       	call   f010ff20 <release_kspinlock>
f01076d4:	83 c4 10             	add    $0x10,%esp
}
f01076d7:	90                   	nop
f01076d8:	c9                   	leave  
f01076d9:	c3                   	ret    

f01076da <timer_ticks>:

/*2023*/
/********* for BSD Priority Scheduler *************/
int64 timer_ticks()
{
f01076da:	55                   	push   %ebp
f01076db:	89 e5                	mov    %esp,%ebp
	return ticks;
f01076dd:	a1 28 6c 85 f0       	mov    0xf0856c28,%eax
f01076e2:	8b 15 2c 6c 85 f0    	mov    0xf0856c2c,%edx
}
f01076e8:	5d                   	pop    %ebp
f01076e9:	c3                   	ret    

f01076ea <env_get_nice>:
int env_get_nice(struct Env* e)
{
f01076ea:	55                   	push   %ebp
f01076eb:	89 e5                	mov    %esp,%ebp
f01076ed:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f01076f0:	83 ec 04             	sub    $0x4,%esp
f01076f3:	68 82 ea 12 f0       	push   $0xf012ea82
f01076f8:	68 9e 02 00 00       	push   $0x29e
f01076fd:	68 13 e6 12 f0       	push   $0xf012e613
f0107702:	e8 a8 98 ff ff       	call   f0100faf <_panic>

f0107707 <env_set_nice>:
}

void env_set_nice(struct Env* e, int nice_value)
{
f0107707:	55                   	push   %ebp
f0107708:	89 e5                	mov    %esp,%ebp
f010770a:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f010770d:	83 ec 04             	sub    $0x4,%esp
f0107710:	68 82 ea 12 f0       	push   $0xf012ea82
f0107715:	68 a3 02 00 00       	push   $0x2a3
f010771a:	68 13 e6 12 f0       	push   $0xf012e613
f010771f:	e8 8b 98 ff ff       	call   f0100faf <_panic>

f0107724 <env_get_recent_cpu>:
}
int env_get_recent_cpu(struct Env* e)
{
f0107724:	55                   	push   %ebp
f0107725:	89 e5                	mov    %esp,%ebp
f0107727:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f010772a:	83 ec 04             	sub    $0x4,%esp
f010772d:	68 82 ea 12 f0       	push   $0xf012ea82
f0107732:	68 a7 02 00 00       	push   $0x2a7
f0107737:	68 13 e6 12 f0       	push   $0xf012e613
f010773c:	e8 6e 98 ff ff       	call   f0100faf <_panic>

f0107741 <get_load_average>:
}
int get_load_average()
{
f0107741:	55                   	push   %ebp
f0107742:	89 e5                	mov    %esp,%ebp
f0107744:	83 ec 08             	sub    $0x8,%esp
	panic("Not implemented function");
f0107747:	83 ec 04             	sub    $0x4,%esp
f010774a:	68 82 ea 12 f0       	push   $0xf012ea82
f010774f:	68 ab 02 00 00       	push   $0x2ab
f0107754:	68 13 e6 12 f0       	push   $0xf012e613
f0107759:	e8 51 98 ff ff       	call   f0100faf <_panic>

f010775e <env_set_priority>:
//==================================================================================//

/*2024*/
/********* for Priority RR Scheduler *************/
void env_set_priority(int envID, int priority)
{
f010775e:	55                   	push   %ebp
f010775f:	89 e5                	mov    %esp,%ebp
f0107761:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 env_set_priority
	//Your code is here
	//Comment the following line
	panic("env_set_priority() is not implemented yet...!!");
f0107764:	83 ec 04             	sub    $0x4,%esp
f0107767:	68 9c ea 12 f0       	push   $0xf012ea9c
f010776c:	68 b8 02 00 00       	push   $0x2b8
f0107771:	68 13 e6 12 f0       	push   $0xf012e613
f0107776:	e8 34 98 ff ff       	call   f0100faf <_panic>

f010777b <sched_set_starv_thresh>:
}
void sched_set_starv_thresh(uint32 starvThresh)
{
f010777b:	55                   	push   %ebp
f010777c:	89 e5                	mov    %esp,%ebp
f010777e:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 sched_set_starv_thresh
	//Your code is here
	//Comment the following line
	panic("sched_set_starv_thresh() is not implemented yet...!!");
f0107781:	83 ec 04             	sub    $0x4,%esp
f0107784:	68 cc ea 12 f0       	push   $0xf012eacc
f0107789:	68 bf 02 00 00       	push   $0x2bf
f010778e:	68 13 e6 12 f0       	push   $0xf012e613
f0107793:	e8 17 98 ff ff       	call   f0100faf <_panic>

f0107798 <isSchedMethodRR>:
#include <kern/cmd/command_prompt.h>
#include <kern/cpu/cpu.h>
#include <kern/cpu/picirq.h>


uint32 isSchedMethodRR(){return (scheduler_method == SCH_RR);}
f0107798:	55                   	push   %ebp
f0107799:	89 e5                	mov    %esp,%ebp
f010779b:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01077a0:	85 c0                	test   %eax,%eax
f01077a2:	0f 94 c0             	sete   %al
f01077a5:	0f b6 c0             	movzbl %al,%eax
f01077a8:	5d                   	pop    %ebp
f01077a9:	c3                   	ret    

f01077aa <isSchedMethodMLFQ>:
uint32 isSchedMethodMLFQ(){return (scheduler_method == SCH_MLFQ); }
f01077aa:	55                   	push   %ebp
f01077ab:	89 e5                	mov    %esp,%ebp
f01077ad:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01077b2:	83 f8 01             	cmp    $0x1,%eax
f01077b5:	0f 94 c0             	sete   %al
f01077b8:	0f b6 c0             	movzbl %al,%eax
f01077bb:	5d                   	pop    %ebp
f01077bc:	c3                   	ret    

f01077bd <isSchedMethodBSD>:
uint32 isSchedMethodBSD(){return(scheduler_method == SCH_BSD); }
f01077bd:	55                   	push   %ebp
f01077be:	89 e5                	mov    %esp,%ebp
f01077c0:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01077c5:	83 f8 02             	cmp    $0x2,%eax
f01077c8:	0f 94 c0             	sete   %al
f01077cb:	0f b6 c0             	movzbl %al,%eax
f01077ce:	5d                   	pop    %ebp
f01077cf:	c3                   	ret    

f01077d0 <isSchedMethodPRIRR>:
uint32 isSchedMethodPRIRR(){return(scheduler_method == SCH_PRIRR); }
f01077d0:	55                   	push   %ebp
f01077d1:	89 e5                	mov    %esp,%ebp
f01077d3:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01077d8:	83 f8 03             	cmp    $0x3,%eax
f01077db:	0f 94 c0             	sete   %al
f01077de:	0f b6 c0             	movzbl %al,%eax
f01077e1:	5d                   	pop    %ebp
f01077e2:	c3                   	ret    

f01077e3 <sched_init>:

//===================================
// [1] Default Scheduler Initializer:
//===================================
void sched_init()
{
f01077e3:	55                   	push   %ebp
f01077e4:	89 e5                	mov    %esp,%ebp
f01077e6:	83 ec 08             	sub    $0x8,%esp
	old_pf_counter = 0;
f01077e9:	c7 05 f8 e8 83 f0 00 	movl   $0x0,0xf083e8f8
f01077f0:	00 00 00 

	sched_init_RR(INIT_QUANTUM_IN_MS);
f01077f3:	83 ec 0c             	sub    $0xc,%esp
f01077f6:	6a 0a                	push   $0xa
f01077f8:	e8 45 02 00 00       	call   f0107a42 <sched_init_RR>
f01077fd:	83 c4 10             	add    $0x10,%esp

	init_queue(&ProcessQueues.env_new_queue);
f0107800:	83 ec 0c             	sub    $0xc,%esp
f0107803:	68 90 e7 83 f0       	push   $0xf083e790
f0107808:	e8 bd e7 ff ff       	call   f0105fca <init_queue>
f010780d:	83 c4 10             	add    $0x10,%esp
	init_queue(&ProcessQueues.env_exit_queue);
f0107810:	83 ec 0c             	sub    $0xc,%esp
f0107813:	68 a0 e7 83 f0       	push   $0xf083e7a0
f0107818:	e8 ad e7 ff ff       	call   f0105fca <init_queue>
f010781d:	83 c4 10             	add    $0x10,%esp

	mycpu()->scheduler_status = SCH_STOPPED;
f0107820:	e8 4b 08 00 00       	call   f0108070 <mycpu>
f0107825:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f010782c:	00 00 00 

	/*2024: initialize lock to protect these Qs in MULTI-CORE case only*/
	init_kspinlock(&ProcessQueues.qlock, "process queues lock");
f010782f:	83 ec 08             	sub    $0x8,%esp
f0107832:	68 04 eb 12 f0       	push   $0xf012eb04
f0107837:	68 20 e7 83 f0       	push   $0xf083e720
f010783c:	e8 09 86 00 00       	call   f010fe4a <init_kspinlock>
f0107841:	83 c4 10             	add    $0x10,%esp
}
f0107844:	90                   	nop
f0107845:	c9                   	leave  
f0107846:	c3                   	ret    

f0107847 <fos_scheduler>:
// [2] Main FOS Scheduler:
//=========================

void
fos_scheduler(void)
{
f0107847:	55                   	push   %ebp
f0107848:	89 e5                	mov    %esp,%ebp
f010784a:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010784d:	9c                   	pushf  
f010784e:	58                   	pop    %eax
f010784f:	89 45 dc             	mov    %eax,-0x24(%ebp)
        return eflags;
f0107852:	8b 45 dc             	mov    -0x24(%ebp),%eax
	//ensure that the scheduler is invoked while interrupt is disabled
	if (read_eflags() & FL_IF)
f0107855:	25 00 02 00 00       	and    $0x200,%eax
f010785a:	85 c0                	test   %eax,%eax
f010785c:	74 14                	je     f0107872 <fos_scheduler+0x2b>
		panic("fos_scheduler: called while the interrupt is enabled!");
f010785e:	83 ec 04             	sub    $0x4,%esp
f0107861:	68 18 eb 12 f0       	push   $0xf012eb18
f0107866:	6a 3a                	push   $0x3a
f0107868:	68 4e eb 12 f0       	push   $0xf012eb4e
f010786d:	e8 3d 97 ff ff       	call   f0100faf <_panic>

	//cprintf("inside scheduler - timer cnt = %d\n", kclock_read_cnt0());
	struct Env *p;
	struct cpu *c = mycpu();
f0107872:	e8 f9 07 00 00       	call   f0108070 <mycpu>
f0107877:	89 45 ec             	mov    %eax,-0x14(%ebp)
	c->proc = 0;
f010787a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010787d:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0107884:	00 00 00 

	chk1();
f0107887:	e8 03 24 01 00       	call   f0119c8f <chk1>
	c->scheduler_status = SCH_STARTED;
f010788c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010788f:	c7 80 b4 00 00 00 01 	movl   $0x1,0xb4(%eax)
f0107896:	00 00 00 

	//This variable should be set to the next environment to be run (if any)
	struct Env* next_env = NULL;
f0107899:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

	//2024: should be outer loop as long as there's any BLOCKED processes.
	//Ref: xv6-x86 OS
	int is_any_blocked = 0;
f01078a0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f01078a7:	fb                   	sti    
		// to avoid a deadlock if all processes are waiting.
		sti();

		// Check ready queue(s) looking for process to run.
		//cprintf("\n[FOS_SCHEDULER] acquire: lock status before acquire = %d\n", qlock.locked);
		acquire_kspinlock(&(ProcessQueues.qlock));  //lock: to protect ready & blocked Qs in multi-CPU
f01078a8:	83 ec 0c             	sub    $0xc,%esp
f01078ab:	68 20 e7 83 f0       	push   $0xf083e720
f01078b0:	e8 c6 85 00 00       	call   f010fe7b <acquire_kspinlock>
f01078b5:	83 c4 10             	add    $0x10,%esp
		//cprintf("ACQUIRED\n");
		do
		{
			//Get next env according to the current scheduler
			next_env = sched_next[scheduler_method]() ;
f01078b8:	a1 fc 6a 85 f0       	mov    0xf0856afc,%eax
f01078bd:	8b 04 85 ac fb 17 f0 	mov    -0xfe80454(,%eax,4),%eax
f01078c4:	ff d0                	call   *%eax
f01078c6:	89 45 e8             	mov    %eax,-0x18(%ebp)

			if(next_env != NULL)
f01078c9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01078cd:	0f 84 f5 00 00 00    	je     f01079c8 <fos_scheduler+0x181>
			{
				//cprintf("\nScheduler select program '%s' [%d]... clock counter = %d\n", next_env->prog_name, next_env->env_id, kclock_read_cnt0());
				// Switch to chosen process. It is the process's job to release qlock
				// and then reacquire it before jumping back to us.
				set_cpu_proc(next_env);
f01078d3:	83 ec 0c             	sub    $0xc,%esp
f01078d6:	ff 75 e8             	pushl  -0x18(%ebp)
f01078d9:	e8 63 42 00 00       	call   f010bb41 <set_cpu_proc>
f01078de:	83 c4 10             	add    $0x10,%esp
				switchuvm(next_env);
f01078e1:	83 ec 0c             	sub    $0xc,%esp
f01078e4:	ff 75 e8             	pushl  -0x18(%ebp)
f01078e7:	e8 c9 44 00 00       	call   f010bdb5 <switchuvm>
f01078ec:	83 c4 10             	add    $0x10,%esp

				//Change its status to RUNNING
				next_env->env_status = ENV_RUNNING;
f01078ef:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01078f2:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%eax)

				//Context switch to it
				context_switch(&(c->scheduler), next_env->context);
f01078f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01078fc:	8b 40 04             	mov    0x4(%eax),%eax
f01078ff:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107902:	83 c2 04             	add    $0x4,%edx
f0107905:	83 ec 08             	sub    $0x8,%esp
f0107908:	50                   	push   %eax
f0107909:	52                   	push   %edx
f010790a:	e8 c3 e2 ff ff       	call   f0105bd2 <context_switch>
f010790f:	83 c4 10             	add    $0x10,%esp

				//ensure that the qlock is still held after returning from the process
				if(!holding_kspinlock(&ProcessQueues.qlock))
f0107912:	83 ec 0c             	sub    $0xc,%esp
f0107915:	68 20 e7 83 f0       	push   $0xf083e720
f010791a:	e8 b1 87 00 00       	call   f01100d0 <holding_kspinlock>
f010791f:	83 c4 10             	add    $0x10,%esp
f0107922:	85 c0                	test   %eax,%eax
f0107924:	75 24                	jne    f010794a <fos_scheduler+0x103>
				{
					printcallstack(&ProcessQueues.qlock);
f0107926:	83 ec 0c             	sub    $0xc,%esp
f0107929:	68 20 e7 83 f0       	push   $0xf083e720
f010792e:	e8 36 87 00 00       	call   f0110069 <printcallstack>
f0107933:	83 c4 10             	add    $0x10,%esp
					panic("fos_scheduler(): qlock is either not held or held by another CPU!");
f0107936:	83 ec 04             	sub    $0x4,%esp
f0107939:	68 60 eb 12 f0       	push   $0xf012eb60
f010793e:	6a 6c                	push   $0x6c
f0107940:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107945:	e8 65 96 ff ff       	call   f0100faf <_panic>
				}

				//Stop the clock now till finding a next proc (if any).
				//This is to avoid clock interrupt inside the scheduler after sti() of the outer loop
				kclock_stop();
f010794a:	e8 cc e3 ff ff       	call   f0105d1b <kclock_stop>
				//cprintf("\n[IEN = %d] clock is stopped! returned to scheduler after context_switch. curenv = %d\n", (read_eflags() & FL_IF) == 0? 0:1, c->proc == NULL? 0 : c->proc->env_id);

				// Process is done running for now. It should have changed its p->status before coming back.
				//If no process on CPU, switch to the kernel
				assert(get_cpu_proc() == c->proc);
f010794f:	e8 c4 41 00 00       	call   f010bb18 <get_cpu_proc>
f0107954:	89 c2                	mov    %eax,%edx
f0107956:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107959:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010795f:	39 c2                	cmp    %eax,%edx
f0107961:	74 16                	je     f0107979 <fos_scheduler+0x132>
f0107963:	68 a2 eb 12 f0       	push   $0xf012eba2
f0107968:	68 bc eb 12 f0       	push   $0xf012ebbc
f010796d:	6a 76                	push   $0x76
f010796f:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107974:	e8 36 96 ff ff       	call   f0100faf <_panic>
				int status = c->proc->env_status ;
f0107979:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010797c:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f0107982:	8b 40 18             	mov    0x18(%eax),%eax
f0107985:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				assert(status != ENV_RUNNING);
f0107988:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
f010798c:	75 16                	jne    f01079a4 <fos_scheduler+0x15d>
f010798e:	68 d1 eb 12 f0       	push   $0xf012ebd1
f0107993:	68 bc eb 12 f0       	push   $0xf012ebbc
f0107998:	6a 78                	push   $0x78
f010799a:	68 4e eb 12 f0       	push   $0xf012eb4e
f010799f:	e8 0b 96 ff ff       	call   f0100faf <_panic>
				if (status == ENV_READY)
f01079a4:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
f01079a8:	74 1e                	je     f01079c8 <fos_scheduler+0x181>
					//OK... will be placed to the correct ready Q in the next iteration
				}
				else
				{
					//					cprintf("scheduler: process %d is BLOCKED/EXITED\n", c->proc->env_id);
					switchkvm();
f01079aa:	e8 ef 43 00 00       	call   f010bd9e <switchkvm>
					struct Env* __e__ = c->proc;
f01079af:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01079b2:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f01079b8:	89 45 e0             	mov    %eax,-0x20(%ebp)
					set_cpu_proc(NULL);
f01079bb:	83 ec 0c             	sub    $0xc,%esp
f01079be:	6a 00                	push   $0x0
f01079c0:	e8 7c 41 00 00       	call   f010bb41 <set_cpu_proc>
f01079c5:	83 c4 10             	add    $0x10,%esp
				}
			}
		} while(next_env);
f01079c8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f01079cc:	0f 85 e6 fe ff ff    	jne    f01078b8 <fos_scheduler+0x71>

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
f01079d2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		for (int i = 0; i < NENV; ++i)
f01079d9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f01079e0:	eb 37                	jmp    f0107a19 <fos_scheduler+0x1d2>
		{
			if (envs[i].env_status == ENV_BLOCKED)
f01079e2:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f01079e8:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01079eb:	89 d0                	mov    %edx,%eax
f01079ed:	c1 e0 02             	shl    $0x2,%eax
f01079f0:	01 d0                	add    %edx,%eax
f01079f2:	c1 e0 03             	shl    $0x3,%eax
f01079f5:	01 d0                	add    %edx,%eax
f01079f7:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01079fe:	01 d0                	add    %edx,%eax
f0107a00:	c1 e0 02             	shl    $0x2,%eax
f0107a03:	01 c8                	add    %ecx,%eax
f0107a05:	8b 40 18             	mov    0x18(%eax),%eax
f0107a08:	83 f8 03             	cmp    $0x3,%eax
f0107a0b:	75 09                	jne    f0107a16 <fos_scheduler+0x1cf>
			{
				is_any_blocked = 1;
f0107a0d:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f0107a14:	eb 0d                	jmp    f0107a23 <fos_scheduler+0x1dc>
			}
		} while(next_env);

		//2024 - check if there's any blocked process?
		is_any_blocked = 0;
		for (int i = 0; i < NENV; ++i)
f0107a16:	ff 45 f0             	incl   -0x10(%ebp)
f0107a19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0107a1c:	3d c5 02 00 00       	cmp    $0x2c5,%eax
f0107a21:	76 bf                	jbe    f01079e2 <fos_scheduler+0x19b>
			{
				is_any_blocked = 1;
				break;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);  //release lock: to protect ready & blocked Qs in multi-CPU
f0107a23:	83 ec 0c             	sub    $0xc,%esp
f0107a26:	68 20 e7 83 f0       	push   $0xf083e720
f0107a2b:	e8 f0 84 00 00       	call   f010ff20 <release_kspinlock>
f0107a30:	83 c4 10             	add    $0x10,%esp
		//cprintf("\n[FOS_SCHEDULER] release: lock status after = %d\n", qlock.locked);
	} while (is_any_blocked > 0);
f0107a33:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107a37:	0f 8f 6a fe ff ff    	jg     f01078a7 <fos_scheduler+0x60>

	/*2015*///No more envs... curenv doesn't exist any more! return back to command prompt
	{
		//cprintf("[sched] no envs - nothing more to do!\n");
		get_into_prompt();
f0107a3d:	e8 a0 a3 ff ff       	call   f0101de2 <get_into_prompt>

f0107a42 <sched_init_RR>:

//=============================
// [3] Initialize RR Scheduler:
//=============================
void sched_init_RR(uint8 quantum)
{
f0107a42:	55                   	push   %ebp
f0107a43:	89 e5                	mov    %esp,%ebp
f0107a45:	83 ec 28             	sub    $0x28,%esp
f0107a48:	8b 45 08             	mov    0x8(%ebp),%eax
f0107a4b:	88 45 e4             	mov    %al,-0x1c(%ebp)
	// Create 1 ready queue for the RR
	num_of_ready_queues = 1;
f0107a4e:	c6 05 60 6d 85 f0 01 	movb   $0x1,0xf0856d60
#if USE_KHEAP
	sched_delete_ready_queues();
f0107a55:	e8 20 e8 ff ff       	call   f010627a <sched_delete_ready_queues>
	ProcessQueues.env_ready_queues = kmalloc(sizeof(struct Env_Queue));
f0107a5a:	83 ec 0c             	sub    $0xc,%esp
f0107a5d:	6a 10                	push   $0x10
f0107a5f:	e8 d2 21 00 00       	call   f0109c36 <kmalloc>
f0107a64:	83 c4 10             	add    $0x10,%esp
f0107a67:	a3 b0 e7 83 f0       	mov    %eax,0xf083e7b0
	quantums = kmalloc(num_of_ready_queues * sizeof(uint8)) ;
f0107a6c:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0107a71:	0f b6 c0             	movzbl %al,%eax
f0107a74:	83 ec 0c             	sub    $0xc,%esp
f0107a77:	50                   	push   %eax
f0107a78:	e8 b9 21 00 00       	call   f0109c36 <kmalloc>
f0107a7d:	83 c4 10             	add    $0x10,%esp
f0107a80:	a3 e4 6a 85 f0       	mov    %eax,0xf0856ae4
#endif
	quantums[0] = quantum;
f0107a85:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0107a8a:	8a 55 e4             	mov    -0x1c(%ebp),%dl
f0107a8d:	88 10                	mov    %dl,(%eax)
	kclock_set_quantum(quantums[0]);
f0107a8f:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0107a94:	8a 00                	mov    (%eax),%al
f0107a96:	0f b6 c0             	movzbl %al,%eax
f0107a99:	83 ec 0c             	sub    $0xc,%esp
f0107a9c:	50                   	push   %eax
f0107a9d:	e8 42 e3 ff ff       	call   f0105de4 <kclock_set_quantum>
f0107aa2:	83 c4 10             	add    $0x10,%esp
	init_queue(&(ProcessQueues.env_ready_queues[0]));
f0107aa5:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107aaa:	83 ec 0c             	sub    $0xc,%esp
f0107aad:	50                   	push   %eax
f0107aae:	e8 17 e5 ff ff       	call   f0105fca <init_queue>
f0107ab3:	83 c4 10             	add    $0x10,%esp
	//=========================================
	//DON'T CHANGE THESE LINES=================
	uint16 cnt0 = kclock_read_cnt0_latch() ; //read after write to ensure it's set to the desired value
f0107ab6:	e8 88 e4 ff ff       	call   f0105f43 <kclock_read_cnt0_latch>
f0107abb:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
	cprintf("*	RR scheduler with initial clock = %d\n", cnt0);
f0107abf:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
f0107ac3:	83 ec 08             	sub    $0x8,%esp
f0107ac6:	50                   	push   %eax
f0107ac7:	68 e8 eb 12 f0       	push   $0xf012ebe8
f0107acc:	e8 8b a1 ff ff       	call   f0101c5c <cprintf>
f0107ad1:	83 c4 10             	add    $0x10,%esp
	mycpu()->scheduler_status = SCH_STOPPED;
f0107ad4:	e8 97 05 00 00       	call   f0108070 <mycpu>
f0107ad9:	c7 80 b4 00 00 00 00 	movl   $0x0,0xb4(%eax)
f0107ae0:	00 00 00 
	scheduler_method = SCH_RR;
f0107ae3:	c7 05 fc 6a 85 f0 00 	movl   $0x0,0xf0856afc
f0107aea:	00 00 00 
	//=========================================
	//=========================================
}
f0107aed:	90                   	nop
f0107aee:	c9                   	leave  
f0107aef:	c3                   	ret    

f0107af0 <sched_init_MLFQ>:

//===============================
// [4] Initialize MLFQ Scheduler:
//===============================
void sched_init_MLFQ(uint8 numOfLevels, uint8 *quantumOfEachLevel)
{
f0107af0:	55                   	push   %ebp
f0107af1:	89 e5                	mov    %esp,%ebp
f0107af3:	83 ec 18             	sub    $0x18,%esp
f0107af6:	8b 45 08             	mov    0x8(%ebp),%eax
f0107af9:	88 45 f4             	mov    %al,-0xc(%ebp)
	panic("Not implemented yet");
f0107afc:	83 ec 04             	sub    $0x4,%esp
f0107aff:	68 10 ec 12 f0       	push   $0xf012ec10
f0107b04:	68 bb 00 00 00       	push   $0xbb
f0107b09:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107b0e:	e8 9c 94 ff ff       	call   f0100faf <_panic>

f0107b13 <sched_init_BSD>:

//===============================
// [5] Initialize BSD Scheduler:
//===============================
void sched_init_BSD(uint8 numOfLevels, uint8 quantum)
{
f0107b13:	55                   	push   %ebp
f0107b14:	89 e5                	mov    %esp,%ebp
f0107b16:	83 ec 18             	sub    $0x18,%esp
f0107b19:	8b 55 08             	mov    0x8(%ebp),%edx
f0107b1c:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107b1f:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107b22:	88 45 f0             	mov    %al,-0x10(%ebp)
	panic("Not implemented yet");
f0107b25:	83 ec 04             	sub    $0x4,%esp
f0107b28:	68 10 ec 12 f0       	push   $0xf012ec10
f0107b2d:	68 ce 00 00 00       	push   $0xce
f0107b32:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107b37:	e8 73 94 ff ff       	call   f0100faf <_panic>

f0107b3c <sched_init_PRIRR>:

//======================================
// [6] Initialize PRIORITY RR Scheduler:
//======================================
void sched_init_PRIRR(uint8 numOfPriorities, uint8 quantum, uint32 starvThresh)
{
f0107b3c:	55                   	push   %ebp
f0107b3d:	89 e5                	mov    %esp,%ebp
f0107b3f:	83 ec 18             	sub    $0x18,%esp
f0107b42:	8b 55 08             	mov    0x8(%ebp),%edx
f0107b45:	8b 45 0c             	mov    0xc(%ebp),%eax
f0107b48:	88 55 f4             	mov    %dl,-0xc(%ebp)
f0107b4b:	88 45 f0             	mov    %al,-0x10(%ebp)
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #2 sched_init_PRIRR
		//Your code is here
		//Comment the following line
		panic("sched_init_PRIRR() is not implemented yet...!!");
f0107b4e:	83 ec 04             	sub    $0x4,%esp
f0107b51:	68 24 ec 12 f0       	push   $0xf012ec24
f0107b56:	68 e4 00 00 00       	push   $0xe4
f0107b5b:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107b60:	e8 4a 94 ff ff       	call   f0100faf <_panic>

f0107b65 <fos_scheduler_RR>:

//=========================
// [7] RR Scheduler:
//=========================
struct Env* fos_scheduler_RR()
{
f0107b65:	55                   	push   %ebp
f0107b66:	89 e5                	mov    %esp,%ebp
f0107b68:	83 ec 18             	sub    $0x18,%esp
	// Pick next environment from the ready queue,
	// and switch to such environment if found.
	// It's OK to choose the previously running env if no other env
	// is runnable.
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107b6b:	83 ec 0c             	sub    $0xc,%esp
f0107b6e:	68 20 e7 83 f0       	push   $0xf083e720
f0107b73:	e8 58 85 00 00       	call   f01100d0 <holding_kspinlock>
f0107b78:	83 c4 10             	add    $0x10,%esp
f0107b7b:	85 c0                	test   %eax,%eax
f0107b7d:	75 17                	jne    f0107b96 <fos_scheduler_RR+0x31>
		panic("fos_scheduler_RR: q.lock is not held by this CPU while it's expected to be.");
f0107b7f:	83 ec 04             	sub    $0x4,%esp
f0107b82:	68 54 ec 12 f0       	push   $0xf012ec54
f0107b87:	68 ff 00 00 00       	push   $0xff
f0107b8c:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107b91:	e8 19 94 ff ff       	call   f0100faf <_panic>
	/****************************************************************************************/
	struct Env *next_env = NULL;
f0107b96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *cur_env = get_cpu_proc();
f0107b9d:	e8 76 3f 00 00       	call   f010bb18 <get_cpu_proc>
f0107ba2:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//If the curenv is still exist, then insert it again in the ready queue
	if (cur_env != NULL)
f0107ba5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0107ba9:	74 14                	je     f0107bbf <fos_scheduler_RR+0x5a>
	{
		//cprintf("RR: [%d] with status %d will be added to ready Q", cur_env->env_id, cur_env->env_status);
		enqueue(&(ProcessQueues.env_ready_queues[0]), cur_env);
f0107bab:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107bb0:	83 ec 08             	sub    $0x8,%esp
f0107bb3:	ff 75 f0             	pushl  -0x10(%ebp)
f0107bb6:	50                   	push   %eax
f0107bb7:	e8 4f e4 ff ff       	call   f010600b <enqueue>
f0107bbc:	83 c4 10             	add    $0x10,%esp
	}

	//Pick the next environment from the ready queue
	next_env = dequeue(&(ProcessQueues.env_ready_queues[0]));
f0107bbf:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0107bc4:	83 ec 0c             	sub    $0xc,%esp
f0107bc7:	50                   	push   %eax
f0107bc8:	e8 cf e4 ff ff       	call   f010609c <dequeue>
f0107bcd:	83 c4 10             	add    $0x10,%esp
f0107bd0:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//Reset the quantum
	//2017: Reset the value of CNT0 for the next clock interval
	kclock_set_quantum(quantums[0]);
f0107bd3:	a1 e4 6a 85 f0       	mov    0xf0856ae4,%eax
f0107bd8:	8a 00                	mov    (%eax),%al
f0107bda:	0f b6 c0             	movzbl %al,%eax
f0107bdd:	83 ec 0c             	sub    $0xc,%esp
f0107be0:	50                   	push   %eax
f0107be1:	e8 fe e1 ff ff       	call   f0105de4 <kclock_set_quantum>
f0107be6:	83 c4 10             	add    $0x10,%esp
	//uint16 cnt0 = kclock_read_cnt0_latch() ;
	//cprintf("CLOCK INTERRUPT AFTER RESET: Counter0 Value = %d\n", cnt0 );

	return next_env;
f0107be9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0107bec:	c9                   	leave  
f0107bed:	c3                   	ret    

f0107bee <fos_scheduler_MLFQ>:

//=========================
// [8] MLFQ Scheduler:
//=========================
struct Env* fos_scheduler_MLFQ()
{
f0107bee:	55                   	push   %ebp
f0107bef:	89 e5                	mov    %esp,%ebp
f0107bf1:	83 ec 08             	sub    $0x8,%esp
	//Apply the MLFQ with the specified levels to pick up the next environment
	//Note: the "curenv" (if exist) should be placed in its correct queue
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107bf4:	83 ec 0c             	sub    $0xc,%esp
f0107bf7:	68 20 e7 83 f0       	push   $0xf083e720
f0107bfc:	e8 cf 84 00 00       	call   f01100d0 <holding_kspinlock>
f0107c01:	83 c4 10             	add    $0x10,%esp
f0107c04:	85 c0                	test   %eax,%eax
f0107c06:	75 17                	jne    f0107c1f <fos_scheduler_MLFQ+0x31>
		panic("fos_scheduler_MLFQ: q.lock is not held by this CPU while it's expected to be.");
f0107c08:	83 ec 04             	sub    $0x4,%esp
f0107c0b:	68 a0 ec 12 f0       	push   $0xf012eca0
f0107c10:	68 1f 01 00 00       	push   $0x11f
f0107c15:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107c1a:	e8 90 93 ff ff       	call   f0100faf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107c1f:	83 ec 04             	sub    $0x4,%esp
f0107c22:	68 10 ec 12 f0       	push   $0xf012ec10
f0107c27:	68 21 01 00 00       	push   $0x121
f0107c2c:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107c31:	e8 79 93 ff ff       	call   f0100faf <_panic>

f0107c36 <fos_scheduler_BSD>:

//=========================
// [9] BSD Scheduler:
//=========================
struct Env* fos_scheduler_BSD()
{
f0107c36:	55                   	push   %ebp
f0107c37:	89 e5                	mov    %esp,%ebp
f0107c39:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107c3c:	83 ec 0c             	sub    $0xc,%esp
f0107c3f:	68 20 e7 83 f0       	push   $0xf083e720
f0107c44:	e8 87 84 00 00       	call   f01100d0 <holding_kspinlock>
f0107c49:	83 c4 10             	add    $0x10,%esp
f0107c4c:	85 c0                	test   %eax,%eax
f0107c4e:	75 17                	jne    f0107c67 <fos_scheduler_BSD+0x31>
		panic("fos_scheduler_BSD: q.lock is not held by this CPU while it's expected to be.");
f0107c50:	83 ec 04             	sub    $0x4,%esp
f0107c53:	68 f0 ec 12 f0       	push   $0xf012ecf0
f0107c58:	68 2b 01 00 00       	push   $0x12b
f0107c5d:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107c62:	e8 48 93 ff ff       	call   f0100faf <_panic>
	/****************************************************************************************/
	panic("Not implemented yet");
f0107c67:	83 ec 04             	sub    $0x4,%esp
f0107c6a:	68 10 ec 12 f0       	push   $0xf012ec10
f0107c6f:	68 2d 01 00 00       	push   $0x12d
f0107c74:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107c79:	e8 31 93 ff ff       	call   f0100faf <_panic>

f0107c7e <fos_scheduler_PRIRR>:

//=============================
// [10] PRIORITY RR Scheduler:
//=============================
struct Env* fos_scheduler_PRIRR()
{
f0107c7e:	55                   	push   %ebp
f0107c7f:	89 e5                	mov    %esp,%ebp
f0107c81:	83 ec 08             	sub    $0x8,%esp
	/*To protect process Qs (or info of current process) in multi-CPU************************/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f0107c84:	83 ec 0c             	sub    $0xc,%esp
f0107c87:	68 20 e7 83 f0       	push   $0xf083e720
f0107c8c:	e8 3f 84 00 00       	call   f01100d0 <holding_kspinlock>
f0107c91:	83 c4 10             	add    $0x10,%esp
f0107c94:	85 c0                	test   %eax,%eax
f0107c96:	75 17                	jne    f0107caf <fos_scheduler_PRIRR+0x31>
		panic("fos_scheduler_PRIRR: q.lock is not held by this CPU while it's expected to be.");
f0107c98:	83 ec 04             	sub    $0x4,%esp
f0107c9b:	68 40 ed 12 f0       	push   $0xf012ed40
f0107ca0:	68 37 01 00 00       	push   $0x137
f0107ca5:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107caa:	e8 00 93 ff ff       	call   f0100faf <_panic>
	/****************************************************************************************/
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #3 fos_scheduler_PRIRR
	//Your code is here
	//Comment the following line
	panic("fos_scheduler_PRIRR() is not implemented yet...!!");
f0107caf:	83 ec 04             	sub    $0x4,%esp
f0107cb2:	68 90 ed 12 f0       	push   $0xf012ed90
f0107cb7:	68 3c 01 00 00       	push   $0x13c
f0107cbc:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107cc1:	e8 e9 92 ff ff       	call   f0100faf <_panic>

f0107cc6 <clock_interrupt_handler>:
//========================================
// [11] Clock Interrupt Handler
//	  (Automatically Called Every Quantum)
//========================================
void clock_interrupt_handler(struct Trapframe* tf)
{
f0107cc6:	55                   	push   %ebp
f0107cc7:	89 e5                	mov    %esp,%ebp
f0107cc9:	83 ec 18             	sub    $0x18,%esp
	if (isSchedMethodPRIRR())
f0107ccc:	e8 ff fa ff ff       	call   f01077d0 <isSchedMethodPRIRR>
f0107cd1:	85 c0                	test   %eax,%eax
f0107cd3:	74 17                	je     f0107cec <clock_interrupt_handler+0x26>
	{
		//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #4 clock_interrupt_handler
		//Your code is here
		//Comment the following line
		panic("clock_interrupt_handler() is not implemented yet...!!");
f0107cd5:	83 ec 04             	sub    $0x4,%esp
f0107cd8:	68 c4 ed 12 f0       	push   $0xf012edc4
f0107cdd:	68 4a 01 00 00       	push   $0x14a
f0107ce2:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107ce7:	e8 c3 92 ff ff       	call   f0100faf <_panic>


	}

	/********DON'T CHANGE THESE LINES***********/
	ticks++ ;
f0107cec:	a1 28 6c 85 f0       	mov    0xf0856c28,%eax
f0107cf1:	8b 15 2c 6c 85 f0    	mov    0xf0856c2c,%edx
f0107cf7:	83 c0 01             	add    $0x1,%eax
f0107cfa:	83 d2 00             	adc    $0x0,%edx
f0107cfd:	a3 28 6c 85 f0       	mov    %eax,0xf0856c28
f0107d02:	89 15 2c 6c 85 f0    	mov    %edx,0xf0856c2c
	struct Env* p = get_cpu_proc();
f0107d08:	e8 0b 3e 00 00       	call   f010bb18 <get_cpu_proc>
f0107d0d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (p == NULL)
f0107d10:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0107d14:	74 30                	je     f0107d46 <clock_interrupt_handler+0x80>
//		cprintf("scheduler status = %d\n", mycpu()->scheduler_status) ;
		//panic("clock_interrupt_handler: no running process at the cpu! unexpected clock interrupt in the kernel!");
	}
	else
	{
		p->nClocks++ ;
f0107d16:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107d19:	8b 80 c0 05 00 00    	mov    0x5c0(%eax),%eax
f0107d1f:	8d 50 01             	lea    0x1(%eax),%edx
f0107d22:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107d25:	89 90 c0 05 00 00    	mov    %edx,0x5c0(%eax)
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f0107d2b:	83 ec 0c             	sub    $0xc,%esp
f0107d2e:	6a 01                	push   $0x1
f0107d30:	e8 ee 7b 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f0107d35:	83 c4 10             	add    $0x10,%esp
f0107d38:	85 c0                	test   %eax,%eax
f0107d3a:	74 05                	je     f0107d41 <clock_interrupt_handler+0x7b>
		{
			update_WS_time_stamps();
f0107d3c:	e8 08 00 00 00       	call   f0107d49 <update_WS_time_stamps>
		}
		//cprintf("\n***************\nClock Handler\n***************\n") ;
		//fos_scheduler();
		yield();
f0107d41:	e8 ed 3e 00 00       	call   f010bc33 <yield>
	}
	/*****************************************/
}
f0107d46:	90                   	nop
f0107d47:	c9                   	leave  
f0107d48:	c3                   	ret    

f0107d49 <update_WS_time_stamps>:
//===================================================================
// [9] Update LRU Timestamp of WS Elements
//	  (Automatically Called Every Quantum in case of LRU Time Approx)
//===================================================================
void update_WS_time_stamps()
{
f0107d49:	55                   	push   %ebp
f0107d4a:	89 e5                	mov    %esp,%ebp
f0107d4c:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #1 update_WS_time_stamps
	//Your code is here
	//Comment the following line
	panic("update_WS_time_stamps is not implemented yet...!!");
f0107d4f:	83 ec 04             	sub    $0x4,%esp
f0107d52:	68 fc ed 12 f0       	push   $0xf012edfc
f0107d57:	68 72 01 00 00       	push   $0x172
f0107d5c:	68 4e eb 12 f0       	push   $0xf012eb4e
f0107d61:	e8 49 92 ff ff       	call   f0100faf <_panic>

f0107d66 <pic_init>:
static bool didinit;

/* Initialize the 8259A interrupt controllers. */
void
pic_init(void)
{
f0107d66:	55                   	push   %ebp
f0107d67:	89 e5                	mov    %esp,%ebp
f0107d69:	83 ec 58             	sub    $0x58,%esp
	didinit = 1;
f0107d6c:	c7 05 8c 5b 81 f0 01 	movl   $0x1,0xf0815b8c
f0107d73:	00 00 00 
f0107d76:	c7 45 f4 21 00 00 00 	movl   $0x21,-0xc(%ebp)
f0107d7d:	c6 45 b2 ff          	movb   $0xff,-0x4e(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107d81:	8a 45 b2             	mov    -0x4e(%ebp),%al
f0107d84:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0107d87:	ee                   	out    %al,(%dx)
f0107d88:	c7 45 f0 a1 00 00 00 	movl   $0xa1,-0x10(%ebp)
f0107d8f:	c6 45 b3 ff          	movb   $0xff,-0x4d(%ebp)
f0107d93:	8a 45 b3             	mov    -0x4d(%ebp),%al
f0107d96:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107d99:	ee                   	out    %al,(%dx)
f0107d9a:	c7 45 ec 20 00 00 00 	movl   $0x20,-0x14(%ebp)
f0107da1:	c6 45 b4 11          	movb   $0x11,-0x4c(%ebp)
f0107da5:	8a 45 b4             	mov    -0x4c(%ebp),%al
f0107da8:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0107dab:	ee                   	out    %al,(%dx)
f0107dac:	c7 45 e8 21 00 00 00 	movl   $0x21,-0x18(%ebp)
f0107db3:	c6 45 b5 20          	movb   $0x20,-0x4b(%ebp)
f0107db7:	8a 45 b5             	mov    -0x4b(%ebp),%al
f0107dba:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0107dbd:	ee                   	out    %al,(%dx)
f0107dbe:	c7 45 e4 21 00 00 00 	movl   $0x21,-0x1c(%ebp)
f0107dc5:	c6 45 b6 04          	movb   $0x4,-0x4a(%ebp)
f0107dc9:	8a 45 b6             	mov    -0x4a(%ebp),%al
f0107dcc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f0107dcf:	ee                   	out    %al,(%dx)
f0107dd0:	c7 45 e0 21 00 00 00 	movl   $0x21,-0x20(%ebp)
f0107dd7:	c6 45 b7 03          	movb   $0x3,-0x49(%ebp)
f0107ddb:	8a 45 b7             	mov    -0x49(%ebp),%al
f0107dde:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0107de1:	ee                   	out    %al,(%dx)
f0107de2:	c7 45 dc a0 00 00 00 	movl   $0xa0,-0x24(%ebp)
f0107de9:	c6 45 b8 11          	movb   $0x11,-0x48(%ebp)
f0107ded:	8a 45 b8             	mov    -0x48(%ebp),%al
f0107df0:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0107df3:	ee                   	out    %al,(%dx)
f0107df4:	c7 45 d8 a1 00 00 00 	movl   $0xa1,-0x28(%ebp)
f0107dfb:	c6 45 b9 28          	movb   $0x28,-0x47(%ebp)
f0107dff:	8a 45 b9             	mov    -0x47(%ebp),%al
f0107e02:	8b 55 d8             	mov    -0x28(%ebp),%edx
f0107e05:	ee                   	out    %al,(%dx)
f0107e06:	c7 45 d4 a1 00 00 00 	movl   $0xa1,-0x2c(%ebp)
f0107e0d:	c6 45 ba 02          	movb   $0x2,-0x46(%ebp)
f0107e11:	8a 45 ba             	mov    -0x46(%ebp),%al
f0107e14:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0107e17:	ee                   	out    %al,(%dx)
f0107e18:	c7 45 d0 a1 00 00 00 	movl   $0xa1,-0x30(%ebp)
f0107e1f:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
f0107e23:	8a 45 bb             	mov    -0x45(%ebp),%al
f0107e26:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0107e29:	ee                   	out    %al,(%dx)
f0107e2a:	c7 45 cc 20 00 00 00 	movl   $0x20,-0x34(%ebp)
f0107e31:	c6 45 bc 68          	movb   $0x68,-0x44(%ebp)
f0107e35:	8a 45 bc             	mov    -0x44(%ebp),%al
f0107e38:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0107e3b:	ee                   	out    %al,(%dx)
f0107e3c:	c7 45 c8 20 00 00 00 	movl   $0x20,-0x38(%ebp)
f0107e43:	c6 45 bd 0a          	movb   $0xa,-0x43(%ebp)
f0107e47:	8a 45 bd             	mov    -0x43(%ebp),%al
f0107e4a:	8b 55 c8             	mov    -0x38(%ebp),%edx
f0107e4d:	ee                   	out    %al,(%dx)
f0107e4e:	c7 45 c4 a0 00 00 00 	movl   $0xa0,-0x3c(%ebp)
f0107e55:	c6 45 be 68          	movb   $0x68,-0x42(%ebp)
f0107e59:	8a 45 be             	mov    -0x42(%ebp),%al
f0107e5c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0107e5f:	ee                   	out    %al,(%dx)
f0107e60:	c7 45 c0 a0 00 00 00 	movl   $0xa0,-0x40(%ebp)
f0107e67:	c6 45 bf 0a          	movb   $0xa,-0x41(%ebp)
f0107e6b:	8a 45 bf             	mov    -0x41(%ebp),%al
f0107e6e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0107e71:	ee                   	out    %al,(%dx)
	outb(PIC1_CMD, 0x0a);             /* read IRR by default */

	outb(PIC2_CMD, 0x68);               /* OCW3 */
	outb(PIC2_CMD, 0x0a);               /* OCW3 */

	if (irq_init_mask_8259A != 0xFFFF)
f0107e72:	66 a1 bc fb 17 f0    	mov    0xf017fbbc,%ax
f0107e78:	66 83 f8 ff          	cmp    $0xffff,%ax
f0107e7c:	74 15                	je     f0107e93 <pic_init+0x12d>
		irq_setmask_8259A(irq_init_mask_8259A);
f0107e7e:	66 a1 bc fb 17 f0    	mov    0xf017fbbc,%ax
f0107e84:	0f b7 c0             	movzwl %ax,%eax
f0107e87:	83 ec 0c             	sub    $0xc,%esp
f0107e8a:	50                   	push   %eax
f0107e8b:	e8 06 00 00 00       	call   f0107e96 <irq_setmask_8259A>
f0107e90:	83 c4 10             	add    $0x10,%esp
}
f0107e93:	90                   	nop
f0107e94:	c9                   	leave  
f0107e95:	c3                   	ret    

f0107e96 <irq_setmask_8259A>:

void
irq_setmask_8259A(uint16 mask)
{
f0107e96:	55                   	push   %ebp
f0107e97:	89 e5                	mov    %esp,%ebp
f0107e99:	83 ec 14             	sub    $0x14,%esp
f0107e9c:	8b 45 08             	mov    0x8(%ebp),%eax
f0107e9f:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
	 * We then use the new functions irq_set_mask() and irq_clear_mask()
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
f0107ea3:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107ea8:	85 c0                	test   %eax,%eax
f0107eaa:	74 34                	je     f0107ee0 <irq_setmask_8259A+0x4a>
		return;

	outb(PIC1_DATA, (char)mask);
f0107eac:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107eaf:	0f b6 c0             	movzbl %al,%eax
f0107eb2:	c7 45 fc 21 00 00 00 	movl   $0x21,-0x4(%ebp)
f0107eb9:	88 45 f6             	mov    %al,-0xa(%ebp)
f0107ebc:	8a 45 f6             	mov    -0xa(%ebp),%al
f0107ebf:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0107ec2:	ee                   	out    %al,(%dx)
	outb(PIC2_DATA, (char)(mask >> 8));
f0107ec3:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0107ec6:	66 c1 e8 08          	shr    $0x8,%ax
f0107eca:	0f b6 c0             	movzbl %al,%eax
f0107ecd:	c7 45 f8 a1 00 00 00 	movl   $0xa1,-0x8(%ebp)
f0107ed4:	88 45 f7             	mov    %al,-0x9(%ebp)
f0107ed7:	8a 45 f7             	mov    -0x9(%ebp),%al
f0107eda:	8b 55 f8             	mov    -0x8(%ebp),%edx
f0107edd:	ee                   	out    %al,(%dx)
f0107ede:	eb 01                	jmp    f0107ee1 <irq_setmask_8259A+0x4b>
	 * to manipulate a specific IRQ mask
	 */
	//irq_init_mask_8259A = mask;

	if (!didinit)
		return;
f0107ee0:	90                   	nop
	//cprintf("enabled interrupts:");
	//for (int i = 0; i < 16; i++)
	//if (~mask & (1<<i))
	//cprintf(" %d", i);
	//cprintf("\n");
}
f0107ee1:	c9                   	leave  
f0107ee2:	c3                   	ret    

f0107ee3 <irq_set_mask>:

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
f0107ee3:	55                   	push   %ebp
f0107ee4:	89 e5                	mov    %esp,%ebp
f0107ee6:	53                   	push   %ebx
f0107ee7:	83 ec 14             	sub    $0x14,%esp
f0107eea:	8b 45 08             	mov    0x8(%ebp),%eax
f0107eed:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107ef0:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107ef5:	85 c0                	test   %eax,%eax
f0107ef7:	74 58                	je     f0107f51 <irq_set_mask+0x6e>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107ef9:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107efd:	77 08                	ja     f0107f07 <irq_set_mask+0x24>
		port = PIC1_DATA;
f0107eff:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107f05:	eb 0a                	jmp    f0107f11 <irq_set_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107f07:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107f0d:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) | (1 << IRQline);
f0107f11:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107f15:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107f18:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f1b:	89 c2                	mov    %eax,%edx
f0107f1d:	ec                   	in     (%dx),%al
f0107f1e:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107f21:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107f24:	88 c2                	mov    %al,%dl
f0107f26:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107f2a:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107f2f:	88 c1                	mov    %al,%cl
f0107f31:	d3 e3                	shl    %cl,%ebx
f0107f33:	89 d8                	mov    %ebx,%eax
f0107f35:	09 d0                	or     %edx,%eax
f0107f37:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107f3a:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107f3e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107f42:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107f45:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107f48:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107f4b:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107f4e:	ee                   	out    %al,(%dx)
f0107f4f:	eb 01                	jmp    f0107f52 <irq_set_mask+0x6f>

/*Ref: OSDev Wiki*/
void irq_set_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107f51:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) | (1 << IRQline);
	outb(port, value);
}
f0107f52:	83 c4 14             	add    $0x14,%esp
f0107f55:	5b                   	pop    %ebx
f0107f56:	5d                   	pop    %ebp
f0107f57:	c3                   	ret    

f0107f58 <irq_clear_mask>:

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
f0107f58:	55                   	push   %ebp
f0107f59:	89 e5                	mov    %esp,%ebp
f0107f5b:	53                   	push   %ebx
f0107f5c:	83 ec 14             	sub    $0x14,%esp
f0107f5f:	8b 45 08             	mov    0x8(%ebp),%eax
f0107f62:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107f65:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107f6a:	85 c0                	test   %eax,%eax
f0107f6c:	74 5a                	je     f0107fc8 <irq_clear_mask+0x70>
		return;

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107f6e:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107f72:	77 08                	ja     f0107f7c <irq_clear_mask+0x24>
		port = PIC1_DATA;
f0107f74:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107f7a:	eb 0a                	jmp    f0107f86 <irq_clear_mask+0x2e>
	} else {
		port = PIC2_DATA;
f0107f7c:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0107f82:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & ~(1 << IRQline);
f0107f86:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0107f8a:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f0107f8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0107f90:	89 c2                	mov    %eax,%edx
f0107f92:	ec                   	in     (%dx),%al
f0107f93:	88 45 ee             	mov    %al,-0x12(%ebp)
	return data;
f0107f96:	8a 45 ee             	mov    -0x12(%ebp),%al
f0107f99:	88 c2                	mov    %al,%dl
f0107f9b:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f0107f9f:	bb 01 00 00 00       	mov    $0x1,%ebx
f0107fa4:	88 c1                	mov    %al,%cl
f0107fa6:	d3 e3                	shl    %cl,%ebx
f0107fa8:	89 d8                	mov    %ebx,%eax
f0107faa:	f7 d0                	not    %eax
f0107fac:	21 d0                	and    %edx,%eax
f0107fae:	88 45 f9             	mov    %al,-0x7(%ebp)
	outb(port, value);
f0107fb1:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
f0107fb5:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
f0107fb9:	89 55 f0             	mov    %edx,-0x10(%ebp)
f0107fbc:	88 45 ef             	mov    %al,-0x11(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0107fbf:	8a 45 ef             	mov    -0x11(%ebp),%al
f0107fc2:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0107fc5:	ee                   	out    %al,(%dx)
f0107fc6:	eb 01                	jmp    f0107fc9 <irq_clear_mask+0x71>

/*Ref: OSDev Wiki*/
void irq_clear_mask(uint8 IRQline)
{
	if (!didinit)
		return;
f0107fc8:	90                   	nop
		port = PIC2_DATA;
		IRQline -= 8;
	}
	value = inb(port) & ~(1 << IRQline);
	outb(port, value);
}
f0107fc9:	83 c4 14             	add    $0x14,%esp
f0107fcc:	5b                   	pop    %ebx
f0107fcd:	5d                   	pop    %ebp
f0107fce:	c3                   	ret    

f0107fcf <irq_get_mask>:


int irq_get_mask(uint8 IRQline)
{
f0107fcf:	55                   	push   %ebp
f0107fd0:	89 e5                	mov    %esp,%ebp
f0107fd2:	53                   	push   %ebx
f0107fd3:	83 ec 14             	sub    $0x14,%esp
f0107fd6:	8b 45 08             	mov    0x8(%ebp),%eax
f0107fd9:	88 45 e8             	mov    %al,-0x18(%ebp)
	if (!didinit)
f0107fdc:	a1 8c 5b 81 f0       	mov    0xf0815b8c,%eax
f0107fe1:	85 c0                	test   %eax,%eax
f0107fe3:	75 07                	jne    f0107fec <irq_get_mask+0x1d>
		return -1;
f0107fe5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f0107fea:	eb 45                	jmp    f0108031 <irq_get_mask+0x62>

	uint16 port;
	uint8 value;

	if(IRQline < 8) {
f0107fec:	80 7d e8 07          	cmpb   $0x7,-0x18(%ebp)
f0107ff0:	77 08                	ja     f0107ffa <irq_get_mask+0x2b>
		port = PIC1_DATA;
f0107ff2:	66 c7 45 fa 21 00    	movw   $0x21,-0x6(%ebp)
f0107ff8:	eb 0a                	jmp    f0108004 <irq_get_mask+0x35>
	} else {
		port = PIC2_DATA;
f0107ffa:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
		IRQline -= 8;
f0108000:	80 6d e8 08          	subb   $0x8,-0x18(%ebp)
	}
	value = inb(port) & (1 << IRQline);
f0108004:	0f b7 45 fa          	movzwl -0x6(%ebp),%eax
f0108008:	89 45 f4             	mov    %eax,-0xc(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f010800b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010800e:	89 c2                	mov    %eax,%edx
f0108010:	ec                   	in     (%dx),%al
f0108011:	88 45 f3             	mov    %al,-0xd(%ebp)
	return data;
f0108014:	8a 45 f3             	mov    -0xd(%ebp),%al
f0108017:	88 c2                	mov    %al,%dl
f0108019:	0f b6 45 e8          	movzbl -0x18(%ebp),%eax
f010801d:	bb 01 00 00 00       	mov    $0x1,%ebx
f0108022:	88 c1                	mov    %al,%cl
f0108024:	d3 e3                	shl    %cl,%ebx
f0108026:	89 d8                	mov    %ebx,%eax
f0108028:	21 d0                	and    %edx,%eax
f010802a:	88 45 f9             	mov    %al,-0x7(%ebp)
	return value;
f010802d:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
}
f0108031:	83 c4 14             	add    $0x14,%esp
f0108034:	5b                   	pop    %ebx
f0108035:	5d                   	pop    %ebp
f0108036:	c3                   	ret    

f0108037 <pic_sendEOI>:
 * If the IRQ came from the Master PIC, it is sufficient to issue this command only to the
 * Master PIC; however if the IRQ came from the Slave PIC, it is necessary to issue the command
 * to both PIC chips.
 */
void pic_sendEOI(uint8 irq)
{
f0108037:	55                   	push   %ebp
f0108038:	89 e5                	mov    %esp,%ebp
f010803a:	83 ec 14             	sub    $0x14,%esp
f010803d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108040:	88 45 ec             	mov    %al,-0x14(%ebp)
	if(irq >= 8)
f0108043:	80 7d ec 07          	cmpb   $0x7,-0x14(%ebp)
f0108047:	76 12                	jbe    f010805b <pic_sendEOI+0x24>
f0108049:	c7 45 f8 a0 00 00 00 	movl   $0xa0,-0x8(%ebp)
f0108050:	c6 45 f7 20          	movb   $0x20,-0x9(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f0108054:	8a 45 f7             	mov    -0x9(%ebp),%al
f0108057:	8b 55 f8             	mov    -0x8(%ebp),%edx
f010805a:	ee                   	out    %al,(%dx)
f010805b:	c7 45 fc 20 00 00 00 	movl   $0x20,-0x4(%ebp)
f0108062:	c6 45 f6 20          	movb   $0x20,-0xa(%ebp)
f0108066:	8a 45 f6             	mov    -0xa(%ebp),%al
f0108069:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010806c:	ee                   	out    %al,(%dx)
		outb(PIC2_CMD,PIC_EOI);

	outb(PIC1_CMD,PIC_EOI);
}
f010806d:	90                   	nop
f010806e:	c9                   	leave  
f010806f:	c3                   	ret    

f0108070 <mycpu>:
extern void idt_init(void);

// Must be called with interrupts disabled to avoid the caller being
// rescheduled between reading lapicid and running through the loop.
struct cpu* mycpu()
{
f0108070:	55                   	push   %ebp
f0108071:	89 e5                	mov    %esp,%ebp
	return &CPUS[0]; //main CPU
f0108073:	b8 00 e9 83 f0       	mov    $0xf083e900,%eax
//  for (i = 0; i < ncpu; ++i) {
//    if (cpus[i].apicid == apicid)
//      return &cpus[i];
//  }
//  panic("unknown apicid\n");
}
f0108078:	5d                   	pop    %ebp
f0108079:	c3                   	ret    

f010807a <cpu_init>:

// Common CPU setup code.
void cpu_init(int cpuIndx)
{
f010807a:	55                   	push   %ebp
f010807b:	89 e5                	mov    %esp,%ebp
f010807d:	83 ec 28             	sub    $0x28,%esp
  struct cpu* c = mycpu();
f0108080:	e8 eb ff ff ff       	call   f0108070 <mycpu>
f0108085:	89 45 f4             	mov    %eax,-0xc(%ebp)
  c->proc = NULL;
f0108088:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010808b:	c7 80 b0 00 00 00 00 	movl   $0x0,0xb0(%eax)
f0108092:	00 00 00 
  c->ncli = 0;
f0108095:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108098:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010809f:	00 00 00 

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f01080a2:	9c                   	pushf  
f01080a3:	58                   	pop    %eax
f01080a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f01080a7:	8b 45 f0             	mov    -0x10(%ebp),%eax
  c->intena = read_eflags() & FL_IF ? 1 : 0;
f01080aa:	25 00 02 00 00       	and    $0x200,%eax
f01080af:	85 c0                	test   %eax,%eax
f01080b1:	0f 95 c0             	setne  %al
f01080b4:	0f b6 d0             	movzbl %al,%edx
f01080b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080ba:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  //c->apicid = ?? ;

  //Initialize the CPU Context to NULL.
  //to be set later to the correct position on the stack during the
  //first switch from scheduler to the first process
  c->scheduler = NULL ;
f01080c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080c3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  c->scheduler_status = SCH_UNINITIALIZED;
f01080ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080cd:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
f01080d4:	ff ff ff 

  //Initialize its sched stack
  c->stack = (char*)(KERN_STACK_TOP - (cpuIndx+1)*KERNEL_STACK_SIZE);
f01080d7:	8b 45 08             	mov    0x8(%ebp),%eax
f01080da:	f7 d0                	not    %eax
f01080dc:	c1 e0 0f             	shl    $0xf,%eax
f01080df:	2d 00 00 40 10       	sub    $0x10400000,%eax
f01080e4:	89 c2                	mov    %eax,%edx
f01080e6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080e9:	89 50 08             	mov    %edx,0x8(%eax)

  //initialize GDT & set it to this CPU
  seg_init();
f01080ec:	e8 18 01 00 00       	call   f0108209 <seg_init>

  //initialize IDT
  idt_init();       // load idt register
f01080f1:	e8 01 50 00 00       	call   f010d0f7 <idt_init>

  //Initialize the TaskState to ZERO.
  //to be initialized later in init.c
  memset(&(c->ts), 0, sizeof(c->ts)) ;
f01080f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01080f9:	83 c0 0c             	add    $0xc,%eax
f01080fc:	83 ec 04             	sub    $0x4,%esp
f01080ff:	6a 68                	push   $0x68
f0108101:	6a 00                	push   $0x0
f0108103:	50                   	push   %eax
f0108104:	e8 60 2c 01 00       	call   f011ad69 <memset>
f0108109:	83 c4 10             	add    $0x10,%esp

  //Indicate it's started
  xchg(&(c->started), 1); // tell startothers() we're up
f010810c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010810f:	05 a4 00 00 00       	add    $0xa4,%eax
f0108114:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108117:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010811e:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0108121:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108124:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0108127:	f0 87 02             	lock xchg %eax,(%edx)
f010812a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  //scheduler();     // start running processes
}
f010812d:	90                   	nop
f010812e:	c9                   	leave  
f010812f:	c3                   	ret    

f0108130 <pushcli>:
// Pushcli/popcli are like cli/sti except that they are matched:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void pushcli(void)
{
f0108130:	55                   	push   %ebp
f0108131:	89 e5                	mov    %esp,%ebp
f0108133:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0108136:	9c                   	pushf  
f0108137:	58                   	pop    %eax
f0108138:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return eflags;
f010813b:	8b 45 f8             	mov    -0x8(%ebp),%eax
  int eflags = read_eflags();
f010813e:	89 45 fc             	mov    %eax,-0x4(%ebp)
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f0108141:	fa                   	cli    
  cli();
  struct cpu* c = mycpu();
f0108142:	e8 29 ff ff ff       	call   f0108070 <mycpu>
f0108147:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(c->ncli == 0)
f010814a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010814d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108153:	85 c0                	test   %eax,%eax
f0108155:	75 13                	jne    f010816a <pushcli+0x3a>
    c->intena = eflags & FL_IF;
f0108157:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010815a:	25 00 02 00 00       	and    $0x200,%eax
f010815f:	89 c2                	mov    %eax,%edx
f0108161:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108164:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
  c->ncli += 1;
f010816a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010816d:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f0108173:	8d 50 01             	lea    0x1(%eax),%edx
f0108176:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108179:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
}
f010817f:	90                   	nop
f0108180:	c9                   	leave  
f0108181:	c3                   	ret    

f0108182 <popcli>:

void popcli(void)
{
f0108182:	55                   	push   %ebp
f0108183:	89 e5                	mov    %esp,%ebp
f0108185:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f0108188:	9c                   	pushf  
f0108189:	58                   	pop    %eax
f010818a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return eflags;
f010818d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  if(read_eflags()&FL_IF)
f0108190:	25 00 02 00 00       	and    $0x200,%eax
f0108195:	85 c0                	test   %eax,%eax
f0108197:	74 14                	je     f01081ad <popcli+0x2b>
    panic("popcli - interruptible");
f0108199:	83 ec 04             	sub    $0x4,%esp
f010819c:	68 2e ee 12 f0       	push   $0xf012ee2e
f01081a1:	6a 5e                	push   $0x5e
f01081a3:	68 45 ee 12 f0       	push   $0xf012ee45
f01081a8:	e8 02 8e ff ff       	call   f0100faf <_panic>
  struct cpu* c = mycpu();
f01081ad:	e8 be fe ff ff       	call   f0108070 <mycpu>
f01081b2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if(--c->ncli < 0)
f01081b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081b8:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01081be:	8d 50 ff             	lea    -0x1(%eax),%edx
f01081c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081c4:	89 90 a8 00 00 00    	mov    %edx,0xa8(%eax)
f01081ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081cd:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01081d3:	85 c0                	test   %eax,%eax
f01081d5:	79 14                	jns    f01081eb <popcli+0x69>
    panic("popcli");
f01081d7:	83 ec 04             	sub    $0x4,%esp
f01081da:	68 54 ee 12 f0       	push   $0xf012ee54
f01081df:	6a 61                	push   $0x61
f01081e1:	68 45 ee 12 f0       	push   $0xf012ee45
f01081e6:	e8 c4 8d ff ff       	call   f0100faf <_panic>
  if(c->ncli == 0 && c->intena)
f01081eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081ee:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f01081f4:	85 c0                	test   %eax,%eax
f01081f6:	75 0e                	jne    f0108206 <popcli+0x84>
f01081f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01081fb:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f0108201:	85 c0                	test   %eax,%eax
f0108203:	74 01                	je     f0108206 <popcli+0x84>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f0108205:	fb                   	sti    
    sti();
}
f0108206:	90                   	nop
f0108207:	c9                   	leave  
f0108208:	c3                   	ret    

f0108209 <seg_init>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seg_init(void)
{
f0108209:	55                   	push   %ebp
f010820a:	89 e5                	mov    %esp,%ebp
f010820c:	83 ec 18             	sub    $0x18,%esp
	// The kernel and user segments are identical(except for the DPL).
	// To load the SS register, the CPL must equal the DPL.  Thus,
	// we must duplicate the segments for the user and the kernel.
	//

	pushcli();	//disable interrupt
f010820f:	e8 1c ff ff ff       	call   f0108130 <pushcli>

	c = mycpu();
f0108214:	e8 57 fe ff ff       	call   f0108070 <mycpu>
f0108219:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// 0x0 - unused (always faults -- for trapping NULL far pointers)
	c->gdt[0] = SEG_NULL;
f010821c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010821f:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
f0108226:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)

	// 0x8 - kernel code segment
	c->gdt[GD_KT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0);
f010822d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108230:	66 c7 40 7c ff ff    	movw   $0xffff,0x7c(%eax)
f0108236:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108239:	66 c7 40 7e 00 00    	movw   $0x0,0x7e(%eax)
f010823f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108242:	c6 80 80 00 00 00 00 	movb   $0x0,0x80(%eax)
f0108249:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010824c:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108252:	83 e2 f0             	and    $0xfffffff0,%edx
f0108255:	83 ca 0a             	or     $0xa,%edx
f0108258:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f010825e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108261:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108267:	83 ca 10             	or     $0x10,%edx
f010826a:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108270:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108273:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f0108279:	83 e2 9f             	and    $0xffffff9f,%edx
f010827c:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108282:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108285:	8a 90 81 00 00 00    	mov    0x81(%eax),%dl
f010828b:	83 ca 80             	or     $0xffffff80,%edx
f010828e:	88 90 81 00 00 00    	mov    %dl,0x81(%eax)
f0108294:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108297:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f010829d:	83 ca 0f             	or     $0xf,%edx
f01082a0:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01082a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082a9:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01082af:	83 e2 ef             	and    $0xffffffef,%edx
f01082b2:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01082b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082bb:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01082c1:	83 e2 df             	and    $0xffffffdf,%edx
f01082c4:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01082ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082cd:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01082d3:	83 ca 40             	or     $0x40,%edx
f01082d6:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01082dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082df:	8a 90 82 00 00 00    	mov    0x82(%eax),%dl
f01082e5:	83 ca 80             	or     $0xffffff80,%edx
f01082e8:	88 90 82 00 00 00    	mov    %dl,0x82(%eax)
f01082ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082f1:	c6 80 83 00 00 00 00 	movb   $0x0,0x83(%eax)

	// 0x10 - kernel data segment
	c->gdt[GD_KD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 0);
f01082f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01082fb:	66 c7 80 84 00 00 00 	movw   $0xffff,0x84(%eax)
f0108302:	ff ff 
f0108304:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108307:	66 c7 80 86 00 00 00 	movw   $0x0,0x86(%eax)
f010830e:	00 00 
f0108310:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108313:	c6 80 88 00 00 00 00 	movb   $0x0,0x88(%eax)
f010831a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010831d:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0108323:	83 e2 f0             	and    $0xfffffff0,%edx
f0108326:	83 ca 02             	or     $0x2,%edx
f0108329:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f010832f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108332:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f0108338:	83 ca 10             	or     $0x10,%edx
f010833b:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108341:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108344:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010834a:	83 e2 9f             	and    $0xffffff9f,%edx
f010834d:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108353:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108356:	8a 90 89 00 00 00    	mov    0x89(%eax),%dl
f010835c:	83 ca 80             	or     $0xffffff80,%edx
f010835f:	88 90 89 00 00 00    	mov    %dl,0x89(%eax)
f0108365:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108368:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f010836e:	83 ca 0f             	or     $0xf,%edx
f0108371:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0108377:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010837a:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108380:	83 e2 ef             	and    $0xffffffef,%edx
f0108383:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f0108389:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010838c:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f0108392:	83 e2 df             	and    $0xffffffdf,%edx
f0108395:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f010839b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010839e:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01083a4:	83 ca 40             	or     $0x40,%edx
f01083a7:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01083ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083b0:	8a 90 8a 00 00 00    	mov    0x8a(%eax),%dl
f01083b6:	83 ca 80             	or     $0xffffff80,%edx
f01083b9:	88 90 8a 00 00 00    	mov    %dl,0x8a(%eax)
f01083bf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083c2:	c6 80 8b 00 00 00 00 	movb   $0x0,0x8b(%eax)

	// 0x18 - user code segment
	c->gdt[GD_UT >> 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3);
f01083c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083cc:	66 c7 80 8c 00 00 00 	movw   $0xffff,0x8c(%eax)
f01083d3:	ff ff 
f01083d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083d8:	66 c7 80 8e 00 00 00 	movw   $0x0,0x8e(%eax)
f01083df:	00 00 
f01083e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083e4:	c6 80 90 00 00 00 00 	movb   $0x0,0x90(%eax)
f01083eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01083ee:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f01083f4:	83 e2 f0             	and    $0xfffffff0,%edx
f01083f7:	83 ca 0a             	or     $0xa,%edx
f01083fa:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108400:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108403:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f0108409:	83 ca 10             	or     $0x10,%edx
f010840c:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108412:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108415:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010841b:	83 ca 60             	or     $0x60,%edx
f010841e:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108424:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108427:	8a 90 91 00 00 00    	mov    0x91(%eax),%dl
f010842d:	83 ca 80             	or     $0xffffff80,%edx
f0108430:	88 90 91 00 00 00    	mov    %dl,0x91(%eax)
f0108436:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108439:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f010843f:	83 ca 0f             	or     $0xf,%edx
f0108442:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108448:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010844b:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108451:	83 e2 ef             	and    $0xffffffef,%edx
f0108454:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010845a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010845d:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108463:	83 e2 df             	and    $0xffffffdf,%edx
f0108466:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010846c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010846f:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108475:	83 ca 40             	or     $0x40,%edx
f0108478:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f010847e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108481:	8a 90 92 00 00 00    	mov    0x92(%eax),%dl
f0108487:	83 ca 80             	or     $0xffffff80,%edx
f010848a:	88 90 92 00 00 00    	mov    %dl,0x92(%eax)
f0108490:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108493:	c6 80 93 00 00 00 00 	movb   $0x0,0x93(%eax)

	// 0x20 - user data segment
	c->gdt[GD_UD >> 3] = SEG(STA_W, 0x0, 0xffffffff, 3);
f010849a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010849d:	66 c7 80 94 00 00 00 	movw   $0xffff,0x94(%eax)
f01084a4:	ff ff 
f01084a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084a9:	66 c7 80 96 00 00 00 	movw   $0x0,0x96(%eax)
f01084b0:	00 00 
f01084b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084b5:	c6 80 98 00 00 00 00 	movb   $0x0,0x98(%eax)
f01084bc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084bf:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01084c5:	83 e2 f0             	and    $0xfffffff0,%edx
f01084c8:	83 ca 02             	or     $0x2,%edx
f01084cb:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01084d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084d4:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01084da:	83 ca 10             	or     $0x10,%edx
f01084dd:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01084e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084e6:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01084ec:	83 ca 60             	or     $0x60,%edx
f01084ef:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f01084f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01084f8:	8a 90 99 00 00 00    	mov    0x99(%eax),%dl
f01084fe:	83 ca 80             	or     $0xffffff80,%edx
f0108501:	88 90 99 00 00 00    	mov    %dl,0x99(%eax)
f0108507:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010850a:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108510:	83 ca 0f             	or     $0xf,%edx
f0108513:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108519:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010851c:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108522:	83 e2 ef             	and    $0xffffffef,%edx
f0108525:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010852b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010852e:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108534:	83 e2 df             	and    $0xffffffdf,%edx
f0108537:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010853d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108540:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108546:	83 ca 40             	or     $0x40,%edx
f0108549:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f010854f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108552:	8a 90 9a 00 00 00    	mov    0x9a(%eax),%dl
f0108558:	83 ca 80             	or     $0xffffff80,%edx
f010855b:	88 90 9a 00 00 00    	mov    %dl,0x9a(%eax)
f0108561:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108564:	c6 80 9b 00 00 00 00 	movb   $0x0,0x9b(%eax)

	// 0x28 - tss, initialized in idt_init()
	c->gdt[GD_TSS >> 3] = SEG_NULL;
f010856b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010856e:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f0108575:	00 00 00 
f0108578:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010857f:	00 00 00 

	popcli();	//enable interrupt
f0108582:	e8 fb fb ff ff       	call   f0108182 <popcli>


}
f0108587:	90                   	nop
f0108588:	c9                   	leave  
f0108589:	c3                   	ret    

f010858a <initialize_kernel_VM>:
//
// From USER_TOP to USER_LIMIT, the user is allowed to read but not write.
// Above USER_LIMIT the user cannot read (or write).

void initialize_kernel_VM()
{
f010858a:	55                   	push   %ebp
f010858b:	89 e5                	mov    %esp,%ebp
f010858d:	83 ec 38             	sub    $0x38,%esp
	//panic("initialize_kernel_VM: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.

	ptr_page_directory = boot_allocate_space(PAGE_SIZE, PAGE_SIZE);
f0108590:	83 ec 08             	sub    $0x8,%esp
f0108593:	68 00 10 00 00       	push   $0x1000
f0108598:	68 00 10 00 00       	push   $0x1000
f010859d:	e8 43 02 00 00       	call   f01087e5 <boot_allocate_space>
f01085a2:	83 c4 10             	add    $0x10,%esp
f01085a5:	a3 d8 6c 85 f0       	mov    %eax,0xf0856cd8
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(ptr_page_directory, 0, PAGE_SIZE);
	phys_page_directory = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f01085aa:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01085af:	89 45 e0             	mov    %eax,-0x20(%ebp)
f01085b2:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f01085b9:	77 14                	ja     f01085cf <initialize_kernel_VM+0x45>
f01085bb:	ff 75 e0             	pushl  -0x20(%ebp)
f01085be:	68 5c ee 12 f0       	push   $0xf012ee5c
f01085c3:	6a 57                	push   $0x57
f01085c5:	68 90 ee 12 f0       	push   $0xf012ee90
f01085ca:	e8 e0 89 ff ff       	call   f0100faf <_panic>
f01085cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01085d2:	05 00 00 00 10       	add    $0x10000000,%eax
f01085d7:	a3 e0 6d 85 f0       	mov    %eax,0xf0856de0
	// Your code goes here:

	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
f01085dc:	c7 45 dc 00 70 17 f0 	movl   $0xf0177000,-0x24(%ebp)
f01085e3:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f01085ea:	77 14                	ja     f0108600 <initialize_kernel_VM+0x76>
f01085ec:	ff 75 dc             	pushl  -0x24(%ebp)
f01085ef:	68 5c ee 12 f0       	push   $0xf012ee5c
f01085f4:	6a 63                	push   $0x63
f01085f6:	68 90 ee 12 f0       	push   $0xf012ee90
f01085fb:	e8 af 89 ff ff       	call   f0100faf <_panic>
f0108600:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108603:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108609:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010860e:	83 ec 0c             	sub    $0xc,%esp
f0108611:	6a 02                	push   $0x2
f0108613:	52                   	push   %edx
f0108614:	68 00 80 00 00       	push   $0x8000
f0108619:	68 00 80 bf ef       	push   $0xefbf8000
f010861e:	50                   	push   %eax
f010861f:	e8 35 02 00 00       	call   f0108859 <boot_map_range>
f0108624:	83 c4 20             	add    $0x20,%esp
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108627:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010862e:	eb 24                	jmp    f0108654 <initialize_kernel_VM+0xca>
	{
		pt_set_page_permissions(ptr_page_directory, KERN_STACK_TOP - ((c+1)*KERNEL_STACK_SIZE), 0, PERM_PRESENT);
f0108630:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108633:	f7 d0                	not    %eax
f0108635:	c1 e0 0f             	shl    $0xf,%eax
f0108638:	8d 90 00 00 c0 ef    	lea    -0x10400000(%eax),%edx
f010863e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108643:	6a 01                	push   $0x1
f0108645:	6a 00                	push   $0x0
f0108647:	52                   	push   %edx
f0108648:	50                   	push   %eax
f0108649:	e8 b1 16 00 00       	call   f0109cff <pt_set_page_permissions>
f010864e:	83 c4 10             	add    $0x10,%esp
	//Ensure that the total size of SCHED Kernel Stack for ALL CPUs is less than PTSIZE (specified area for them)
	assert(NCPUS*KERNEL_STACK_SIZE < PTSIZE);

	boot_map_range(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE, NCPUS*KERNEL_STACK_SIZE, STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom), PERM_WRITEABLE) ;
	//set bottom page of each stack as a GUARD page
	for (int c = 0; c < NCPUS; ++c)
f0108651:	ff 45 f4             	incl   -0xc(%ebp)
f0108654:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108658:	7e d6                	jle    f0108630 <initialize_kernel_VM+0xa6>
	// Permissions: kernel RW, user NONE
	// Your code goes here:

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
f010865a:	c7 45 e8 00 00 00 f0 	movl   $0xf0000000,-0x18(%ebp)
f0108661:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	unsigned int nTables=0;
f0108668:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010866f:	eb 25                	jmp    f0108696 <initialize_kernel_VM+0x10c>
	{
		++nTables;
f0108671:	ff 45 e4             	incl   -0x1c(%ebp)
		boot_get_page_table(ptr_page_directory, (uint32)sva, 1);
f0108674:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108677:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010867c:	83 ec 04             	sub    $0x4,%esp
f010867f:	6a 01                	push   $0x1
f0108681:	52                   	push   %edx
f0108682:	50                   	push   %eax
f0108683:	e8 45 02 00 00       	call   f01088cd <boot_get_page_table>
f0108688:	83 c4 10             	add    $0x10,%esp

	//2016:
	//boot tables
	unsigned long long sva = KERNEL_BASE;
	unsigned int nTables=0;
	for (;sva < 0xFFFFFFFF;  sva += PTSIZE)
f010868b:	81 45 e8 00 00 40 00 	addl   $0x400000,-0x18(%ebp)
f0108692:	83 55 ec 00          	adcl   $0x0,-0x14(%ebp)
f0108696:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010869a:	72 d5                	jb     f0108671 <initialize_kernel_VM+0xe7>
f010869c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01086a0:	77 06                	ja     f01086a8 <initialize_kernel_VM+0x11e>
f01086a2:	83 7d e8 fe          	cmpl   $0xfffffffe,-0x18(%ebp)
f01086a6:	76 c9                	jbe    f0108671 <initialize_kernel_VM+0xe7>
	//    - frames_info -- kernel RW, user NONE
	//    - the image mapped at READ_ONLY_FRAMES_INFO  -- kernel R, user R
	// Your code goes here:
	//cprintf("size of WorkingSetPage = %d\n",sizeof(struct WorkingSetPage));
	uint32 array_size;
	array_size = number_of_frames * sizeof(struct FrameInfo) ;
f01086a8:	8b 15 b8 e9 83 f0    	mov    0xf083e9b8,%edx
f01086ae:	89 d0                	mov    %edx,%eax
f01086b0:	c1 e0 02             	shl    $0x2,%eax
f01086b3:	01 d0                	add    %edx,%eax
f01086b5:	c1 e0 02             	shl    $0x2,%eax
f01086b8:	89 45 d8             	mov    %eax,-0x28(%ebp)
	frames_info = boot_allocate_space(array_size, PAGE_SIZE);
f01086bb:	83 ec 08             	sub    $0x8,%esp
f01086be:	68 00 10 00 00       	push   $0x1000
f01086c3:	ff 75 d8             	pushl  -0x28(%ebp)
f01086c6:	e8 1a 01 00 00       	call   f01087e5 <boot_allocate_space>
f01086cb:	83 c4 10             	add    $0x10,%esp
f01086ce:	a3 08 6b 85 f0       	mov    %eax,0xf0856b08
	//2016: Not valid any more since the RAM size exceed the 64 MB limit. This lead to the
	// 		size of "frames_info" can exceed the 4 MB space for "READ_ONLY_FRAMES_INFO"
	//boot_map_range(ptr_page_directory, READ_ONLY_FRAMES_INFO, array_size, STATIC_KERNEL_PHYSICAL_ADDRESS(frames_info),PERM_USER) ;


	uint32 disk_array_size = PAGES_PER_FILE * sizeof(struct FrameInfo);
f01086d3:	c7 45 d4 00 a0 28 00 	movl   $0x28a000,-0x2c(%ebp)
	disk_frames_info = boot_allocate_space(disk_array_size , PAGE_SIZE);
f01086da:	83 ec 08             	sub    $0x8,%esp
f01086dd:	68 00 10 00 00       	push   $0x1000
f01086e2:	ff 75 d4             	pushl  -0x2c(%ebp)
f01086e5:	e8 fb 00 00 00       	call   f01087e5 <boot_allocate_space>
f01086ea:	83 c4 10             	add    $0x10,%esp
f01086ed:	a3 44 e5 83 f0       	mov    %eax,0xf083e544
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(disk_frames_info , 0, disk_array_size);

	// This allows the kernel & user to access any page table entry using a
	// specified VA for each: VPT for kernel and UVPT for User.
	setup_listing_to_all_page_tables_entries();
f01086f2:	e8 05 05 00 00       	call   f0108bfc <setup_listing_to_all_page_tables_entries>
	// Permissions:
	//    - envs itself -- kernel RW, user NONE
	//    - the image of envs mapped at UENVS  -- kernel R, user R

	// LAB 3: Your code here.
	cprintf("*	Max Envs = %d, Nearest Pow of 2 = %d\n",NENV, NEARPOW2NENV);
f01086f7:	83 ec 0c             	sub    $0xc,%esp
f01086fa:	68 c6 02 00 00       	push   $0x2c6
f01086ff:	e8 17 05 01 00       	call   f0118c1b <nearest_pow2_ceil>
f0108704:	83 c4 10             	add    $0x10,%esp
f0108707:	83 ec 04             	sub    $0x4,%esp
f010870a:	50                   	push   %eax
f010870b:	68 c6 02 00 00       	push   $0x2c6
f0108710:	68 b0 ee 12 f0       	push   $0xf012eeb0
f0108715:	e8 42 95 ff ff       	call   f0101c5c <cprintf>
f010871a:	83 c4 10             	add    $0x10,%esp
	int envs_size = NENV * sizeof(struct Env) ;
f010871d:	c7 45 d0 98 fd 0f 00 	movl   $0xffd98,-0x30(%ebp)

	//allocate space for "envs" array aligned on 4KB boundary
	envs = boot_allocate_space(envs_size, PAGE_SIZE);
f0108724:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108727:	83 ec 08             	sub    $0x8,%esp
f010872a:	68 00 10 00 00       	push   $0x1000
f010872f:	50                   	push   %eax
f0108730:	e8 b0 00 00 00       	call   f01087e5 <boot_allocate_space>
f0108735:	83 c4 10             	add    $0x10,%esp
f0108738:	a3 90 5b 81 f0       	mov    %eax,0xf0815b90
	/*2023: this line is moved to the boot_allocate_space()*/ //memset(envs , 0, envs_size);

	//make the user to access this array by mapping it to UPAGES linear address (UPAGES is in User/Kernel space)
	boot_map_range(ptr_page_directory, UENVS, envs_size, STATIC_KERNEL_PHYSICAL_ADDRESS(envs), PERM_USER) ;
f010873d:	a1 90 5b 81 f0       	mov    0xf0815b90,%eax
f0108742:	89 45 cc             	mov    %eax,-0x34(%ebp)
f0108745:	81 7d cc ff ff ff ef 	cmpl   $0xefffffff,-0x34(%ebp)
f010874c:	77 17                	ja     f0108765 <initialize_kernel_VM+0x1db>
f010874e:	ff 75 cc             	pushl  -0x34(%ebp)
f0108751:	68 5c ee 12 f0       	push   $0xf012ee5c
f0108756:	68 b1 00 00 00       	push   $0xb1
f010875b:	68 90 ee 12 f0       	push   $0xf012ee90
f0108760:	e8 4a 88 ff ff       	call   f0100faf <_panic>
f0108765:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108768:	8d 88 00 00 00 10    	lea    0x10000000(%eax),%ecx
f010876e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0108771:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108776:	83 ec 0c             	sub    $0xc,%esp
f0108779:	6a 04                	push   $0x4
f010877b:	51                   	push   %ecx
f010877c:	52                   	push   %edx
f010877d:	68 00 00 c0 ee       	push   $0xeec00000
f0108782:	50                   	push   %eax
f0108783:	e8 d1 00 00 00       	call   f0108859 <boot_map_range>
f0108788:	83 c4 20             	add    $0x20,%esp

	//update permissions of the corresponding entry in page directory to make it USER with PERMISSION read only
	ptr_page_directory[PDX(UENVS)] = ptr_page_directory[PDX(UENVS)]|(PERM_USER|(PERM_PRESENT & (~PERM_WRITEABLE)));
f010878b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108790:	05 ec 0e 00 00       	add    $0xeec,%eax
f0108795:	8b 15 d8 6c 85 f0    	mov    0xf0856cd8,%edx
f010879b:	81 c2 ec 0e 00 00    	add    $0xeec,%edx
f01087a1:	8b 12                	mov    (%edx),%edx
f01087a3:	83 ca 05             	or     $0x5,%edx
f01087a6:	89 10                	mov    %edx,(%eax)
#if USE_KHEAP
	{
		// MAKE SURE THAT THIS MAPPING HAPPENS AFTER ALL BOOT ALLOCATIONS (boot_allocate_space)
		// calls are fininshed, and no remaining data to be allocated for the kernel
		// map all used pages so far for the kernel
		boot_map_range(ptr_page_directory, KERNEL_BASE, (uint32)ptr_free_mem - KERNEL_BASE, 0, PERM_WRITEABLE) ;
f01087a8:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f01087ad:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f01087b3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01087b8:	83 ec 0c             	sub    $0xc,%esp
f01087bb:	6a 02                	push   $0x2
f01087bd:	6a 00                	push   $0x0
f01087bf:	52                   	push   %edx
f01087c0:	68 00 00 00 f0       	push   $0xf0000000
f01087c5:	50                   	push   %eax
f01087c6:	e8 8e 00 00 00       	call   f0108859 <boot_map_range>
f01087cb:	83 c4 20             	add    $0x20,%esp
	{
		boot_map_range(ptr_page_directory, KERNEL_BASE, 0xFFFFFFFF - KERNEL_BASE, 0, PERM_WRITEABLE) ;
	}
#endif
	// Check that the initial page directory has been set up correctly.
	check_boot_pgdir();
f01087ce:	e8 31 18 01 00       	call   f011a004 <check_boot_pgdir>

	memory_scarce_threshold_percentage = DEFAULT_MEM_SCARCE_PERCENTAGE;	// Memory remains plentiful till % of free frames gets below 25% of the memory space
f01087d3:	c7 05 f0 e8 83 f0 19 	movl   $0x19,0xf083e8f0
f01087da:	00 00 00 

	/*
	NOW: Turn off the segmentation by setting the segments' base to 0, and
	turn on the paging by setting the corresponding flags in control register 0 (cr0)
	 */
	turn_on_paging() ;
f01087dd:	e8 e6 02 00 00       	call   f0108ac8 <turn_on_paging>
}
f01087e2:	90                   	nop
f01087e3:	c9                   	leave  
f01087e4:	c3                   	ret    

f01087e5 <boot_allocate_space>:
// It's too early to run out of memory.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void* boot_allocate_space(uint32 size, uint32 align)
{
f01087e5:	55                   	push   %ebp
f01087e6:	89 e5                	mov    %esp,%ebp
f01087e8:	83 ec 18             	sub    $0x18,%esp
	// Initialize ptr_free_mem if this is the first time.
	// 'end_of_kernel' is a symbol automatically generated by the linker,
	// which points to the end of the kernel-
	// i.e., the first virtual address that the linker
	// did not assign to any kernel code or global variables.
	if (ptr_free_mem == 0)
f01087eb:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f01087f0:	85 c0                	test   %eax,%eax
f01087f2:	75 0a                	jne    f01087fe <boot_allocate_space+0x19>
		ptr_free_mem = end_of_kernel;
f01087f4:	c7 05 d0 6c 85 f0 d0 	movl   $0xf087d6d0,0xf0856cd0
f01087fb:	d6 87 f0 

	// Your code here:
	//	Step 1: round ptr_free_mem up to be aligned properly
	ptr_free_mem = ROUNDUP(ptr_free_mem, align) ;
f01087fe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108801:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108804:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108809:	89 c2                	mov    %eax,%edx
f010880b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010880e:	01 d0                	add    %edx,%eax
f0108810:	48                   	dec    %eax
f0108811:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108814:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108817:	ba 00 00 00 00       	mov    $0x0,%edx
f010881c:	f7 75 f4             	divl   -0xc(%ebp)
f010881f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108822:	29 d0                	sub    %edx,%eax
f0108824:	a3 d0 6c 85 f0       	mov    %eax,0xf0856cd0

	//	Step 2: save current value of ptr_free_mem as allocated space
	void *ptr_allocated_mem;
	ptr_allocated_mem = ptr_free_mem ;
f0108829:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f010882e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	//	Step 3: increase ptr_free_mem to record allocation
	ptr_free_mem += size ;
f0108831:	8b 15 d0 6c 85 f0    	mov    0xf0856cd0,%edx
f0108837:	8b 45 08             	mov    0x8(%ebp),%eax
f010883a:	01 d0                	add    %edx,%eax
f010883c:	a3 d0 6c 85 f0       	mov    %eax,0xf0856cd0

	//// 2016: Step 3.5: initialize allocated space by ZEROOOOOOOOOOOOOO
	/*2023*/ /*THIS LINE IS UNCOMMENTED To Ensure that any boot allocations ARE SET TO ZERO
	 * This is mainly to ensure that any restart will be fresh and no grabage data will be exist
	 */
	memset(ptr_allocated_mem, 0, size);
f0108841:	83 ec 04             	sub    $0x4,%esp
f0108844:	ff 75 08             	pushl  0x8(%ebp)
f0108847:	6a 00                	push   $0x0
f0108849:	ff 75 ec             	pushl  -0x14(%ebp)
f010884c:	e8 18 25 01 00       	call   f011ad69 <memset>
f0108851:	83 c4 10             	add    $0x10,%esp

	//	Step 4: return allocated space
	return ptr_allocated_mem ;
f0108854:	8b 45 ec             	mov    -0x14(%ebp),%eax

}
f0108857:	c9                   	leave  
f0108858:	c3                   	ret    

f0108859 <boot_map_range>:
//
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
void boot_map_range(uint32 *ptr_page_directory, uint32 virtual_address, uint32 size, uint32 physical_address, int perm)
{
f0108859:	55                   	push   %ebp
f010885a:	89 e5                	mov    %esp,%ebp
f010885c:	83 ec 18             	sub    $0x18,%esp
	int i = 0 ;
f010885f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f0108866:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010886d:	eb 53                	jmp    f01088c2 <boot_map_range+0x69>
	{
		uint32 *ptr_page_table = boot_get_page_table(ptr_page_directory, virtual_address, 1) ;
f010886f:	83 ec 04             	sub    $0x4,%esp
f0108872:	6a 01                	push   $0x1
f0108874:	ff 75 0c             	pushl  0xc(%ebp)
f0108877:	ff 75 08             	pushl  0x8(%ebp)
f010887a:	e8 4e 00 00 00       	call   f01088cd <boot_get_page_table>
f010887f:	83 c4 10             	add    $0x10,%esp
f0108882:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 index_page_table = PTX(virtual_address);
f0108885:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108888:	c1 e8 0c             	shr    $0xc,%eax
f010888b:	25 ff 03 00 00       	and    $0x3ff,%eax
f0108890:	89 45 ec             	mov    %eax,-0x14(%ebp)
		//LOG_VARS("\nCONSTRUCT_ENTRY = %x",physical_address);
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;
f0108893:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108896:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010889d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01088a0:	01 c2                	add    %eax,%edx
f01088a2:	8b 45 18             	mov    0x18(%ebp),%eax
f01088a5:	0b 45 14             	or     0x14(%ebp),%eax
f01088a8:	83 c8 01             	or     $0x1,%eax
f01088ab:	89 02                	mov    %eax,(%edx)

		physical_address += PAGE_SIZE ;
f01088ad:	81 45 14 00 10 00 00 	addl   $0x1000,0x14(%ebp)
		virtual_address += PAGE_SIZE ;
f01088b4:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
{
	int i = 0 ;
	//physical_address = ROUNDUP(physical_address, PAGE_SIZE) ;
	///we assume here that all addresses are given divisible by 4 KB, look at boot_allocate_space ...

	for (i = 0 ; i < size ; i += PAGE_SIZE)
f01088bb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01088c2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088c5:	3b 45 10             	cmp    0x10(%ebp),%eax
f01088c8:	72 a5                	jb     f010886f <boot_map_range+0x16>
		ptr_page_table[index_page_table] = CONSTRUCT_ENTRY(physical_address, perm | PERM_PRESENT) ;

		physical_address += PAGE_SIZE ;
		virtual_address += PAGE_SIZE ;
	}
}
f01088ca:	90                   	nop
f01088cb:	c9                   	leave  
f01088cc:	c3                   	ret    

f01088cd <boot_get_page_table>:
// boot_get_page_table cannot fail.  It's too early to fail.
// This function may ONLY be used during boot time,
// before the free_frame_list has been set up.
//
uint32* boot_get_page_table(uint32 *ptr_page_directory, uint32 virtual_address, int create)
{
f01088cd:	55                   	push   %ebp
f01088ce:	89 e5                	mov    %esp,%ebp
f01088d0:	83 ec 28             	sub    $0x28,%esp
	uint32 index_page_directory = PDX(virtual_address);
f01088d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01088d6:	c1 e8 16             	shr    $0x16,%eax
f01088d9:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 page_directory_entry = ptr_page_directory[index_page_directory];
f01088dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01088df:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01088e6:	8b 45 08             	mov    0x8(%ebp),%eax
f01088e9:	01 d0                	add    %edx,%eax
f01088eb:	8b 00                	mov    (%eax),%eax
f01088ed:	89 45 f0             	mov    %eax,-0x10(%ebp)

	//cprintf("boot d ind = %d, entry = %x\n",index_page_directory, page_directory_entry);
	uint32 phys_page_table = EXTRACT_ADDRESS(page_directory_entry);
f01088f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01088f3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01088f8:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint32 *ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table);
f01088fb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01088fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0108901:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108904:	c1 e8 0c             	shr    $0xc,%eax
f0108907:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010890a:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f010890f:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f0108912:	72 17                	jb     f010892b <boot_get_page_table+0x5e>
f0108914:	ff 75 e8             	pushl  -0x18(%ebp)
f0108917:	68 d8 ee 12 f0       	push   $0xf012eed8
f010891c:	68 33 01 00 00       	push   $0x133
f0108921:	68 90 ee 12 f0       	push   $0xf012ee90
f0108926:	e8 84 86 ff ff       	call   f0100faf <_panic>
f010892b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010892e:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0108933:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (phys_page_table == 0)
f0108936:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010893a:	75 72                	jne    f01089ae <boot_get_page_table+0xe1>
	{
		if (create)
f010893c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f0108940:	74 65                	je     f01089a7 <boot_get_page_table+0xda>
		{
			ptr_page_table = boot_allocate_space(PAGE_SIZE, PAGE_SIZE) ;
f0108942:	83 ec 08             	sub    $0x8,%esp
f0108945:	68 00 10 00 00       	push   $0x1000
f010894a:	68 00 10 00 00       	push   $0x1000
f010894f:	e8 91 fe ff ff       	call   f01087e5 <boot_allocate_space>
f0108954:	83 c4 10             	add    $0x10,%esp
f0108957:	89 45 e0             	mov    %eax,-0x20(%ebp)
			phys_page_table = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_table);
f010895a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010895d:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108960:	81 7d dc ff ff ff ef 	cmpl   $0xefffffff,-0x24(%ebp)
f0108967:	77 17                	ja     f0108980 <boot_get_page_table+0xb3>
f0108969:	ff 75 dc             	pushl  -0x24(%ebp)
f010896c:	68 5c ee 12 f0       	push   $0xf012ee5c
f0108971:	68 39 01 00 00       	push   $0x139
f0108976:	68 90 ee 12 f0       	push   $0xf012ee90
f010897b:	e8 2f 86 ff ff       	call   f0100faf <_panic>
f0108980:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108983:	05 00 00 00 10       	add    $0x10000000,%eax
f0108988:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_page_directory[index_page_directory] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_WRITEABLE);
f010898b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010898e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0108995:	8b 45 08             	mov    0x8(%ebp),%eax
f0108998:	01 d0                	add    %edx,%eax
f010899a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010899d:	83 ca 03             	or     $0x3,%edx
f01089a0:	89 10                	mov    %edx,(%eax)
			return ptr_page_table ;
f01089a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01089a5:	eb 0a                	jmp    f01089b1 <boot_get_page_table+0xe4>
		}
		else
			return 0 ;
f01089a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01089ac:	eb 03                	jmp    f01089b1 <boot_get_page_table+0xe4>
	}
	return ptr_page_table ;
f01089ae:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
f01089b1:	c9                   	leave  
f01089b2:	c3                   	ret    

f01089b3 <nvram_read>:


int nvram_read(int r)
{
f01089b3:	55                   	push   %ebp
f01089b4:	89 e5                	mov    %esp,%ebp
f01089b6:	53                   	push   %ebx
f01089b7:	83 ec 04             	sub    $0x4,%esp
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
f01089ba:	8b 45 08             	mov    0x8(%ebp),%eax
f01089bd:	83 ec 0c             	sub    $0xc,%esp
f01089c0:	50                   	push   %eax
f01089c1:	e8 27 d2 ff ff       	call   f0105bed <mc146818_read>
f01089c6:	83 c4 10             	add    $0x10,%esp
f01089c9:	89 c3                	mov    %eax,%ebx
f01089cb:	8b 45 08             	mov    0x8(%ebp),%eax
f01089ce:	40                   	inc    %eax
f01089cf:	83 ec 0c             	sub    $0xc,%esp
f01089d2:	50                   	push   %eax
f01089d3:	e8 15 d2 ff ff       	call   f0105bed <mc146818_read>
f01089d8:	83 c4 10             	add    $0x10,%esp
f01089db:	c1 e0 08             	shl    $0x8,%eax
f01089de:	09 d8                	or     %ebx,%eax
}
f01089e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f01089e3:	c9                   	leave  
f01089e4:	c3                   	ret    

f01089e5 <detect_memory>:

void detect_memory()
{
f01089e5:	55                   	push   %ebp
f01089e6:	89 e5                	mov    %esp,%ebp
f01089e8:	83 ec 28             	sub    $0x28,%esp
	uint32 maxpa;	// Maximum physical address
	uint32 size_of_base_mem;		// Amount of base memory (in bytes)
	uint32 size_of_extended_mem;		// Amount of extended memory (in bytes)

	// CMOS tells us how many kilobytes there are
	size_of_base_mem = ROUNDDOWN(nvram_read(NVRAM_BASELO)*1024, PAGE_SIZE);
f01089eb:	83 ec 0c             	sub    $0xc,%esp
f01089ee:	6a 15                	push   $0x15
f01089f0:	e8 be ff ff ff       	call   f01089b3 <nvram_read>
f01089f5:	83 c4 10             	add    $0x10,%esp
f01089f8:	c1 e0 0a             	shl    $0xa,%eax
f01089fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01089fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108a01:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108a06:	89 45 e8             	mov    %eax,-0x18(%ebp)
	size_of_extended_mem = ROUNDDOWN(nvram_read(NVRAM_EXTLO)*1024, PAGE_SIZE);
f0108a09:	83 ec 0c             	sub    $0xc,%esp
f0108a0c:	6a 17                	push   $0x17
f0108a0e:	e8 a0 ff ff ff       	call   f01089b3 <nvram_read>
f0108a13:	83 c4 10             	add    $0x10,%esp
f0108a16:	c1 e0 0a             	shl    $0xa,%eax
f0108a19:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0108a1c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108a1f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108a24:	89 45 f0             	mov    %eax,-0x10(%ebp)
	//2016
	//For physical memory larger than 16MB, we needed to read total memory size
	// from a different register of the MC chip, see here:
	// http://bochs.sourceforge.net/techspec/CMOS-reference.txt
	// "CMOS 34h - AMI -"
	uint32 size_of_other_mem = ROUNDDOWN(nvram_read(0x34)*1024*64, PAGE_SIZE);
f0108a27:	83 ec 0c             	sub    $0xc,%esp
f0108a2a:	6a 34                	push   $0x34
f0108a2c:	e8 82 ff ff ff       	call   f01089b3 <nvram_read>
f0108a31:	83 c4 10             	add    $0x10,%esp
f0108a34:	c1 e0 10             	shl    $0x10,%eax
f0108a37:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108a3a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108a3d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0108a42:	89 45 dc             	mov    %eax,-0x24(%ebp)
	//cprintf("other mem = %dK\n", size_of_other_mem/1024);

	// Calculate the maximum physical address based on whether
	// or not there is any extended memory.  See comment in ../inc/mmu.h.
	//2016
	if(size_of_other_mem > 0)
f0108a45:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0108a49:	74 18                	je     f0108a63 <detect_memory+0x7e>
	{
		maxpa = size_of_other_mem + 16*1024*1024;
f0108a4b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108a4e:	05 00 00 00 01       	add    $0x1000000,%eax
f0108a53:	89 45 f4             	mov    %eax,-0xc(%ebp)
		size_of_extended_mem = maxpa - PHYS_EXTENDED_MEM;
f0108a56:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a59:	2d 00 00 10 00       	sub    $0x100000,%eax
f0108a5e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0108a61:	eb 19                	jmp    f0108a7c <detect_memory+0x97>
	}
	else
	{
		if (size_of_extended_mem)
f0108a63:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0108a67:	74 0d                	je     f0108a76 <detect_memory+0x91>
			maxpa = PHYS_EXTENDED_MEM + size_of_extended_mem;
f0108a69:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108a6c:	05 00 00 10 00       	add    $0x100000,%eax
f0108a71:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108a74:	eb 06                	jmp    f0108a7c <detect_memory+0x97>
		else
			maxpa = size_of_extended_mem;
f0108a76:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108a79:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	uint32 kernel_virtual_area = ((0xFFFFFFFF-KERNEL_BASE)+1);
f0108a7c:	c7 45 d8 00 00 00 10 	movl   $0x10000000,-0x28(%ebp)
	{
		cprintf("*	Error!: Physical memory = %dK larger than kernel virtual area (%dK)\n", maxpa/1024, kernel_virtual_area/1024);
		cprintf("*	Cannot use physical memory larger than kernel virtual area\nTo enable physical memory larger than virtual kernel area, set USE_KHEAP = 1 in FOS code");
		while(1);
	}
	number_of_frames = maxpa / PAGE_SIZE;
f0108a83:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a86:	c1 e8 0c             	shr    $0xc,%eax
f0108a89:	a3 b8 e9 83 f0       	mov    %eax,0xf083e9b8

	cprintf("*	Physical memory: %dK available, ", (int)(maxpa/1024));
f0108a8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108a91:	c1 e8 0a             	shr    $0xa,%eax
f0108a94:	83 ec 08             	sub    $0x8,%esp
f0108a97:	50                   	push   %eax
f0108a98:	68 08 ef 12 f0       	push   $0xf012ef08
f0108a9d:	e8 ba 91 ff ff       	call   f0101c5c <cprintf>
f0108aa2:	83 c4 10             	add    $0x10,%esp
	cprintf("base = %dK, extended = %dK\n", (int)(size_of_base_mem/1024), (int)(size_of_extended_mem/1024));
f0108aa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108aa8:	c1 e8 0a             	shr    $0xa,%eax
f0108aab:	89 c2                	mov    %eax,%edx
f0108aad:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ab0:	c1 e8 0a             	shr    $0xa,%eax
f0108ab3:	83 ec 04             	sub    $0x4,%esp
f0108ab6:	52                   	push   %edx
f0108ab7:	50                   	push   %eax
f0108ab8:	68 2b ef 12 f0       	push   $0xf012ef2b
f0108abd:	e8 9a 91 ff ff       	call   f0101c5c <cprintf>
f0108ac2:	83 c4 10             	add    $0x10,%esp
}
f0108ac5:	90                   	nop
f0108ac6:	c9                   	leave  
f0108ac7:	c3                   	ret    

f0108ac8 <turn_on_paging>:
// --------------------------------------------------------------
// Set up initial memory mappings and turn on MMU.
// --------------------------------------------------------------

void turn_on_paging()
{
f0108ac8:	55                   	push   %ebp
f0108ac9:	89 e5                	mov    %esp,%ebp
f0108acb:	83 ec 48             	sub    $0x48,%esp
	// (Limits our kernel to <4MB)

	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
f0108ace:	c7 45 f4 c0 03 00 00 	movl   $0x3c0,-0xc(%ebp)
		int j = 0;
f0108ad5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108adc:	eb 24                	jmp    f0108b02 <turn_on_paging+0x3a>
		{
			ptr_page_directory[j] = ptr_page_directory[i];
f0108ade:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108ae3:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108ae6:	c1 e2 02             	shl    $0x2,%edx
f0108ae9:	01 c2                	add    %eax,%edx
f0108aeb:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108af0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108af3:	c1 e1 02             	shl    $0x2,%ecx
f0108af6:	01 c8                	add    %ecx,%eax
f0108af8:	8b 00                	mov    (%eax),%eax
f0108afa:	89 02                	mov    %eax,(%edx)
	//2016
	//ptr_page_directory[0] = ptr_page_directory[PDX(KERNEL_BASE)];
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108afc:	ff 45 f4             	incl   -0xc(%ebp)
f0108aff:	ff 45 f0             	incl   -0x10(%ebp)
f0108b02:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108b07:	c1 e8 16             	shr    $0x16,%eax
f0108b0a:	89 c2                	mov    %eax,%edx
f0108b0c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108b0f:	39 c2                	cmp    %eax,%edx
f0108b11:	77 cb                	ja     f0108ade <turn_on_paging+0x16>
			ptr_page_directory[j] = ptr_page_directory[i];
		}
	}

	// Install page table.
	lcr3(phys_page_directory);
f0108b13:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0108b18:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108b1b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108b1e:	0f 22 d8             	mov    %eax,%cr3

static __inline uint32
rcr0(void)
{
	uint32 val;
	__asm __volatile("movl %%cr0,%0" : "=r" (val));
f0108b21:	0f 20 c0             	mov    %cr0,%eax
f0108b24:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f0108b27:	8b 45 d8             	mov    -0x28(%ebp),%eax

	// Turn on paging.
	uint32 cr0;
	cr0 = rcr0();
f0108b2a:	89 45 dc             	mov    %eax,-0x24(%ebp)
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_TS|CR0_EM|CR0_MP;
f0108b2d:	81 4d dc 2f 00 05 80 	orl    $0x8005002f,-0x24(%ebp)
	cr0 &= ~(CR0_TS|CR0_EM);
f0108b34:	83 65 dc f3          	andl   $0xfffffff3,-0x24(%ebp)
f0108b38:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108b3b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
}

static __inline void
lcr0(uint32 val)
{
	__asm __volatile("movl %0,%%cr0" : : "r" (val));
f0108b3e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0108b41:	0f 22 c0             	mov    %eax,%cr0
	// (x < 4MB so uses paging ptr_page_directory[0])

	// Reload all segment registers.
	//2024: replaced by lgdt()
	//asm volatile("lgdt gdt_pd");
	pushcli();	//disable interrupt
f0108b44:	e8 e7 f5 ff ff       	call   f0108130 <pushcli>
	lgdt(mycpu()->gdt, sizeof(mycpu()->gdt));
f0108b49:	e8 22 f5 ff ff       	call   f0108070 <mycpu>
f0108b4e:	83 c0 74             	add    $0x74,%eax
f0108b51:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0108b54:	c7 45 cc 30 00 00 00 	movl   $0x30,-0x34(%ebp)
static __inline void
lgdt(struct Segdesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f0108b5b:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0108b5e:	48                   	dec    %eax
f0108b5f:	66 89 45 c6          	mov    %ax,-0x3a(%ebp)
  pd[1] = (uint32)p;
f0108b63:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108b66:	66 89 45 c8          	mov    %ax,-0x38(%ebp)
  pd[2] = (uint32)p >> 16;
f0108b6a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0108b6d:	c1 e8 10             	shr    $0x10,%eax
f0108b70:	66 89 45 ca          	mov    %ax,-0x36(%ebp)

  __asm __volatile("lgdt (%0)" : : "r" (pd));
f0108b74:	8d 45 c6             	lea    -0x3a(%ebp),%eax
f0108b77:	0f 01 10             	lgdtl  (%eax)
	popcli();	//enable interrupt
f0108b7a:	e8 03 f6 ff ff       	call   f0108182 <popcli>
	asm volatile("movw %%ax,%%gs" :: "a" (GD_UD|3));
f0108b7f:	b8 23 00 00 00       	mov    $0x23,%eax
f0108b84:	8e e8                	mov    %eax,%gs
	asm volatile("movw %%ax,%%fs" :: "a" (GD_UD|3));
f0108b86:	b8 23 00 00 00       	mov    $0x23,%eax
f0108b8b:	8e e0                	mov    %eax,%fs
	asm volatile("movw %%ax,%%es" :: "a" (GD_KD));
f0108b8d:	b8 10 00 00 00       	mov    $0x10,%eax
f0108b92:	8e c0                	mov    %eax,%es
	asm volatile("movw %%ax,%%ds" :: "a" (GD_KD));
f0108b94:	b8 10 00 00 00       	mov    $0x10,%eax
f0108b99:	8e d8                	mov    %eax,%ds
	asm volatile("movw %%ax,%%ss" :: "a" (GD_KD));
f0108b9b:	b8 10 00 00 00       	mov    $0x10,%eax
f0108ba0:	8e d0                	mov    %eax,%ss
	asm volatile("ljmp %0,$1f\n 1:\n" :: "i" (GD_KT));  // reload cs
f0108ba2:	ea a9 8b 10 f0 08 00 	ljmp   $0x8,$0xf0108ba9
	asm volatile("lldt %%ax" :: "a" (0));
f0108ba9:	b8 00 00 00 00       	mov    $0x0,%eax
f0108bae:	0f 00 d0             	lldt   %ax
	// This mapping was only used after paging was turned on but
	// before the segment registers were reloaded.
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
f0108bb1:	c7 45 ec c0 03 00 00 	movl   $0x3c0,-0x14(%ebp)
		int j = 0;
f0108bb8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108bbf:	eb 19                	jmp    f0108bda <turn_on_paging+0x112>
		{
			ptr_page_directory[j] = 0;
f0108bc1:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108bc6:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0108bc9:	c1 e2 02             	shl    $0x2,%edx
f0108bcc:	01 d0                	add    %edx,%eax
f0108bce:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	//2016
	//ptr_page_directory[0] = 0;
	{
		int i = PDX(KERNEL_BASE);
		int j = 0;
		for(; i< PDX((uint32)ptr_free_mem); ++i, ++j)
f0108bd4:	ff 45 ec             	incl   -0x14(%ebp)
f0108bd7:	ff 45 e8             	incl   -0x18(%ebp)
f0108bda:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108bdf:	c1 e8 16             	shr    $0x16,%eax
f0108be2:	89 c2                	mov    %eax,%edx
f0108be4:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108be7:	39 c2                	cmp    %eax,%edx
f0108be9:	77 d6                	ja     f0108bc1 <turn_on_paging+0xf9>
			ptr_page_directory[j] = 0;
		}
	}

	// Flush the TLB for good measure, to kill the ptr_page_directory[0] mapping.
	lcr3(phys_page_directory);
f0108beb:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0108bf0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0108bf3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108bf6:	0f 22 d8             	mov    %eax,%cr3

}
f0108bf9:	90                   	nop
f0108bfa:	c9                   	leave  
f0108bfb:	c3                   	ret    

f0108bfc <setup_listing_to_all_page_tables_entries>:

void setup_listing_to_all_page_tables_entries()
{
f0108bfc:	55                   	push   %ebp
f0108bfd:	89 e5                	mov    %esp,%ebp
f0108bff:	83 ec 18             	sub    $0x18,%esp
	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address VPT.

	// Permissions: kernel RW, user NONE
	uint32 phys_frame_address = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory);
f0108c02:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108c07:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0108c0a:	81 7d f4 ff ff ff ef 	cmpl   $0xefffffff,-0xc(%ebp)
f0108c11:	77 17                	ja     f0108c2a <setup_listing_to_all_page_tables_entries+0x2e>
f0108c13:	ff 75 f4             	pushl  -0xc(%ebp)
f0108c16:	68 5c ee 12 f0       	push   $0xf012ee5c
f0108c1b:	68 cf 01 00 00       	push   $0x1cf
f0108c20:	68 90 ee 12 f0       	push   $0xf012ee90
f0108c25:	e8 85 83 ff ff       	call   f0100faf <_panic>
f0108c2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108c2d:	05 00 00 00 10       	add    $0x10000000,%eax
f0108c32:	89 45 f0             	mov    %eax,-0x10(%ebp)
	ptr_page_directory[PDX(VPT)] = CONSTRUCT_ENTRY(phys_frame_address , PERM_PRESENT | PERM_WRITEABLE);
f0108c35:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108c3a:	05 fc 0e 00 00       	add    $0xefc,%eax
f0108c3f:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0108c42:	83 ca 03             	or     $0x3,%edx
f0108c45:	89 10                	mov    %edx,(%eax)

	// same for UVPT
	//Permissions: kernel R, user R
	ptr_page_directory[PDX(UVPT)] = STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_page_directory)|PERM_USER|PERM_PRESENT;
f0108c47:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108c4c:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f0108c52:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0108c57:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108c5a:	81 7d ec ff ff ff ef 	cmpl   $0xefffffff,-0x14(%ebp)
f0108c61:	77 17                	ja     f0108c7a <setup_listing_to_all_page_tables_entries+0x7e>
f0108c63:	ff 75 ec             	pushl  -0x14(%ebp)
f0108c66:	68 5c ee 12 f0       	push   $0xf012ee5c
f0108c6b:	68 d4 01 00 00       	push   $0x1d4
f0108c70:	68 90 ee 12 f0       	push   $0xf012ee90
f0108c75:	e8 35 83 ff ff       	call   f0100faf <_panic>
f0108c7a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108c7d:	05 00 00 00 10       	add    $0x10000000,%eax
f0108c82:	83 c8 05             	or     $0x5,%eax
f0108c85:	89 02                	mov    %eax,(%edx)

}
f0108c87:	90                   	nop
f0108c88:	c9                   	leave  
f0108c89:	c3                   	ret    

f0108c8a <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f0108c8a:	55                   	push   %ebp
f0108c8b:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f0108c8d:	8b 45 08             	mov    0x8(%ebp),%eax
f0108c90:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0108c96:	29 d0                	sub    %edx,%eax
f0108c98:	c1 f8 02             	sar    $0x2,%eax
f0108c9b:	89 c2                	mov    %eax,%edx
f0108c9d:	89 d0                	mov    %edx,%eax
f0108c9f:	c1 e0 02             	shl    $0x2,%eax
f0108ca2:	01 d0                	add    %edx,%eax
f0108ca4:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0108cab:	01 c8                	add    %ecx,%eax
f0108cad:	01 c0                	add    %eax,%eax
f0108caf:	01 d0                	add    %edx,%eax
f0108cb1:	89 c1                	mov    %eax,%ecx
f0108cb3:	c1 e1 08             	shl    $0x8,%ecx
f0108cb6:	01 c8                	add    %ecx,%eax
f0108cb8:	89 c1                	mov    %eax,%ecx
f0108cba:	c1 e1 10             	shl    $0x10,%ecx
f0108cbd:	01 c8                	add    %ecx,%eax
f0108cbf:	c1 e0 02             	shl    $0x2,%eax
f0108cc2:	01 d0                	add    %edx,%eax
}
f0108cc4:	5d                   	pop    %ebp
f0108cc5:	c3                   	ret    

f0108cc6 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0108cc6:	55                   	push   %ebp
f0108cc7:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0108cc9:	ff 75 08             	pushl  0x8(%ebp)
f0108ccc:	e8 b9 ff ff ff       	call   f0108c8a <to_frame_number>
f0108cd1:	83 c4 04             	add    $0x4,%esp
f0108cd4:	c1 e0 0c             	shl    $0xc,%eax
}
f0108cd7:	c9                   	leave  
f0108cd8:	c3                   	ret    

f0108cd9 <to_frame_info>:

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0108cd9:	55                   	push   %ebp
f0108cda:	89 e5                	mov    %esp,%ebp
f0108cdc:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0108cdf:	8b 45 08             	mov    0x8(%ebp),%eax
f0108ce2:	c1 e8 0c             	shr    $0xc,%eax
f0108ce5:	89 c2                	mov    %eax,%edx
f0108ce7:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0108cec:	39 c2                	cmp    %eax,%edx
f0108cee:	72 14                	jb     f0108d04 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0108cf0:	83 ec 04             	sub    $0x4,%esp
f0108cf3:	68 48 ef 12 f0       	push   $0xf012ef48
f0108cf8:	6a 4e                	push   $0x4e
f0108cfa:	68 6d ef 12 f0       	push   $0xf012ef6d
f0108cff:	e8 ab 82 ff ff       	call   f0100faf <_panic>
	return &frames_info[PPN(physical_address)];
f0108d04:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0108d0a:	8b 45 08             	mov    0x8(%ebp),%eax
f0108d0d:	c1 e8 0c             	shr    $0xc,%eax
f0108d10:	89 c1                	mov    %eax,%ecx
f0108d12:	89 c8                	mov    %ecx,%eax
f0108d14:	c1 e0 02             	shl    $0x2,%eax
f0108d17:	01 c8                	add    %ecx,%eax
f0108d19:	c1 e0 02             	shl    $0x2,%eax
f0108d1c:	01 d0                	add    %edx,%eax
}
f0108d1e:	c9                   	leave  
f0108d1f:	c3                   	ret    

f0108d20 <tlb_invalidate>:




void tlb_invalidate(uint32 *ptr_page_directory, void *virtual_address)
{
f0108d20:	55                   	push   %ebp
f0108d21:	89 e5                	mov    %esp,%ebp
f0108d23:	83 ec 18             	sub    $0x18,%esp
	// Flush the entry only if we're modifying the current address space.
	/*2025*/ //check is added
	struct Env* e = get_cpu_proc();
f0108d26:	e8 ed 2d 00 00       	call   f010bb18 <get_cpu_proc>
f0108d2b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!e || e->env_page_directory == ptr_page_directory)
f0108d2e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0108d32:	74 0b                	je     f0108d3f <tlb_invalidate+0x1f>
f0108d34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108d37:	8b 40 64             	mov    0x64(%eax),%eax
f0108d3a:	3b 45 08             	cmp    0x8(%ebp),%eax
f0108d3d:	75 0c                	jne    f0108d4b <tlb_invalidate+0x2b>
f0108d3f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0108d42:	89 45 f0             	mov    %eax,-0x10(%ebp)
}

static __inline void
invlpg(void *addr)
{
	__asm __volatile("invlpg (%0)" : : "r" (addr) : "memory");
f0108d45:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108d48:	0f 01 38             	invlpg (%eax)
		invlpg(virtual_address);
}
f0108d4b:	90                   	nop
f0108d4c:	c9                   	leave  
f0108d4d:	c3                   	ret    

f0108d4e <initialize_paging>:
// and NEVER use boot_allocate_space() or the related boot-time functions above.
//

extern void initialize_disk_page_file();
void initialize_paging()
{
f0108d4e:	55                   	push   %ebp
f0108d4f:	89 e5                	mov    %esp,%ebp
f0108d51:	53                   	push   %ebx
f0108d52:	83 ec 24             	sub    $0x24,%esp
	//     Some of it is in use, some is free. Where is the kernel?
	//     Which frames are used for page tables and other data structures?
	//
	// Change the code to reflect this.
	int i;
	LIST_INIT(&MemFrameLists.free_frame_list);
f0108d55:	c7 05 c0 e7 83 f0 00 	movl   $0x0,0xf083e7c0
f0108d5c:	00 00 00 
f0108d5f:	c7 05 c4 e7 83 f0 00 	movl   $0x0,0xf083e7c4
f0108d66:	00 00 00 
f0108d69:	c7 05 cc e7 83 f0 00 	movl   $0x0,0xf083e7cc
f0108d70:	00 00 00 
	LIST_INIT(&MemFrameLists.modified_frame_list);
f0108d73:	c7 05 d0 e7 83 f0 00 	movl   $0x0,0xf083e7d0
f0108d7a:	00 00 00 
f0108d7d:	c7 05 d4 e7 83 f0 00 	movl   $0x0,0xf083e7d4
f0108d84:	00 00 00 
f0108d87:	c7 05 dc e7 83 f0 00 	movl   $0x0,0xf083e7dc
f0108d8e:	00 00 00 

	//Initialize the corresponding lock
	init_kspinlock(&MemFrameLists.mfllock, "Frame Info Lock");
f0108d91:	83 ec 08             	sub    $0x8,%esp
f0108d94:	68 87 ef 12 f0       	push   $0xf012ef87
f0108d99:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0108d9e:	e8 a7 70 00 00       	call   f010fe4a <init_kspinlock>
f0108da3:	83 c4 10             	add    $0x10,%esp

	frames_info[0].references = 1;
f0108da6:	a1 08 6b 85 f0       	mov    0xf0856b08,%eax
f0108dab:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[1].references = 1;
f0108db1:	a1 08 6b 85 f0       	mov    0xf0856b08,%eax
f0108db6:	83 c0 14             	add    $0x14,%eax
f0108db9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	frames_info[2].references = 1;
f0108dbf:	a1 08 6b 85 f0       	mov    0xf0856b08,%eax
f0108dc4:	83 c0 28             	add    $0x28,%eax
f0108dc7:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
f0108dcd:	c7 05 18 6b 85 f0 00 	movl   $0xf0001000,0xf0856b18
f0108dd4:	10 00 f0 
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
f0108dd7:	c7 05 64 6d 85 f0 00 	movl   $0xf0002000,0xf0856d64
f0108dde:	20 00 f0 
	i =0;
f0108de1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<1024; i++)
f0108de8:	eb 1f                	jmp    f0108e09 <initialize_paging+0xbb>
	{
		ptr_zero_page[i]=0;
f0108dea:	8b 15 18 6b 85 f0    	mov    0xf0856b18,%edx
f0108df0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108df3:	01 d0                	add    %edx,%eax
f0108df5:	c6 00 00             	movb   $0x0,(%eax)
		ptr_temp_page[i]=0;
f0108df8:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f0108dfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0108e01:	01 d0                	add    %edx,%eax
f0108e03:	c6 00 00             	movb   $0x0,(%eax)
	frames_info[1].references = 1;
	frames_info[2].references = 1;
	ptr_zero_page = (uint8*) KERNEL_BASE+PAGE_SIZE;
	ptr_temp_page = (uint8*) KERNEL_BASE+2*PAGE_SIZE;
	i =0;
	for(;i<1024; i++)
f0108e06:	ff 45 f4             	incl   -0xc(%ebp)
f0108e09:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f0108e10:	7e d8                	jle    f0108dea <initialize_paging+0x9c>
	{
		ptr_zero_page[i]=0;
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);
f0108e12:	c7 45 f0 00 10 00 00 	movl   $0x1000,-0x10(%ebp)
f0108e19:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0108e1c:	05 ff ff 09 00       	add    $0x9ffff,%eax
f0108e21:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0108e24:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e27:	ba 00 00 00 00       	mov    $0x0,%edx
f0108e2c:	f7 75 f0             	divl   -0x10(%ebp)
f0108e2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0108e32:	29 d0                	sub    %edx,%eax
f0108e34:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108e37:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0108e3e:	e9 ef 00 00 00       	jmp    f0108f32 <initialize_paging+0x1e4>
	{

		initialize_frame_info(&(frames_info[i]));
f0108e43:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108e49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e4c:	89 d0                	mov    %edx,%eax
f0108e4e:	c1 e0 02             	shl    $0x2,%eax
f0108e51:	01 d0                	add    %edx,%eax
f0108e53:	c1 e0 02             	shl    $0x2,%eax
f0108e56:	01 c8                	add    %ecx,%eax
f0108e58:	83 ec 0c             	sub    $0xc,%esp
f0108e5b:	50                   	push   %eax
f0108e5c:	e8 c6 02 00 00       	call   f0109127 <initialize_frame_info>
f0108e61:	83 c4 10             	add    $0x10,%esp
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f0108e64:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108e6a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e6d:	89 d0                	mov    %edx,%eax
f0108e6f:	c1 e0 02             	shl    $0x2,%eax
f0108e72:	01 d0                	add    %edx,%eax
f0108e74:	c1 e0 02             	shl    $0x2,%eax
f0108e77:	01 c8                	add    %ecx,%eax
f0108e79:	85 c0                	test   %eax,%eax
f0108e7b:	75 14                	jne    f0108e91 <initialize_paging+0x143>
f0108e7d:	83 ec 04             	sub    $0x4,%esp
f0108e80:	68 98 ef 12 f0       	push   $0xf012ef98
f0108e85:	6a 62                	push   $0x62
f0108e87:	68 bb ef 12 f0       	push   $0xf012efbb
f0108e8c:	e8 1e 81 ff ff       	call   f0100faf <_panic>
f0108e91:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108e97:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108e9a:	89 d0                	mov    %edx,%eax
f0108e9c:	c1 e0 02             	shl    $0x2,%eax
f0108e9f:	01 d0                	add    %edx,%eax
f0108ea1:	c1 e0 02             	shl    $0x2,%eax
f0108ea4:	01 c8                	add    %ecx,%eax
f0108ea6:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0108eac:	89 10                	mov    %edx,(%eax)
f0108eae:	8b 00                	mov    (%eax),%eax
f0108eb0:	85 c0                	test   %eax,%eax
f0108eb2:	74 20                	je     f0108ed4 <initialize_paging+0x186>
f0108eb4:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0108eba:	8b 1d 08 6b 85 f0    	mov    0xf0856b08,%ebx
f0108ec0:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0108ec3:	89 c8                	mov    %ecx,%eax
f0108ec5:	c1 e0 02             	shl    $0x2,%eax
f0108ec8:	01 c8                	add    %ecx,%eax
f0108eca:	c1 e0 02             	shl    $0x2,%eax
f0108ecd:	01 d8                	add    %ebx,%eax
f0108ecf:	89 42 04             	mov    %eax,0x4(%edx)
f0108ed2:	eb 1a                	jmp    f0108eee <initialize_paging+0x1a0>
f0108ed4:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108eda:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108edd:	89 d0                	mov    %edx,%eax
f0108edf:	c1 e0 02             	shl    $0x2,%eax
f0108ee2:	01 d0                	add    %edx,%eax
f0108ee4:	c1 e0 02             	shl    $0x2,%eax
f0108ee7:	01 c8                	add    %ecx,%eax
f0108ee9:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f0108eee:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108ef4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108ef7:	89 d0                	mov    %edx,%eax
f0108ef9:	c1 e0 02             	shl    $0x2,%eax
f0108efc:	01 d0                	add    %edx,%eax
f0108efe:	c1 e0 02             	shl    $0x2,%eax
f0108f01:	01 c8                	add    %ecx,%eax
f0108f03:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f0108f08:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108f0e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f11:	89 d0                	mov    %edx,%eax
f0108f13:	c1 e0 02             	shl    $0x2,%eax
f0108f16:	01 d0                	add    %edx,%eax
f0108f18:	c1 e0 02             	shl    $0x2,%eax
f0108f1b:	01 c8                	add    %ecx,%eax
f0108f1d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0108f24:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0108f29:	40                   	inc    %eax
f0108f2a:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
		ptr_temp_page[i]=0;
	}

	int range_end = ROUNDUP(PHYS_IO_MEM,PAGE_SIZE);

	for (i = 3; i < range_end/PAGE_SIZE; i++)
f0108f2f:	ff 45 f4             	incl   -0xc(%ebp)
f0108f32:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108f35:	85 c0                	test   %eax,%eax
f0108f37:	79 05                	jns    f0108f3e <initialize_paging+0x1f0>
f0108f39:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108f3e:	c1 f8 0c             	sar    $0xc,%eax
f0108f41:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0108f44:	0f 8f f9 fe ff ff    	jg     f0108e43 <initialize_paging+0xf5>
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108f4a:	c7 45 f4 a0 00 00 00 	movl   $0xa0,-0xc(%ebp)
f0108f51:	eb 1e                	jmp    f0108f71 <initialize_paging+0x223>
	{
		frames_info[i].references = 1;
f0108f53:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108f59:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108f5c:	89 d0                	mov    %edx,%eax
f0108f5e:	c1 e0 02             	shl    $0x2,%eax
f0108f61:	01 d0                	add    %edx,%eax
f0108f63:	c1 e0 02             	shl    $0x2,%eax
f0108f66:	01 c8                	add    %ecx,%eax
f0108f68:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		//frames_info[i].references = 0;

		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	for (i = PHYS_IO_MEM/PAGE_SIZE ; i < PHYS_EXTENDED_MEM/PAGE_SIZE; i++)
f0108f6e:	ff 45 f4             	incl   -0xc(%ebp)
f0108f71:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
f0108f78:	7e d9                	jle    f0108f53 <initialize_paging+0x205>
	{
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);
f0108f7a:	c7 45 e4 00 10 00 00 	movl   $0x1000,-0x1c(%ebp)
f0108f81:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f0108f86:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0108f89:	81 7d e0 ff ff ff ef 	cmpl   $0xefffffff,-0x20(%ebp)
f0108f90:	77 14                	ja     f0108fa6 <initialize_paging+0x258>
f0108f92:	ff 75 e0             	pushl  -0x20(%ebp)
f0108f95:	68 d8 ef 12 f0       	push   $0xf012efd8
f0108f9a:	6a 6a                	push   $0x6a
f0108f9c:	68 bb ef 12 f0       	push   $0xf012efbb
f0108fa1:	e8 09 80 ff ff       	call   f0100faf <_panic>
f0108fa6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0108fa9:	8d 90 00 00 00 10    	lea    0x10000000(%eax),%edx
f0108faf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0108fb2:	01 d0                	add    %edx,%eax
f0108fb4:	48                   	dec    %eax
f0108fb5:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0108fb8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108fbb:	ba 00 00 00 00       	mov    $0x0,%edx
f0108fc0:	f7 75 e4             	divl   -0x1c(%ebp)
f0108fc3:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0108fc6:	29 d0                	sub    %edx,%eax
f0108fc8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108fcb:	c7 45 f4 00 01 00 00 	movl   $0x100,-0xc(%ebp)
f0108fd2:	eb 1e                	jmp    f0108ff2 <initialize_paging+0x2a4>
	{
		frames_info[i].references = 1;
f0108fd4:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0108fda:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0108fdd:	89 d0                	mov    %edx,%eax
f0108fdf:	c1 e0 02             	shl    $0x2,%eax
f0108fe2:	01 d0                	add    %edx,%eax
f0108fe4:	c1 e0 02             	shl    $0x2,%eax
f0108fe7:	01 c8                	add    %ecx,%eax
f0108fe9:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
		frames_info[i].references = 1;
	}

	range_end = ROUNDUP(STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_free_mem), PAGE_SIZE);

	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
f0108fef:	ff 45 f4             	incl   -0xc(%ebp)
f0108ff2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0108ff5:	85 c0                	test   %eax,%eax
f0108ff7:	79 05                	jns    f0108ffe <initialize_paging+0x2b0>
f0108ff9:	05 ff 0f 00 00       	add    $0xfff,%eax
f0108ffe:	c1 f8 0c             	sar    $0xc,%eax
f0109001:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0109004:	7f ce                	jg     f0108fd4 <initialize_paging+0x286>
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0109006:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109009:	85 c0                	test   %eax,%eax
f010900b:	79 05                	jns    f0109012 <initialize_paging+0x2c4>
f010900d:	05 ff 0f 00 00       	add    $0xfff,%eax
f0109012:	c1 f8 0c             	sar    $0xc,%eax
f0109015:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109018:	e9 ef 00 00 00       	jmp    f010910c <initialize_paging+0x3be>
	{
		initialize_frame_info(&(frames_info[i]));
f010901d:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0109023:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109026:	89 d0                	mov    %edx,%eax
f0109028:	c1 e0 02             	shl    $0x2,%eax
f010902b:	01 d0                	add    %edx,%eax
f010902d:	c1 e0 02             	shl    $0x2,%eax
f0109030:	01 c8                	add    %ecx,%eax
f0109032:	83 ec 0c             	sub    $0xc,%esp
f0109035:	50                   	push   %eax
f0109036:	e8 ec 00 00 00       	call   f0109127 <initialize_frame_info>
f010903b:	83 c4 10             	add    $0x10,%esp

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
f010903e:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0109044:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109047:	89 d0                	mov    %edx,%eax
f0109049:	c1 e0 02             	shl    $0x2,%eax
f010904c:	01 d0                	add    %edx,%eax
f010904e:	c1 e0 02             	shl    $0x2,%eax
f0109051:	01 c8                	add    %ecx,%eax
f0109053:	85 c0                	test   %eax,%eax
f0109055:	75 14                	jne    f010906b <initialize_paging+0x31d>
f0109057:	83 ec 04             	sub    $0x4,%esp
f010905a:	68 98 ef 12 f0       	push   $0xf012ef98
f010905f:	6a 76                	push   $0x76
f0109061:	68 bb ef 12 f0       	push   $0xf012efbb
f0109066:	e8 44 7f ff ff       	call   f0100faf <_panic>
f010906b:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f0109071:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109074:	89 d0                	mov    %edx,%eax
f0109076:	c1 e0 02             	shl    $0x2,%eax
f0109079:	01 d0                	add    %edx,%eax
f010907b:	c1 e0 02             	shl    $0x2,%eax
f010907e:	01 c8                	add    %ecx,%eax
f0109080:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0109086:	89 10                	mov    %edx,(%eax)
f0109088:	8b 00                	mov    (%eax),%eax
f010908a:	85 c0                	test   %eax,%eax
f010908c:	74 20                	je     f01090ae <initialize_paging+0x360>
f010908e:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0109094:	8b 1d 08 6b 85 f0    	mov    0xf0856b08,%ebx
f010909a:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010909d:	89 c8                	mov    %ecx,%eax
f010909f:	c1 e0 02             	shl    $0x2,%eax
f01090a2:	01 c8                	add    %ecx,%eax
f01090a4:	c1 e0 02             	shl    $0x2,%eax
f01090a7:	01 d8                	add    %ebx,%eax
f01090a9:	89 42 04             	mov    %eax,0x4(%edx)
f01090ac:	eb 1a                	jmp    f01090c8 <initialize_paging+0x37a>
f01090ae:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f01090b4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01090b7:	89 d0                	mov    %edx,%eax
f01090b9:	c1 e0 02             	shl    $0x2,%eax
f01090bc:	01 d0                	add    %edx,%eax
f01090be:	c1 e0 02             	shl    $0x2,%eax
f01090c1:	01 c8                	add    %ecx,%eax
f01090c3:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f01090c8:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f01090ce:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01090d1:	89 d0                	mov    %edx,%eax
f01090d3:	c1 e0 02             	shl    $0x2,%eax
f01090d6:	01 d0                	add    %edx,%eax
f01090d8:	c1 e0 02             	shl    $0x2,%eax
f01090db:	01 c8                	add    %ecx,%eax
f01090dd:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f01090e2:	8b 0d 08 6b 85 f0    	mov    0xf0856b08,%ecx
f01090e8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01090eb:	89 d0                	mov    %edx,%eax
f01090ed:	c1 e0 02             	shl    $0x2,%eax
f01090f0:	01 d0                	add    %edx,%eax
f01090f2:	c1 e0 02             	shl    $0x2,%eax
f01090f5:	01 c8                	add    %ecx,%eax
f01090f7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01090fe:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0109103:	40                   	inc    %eax
f0109104:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
	for (i = PHYS_EXTENDED_MEM/PAGE_SIZE ; i < range_end/PAGE_SIZE; i++)
	{
		frames_info[i].references = 1;
	}

	for (i = range_end/PAGE_SIZE ; i < number_of_frames; i++)
f0109109:	ff 45 f4             	incl   -0xc(%ebp)
f010910c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010910f:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109114:	39 c2                	cmp    %eax,%edx
f0109116:	0f 82 01 ff ff ff    	jb     f010901d <initialize_paging+0x2cf>

		//frames_info[i].references = 0;
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, &frames_info[i]);
	}

	initialize_disk_page_file();
f010911c:	e8 13 bc ff ff       	call   f0104d34 <initialize_disk_page_file>
}
f0109121:	90                   	nop
f0109122:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0109125:	c9                   	leave  
f0109126:	c3                   	ret    

f0109127 <initialize_frame_info>:
// Initialize a Frame_Info structure.
// The result has null links and 0 references.
// Note that the corresponding physical frame is NOT initialized!
//
void initialize_frame_info(struct FrameInfo *ptr_frame_info)
{
f0109127:	55                   	push   %ebp
f0109128:	89 e5                	mov    %esp,%ebp
f010912a:	83 ec 08             	sub    $0x8,%esp
	memset(ptr_frame_info, 0, sizeof(*ptr_frame_info));
f010912d:	83 ec 04             	sub    $0x4,%esp
f0109130:	6a 14                	push   $0x14
f0109132:	6a 00                	push   $0x0
f0109134:	ff 75 08             	pushl  0x8(%ebp)
f0109137:	e8 2d 1c 01 00       	call   f011ad69 <memset>
f010913c:	83 c4 10             	add    $0x10,%esp
}
f010913f:	90                   	nop
f0109140:	c9                   	leave  
f0109141:	c3                   	ret    

f0109142 <allocate_frame>:
//   If failed, it panic.
//
// Hint: use LIST_FIRST, LIST_REMOVE, and initialize_frame_info
// Hint: references should not be incremented
int allocate_frame(struct FrameInfo **ptr_frame_info)
{
f0109142:	55                   	push   %ebp
f0109143:	89 e5                	mov    %esp,%ebp
f0109145:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109148:	83 ec 0c             	sub    $0xc,%esp
f010914b:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109150:	e8 7b 6f 00 00       	call   f01100d0 <holding_kspinlock>
f0109155:	83 c4 10             	add    $0x10,%esp
f0109158:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f010915b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010915f:	75 10                	jne    f0109171 <allocate_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109161:	83 ec 0c             	sub    $0xc,%esp
f0109164:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109169:	e8 0d 6d 00 00       	call   f010fe7b <acquire_kspinlock>
f010916e:	83 c4 10             	add    $0x10,%esp
	}

	*ptr_frame_info = LIST_FIRST(&MemFrameLists.free_frame_list);
f0109171:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f0109177:	8b 45 08             	mov    0x8(%ebp),%eax
f010917a:	89 10                	mov    %edx,(%eax)
	int c = 0;
f010917c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

	if (*ptr_frame_info == NULL)
f0109183:	8b 45 08             	mov    0x8(%ebp),%eax
f0109186:	8b 00                	mov    (%eax),%eax
f0109188:	85 c0                	test   %eax,%eax
f010918a:	75 17                	jne    f01091a3 <allocate_frame+0x61>
	{
		panic("ERROR: Kernel run out of memory... allocate_frame cannot find a free frame.\n");
f010918c:	83 ec 04             	sub    $0x4,%esp
f010918f:	68 0c f0 12 f0       	push   $0xf012f00c
f0109194:	68 a2 00 00 00       	push   $0xa2
f0109199:	68 bb ef 12 f0       	push   $0xf012efbb
f010919e:	e8 0c 7e ff ff       	call   f0100faf <_panic>
	}

	LIST_REMOVE(&MemFrameLists.free_frame_list,*ptr_frame_info);
f01091a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01091a6:	8b 00                	mov    (%eax),%eax
f01091a8:	85 c0                	test   %eax,%eax
f01091aa:	75 17                	jne    f01091c3 <allocate_frame+0x81>
f01091ac:	83 ec 04             	sub    $0x4,%esp
f01091af:	68 59 f0 12 f0       	push   $0xf012f059
f01091b4:	68 a5 00 00 00       	push   $0xa5
f01091b9:	68 bb ef 12 f0       	push   $0xf012efbb
f01091be:	e8 ec 7d ff ff       	call   f0100faf <_panic>
f01091c3:	8b 45 08             	mov    0x8(%ebp),%eax
f01091c6:	8b 00                	mov    (%eax),%eax
f01091c8:	8b 00                	mov    (%eax),%eax
f01091ca:	85 c0                	test   %eax,%eax
f01091cc:	74 14                	je     f01091e2 <allocate_frame+0xa0>
f01091ce:	8b 45 08             	mov    0x8(%ebp),%eax
f01091d1:	8b 00                	mov    (%eax),%eax
f01091d3:	8b 00                	mov    (%eax),%eax
f01091d5:	8b 55 08             	mov    0x8(%ebp),%edx
f01091d8:	8b 12                	mov    (%edx),%edx
f01091da:	8b 52 04             	mov    0x4(%edx),%edx
f01091dd:	89 50 04             	mov    %edx,0x4(%eax)
f01091e0:	eb 0d                	jmp    f01091ef <allocate_frame+0xad>
f01091e2:	8b 45 08             	mov    0x8(%ebp),%eax
f01091e5:	8b 00                	mov    (%eax),%eax
f01091e7:	8b 40 04             	mov    0x4(%eax),%eax
f01091ea:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f01091ef:	8b 45 08             	mov    0x8(%ebp),%eax
f01091f2:	8b 00                	mov    (%eax),%eax
f01091f4:	8b 40 04             	mov    0x4(%eax),%eax
f01091f7:	85 c0                	test   %eax,%eax
f01091f9:	74 13                	je     f010920e <allocate_frame+0xcc>
f01091fb:	8b 45 08             	mov    0x8(%ebp),%eax
f01091fe:	8b 00                	mov    (%eax),%eax
f0109200:	8b 40 04             	mov    0x4(%eax),%eax
f0109203:	8b 55 08             	mov    0x8(%ebp),%edx
f0109206:	8b 12                	mov    (%edx),%edx
f0109208:	8b 12                	mov    (%edx),%edx
f010920a:	89 10                	mov    %edx,(%eax)
f010920c:	eb 0c                	jmp    f010921a <allocate_frame+0xd8>
f010920e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109211:	8b 00                	mov    (%eax),%eax
f0109213:	8b 00                	mov    (%eax),%eax
f0109215:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f010921a:	8b 45 08             	mov    0x8(%ebp),%eax
f010921d:	8b 00                	mov    (%eax),%eax
f010921f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f0109225:	8b 45 08             	mov    0x8(%ebp),%eax
f0109228:	8b 00                	mov    (%eax),%eax
f010922a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f0109231:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0109236:	48                   	dec    %eax
f0109237:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
	}

	/**********************************************************
	 ***********************************************************/

	initialize_frame_info(*ptr_frame_info);
f010923c:	8b 45 08             	mov    0x8(%ebp),%eax
f010923f:	8b 00                	mov    (%eax),%eax
f0109241:	83 ec 0c             	sub    $0xc,%esp
f0109244:	50                   	push   %eax
f0109245:	e8 dd fe ff ff       	call   f0109127 <initialize_frame_info>
f010924a:	83 c4 10             	add    $0x10,%esp

	if (!lock_already_held)
f010924d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109251:	75 10                	jne    f0109263 <allocate_frame+0x121>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109253:	83 ec 0c             	sub    $0xc,%esp
f0109256:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010925b:	e8 c0 6c 00 00       	call   f010ff20 <release_kspinlock>
f0109260:	83 c4 10             	add    $0x10,%esp
	}

	return 0;
f0109263:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109268:	c9                   	leave  
f0109269:	c3                   	ret    

f010926a <free_frame>:
//
// Return a frame to the free_frame_list.
// (This function should only be called when ptr_frame_info->references reaches 0.)
//
void free_frame(struct FrameInfo *ptr_frame_info)
{
f010926a:	55                   	push   %ebp
f010926b:	89 e5                	mov    %esp,%ebp
f010926d:	83 ec 18             	sub    $0x18,%esp
	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f0109270:	83 ec 0c             	sub    $0xc,%esp
f0109273:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109278:	e8 53 6e 00 00       	call   f01100d0 <holding_kspinlock>
f010927d:	83 c4 10             	add    $0x10,%esp
f0109280:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if (!lock_already_held)
f0109283:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109287:	75 10                	jne    f0109299 <free_frame+0x2f>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109289:	83 ec 0c             	sub    $0xc,%esp
f010928c:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109291:	e8 e5 6b 00 00       	call   f010fe7b <acquire_kspinlock>
f0109296:	83 c4 10             	add    $0x10,%esp
	}
	{
		/*2012: clear it to ensure that its members (env, isBuffered, ...) become NULL*/
		initialize_frame_info(ptr_frame_info);
f0109299:	83 ec 0c             	sub    $0xc,%esp
f010929c:	ff 75 08             	pushl  0x8(%ebp)
f010929f:	e8 83 fe ff ff       	call   f0109127 <initialize_frame_info>
f01092a4:	83 c4 10             	add    $0x10,%esp
		/*=============================================================================*/
		// Fill this function in
		LIST_INSERT_HEAD(&MemFrameLists.free_frame_list, ptr_frame_info);
f01092a7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01092ab:	75 17                	jne    f01092c4 <free_frame+0x5a>
f01092ad:	83 ec 04             	sub    $0x4,%esp
f01092b0:	68 98 ef 12 f0       	push   $0xf012ef98
f01092b5:	68 ce 00 00 00       	push   $0xce
f01092ba:	68 bb ef 12 f0       	push   $0xf012efbb
f01092bf:	e8 eb 7c ff ff       	call   f0100faf <_panic>
f01092c4:	8b 15 c0 e7 83 f0    	mov    0xf083e7c0,%edx
f01092ca:	8b 45 08             	mov    0x8(%ebp),%eax
f01092cd:	89 10                	mov    %edx,(%eax)
f01092cf:	8b 45 08             	mov    0x8(%ebp),%eax
f01092d2:	8b 00                	mov    (%eax),%eax
f01092d4:	85 c0                	test   %eax,%eax
f01092d6:	74 0d                	je     f01092e5 <free_frame+0x7b>
f01092d8:	a1 c0 e7 83 f0       	mov    0xf083e7c0,%eax
f01092dd:	8b 55 08             	mov    0x8(%ebp),%edx
f01092e0:	89 50 04             	mov    %edx,0x4(%eax)
f01092e3:	eb 08                	jmp    f01092ed <free_frame+0x83>
f01092e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01092e8:	a3 c4 e7 83 f0       	mov    %eax,0xf083e7c4
f01092ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01092f0:	a3 c0 e7 83 f0       	mov    %eax,0xf083e7c0
f01092f5:	8b 45 08             	mov    0x8(%ebp),%eax
f01092f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f01092ff:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0109304:	40                   	inc    %eax
f0109305:	a3 cc e7 83 f0       	mov    %eax,0xf083e7cc
		//LOG_STATMENT(cprintf("FN # %d FREED",to_frame_number(ptr_frame_info)));
	}
	if (!lock_already_held)
f010930a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010930e:	75 10                	jne    f0109320 <free_frame+0xb6>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109310:	83 ec 0c             	sub    $0xc,%esp
f0109313:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109318:	e8 03 6c 00 00       	call   f010ff20 <release_kspinlock>
f010931d:	83 c4 10             	add    $0x10,%esp
	}
}
f0109320:	90                   	nop
f0109321:	c9                   	leave  
f0109322:	c3                   	ret    

f0109323 <decrement_references>:
//
// Decrement the reference count on a frame
// freeing it if there are no more references.
//
void decrement_references(struct FrameInfo* ptr_frame_info)
{
f0109323:	55                   	push   %ebp
f0109324:	89 e5                	mov    %esp,%ebp
f0109326:	83 ec 08             	sub    $0x8,%esp
	if (--(ptr_frame_info->references) == 0)
f0109329:	8b 45 08             	mov    0x8(%ebp),%eax
f010932c:	8b 40 08             	mov    0x8(%eax),%eax
f010932f:	48                   	dec    %eax
f0109330:	8b 55 08             	mov    0x8(%ebp),%edx
f0109333:	66 89 42 08          	mov    %ax,0x8(%edx)
f0109337:	8b 45 08             	mov    0x8(%ebp),%eax
f010933a:	8b 40 08             	mov    0x8(%eax),%eax
f010933d:	66 85 c0             	test   %ax,%ax
f0109340:	75 0e                	jne    f0109350 <decrement_references+0x2d>
		free_frame(ptr_frame_info);
f0109342:	83 ec 0c             	sub    $0xc,%esp
f0109345:	ff 75 08             	pushl  0x8(%ebp)
f0109348:	e8 1d ff ff ff       	call   f010926a <free_frame>
f010934d:	83 c4 10             	add    $0x10,%esp
}
f0109350:	90                   	nop
f0109351:	c9                   	leave  
f0109352:	c3                   	ret    

f0109353 <get_page_table>:
//  TABLE_IN_MEMORY : if page table exists in main memory
//	TABLE_NOT_EXIST : if page table doesn't exist,
//

int get_page_table(uint32 *ptr_page_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109353:	55                   	push   %ebp
f0109354:	89 e5                	mov    %esp,%ebp
f0109356:	83 ec 28             	sub    $0x28,%esp
	//	cprintf("gpt .05\n");
	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109359:	8b 45 0c             	mov    0xc(%ebp),%eax
f010935c:	c1 e8 16             	shr    $0x16,%eax
f010935f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109366:	8b 45 08             	mov    0x8(%ebp),%eax
f0109369:	01 d0                	add    %edx,%eax
f010936b:	8b 00                	mov    (%eax),%eax
f010936d:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//2022: check PERM_PRESENT of the table first before calculating its PA
	if ( (page_directory_entry & PERM_PRESENT) == PERM_PRESENT)
f0109370:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109373:	83 e0 01             	and    $0x1,%eax
f0109376:	85 c0                	test   %eax,%eax
f0109378:	74 74                	je     f01093ee <get_page_table+0x9b>
	{
		//	cprintf("gpt .07, page_directory_entry= %x \n",page_directory_entry);
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010937a:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109381:	77 1d                	ja     f01093a0 <get_page_table+0x4d>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109383:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109386:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010938b:	83 ec 0c             	sub    $0xc,%esp
f010938e:	50                   	push   %eax
f010938f:	e8 d6 08 00 00       	call   f0109c6a <kheap_virtual_address>
f0109394:	83 c4 10             	add    $0x10,%esp
f0109397:	89 c2                	mov    %eax,%edx
f0109399:	8b 45 10             	mov    0x10(%ebp),%eax
f010939c:	89 10                	mov    %edx,(%eax)
f010939e:	eb 44                	jmp    f01093e4 <get_page_table+0x91>
			//cprintf("===>get_page_table: page_dir_entry = %x ptr_page_table = %x\n", page_directory_entry,*ptr_page_table);
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f01093a0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01093a3:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01093a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01093ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093ae:	c1 e8 0c             	shr    $0xc,%eax
f01093b1:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01093b4:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f01093b9:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f01093bc:	72 17                	jb     f01093d5 <get_page_table+0x82>
f01093be:	ff 75 f0             	pushl  -0x10(%ebp)
f01093c1:	68 78 f0 12 f0       	push   $0xf012f078
f01093c6:	68 fa 00 00 00       	push   $0xfa
f01093cb:	68 bb ef 12 f0       	push   $0xf012efbb
f01093d0:	e8 da 7b ff ff       	call   f0100faf <_panic>
f01093d5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01093d8:	2d 00 00 00 10       	sub    $0x10000000,%eax
f01093dd:	89 c2                	mov    %eax,%edx
f01093df:	8b 45 10             	mov    0x10(%ebp),%eax
f01093e2:	89 10                	mov    %edx,(%eax)
		}
		return TABLE_IN_MEMORY;
f01093e4:	b8 00 00 00 00       	mov    $0x0,%eax
f01093e9:	e9 b9 00 00 00       	jmp    f01094a7 <get_page_table+0x154>
	}
	else if (page_directory_entry != 0) //the table exists but not in main mem, so it must be in sec mem
f01093ee:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01093f2:	0f 84 a1 00 00 00    	je     f0109499 <get_page_table+0x146>
f01093f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01093fb:	89 45 e0             	mov    %eax,-0x20(%ebp)

//Ahmed 2010:
static __inline void
lcr2(uint32 val)
{
	__asm __volatile("movl %0,%%cr2" : : "r" (val));
f01093fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109401:	0f 22 d0             	mov    %eax,%cr2
		// Call the fault_handler() to load the table in memory for us ...
		//		cprintf("gpt .1\n, %x page_directory_entry\n", page_directory_entry);
		lcr2((uint32)virtual_address) ;

		//		cprintf("gpt .12\n");
		fault_handler(NULL);
f0109404:	83 ec 0c             	sub    $0xc,%esp
f0109407:	6a 00                	push   $0x0
f0109409:	e8 41 66 00 00       	call   f010fa4f <fault_handler>
f010940e:	83 c4 10             	add    $0x10,%esp

		//		cprintf("gpt .15\n");
		// now the page_fault_handler() should have returned successfully and updated the
		// directory with the new table frame number in memory
		page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109411:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109414:	c1 e8 16             	shr    $0x16,%eax
f0109417:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f010941e:	8b 45 08             	mov    0x8(%ebp),%eax
f0109421:	01 d0                	add    %edx,%eax
f0109423:	8b 00                	mov    (%eax),%eax
f0109425:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f0109428:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010942f:	77 1d                	ja     f010944e <get_page_table+0xfb>
		{
			*ptr_page_table = (void *)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109431:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109434:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109439:	83 ec 0c             	sub    $0xc,%esp
f010943c:	50                   	push   %eax
f010943d:	e8 28 08 00 00       	call   f0109c6a <kheap_virtual_address>
f0109442:	83 c4 10             	add    $0x10,%esp
f0109445:	89 c2                	mov    %eax,%edx
f0109447:	8b 45 10             	mov    0x10(%ebp),%eax
f010944a:	89 10                	mov    %edx,(%eax)
f010944c:	eb 44                	jmp    f0109492 <get_page_table+0x13f>
		}
		else
		{
			*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f010944e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109451:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109456:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109459:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010945c:	c1 e8 0c             	shr    $0xc,%eax
f010945f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109462:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109467:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010946a:	72 17                	jb     f0109483 <get_page_table+0x130>
f010946c:	ff 75 e8             	pushl  -0x18(%ebp)
f010946f:	68 78 f0 12 f0       	push   $0xf012f078
f0109474:	68 12 01 00 00       	push   $0x112
f0109479:	68 bb ef 12 f0       	push   $0xf012efbb
f010947e:	e8 2c 7b ff ff       	call   f0100faf <_panic>
f0109483:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109486:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010948b:	89 c2                	mov    %eax,%edx
f010948d:	8b 45 10             	mov    0x10(%ebp),%eax
f0109490:	89 10                	mov    %edx,(%eax)
		}

		return TABLE_IN_MEMORY;
f0109492:	b8 00 00 00 00       	mov    $0x0,%eax
f0109497:	eb 0e                	jmp    f01094a7 <get_page_table+0x154>
	}
	else // there is no table for this va anywhere. This is a new table required, so check if the user want creation
	{
		//		cprintf("gpt .2\n");
		*ptr_page_table = 0;
f0109499:	8b 45 10             	mov    0x10(%ebp),%eax
f010949c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return TABLE_NOT_EXIST;
f01094a2:	b8 01 00 00 00       	mov    $0x1,%eax
	}
}
f01094a7:	c9                   	leave  
f01094a8:	c3                   	ret    

f01094a9 <create_page_table>:

void * create_page_table(uint32 *ptr_directory, const uint32 virtual_address)
{
f01094a9:	55                   	push   %ebp
f01094aa:	89 e5                	mov    %esp,%ebp
f01094ac:	53                   	push   %ebx
f01094ad:	83 ec 14             	sub    $0x14,%esp
	//	b.	clear the TLB cache (using "tlbflush()")

	//change this "return" according to your answer

#if USE_KHEAP
	uint32 * ptr_page_table = kmalloc(PAGE_SIZE);
f01094b0:	83 ec 0c             	sub    $0xc,%esp
f01094b3:	68 00 10 00 00       	push   $0x1000
f01094b8:	e8 79 07 00 00       	call   f0109c36 <kmalloc>
f01094bd:	83 c4 10             	add    $0x10,%esp
f01094c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("new table is created==================\n");
	if(ptr_page_table == NULL)
f01094c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01094c7:	75 17                	jne    f01094e0 <create_page_table+0x37>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f01094c9:	83 ec 04             	sub    $0x4,%esp
f01094cc:	68 a7 f0 12 f0       	push   $0xf012f0a7
f01094d1:	68 32 01 00 00       	push   $0x132
f01094d6:	68 bb ef 12 f0       	push   $0xf012efbb
f01094db:	e8 cf 7a ff ff       	call   f0100faf <_panic>
	}
	//cprintf("Table is created for va %x\n", virtual_address);
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(
f01094e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01094e3:	c1 e8 16             	shr    $0x16,%eax
f01094e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01094ed:	8b 45 08             	mov    0x8(%ebp),%eax
f01094f0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
f01094f3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01094f6:	83 ec 0c             	sub    $0xc,%esp
f01094f9:	50                   	push   %eax
f01094fa:	e8 85 07 00 00       	call   f0109c84 <kheap_physical_address>
f01094ff:	83 c4 10             	add    $0x10,%esp
f0109502:	83 c8 07             	or     $0x7,%eax
f0109505:	89 03                	mov    %eax,(%ebx)
			kheap_physical_address((unsigned int)ptr_page_table)
			, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);

	//================
	memset(ptr_page_table , 0, PAGE_SIZE);
f0109507:	83 ec 04             	sub    $0x4,%esp
f010950a:	68 00 10 00 00       	push   $0x1000
f010950f:	6a 00                	push   $0x0
f0109511:	ff 75 f4             	pushl  -0xc(%ebp)
f0109514:	e8 50 18 01 00       	call   f011ad69 <memset>
f0109519:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010951c:	0f 20 d8             	mov    %cr3,%eax
f010951f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109522:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109525:	0f 22 d8             	mov    %eax,%cr3
	__static_cpt(ptr_directory, virtual_address, &ptr_page_table) ;
#endif

	//cprintf("KERNEL: NEW TABLE for va %x \n", virtual_address);

	return ptr_page_table;
f0109528:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010952b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010952e:	c9                   	leave  
f010952f:	c3                   	ret    

f0109530 <__static_cpt>:

void __static_cpt(uint32 *ptr_directory, const uint32 virtual_address, uint32 **ptr_page_table)
{
f0109530:	55                   	push   %ebp
f0109531:	89 e5                	mov    %esp,%ebp
f0109533:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_new_frame_info;
	int err = allocate_frame(&ptr_new_frame_info) ;
f0109536:	83 ec 0c             	sub    $0xc,%esp
f0109539:	8d 45 e0             	lea    -0x20(%ebp),%eax
f010953c:	50                   	push   %eax
f010953d:	e8 00 fc ff ff       	call   f0109142 <allocate_frame>
f0109542:	83 c4 10             	add    $0x10,%esp
f0109545:	89 45 f4             	mov    %eax,-0xc(%ebp)

	uint32 phys_page_table = to_physical_address(ptr_new_frame_info);
f0109548:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010954b:	83 ec 0c             	sub    $0xc,%esp
f010954e:	50                   	push   %eax
f010954f:	e8 72 f7 ff ff       	call   f0108cc6 <to_physical_address>
f0109554:	83 c4 10             	add    $0x10,%esp
f0109557:	89 45 f0             	mov    %eax,-0x10(%ebp)
	*ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(phys_page_table) ;
f010955a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010955d:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0109560:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109563:	c1 e8 0c             	shr    $0xc,%eax
f0109566:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0109569:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f010956e:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f0109571:	72 17                	jb     f010958a <__static_cpt+0x5a>
f0109573:	ff 75 ec             	pushl  -0x14(%ebp)
f0109576:	68 78 f0 12 f0       	push   $0xf012f078
f010957b:	68 4d 01 00 00       	push   $0x14d
f0109580:	68 bb ef 12 f0       	push   $0xf012efbb
f0109585:	e8 25 7a ff ff       	call   f0100faf <_panic>
f010958a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010958d:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0109592:	89 c2                	mov    %eax,%edx
f0109594:	8b 45 10             	mov    0x10(%ebp),%eax
f0109597:	89 10                	mov    %edx,(%eax)
	ptr_new_frame_info->references = 1;
f0109599:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010959c:	66 c7 40 08 01 00    	movw   $0x1,0x8(%eax)
	ptr_directory[PDX(virtual_address)] = CONSTRUCT_ENTRY(phys_page_table, PERM_PRESENT | PERM_USER | PERM_WRITEABLE);
f01095a2:	8b 45 0c             	mov    0xc(%ebp),%eax
f01095a5:	c1 e8 16             	shr    $0x16,%eax
f01095a8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01095af:	8b 45 08             	mov    0x8(%ebp),%eax
f01095b2:	01 d0                	add    %edx,%eax
f01095b4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f01095b7:	83 ca 07             	or     $0x7,%edx
f01095ba:	89 10                	mov    %edx,(%eax)
	//initialize new page table by 0's
	memset(*ptr_page_table , 0, PAGE_SIZE);
f01095bc:	8b 45 10             	mov    0x10(%ebp),%eax
f01095bf:	8b 00                	mov    (%eax),%eax
f01095c1:	83 ec 04             	sub    $0x4,%esp
f01095c4:	68 00 10 00 00       	push   $0x1000
f01095c9:	6a 00                	push   $0x0
f01095cb:	50                   	push   %eax
f01095cc:	e8 98 17 01 00       	call   f011ad69 <memset>
f01095d1:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f01095d4:	0f 20 d8             	mov    %cr3,%eax
f01095d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f01095da:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01095dd:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f01095e0:	90                   	nop
f01095e1:	c9                   	leave  
f01095e2:	c3                   	ret    

f01095e3 <map_frame>:
//   0 on success
//
// Hint: implement using get_page_table() and unmap_frame().
//
int map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01095e3:	55                   	push   %ebp
f01095e4:	89 e5                	mov    %esp,%ebp
f01095e6:	83 ec 28             	sub    $0x28,%esp
	// Fill this function in
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01095e9:	ff 75 0c             	pushl  0xc(%ebp)
f01095ec:	e8 d5 f6 ff ff       	call   f0108cc6 <to_physical_address>
f01095f1:	83 c4 04             	add    $0x4,%esp
f01095f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ptr_page_table;
	if( get_page_table(ptr_page_directory, virtual_address, &ptr_page_table) == TABLE_NOT_EXIST)
f01095f7:	83 ec 04             	sub    $0x4,%esp
f01095fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f01095fd:	50                   	push   %eax
f01095fe:	ff 75 10             	pushl  0x10(%ebp)
f0109601:	ff 75 08             	pushl  0x8(%ebp)
f0109604:	e8 4a fd ff ff       	call   f0109353 <get_page_table>
f0109609:	83 c4 10             	add    $0x10,%esp
f010960c:	83 f8 01             	cmp    $0x1,%eax
f010960f:	75 1b                	jne    f010962c <map_frame+0x49>
		//page_directory_entry = ptr_page_directory[PDX(virtual_address)];
		//ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
		=============================================================================================*/
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, (uint32)virtual_address);
f0109611:	83 ec 08             	sub    $0x8,%esp
f0109614:	ff 75 10             	pushl  0x10(%ebp)
f0109617:	ff 75 08             	pushl  0x8(%ebp)
f010961a:	e8 8a fe ff ff       	call   f01094a9 <create_page_table>
f010961f:	83 c4 10             	add    $0x10,%esp
f0109622:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			//cprintf("======>page table created using kheap for VA %x at dir = %x PT = %x\n", virtual_address, ptr_page_directory[PDX(virtual_address)], ptr_page_table);
			uint32* ptr_page_table2 =NULL;
f0109625:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
#endif

	}

	//cprintf("NOW .. map add = %x ptr_page_table = %x PTX(virtual_address) = %d\n", virtual_address, ptr_page_table,PTX(virtual_address));
	uint32 page_table_entry = ptr_page_table[PTX(virtual_address)];
f010962c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010962f:	8b 55 10             	mov    0x10(%ebp),%edx
f0109632:	c1 ea 0c             	shr    $0xc,%edx
f0109635:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010963b:	c1 e2 02             	shl    $0x2,%edx
f010963e:	01 d0                	add    %edx,%eax
f0109640:	8b 00                	mov    (%eax),%eax
f0109642:	89 45 ec             	mov    %eax,-0x14(%ebp)

	}*/

	/*NEW'15 CORRECT SOLUTION*/
	//If already mapped
	if ((page_table_entry & PERM_PRESENT) == PERM_PRESENT)
f0109645:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109648:	83 e0 01             	and    $0x1,%eax
f010964b:	85 c0                	test   %eax,%eax
f010964d:	74 25                	je     f0109674 <map_frame+0x91>
	{
		//on this pa, then do nothing
		if (EXTRACT_ADDRESS(page_table_entry) == physical_address)
f010964f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109652:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109657:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010965a:	75 07                	jne    f0109663 <map_frame+0x80>
			return 0;
f010965c:	b8 00 00 00 00       	mov    $0x0,%eax
f0109661:	eb 68                	jmp    f01096cb <map_frame+0xe8>
		//on another pa, then unmap it
		else
			unmap_frame(ptr_page_directory , virtual_address);
f0109663:	83 ec 08             	sub    $0x8,%esp
f0109666:	ff 75 10             	pushl  0x10(%ebp)
f0109669:	ff 75 08             	pushl  0x8(%ebp)
f010966c:	e8 de 00 00 00       	call   f010974f <unmap_frame>
f0109671:	83 c4 10             	add    $0x10,%esp
	}
	ptr_frame_info->references++;
f0109674:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109677:	8b 40 08             	mov    0x8(%eax),%eax
f010967a:	40                   	inc    %eax
f010967b:	8b 55 0c             	mov    0xc(%ebp),%edx
f010967e:	66 89 42 08          	mov    %ax,0x8(%edx)

	/*********************************************************************************/
	/*NEW'23 el7:)
	 * map_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
	uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f0109682:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109685:	8b 55 10             	mov    0x10(%ebp),%edx
f0109688:	c1 ea 0c             	shr    $0xc,%edx
f010968b:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109691:	c1 e2 02             	shl    $0x2,%edx
f0109694:	01 d0                	add    %edx,%eax
f0109696:	8b 00                	mov    (%eax),%eax
f0109698:	25 00 0e 00 00       	and    $0xe00,%eax
f010969d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , pte_available_bits | perm | PERM_PRESENT);
f01096a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01096a3:	8b 55 10             	mov    0x10(%ebp),%edx
f01096a6:	c1 ea 0c             	shr    $0xc,%edx
f01096a9:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01096af:	c1 e2 02             	shl    $0x2,%edx
f01096b2:	01 c2                	add    %eax,%edx
f01096b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01096b7:	0b 45 e8             	or     -0x18(%ebp),%eax
f01096ba:	89 c1                	mov    %eax,%ecx
f01096bc:	8b 45 14             	mov    0x14(%ebp),%eax
f01096bf:	09 c8                	or     %ecx,%eax
f01096c1:	83 c8 01             	or     $0x1,%eax
f01096c4:	89 02                	mov    %eax,(%edx)
	/*********************************************************************************/

	return 0;
f01096c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01096cb:	c9                   	leave  
f01096cc:	c3                   	ret    

f01096cd <get_frame_info>:
//	2. buffered to 'virtual_address'
// If the page table entry corresponding to 'virtual_address' exists, then we store a pointer to the table in 'ptr_page_table'
// Return 0 if there is no frame mapped/buffered at virtual_address.
//
struct FrameInfo * get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table)
{
f01096cd:	55                   	push   %ebp
f01096ce:	89 e5                	mov    %esp,%ebp
f01096d0:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 ret =  get_page_table(ptr_page_directory, virtual_address, ptr_page_table) ;
f01096d3:	83 ec 04             	sub    $0x4,%esp
f01096d6:	ff 75 10             	pushl  0x10(%ebp)
f01096d9:	ff 75 0c             	pushl  0xc(%ebp)
f01096dc:	ff 75 08             	pushl  0x8(%ebp)
f01096df:	e8 6f fc ff ff       	call   f0109353 <get_page_table>
f01096e4:	83 c4 10             	add    $0x10,%esp
f01096e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if((*ptr_page_table) != 0)
f01096ea:	8b 45 10             	mov    0x10(%ebp),%eax
f01096ed:	8b 00                	mov    (%eax),%eax
f01096ef:	85 c0                	test   %eax,%eax
f01096f1:	74 55                	je     f0109748 <get_frame_info+0x7b>
	{
		uint32 index_page_table = PTX(virtual_address);
f01096f3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01096f6:	c1 e8 0c             	shr    $0xc,%eax
f01096f9:	25 ff 03 00 00       	and    $0x3ff,%eax
f01096fe:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32 page_table_entry = (*ptr_page_table)[index_page_table];
f0109701:	8b 45 10             	mov    0x10(%ebp),%eax
f0109704:	8b 00                	mov    (%eax),%eax
f0109706:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109709:	c1 e2 02             	shl    $0x2,%edx
f010970c:	01 d0                	add    %edx,%eax
f010970e:	8b 00                	mov    (%eax),%eax
f0109710:	89 45 ec             	mov    %eax,-0x14(%ebp)

		/*2023 el7:)*///Make sure it has a frame number other than 0 (not just a marked page from the page allocator)
		/*2025 el7:)*///or if it's 0, make sure it's either present or buffered
		//if( page_table_entry != 0)
		//if((page_table_entry & ~0xFFF) != 0)
		if( ((page_table_entry & ~0xFFF) != 0) || ((page_table_entry & (PERM_PRESENT|PERM_BUFFERED)) != 0))
f0109713:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109716:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010971b:	85 c0                	test   %eax,%eax
f010971d:	75 0c                	jne    f010972b <get_frame_info+0x5e>
f010971f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109722:	25 01 02 00 00       	and    $0x201,%eax
f0109727:	85 c0                	test   %eax,%eax
f0109729:	74 16                	je     f0109741 <get_frame_info+0x74>
		{
			return to_frame_info( EXTRACT_ADDRESS ( page_table_entry ) );
f010972b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010972e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109733:	83 ec 0c             	sub    $0xc,%esp
f0109736:	50                   	push   %eax
f0109737:	e8 9d f5 ff ff       	call   f0108cd9 <to_frame_info>
f010973c:	83 c4 10             	add    $0x10,%esp
f010973f:	eb 0c                	jmp    f010974d <get_frame_info+0x80>
		}
		return 0;
f0109741:	b8 00 00 00 00       	mov    $0x0,%eax
f0109746:	eb 05                	jmp    f010974d <get_frame_info+0x80>
	}
	return 0;
f0109748:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010974d:	c9                   	leave  
f010974e:	c3                   	ret    

f010974f <unmap_frame>:
//
// Hint: implement using get_frame_info(),
// 	tlb_invalidate(), and decrement_references().
//
void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address)
{
f010974f:	55                   	push   %ebp
f0109750:	89 e5                	mov    %esp,%ebp
f0109752:	83 ec 18             	sub    $0x18,%esp
	// Fill this function in
	uint32 *ptr_page_table;
	struct FrameInfo* ptr_frame_info = get_frame_info(ptr_page_directory, virtual_address, &ptr_page_table);
f0109755:	83 ec 04             	sub    $0x4,%esp
f0109758:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010975b:	50                   	push   %eax
f010975c:	ff 75 0c             	pushl  0xc(%ebp)
f010975f:	ff 75 08             	pushl  0x8(%ebp)
f0109762:	e8 66 ff ff ff       	call   f01096cd <get_frame_info>
f0109767:	83 c4 10             	add    $0x10,%esp
f010976a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if( ptr_frame_info != 0 )
f010976d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109771:	74 7d                	je     f01097f0 <unmap_frame+0xa1>
	{
		if (ptr_frame_info->isBuffered && !CHECK_IF_KERNEL_ADDRESS((uint32)virtual_address))
f0109773:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109776:	8a 40 10             	mov    0x10(%eax),%al
f0109779:	84 c0                	test   %al,%al
f010977b:	74 1c                	je     f0109799 <unmap_frame+0x4a>
f010977d:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f0109784:	77 13                	ja     f0109799 <unmap_frame+0x4a>
			cprintf("WARNING: Freeing BUFFERED frame at va %x!!!\n", virtual_address) ;
f0109786:	83 ec 08             	sub    $0x8,%esp
f0109789:	ff 75 0c             	pushl  0xc(%ebp)
f010978c:	68 c4 f0 12 f0       	push   $0xf012f0c4
f0109791:	e8 c6 84 ff ff       	call   f0101c5c <cprintf>
f0109796:	83 c4 10             	add    $0x10,%esp
		decrement_references(ptr_frame_info);
f0109799:	83 ec 0c             	sub    $0xc,%esp
f010979c:	ff 75 f4             	pushl  -0xc(%ebp)
f010979f:	e8 7f fb ff ff       	call   f0109323 <decrement_references>
f01097a4:	83 c4 10             	add    $0x10,%esp

		/*********************************************************************************/
		/*NEW'23 el7:)
		 * unmap_frame(): KEEP THE VALUES OF THE AVAILABLE BITS*/
		uint32 pte_available_bits = ptr_page_table[PTX(virtual_address)] & PERM_AVAILABLE;
f01097a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097aa:	8b 55 0c             	mov    0xc(%ebp),%edx
f01097ad:	c1 ea 0c             	shr    $0xc,%edx
f01097b0:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01097b6:	c1 e2 02             	shl    $0x2,%edx
f01097b9:	01 d0                	add    %edx,%eax
f01097bb:	8b 00                	mov    (%eax),%eax
f01097bd:	25 00 0e 00 00       	and    $0xe00,%eax
f01097c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
		ptr_page_table[PTX(virtual_address)] = pte_available_bits;
f01097c5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01097c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f01097cb:	c1 ea 0c             	shr    $0xc,%edx
f01097ce:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f01097d4:	c1 e2 02             	shl    $0x2,%edx
f01097d7:	01 c2                	add    %eax,%edx
f01097d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01097dc:	89 02                	mov    %eax,(%edx)
		/*********************************************************************************/

		tlb_invalidate(ptr_page_directory, (void *)virtual_address);
f01097de:	8b 45 0c             	mov    0xc(%ebp),%eax
f01097e1:	83 ec 08             	sub    $0x8,%esp
f01097e4:	50                   	push   %eax
f01097e5:	ff 75 08             	pushl  0x8(%ebp)
f01097e8:	e8 33 f5 ff ff       	call   f0108d20 <tlb_invalidate>
f01097ed:	83 c4 10             	add    $0x10,%esp
	}
}
f01097f0:	90                   	nop
f01097f1:	c9                   	leave  
f01097f2:	c3                   	ret    

f01097f3 <loadtime_map_frame>:
// RETURNS:
//   0 on success
//
//
int loadtime_map_frame(uint32 *ptr_page_directory, struct FrameInfo *ptr_frame_info, uint32 virtual_address, int perm)
{
f01097f3:	55                   	push   %ebp
f01097f4:	89 e5                	mov    %esp,%ebp
f01097f6:	83 ec 28             	sub    $0x28,%esp
	uint32 physical_address = to_physical_address(ptr_frame_info);
f01097f9:	ff 75 0c             	pushl  0xc(%ebp)
f01097fc:	e8 c5 f4 ff ff       	call   f0108cc6 <to_physical_address>
f0109801:	83 c4 04             	add    $0x4,%esp
f0109804:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32 *ptr_page_table;

	uint32 page_directory_entry = ptr_page_directory[PDX(virtual_address)];
f0109807:	8b 45 10             	mov    0x10(%ebp),%eax
f010980a:	c1 e8 16             	shr    $0x16,%eax
f010980d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109814:	8b 45 08             	mov    0x8(%ebp),%eax
f0109817:	01 d0                	add    %edx,%eax
f0109819:	8b 00                	mov    (%eax),%eax
f010981b:	89 45 ec             	mov    %eax,-0x14(%ebp)

	if(USE_KHEAP && !CHECK_IF_KERNEL_ADDRESS(virtual_address))
f010981e:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f0109825:	77 19                	ja     f0109840 <loadtime_map_frame+0x4d>
	{
		ptr_page_table = (uint32*)kheap_virtual_address(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109827:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010982a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010982f:	83 ec 0c             	sub    $0xc,%esp
f0109832:	50                   	push   %eax
f0109833:	e8 32 04 00 00       	call   f0109c6a <kheap_virtual_address>
f0109838:	83 c4 10             	add    $0x10,%esp
f010983b:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010983e:	eb 40                	jmp    f0109880 <loadtime_map_frame+0x8d>
	}
	else
	{
		ptr_page_table = STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(page_directory_entry)) ;
f0109840:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109843:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109848:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010984b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010984e:	c1 e8 0c             	shr    $0xc,%eax
f0109851:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109854:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109859:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010985c:	72 17                	jb     f0109875 <loadtime_map_frame+0x82>
f010985e:	ff 75 e8             	pushl  -0x18(%ebp)
f0109861:	68 78 f0 12 f0       	push   $0xf012f078
f0109866:	68 0c 02 00 00       	push   $0x20c
f010986b:	68 bb ef 12 f0       	push   $0xf012efbb
f0109870:	e8 3a 77 ff ff       	call   f0100faf <_panic>
f0109875:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0109878:	2d 00 00 00 10       	sub    $0x10000000,%eax
f010987d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}

	//if page table not exist, create it in memory and link it with the directory
	if (page_directory_entry == 0)
f0109880:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109884:	75 14                	jne    f010989a <loadtime_map_frame+0xa7>
	{
#if USE_KHEAP
		{
			ptr_page_table = create_page_table(ptr_page_directory, virtual_address);
f0109886:	83 ec 08             	sub    $0x8,%esp
f0109889:	ff 75 10             	pushl  0x10(%ebp)
f010988c:	ff 75 08             	pushl  0x8(%ebp)
f010988f:	e8 15 fc ff ff       	call   f01094a9 <create_page_table>
f0109894:	83 c4 10             	add    $0x10,%esp
f0109897:	89 45 f4             	mov    %eax,-0xc(%ebp)
			__static_cpt(ptr_page_directory, virtual_address, &ptr_page_table);
		}
#endif
	}

	ptr_frame_info->references++;
f010989a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010989d:	8b 40 08             	mov    0x8(%eax),%eax
f01098a0:	40                   	inc    %eax
f01098a1:	8b 55 0c             	mov    0xc(%ebp),%edx
f01098a4:	66 89 42 08          	mov    %ax,0x8(%edx)
	ptr_page_table[PTX(virtual_address)] = CONSTRUCT_ENTRY(physical_address , perm | PERM_PRESENT);
f01098a8:	8b 45 10             	mov    0x10(%ebp),%eax
f01098ab:	c1 e8 0c             	shr    $0xc,%eax
f01098ae:	25 ff 03 00 00       	and    $0x3ff,%eax
f01098b3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01098ba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01098bd:	01 c2                	add    %eax,%edx
f01098bf:	8b 45 14             	mov    0x14(%ebp),%eax
f01098c2:	0b 45 f0             	or     -0x10(%ebp),%eax
f01098c5:	83 c8 01             	or     $0x1,%eax
f01098c8:	89 02                	mov    %eax,(%edx)

	return 0;
f01098ca:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01098cf:	c9                   	leave  
f01098d0:	c3                   	ret    

f01098d1 <calculate_available_frames>:



// calculate_available_frames:
struct freeFramesCounters calculate_available_frames()
{
f01098d1:	55                   	push   %ebp
f01098d2:	89 e5                	mov    %esp,%ebp
f01098d4:	57                   	push   %edi
f01098d5:	56                   	push   %esi
f01098d6:	53                   	push   %ebx
f01098d7:	83 ec 2c             	sub    $0x2c,%esp
	struct FrameInfo *ptr;
	uint32 totalFreeUnBuffered = 0 ;
f01098da:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint32 totalFreeBuffered = 0 ;
f01098e1:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	uint32 totalModified = 0 ;
f01098e8:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	bool lock_is_held = holding_kspinlock(&MemFrameLists.mfllock);
f01098ef:	83 ec 0c             	sub    $0xc,%esp
f01098f2:	68 e0 e7 83 f0       	push   $0xf083e7e0
f01098f7:	e8 d4 67 00 00       	call   f01100d0 <holding_kspinlock>
f01098fc:	83 c4 10             	add    $0x10,%esp
f01098ff:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	if (!lock_is_held)
f0109902:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0109906:	75 10                	jne    f0109918 <calculate_available_frames+0x47>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f0109908:	83 ec 0c             	sub    $0xc,%esp
f010990b:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109910:	e8 66 65 00 00       	call   f010fe7b <acquire_kspinlock>
f0109915:	83 c4 10             	add    $0x10,%esp
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109918:	a1 c0 e7 83 f0       	mov    0xf083e7c0,%eax
f010991d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0109920:	eb 1a                	jmp    f010993c <calculate_available_frames+0x6b>
		{
			if (ptr->isBuffered)
f0109922:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109925:	8a 40 10             	mov    0x10(%eax),%al
f0109928:	84 c0                	test   %al,%al
f010992a:	74 05                	je     f0109931 <calculate_available_frames+0x60>
				totalFreeBuffered++ ;
f010992c:	ff 45 dc             	incl   -0x24(%ebp)
f010992f:	eb 03                	jmp    f0109934 <calculate_available_frames+0x63>
			else
				totalFreeUnBuffered++ ;
f0109931:	ff 45 e0             	incl   -0x20(%ebp)
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		//calculate the free frames from the free frame list

		LIST_FOREACH(ptr, &MemFrameLists.free_frame_list)
f0109934:	a1 c8 e7 83 f0       	mov    0xf083e7c8,%eax
f0109939:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010993c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109940:	74 07                	je     f0109949 <calculate_available_frames+0x78>
f0109942:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0109945:	8b 00                	mov    (%eax),%eax
f0109947:	eb 05                	jmp    f010994e <calculate_available_frames+0x7d>
f0109949:	b8 00 00 00 00       	mov    $0x0,%eax
f010994e:	a3 c8 e7 83 f0       	mov    %eax,0xf083e7c8
f0109953:	a1 c8 e7 83 f0       	mov    0xf083e7c8,%eax
f0109958:	85 c0                	test   %eax,%eax
f010995a:	75 c6                	jne    f0109922 <calculate_available_frames+0x51>
f010995c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0109960:	75 c0                	jne    f0109922 <calculate_available_frames+0x51>
			else
				totalFreeUnBuffered++ ;
		}

		/*2023: UPDATE based on suggestion from T112 2023.Term1*/
		totalModified= LIST_SIZE(&MemFrameLists.modified_frame_list);
f0109962:	a1 dc e7 83 f0       	mov    0xf083e7dc,%eax
f0109967:	89 45 d8             	mov    %eax,-0x28(%ebp)
		//	LIST_FOREACH(ptr, &modified_frame_list)
		//	{
		//		totalModified++ ;
		//	}
	}
	if (!lock_is_held)
f010996a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f010996e:	75 10                	jne    f0109980 <calculate_available_frames+0xaf>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f0109970:	83 ec 0c             	sub    $0xc,%esp
f0109973:	68 e0 e7 83 f0       	push   $0xf083e7e0
f0109978:	e8 a3 65 00 00       	call   f010ff20 <release_kspinlock>
f010997d:	83 c4 10             	add    $0x10,%esp
	}
	struct freeFramesCounters counters ;
	counters.freeBuffered = totalFreeBuffered ;
f0109980:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0109983:	89 45 c8             	mov    %eax,-0x38(%ebp)
	counters.freeNotBuffered = totalFreeUnBuffered ;
f0109986:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0109989:	89 45 cc             	mov    %eax,-0x34(%ebp)
	counters.modified = totalModified;
f010998c:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010998f:	89 45 d0             	mov    %eax,-0x30(%ebp)
	return counters;
f0109992:	8b 45 08             	mov    0x8(%ebp),%eax
f0109995:	89 c3                	mov    %eax,%ebx
f0109997:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010999a:	ba 03 00 00 00       	mov    $0x3,%edx
f010999f:	89 df                	mov    %ebx,%edi
f01099a1:	89 c6                	mov    %eax,%esi
f01099a3:	89 d1                	mov    %edx,%ecx
f01099a5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f01099a7:	8b 45 08             	mov    0x8(%ebp),%eax
f01099aa:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01099ad:	5b                   	pop    %ebx
f01099ae:	5e                   	pop    %esi
f01099af:	5f                   	pop    %edi
f01099b0:	5d                   	pop    %ebp
f01099b1:	c2 04 00             	ret    $0x4

f01099b4 <sharing_init>:
//===========================
// [1] INITIALIZE SHARES:
//===========================
//Initialize the list and the corresponding lock
void sharing_init()
{
f01099b4:	55                   	push   %ebp
f01099b5:	89 e5                	mov    %esp,%ebp
f01099b7:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	LIST_INIT(&AllShares.shares_list) ;
f01099ba:	c7 05 80 e6 83 f0 00 	movl   $0x0,0xf083e680
f01099c1:	00 00 00 
f01099c4:	c7 05 84 e6 83 f0 00 	movl   $0x0,0xf083e684
f01099cb:	00 00 00 
f01099ce:	c7 05 8c e6 83 f0 00 	movl   $0x0,0xf083e68c
f01099d5:	00 00 00 
	init_kspinlock(&AllShares.shareslock, "shares lock");
f01099d8:	83 ec 08             	sub    $0x8,%esp
f01099db:	68 f4 f0 12 f0       	push   $0xf012f0f4
f01099e0:	68 90 e6 83 f0       	push   $0xf083e690
f01099e5:	e8 60 64 00 00       	call   f010fe4a <init_kspinlock>
f01099ea:	83 c4 10             	add    $0x10,%esp
	//init_sleeplock(&AllShares.sharessleeplock, "shares sleep lock");
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f01099ed:	90                   	nop
f01099ee:	c9                   	leave  
f01099ef:	c3                   	ret    

f01099f0 <find_share>:
//Search for the given shared object in the "shares_list"
//Return:
//	a) if found: ptr to Share object
//	b) else: NULL
struct Share* find_share(int32 ownerID, char* name)
{
f01099f0:	55                   	push   %ebp
f01099f1:	89 e5                	mov    %esp,%ebp
f01099f3:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct Share * ret = NULL;
f01099f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	bool wasHeld = holding_kspinlock(&(AllShares.shareslock));
f01099fd:	83 ec 0c             	sub    $0xc,%esp
f0109a00:	68 90 e6 83 f0       	push   $0xf083e690
f0109a05:	e8 c6 66 00 00       	call   f01100d0 <holding_kspinlock>
f0109a0a:	83 c4 10             	add    $0x10,%esp
f0109a0d:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (!wasHeld)
f0109a10:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109a14:	75 10                	jne    f0109a26 <find_share+0x36>
	{
		acquire_kspinlock(&(AllShares.shareslock));
f0109a16:	83 ec 0c             	sub    $0xc,%esp
f0109a19:	68 90 e6 83 f0       	push   $0xf083e690
f0109a1e:	e8 58 64 00 00       	call   f010fe7b <acquire_kspinlock>
f0109a23:	83 c4 10             	add    $0x10,%esp
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f0109a26:	a1 80 e6 83 f0       	mov    0xf083e680,%eax
f0109a2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109a2e:	eb 34                	jmp    f0109a64 <find_share+0x74>
		{
			//cprintf("shared var name = %s compared with %s\n", name, shr->name);
			if(shr->ownerID == ownerID && strcmp(name, shr->name)==0)
f0109a30:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a33:	8b 40 04             	mov    0x4(%eax),%eax
f0109a36:	3b 45 08             	cmp    0x8(%ebp),%eax
f0109a39:	75 21                	jne    f0109a5c <find_share+0x6c>
f0109a3b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a3e:	83 c0 08             	add    $0x8,%eax
f0109a41:	83 ec 08             	sub    $0x8,%esp
f0109a44:	50                   	push   %eax
f0109a45:	ff 75 0c             	pushl  0xc(%ebp)
f0109a48:	e8 3a 12 01 00       	call   f011ac87 <strcmp>
f0109a4d:	83 c4 10             	add    $0x10,%esp
f0109a50:	85 c0                	test   %eax,%eax
f0109a52:	75 08                	jne    f0109a5c <find_share+0x6c>
			{
				//cprintf("%s found\n", name);
				ret = shr;
f0109a54:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a57:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0109a5a:	eb 2f                	jmp    f0109a8b <find_share+0x9b>
	{
		acquire_kspinlock(&(AllShares.shareslock));
	}
	{
		struct Share * shr ;
		LIST_FOREACH(shr, &(AllShares.shares_list))
f0109a5c:	a1 88 e6 83 f0       	mov    0xf083e688,%eax
f0109a61:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0109a64:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109a68:	74 08                	je     f0109a72 <find_share+0x82>
f0109a6a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109a6d:	8b 40 58             	mov    0x58(%eax),%eax
f0109a70:	eb 05                	jmp    f0109a77 <find_share+0x87>
f0109a72:	b8 00 00 00 00       	mov    $0x0,%eax
f0109a77:	a3 88 e6 83 f0       	mov    %eax,0xf083e688
f0109a7c:	a1 88 e6 83 f0       	mov    0xf083e688,%eax
f0109a81:	85 c0                	test   %eax,%eax
f0109a83:	75 ab                	jne    f0109a30 <find_share+0x40>
f0109a85:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109a89:	75 a5                	jne    f0109a30 <find_share+0x40>
				ret = shr;
				break;
			}
		}
	}
	if (!wasHeld)
f0109a8b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0109a8f:	75 10                	jne    f0109aa1 <find_share+0xb1>
	{
		release_kspinlock(&(AllShares.shareslock));
f0109a91:	83 ec 0c             	sub    $0xc,%esp
f0109a94:	68 90 e6 83 f0       	push   $0xf083e690
f0109a99:	e8 82 64 00 00       	call   f010ff20 <release_kspinlock>
f0109a9e:	83 c4 10             	add    $0x10,%esp
	}
	return ret;
f0109aa1:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("not handled when KERN HEAP is disabled");
#endif
}
f0109aa4:	c9                   	leave  
f0109aa5:	c3                   	ret    

f0109aa6 <size_of_shared_object>:

//==============================
// [3] Get Size of Share Object:
//==============================
int size_of_shared_object(int32 ownerID, char* shareName)
{
f0109aa6:	55                   	push   %ebp
f0109aa7:	89 e5                	mov    %esp,%ebp
f0109aa9:	83 ec 18             	sub    $0x18,%esp
	// This function should return the size of the given shared object
	// RETURN:
	//	a) If found, return size of shared object
	//	b) Else, return E_SHARED_MEM_NOT_EXISTS
	//
	struct Share* ptr_share = find_share(ownerID, shareName);
f0109aac:	83 ec 08             	sub    $0x8,%esp
f0109aaf:	ff 75 0c             	pushl  0xc(%ebp)
f0109ab2:	ff 75 08             	pushl  0x8(%ebp)
f0109ab5:	e8 36 ff ff ff       	call   f01099f0 <find_share>
f0109aba:	83 c4 10             	add    $0x10,%esp
f0109abd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (ptr_share == NULL)
f0109ac0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0109ac4:	75 07                	jne    f0109acd <size_of_shared_object+0x27>
		return E_SHARED_MEM_NOT_EXISTS;
f0109ac6:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
f0109acb:	eb 06                	jmp    f0109ad3 <size_of_shared_object+0x2d>
	else
		return ptr_share->size;
f0109acd:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109ad0:	8b 40 48             	mov    0x48(%eax),%eax

	return 0;
}
f0109ad3:	c9                   	leave  
f0109ad4:	c3                   	ret    

f0109ad5 <alloc_share>:
//=====================================
//Allocates a new shared object and initialize its member
//It dynamically creates the "framesStorage"
//Return: allocatedObject (pointer to struct Share) passed by reference
struct Share* alloc_share(int32 ownerID, char* shareName, uint32 size, uint8 isWritable)
{
f0109ad5:	55                   	push   %ebp
f0109ad6:	89 e5                	mov    %esp,%ebp
f0109ad8:	83 ec 18             	sub    $0x18,%esp
f0109adb:	8b 45 14             	mov    0x14(%ebp),%eax
f0109ade:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #1 alloc_share
	//Your code is here
	//Comment the following line
	panic("alloc_share() is not implemented yet...!!");
f0109ae1:	83 ec 04             	sub    $0x4,%esp
f0109ae4:	68 00 f1 12 f0       	push   $0xf012f100
f0109ae9:	6a 6e                	push   $0x6e
f0109aeb:	68 2c f1 12 f0       	push   $0xf012f12c
f0109af0:	e8 ba 74 ff ff       	call   f0100faf <_panic>

f0109af5 <create_shared_object>:

//=========================
// [4] Create Share Object:
//=========================
int create_shared_object(int32 ownerID, char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f0109af5:	55                   	push   %ebp
f0109af6:	89 e5                	mov    %esp,%ebp
f0109af8:	83 ec 18             	sub    $0x18,%esp
f0109afb:	8b 45 14             	mov    0x14(%ebp),%eax
f0109afe:	88 45 f4             	mov    %al,-0xc(%ebp)
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #3 create_shared_object
	//Your code is here
	//Comment the following line
	panic("create_shared_object() is not implemented yet...!!");
f0109b01:	83 ec 04             	sub    $0x4,%esp
f0109b04:	68 50 f1 12 f0       	push   $0xf012f150
f0109b09:	6a 7a                	push   $0x7a
f0109b0b:	68 2c f1 12 f0       	push   $0xf012f12c
f0109b10:	e8 9a 74 ff ff       	call   f0100faf <_panic>

f0109b15 <get_shared_object>:

//======================
// [5] Get Share Object:
//======================
int get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f0109b15:	55                   	push   %ebp
f0109b16:	89 e5                	mov    %esp,%ebp
f0109b18:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#3] SHARED MEMORY - #5 get_shared_object
	//Your code is here
	//Comment the following line
	panic("get_shared_object() is not implemented yet...!!");
f0109b1b:	83 ec 04             	sub    $0x4,%esp
f0109b1e:	68 84 f1 12 f0       	push   $0xf012f184
f0109b23:	68 8f 00 00 00       	push   $0x8f
f0109b28:	68 2c f1 12 f0       	push   $0xf012f12c
f0109b2d:	e8 7d 74 ff ff       	call   f0100faf <_panic>

f0109b32 <free_share>:
// [1] Delete Share Object:
//=========================
//delete the given shared object from the "shares_list"
//it should free its framesStorage and the share object itself
void free_share(struct Share* ptrShare)
{
f0109b32:	55                   	push   %ebp
f0109b33:	89 e5                	mov    %esp,%ebp
f0109b35:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - free_share
	//Your code is here
	//Comment the following line
	panic("free_share() is not implemented yet...!!");
f0109b38:	83 ec 04             	sub    $0x4,%esp
f0109b3b:	68 b4 f1 12 f0       	push   $0xf012f1b4
f0109b40:	68 a9 00 00 00       	push   $0xa9
f0109b45:	68 2c f1 12 f0       	push   $0xf012f12c
f0109b4a:	e8 60 74 ff ff       	call   f0100faf <_panic>

f0109b4f <delete_shared_object>:

//=========================
// [2] Free Share Object:
//=========================
int delete_shared_object(int32 sharedObjectID, void *startVA)
{
f0109b4f:	55                   	push   %ebp
f0109b50:	89 e5                	mov    %esp,%ebp
f0109b52:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#5] EXIT #2 - delete_shared_object
	//Your code is here
	//Comment the following line
	panic("delete_shared_object() is not implemented yet...!!");
f0109b55:	83 ec 04             	sub    $0x4,%esp
f0109b58:	68 e0 f1 12 f0       	push   $0xf012f1e0
f0109b5d:	68 b5 00 00 00       	push   $0xb5
f0109b62:	68 2c f1 12 f0       	push   $0xf012f12c
f0109b67:	e8 43 74 ff ff       	call   f0100faf <_panic>

f0109b6c <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0109b6c:	55                   	push   %ebp
f0109b6d:	89 e5                	mov    %esp,%ebp
f0109b6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109b72:	a3 c4 69 85 f0       	mov    %eax,0xf08569c4
f0109b77:	90                   	nop
f0109b78:	5d                   	pop    %ebp
f0109b79:	c3                   	ret    

f0109b7a <kheap_init>:
// [1] INITIALIZE KERNEL HEAP:
//==============================================
//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #0 kheap_init [GIVEN]
//Remember to initialize locks (if any)
void kheap_init()
{
f0109b7a:	55                   	push   %ebp
f0109b7b:	89 e5                	mov    %esp,%ebp
f0109b7d:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		initialize_dynamic_allocator(KERNEL_HEAP_START, KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE);
f0109b80:	83 ec 08             	sub    $0x8,%esp
f0109b83:	68 00 00 00 f8       	push   $0xf8000000
f0109b88:	68 00 00 00 f6       	push   $0xf6000000
f0109b8d:	e8 8b 1b 01 00       	call   f011b71d <initialize_dynamic_allocator>
f0109b92:	83 c4 10             	add    $0x10,%esp
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0109b95:	83 ec 0c             	sub    $0xc,%esp
f0109b98:	6a 05                	push   $0x5
f0109b9a:	e8 cd ff ff ff       	call   f0109b6c <set_kheap_strategy>
f0109b9f:	83 c4 10             	add    $0x10,%esp
		kheapPageAllocStart = dynAllocEnd + PAGE_SIZE;
f0109ba2:	a1 40 e5 83 f0       	mov    0xf083e540,%eax
f0109ba7:	05 00 10 00 00       	add    $0x1000,%eax
f0109bac:	a3 fc e8 83 f0       	mov    %eax,0xf083e8fc
		kheapPageAllocBreak = kheapPageAllocStart;
f0109bb1:	a1 fc e8 83 f0       	mov    0xf083e8fc,%eax
f0109bb6:	a3 10 6b 85 f0       	mov    %eax,0xf0856b10
	}
	//==================================================================================
	//==================================================================================
}
f0109bbb:	90                   	nop
f0109bbc:	c9                   	leave  
f0109bbd:	c3                   	ret    

f0109bbe <get_page>:

//==============================================
// [2] GET A PAGE FROM THE KERNEL FOR DA:
//==============================================
int get_page(void* va)
{
f0109bbe:	55                   	push   %ebp
f0109bbf:	89 e5                	mov    %esp,%ebp
f0109bc1:	83 ec 18             	sub    $0x18,%esp
	int ret = alloc_page(ptr_page_directory, ROUNDDOWN((uint32)va, PAGE_SIZE), PERM_WRITEABLE, 1);
f0109bc4:	8b 45 08             	mov    0x8(%ebp),%eax
f0109bc7:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109bca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109bcd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109bd2:	89 c2                	mov    %eax,%edx
f0109bd4:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109bd9:	6a 01                	push   $0x1
f0109bdb:	6a 02                	push   $0x2
f0109bdd:	52                   	push   %edx
f0109bde:	50                   	push   %eax
f0109bdf:	e8 6a 02 00 00       	call   f0109e4e <alloc_page>
f0109be4:	83 c4 10             	add    $0x10,%esp
f0109be7:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret < 0)
f0109bea:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0109bee:	79 14                	jns    f0109c04 <get_page+0x46>
		panic("get_page() in kern: failed to allocate page from the kernel");
f0109bf0:	83 ec 04             	sub    $0x4,%esp
f0109bf3:	68 14 f2 12 f0       	push   $0xf012f214
f0109bf8:	6a 29                	push   $0x29
f0109bfa:	68 50 f2 12 f0       	push   $0xf012f250
f0109bff:	e8 ab 73 ff ff       	call   f0100faf <_panic>
	return 0;
f0109c04:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0109c09:	c9                   	leave  
f0109c0a:	c3                   	ret    

f0109c0b <return_page>:

//==============================================
// [3] RETURN A PAGE FROM THE DA TO KERNEL:
//==============================================
void return_page(void* va)
{
f0109c0b:	55                   	push   %ebp
f0109c0c:	89 e5                	mov    %esp,%ebp
f0109c0e:	83 ec 18             	sub    $0x18,%esp
	unmap_frame(ptr_page_directory, ROUNDDOWN((uint32)va, PAGE_SIZE));
f0109c11:	8b 45 08             	mov    0x8(%ebp),%eax
f0109c14:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0109c17:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109c1a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0109c1f:	89 c2                	mov    %eax,%edx
f0109c21:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109c26:	83 ec 08             	sub    $0x8,%esp
f0109c29:	52                   	push   %edx
f0109c2a:	50                   	push   %eax
f0109c2b:	e8 1f fb ff ff       	call   f010974f <unmap_frame>
f0109c30:	83 c4 10             	add    $0x10,%esp
}
f0109c33:	90                   	nop
f0109c34:	c9                   	leave  
f0109c35:	c3                   	ret    

f0109c36 <kmalloc>:
//==================================================================================//
//===================================
// [1] ALLOCATE SPACE IN KERNEL HEAP:
//===================================
void* kmalloc(unsigned int size)
{
f0109c36:	55                   	push   %ebp
f0109c37:	89 e5                	mov    %esp,%ebp
f0109c39:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #1 kmalloc
	//Your code is here
	//Comment the following line
	kpanic_into_prompt("kmalloc() is not implemented yet...!!");
f0109c3c:	83 ec 04             	sub    $0x4,%esp
f0109c3f:	68 64 f2 12 f0       	push   $0xf012f264
f0109c44:	6a 40                	push   $0x40
f0109c46:	68 50 f2 12 f0       	push   $0xf012f250
f0109c4b:	e8 93 74 ff ff       	call   f01010e3 <_panic_into_prompt>

f0109c50 <kfree>:

//=================================
// [2] FREE SPACE FROM KERNEL HEAP:
//=================================
void kfree(void* virtual_address)
{
f0109c50:	55                   	push   %ebp
f0109c51:	89 e5                	mov    %esp,%ebp
f0109c53:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #2 kfree
	//Your code is here
	//Comment the following line
	panic("kfree() is not implemented yet...!!");
f0109c56:	83 ec 04             	sub    $0x4,%esp
f0109c59:	68 8c f2 12 f0       	push   $0xf012f28c
f0109c5e:	6a 4d                	push   $0x4d
f0109c60:	68 50 f2 12 f0       	push   $0xf012f250
f0109c65:	e8 45 73 ff ff       	call   f0100faf <_panic>

f0109c6a <kheap_virtual_address>:

//=================================
// [3] FIND VA OF GIVEN PA:
//=================================
unsigned int kheap_virtual_address(unsigned int physical_address)
{
f0109c6a:	55                   	push   %ebp
f0109c6b:	89 e5                	mov    %esp,%ebp
f0109c6d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #3 kheap_virtual_address
	//Your code is here
	//Comment the following line
	panic("kheap_virtual_address() is not implemented yet...!!");
f0109c70:	83 ec 04             	sub    $0x4,%esp
f0109c73:	68 b0 f2 12 f0       	push   $0xf012f2b0
f0109c78:	6a 58                	push   $0x58
f0109c7a:	68 50 f2 12 f0       	push   $0xf012f250
f0109c7f:	e8 2b 73 ff ff       	call   f0100faf <_panic>

f0109c84 <kheap_physical_address>:

//=================================
// [4] FIND PA OF GIVEN VA:
//=================================
unsigned int kheap_physical_address(unsigned int virtual_address)
{
f0109c84:	55                   	push   %ebp
f0109c85:	89 e5                	mov    %esp,%ebp
f0109c87:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#2] KERNEL HEAP - #4 kheap_physical_address
	//Your code is here
	//Comment the following line
	panic("kheap_physical_address() is not implemented yet...!!");
f0109c8a:	83 ec 04             	sub    $0x4,%esp
f0109c8d:	68 e4 f2 12 f0       	push   $0xf012f2e4
f0109c92:	6a 65                	push   $0x65
f0109c94:	68 50 f2 12 f0       	push   $0xf012f250
f0109c99:	e8 11 73 ff ff       	call   f0100faf <_panic>

f0109c9e <krealloc>:
//	A call with new_size = zero is equivalent to kfree().

extern __inline__ uint32 get_block_size(void *va);

void *krealloc(void *virtual_address, uint32 new_size)
{
f0109c9e:	55                   	push   %ebp
f0109c9f:	89 e5                	mov    %esp,%ebp
f0109ca1:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - krealloc
	//Your code is here
	//Comment the following line
	panic("krealloc() is not implemented yet...!!");
f0109ca4:	83 ec 04             	sub    $0x4,%esp
f0109ca7:	68 1c f3 12 f0       	push   $0xf012f31c
f0109cac:	6a 7e                	push   $0x7e
f0109cae:	68 50 f2 12 f0       	push   $0xf012f250
f0109cb3:	e8 f7 72 ff ff       	call   f0100faf <_panic>

f0109cb8 <to_frame_info>:
{
	return to_frame_number(ptr_frame_info) << PGSHIFT;
}

static inline struct FrameInfo* to_frame_info(uint32 physical_address)
{
f0109cb8:	55                   	push   %ebp
f0109cb9:	89 e5                	mov    %esp,%ebp
f0109cbb:	83 ec 08             	sub    $0x8,%esp
	if (PPN(physical_address) >= number_of_frames)
f0109cbe:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cc1:	c1 e8 0c             	shr    $0xc,%eax
f0109cc4:	89 c2                	mov    %eax,%edx
f0109cc6:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0109ccb:	39 c2                	cmp    %eax,%edx
f0109ccd:	72 14                	jb     f0109ce3 <to_frame_info+0x2b>
		panic("to_frame_info called with invalid pa");
f0109ccf:	83 ec 04             	sub    $0x4,%esp
f0109cd2:	68 44 f3 12 f0       	push   $0xf012f344
f0109cd7:	6a 4e                	push   $0x4e
f0109cd9:	68 69 f3 12 f0       	push   $0xf012f369
f0109cde:	e8 cc 72 ff ff       	call   f0100faf <_panic>
	return &frames_info[PPN(physical_address)];
f0109ce3:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f0109ce9:	8b 45 08             	mov    0x8(%ebp),%eax
f0109cec:	c1 e8 0c             	shr    $0xc,%eax
f0109cef:	89 c1                	mov    %eax,%ecx
f0109cf1:	89 c8                	mov    %ecx,%eax
f0109cf3:	c1 e0 02             	shl    $0x2,%eax
f0109cf6:	01 c8                	add    %ecx,%eax
f0109cf8:	c1 e0 02             	shl    $0x2,%eax
f0109cfb:	01 d0                	add    %edx,%eax
}
f0109cfd:	c9                   	leave  
f0109cfe:	c3                   	ret    

f0109cff <pt_set_page_permissions>:
//	1. Set to 1 all "permissions_to_set"
//	2. Set to 0 all "permissions_to_reset"
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_set_page_permissions(uint32* directory, uint32 virtual_address, uint32 permissions_to_set, uint32 permissions_to_clear)
{
f0109cff:	55                   	push   %ebp
f0109d00:	89 e5                	mov    %esp,%ebp
f0109d02:	83 ec 18             	sub    $0x18,%esp
	//[1] Get the table
	uint32* ptr_page_table ;
	int ret = get_page_table(directory, virtual_address, &ptr_page_table);
f0109d05:	83 ec 04             	sub    $0x4,%esp
f0109d08:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109d0b:	50                   	push   %eax
f0109d0c:	ff 75 0c             	pushl  0xc(%ebp)
f0109d0f:	ff 75 08             	pushl  0x8(%ebp)
f0109d12:	e8 3c f6 ff ff       	call   f0109353 <get_page_table>
f0109d17:	83 c4 10             	add    $0x10,%esp
f0109d1a:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//[2] If exists, update permissions
	if (ptr_page_table != NULL)
f0109d1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d20:	85 c0                	test   %eax,%eax
f0109d22:	74 64                	je     f0109d88 <pt_set_page_permissions+0x89>
	{
		ptr_page_table[PTX(virtual_address)] |= (permissions_to_set);
f0109d24:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d27:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d2a:	c1 ea 0c             	shr    $0xc,%edx
f0109d2d:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d33:	c1 e2 02             	shl    $0x2,%edx
f0109d36:	01 c2                	add    %eax,%edx
f0109d38:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d3b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109d3e:	c1 e9 0c             	shr    $0xc,%ecx
f0109d41:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109d47:	c1 e1 02             	shl    $0x2,%ecx
f0109d4a:	01 c8                	add    %ecx,%eax
f0109d4c:	8b 00                	mov    (%eax),%eax
f0109d4e:	0b 45 10             	or     0x10(%ebp),%eax
f0109d51:	89 02                	mov    %eax,(%edx)
		ptr_page_table[PTX(virtual_address)] &= (~permissions_to_clear);
f0109d53:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109d56:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109d59:	c1 ea 0c             	shr    $0xc,%edx
f0109d5c:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0109d62:	c1 e2 02             	shl    $0x2,%edx
f0109d65:	01 d0                	add    %edx,%eax
f0109d67:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0109d6a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f0109d6d:	c1 e9 0c             	shr    $0xc,%ecx
f0109d70:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f0109d76:	c1 e1 02             	shl    $0x2,%ecx
f0109d79:	01 ca                	add    %ecx,%edx
f0109d7b:	8b 12                	mov    (%edx),%edx
f0109d7d:	8b 4d 14             	mov    0x14(%ebp),%ecx
f0109d80:	f7 d1                	not    %ecx
f0109d82:	21 ca                	and    %ecx,%edx
f0109d84:	89 10                	mov    %edx,(%eax)
f0109d86:	eb 27                	jmp    f0109daf <pt_set_page_permissions+0xb0>

	}
	//[3] Else, should "panic" since the table should be exist
	else
	{
		cprintf("va=%x not exist and has no page table\n", virtual_address);
f0109d88:	83 ec 08             	sub    $0x8,%esp
f0109d8b:	ff 75 0c             	pushl  0xc(%ebp)
f0109d8e:	68 84 f3 12 f0       	push   $0xf012f384
f0109d93:	e8 c4 7e ff ff       	call   f0101c5c <cprintf>
f0109d98:	83 c4 10             	add    $0x10,%esp
		//cprintf("[%s] va = %x\n", ptr_env->prog_name, virtual_address) ;
		panic("function pt_set_page_permissions() called with invalid virtual address. The corresponding page table doesn't exist\n") ;
f0109d9b:	83 ec 04             	sub    $0x4,%esp
f0109d9e:	68 ac f3 12 f0       	push   $0xf012f3ac
f0109da3:	6a 27                	push   $0x27
f0109da5:	68 20 f4 12 f0       	push   $0xf012f420
f0109daa:	e8 00 72 ff ff       	call   f0100faf <_panic>
	}

	//[4] Invalidate the cache memory (TLB) [call tlb_invalidate(..)]
	//tlb_invalidate(NULL, (void *)virtual_address);
	tlb_invalidate(directory, (void *)virtual_address);
f0109daf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109db2:	83 ec 08             	sub    $0x8,%esp
f0109db5:	50                   	push   %eax
f0109db6:	ff 75 08             	pushl  0x8(%ebp)
f0109db9:	e8 62 ef ff ff       	call   f0108d20 <tlb_invalidate>
f0109dbe:	83 c4 10             	add    $0x10,%esp
}
f0109dc1:	90                   	nop
f0109dc2:	c9                   	leave  
f0109dc3:	c3                   	ret    

f0109dc4 <pt_get_page_permissions>:
//2) GET PAGE PERMISSIONS
//===============================
//Should get ALL page permissions of the given VA
//If the page table not exist, return -1
inline int pt_get_page_permissions(uint32* directory, uint32 virtual_address )
{
f0109dc4:	55                   	push   %ebp
f0109dc5:	89 e5                	mov    %esp,%ebp
f0109dc7:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_get_page_permissions() is not implemented yet!");
f0109dca:	83 ec 04             	sub    $0x4,%esp
f0109dcd:	68 3c f4 12 f0       	push   $0xf012f43c
f0109dd2:	6a 38                	push   $0x38
f0109dd4:	68 20 f4 12 f0       	push   $0xf012f420
f0109dd9:	e8 d1 71 ff ff       	call   f0100faf <_panic>

f0109dde <pt_clear_page_table_entry>:
//Should clear the entire entry of the page table for the given VA
//If the page table not exist, return -1
//It's expected that the page table already exist. If not, the function should panic
//REMEMBER: to invalidate the TLB cache
inline void pt_clear_page_table_entry(uint32* directory, uint32 virtual_address)
{
f0109dde:	55                   	push   %ebp
f0109ddf:	89 e5                	mov    %esp,%ebp
f0109de1:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("pt_clear_page_table_entry() is not implemented yet!");
f0109de4:	83 ec 04             	sub    $0x4,%esp
f0109de7:	68 70 f4 12 f0       	push   $0xf012f470
f0109dec:	6a 46                	push   $0x46
f0109dee:	68 20 f4 12 f0       	push   $0xf012f420
f0109df3:	e8 b7 71 ff ff       	call   f0100faf <_panic>

f0109df8 <virtual_to_physical>:
//1) ADDRESS CONVERTION (VA->PA)
//===============================
//return the physical address corresponding to given virtual_address
//If the page or the page table is not present, return -1
inline uint32 virtual_to_physical(uint32* directory, uint32 virtual_address)
{
f0109df8:	55                   	push   %ebp
f0109df9:	89 e5                	mov    %esp,%ebp
f0109dfb:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109dfe:	83 ec 04             	sub    $0x4,%esp
f0109e01:	68 a4 f4 12 f0       	push   $0xf012f4a4
f0109e06:	6a 58                	push   $0x58
f0109e08:	68 20 f4 12 f0       	push   $0xf012f420
f0109e0d:	e8 9d 71 ff ff       	call   f0100faf <_panic>

f0109e12 <physical_to_virtual>:
//===============================
//return the VIRTUAL address corresponding to given physical address
//If multiple VA's, return the first occurrence
//If not found, return 0xFFFFFFFF
inline uint32 physical_to_virtual(uint32* directory, uint32 physical_address)
{
f0109e12:	55                   	push   %ebp
f0109e13:	89 e5                	mov    %esp,%ebp
f0109e15:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109e18:	83 ec 04             	sub    $0x4,%esp
f0109e1b:	68 a4 f4 12 f0       	push   $0xf012f4a4
f0109e20:	6a 65                	push   $0x65
f0109e22:	68 20 f4 12 f0       	push   $0xf012f420
f0109e27:	e8 83 71 ff ff       	call   f0100faf <_panic>

f0109e2c <num_of_references>:
//===============================
//3) NUMBER OF REFERENCES
//===============================
//return the number of page references on the frame at the given physical address
inline uint32 num_of_references(uint32 physical_address)
{
f0109e2c:	55                   	push   %ebp
f0109e2d:	89 e5                	mov    %esp,%ebp
f0109e2f:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#1: fill this function.
	//Comment the following line
//	panic("Function is not implemented yet!");
	struct FrameInfo* ptr_fi = to_frame_info(physical_address);
f0109e32:	83 ec 0c             	sub    $0xc,%esp
f0109e35:	ff 75 08             	pushl  0x8(%ebp)
f0109e38:	e8 7b fe ff ff       	call   f0109cb8 <to_frame_info>
f0109e3d:	83 c4 10             	add    $0x10,%esp
f0109e40:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return ptr_fi->references;
f0109e43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0109e46:	8b 40 08             	mov    0x8(%eax),%eax
f0109e49:	0f b7 c0             	movzwl %ax,%eax
}
f0109e4c:	c9                   	leave  
f0109e4d:	c3                   	ret    

f0109e4e <alloc_page>:
//	0 on success,
//	1 if already mapped
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_page(uint32* directory, uint32 va, uint32 perms, bool set_to_zero)
{
f0109e4e:	55                   	push   %ebp
f0109e4f:	89 e5                	mov    %esp,%ebp
f0109e51:	83 ec 18             	sub    $0x18,%esp
	//TODO: LAB4 Example#2: fill this function.
	//Comment the following line
	//panic("Function is not implemented yet!");
	uint32* ptr_table ;
	struct FrameInfo* ptr_fi = get_frame_info(directory, va, &ptr_table);
f0109e54:	83 ec 04             	sub    $0x4,%esp
f0109e57:	8d 45 f0             	lea    -0x10(%ebp),%eax
f0109e5a:	50                   	push   %eax
f0109e5b:	ff 75 0c             	pushl  0xc(%ebp)
f0109e5e:	ff 75 08             	pushl  0x8(%ebp)
f0109e61:	e8 67 f8 ff ff       	call   f01096cd <get_frame_info>
f0109e66:	83 c4 10             	add    $0x10,%esp
f0109e69:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if (ptr_fi != NULL) {
f0109e6c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e6f:	85 c0                	test   %eax,%eax
f0109e71:	74 07                	je     f0109e7a <alloc_page+0x2c>
		return 1;
f0109e73:	b8 01 00 00 00       	mov    $0x1,%eax
f0109e78:	eb 75                	jmp    f0109eef <alloc_page+0xa1>
	}
	else {
		int ret = allocate_frame(&ptr_fi);
f0109e7a:	83 ec 0c             	sub    $0xc,%esp
f0109e7d:	8d 45 ec             	lea    -0x14(%ebp),%eax
f0109e80:	50                   	push   %eax
f0109e81:	e8 bc f2 ff ff       	call   f0109142 <allocate_frame>
f0109e86:	83 c4 10             	add    $0x10,%esp
f0109e89:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f0109e8c:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0109e90:	75 07                	jne    f0109e99 <alloc_page+0x4b>
			return E_NO_MEM;
f0109e92:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0109e97:	eb 56                	jmp    f0109eef <alloc_page+0xa1>
		}
		ret = map_frame(directory, ptr_fi, va, perms);
f0109e99:	8b 55 10             	mov    0x10(%ebp),%edx
f0109e9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109e9f:	52                   	push   %edx
f0109ea0:	ff 75 0c             	pushl  0xc(%ebp)
f0109ea3:	50                   	push   %eax
f0109ea4:	ff 75 08             	pushl  0x8(%ebp)
f0109ea7:	e8 37 f7 ff ff       	call   f01095e3 <map_frame>
f0109eac:	83 c4 10             	add    $0x10,%esp
f0109eaf:	89 45 f4             	mov    %eax,-0xc(%ebp)
		if (ret == E_NO_MEM) {
f0109eb2:	83 7d f4 fc          	cmpl   $0xfffffffc,-0xc(%ebp)
f0109eb6:	75 16                	jne    f0109ece <alloc_page+0x80>
			free_frame(ptr_fi);
f0109eb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109ebb:	83 ec 0c             	sub    $0xc,%esp
f0109ebe:	50                   	push   %eax
f0109ebf:	e8 a6 f3 ff ff       	call   f010926a <free_frame>
f0109ec4:	83 c4 10             	add    $0x10,%esp
			return E_NO_MEM;
f0109ec7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
f0109ecc:	eb 21                	jmp    f0109eef <alloc_page+0xa1>
		}
		if (set_to_zero) {
f0109ece:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0109ed2:	74 16                	je     f0109eea <alloc_page+0x9c>
			memset((void*)va, 0, PAGE_SIZE);
f0109ed4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109ed7:	83 ec 04             	sub    $0x4,%esp
f0109eda:	68 00 10 00 00       	push   $0x1000
f0109edf:	6a 00                	push   $0x0
f0109ee1:	50                   	push   %eax
f0109ee2:	e8 82 0e 01 00       	call   f011ad69 <memset>
f0109ee7:	83 c4 10             	add    $0x10,%esp
		}
		return 0;
f0109eea:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0109eef:	c9                   	leave  
f0109ef0:	c3                   	ret    

f0109ef1 <alloc_shared_page>:
//Return
//	0 on success,
//  E_NO_MEM if no memory
//HINT: remember to free the allocated frame if there is no space for the necessary page table
inline int alloc_shared_page(uint32* page_dir1, uint32 va1,uint32* page_dir2, uint32 va2, uint32 perms)
{
f0109ef1:	55                   	push   %ebp
f0109ef2:	89 e5                	mov    %esp,%ebp
f0109ef4:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("Function is not implemented yet!");
f0109ef7:	83 ec 04             	sub    $0x4,%esp
f0109efa:	68 a4 f4 12 f0       	push   $0xf012f4a4
f0109eff:	68 a9 00 00 00       	push   $0xa9
f0109f04:	68 20 f4 12 f0       	push   $0xf012f420
f0109f09:	e8 a1 70 ff ff       	call   f0100faf <_panic>

f0109f0e <del_page_table>:
//	1. removing the link between the directory and the table and
//	2. adding the frame of the table to the free frame list.

//REMEMBER: to invalidate the TLB cache
inline void del_page_table(uint32* page_dir, uint32 va)
{
f0109f0e:	55                   	push   %ebp
f0109f0f:	89 e5                	mov    %esp,%ebp
f0109f11:	83 ec 18             	sub    $0x18,%esp
	//Comment the following line
	//panic("Function is not implemented yet!");

	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);
f0109f14:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109f19:	83 ec 04             	sub    $0x4,%esp
f0109f1c:	8d 55 ec             	lea    -0x14(%ebp),%edx
f0109f1f:	52                   	push   %edx
f0109f20:	ff 75 0c             	pushl  0xc(%ebp)
f0109f23:	50                   	push   %eax
f0109f24:	e8 2a f4 ff ff       	call   f0109353 <get_page_table>
f0109f29:	83 c4 10             	add    $0x10,%esp

	if (ptr_page_table == NULL)
f0109f2c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109f2f:	85 c0                	test   %eax,%eax
f0109f31:	74 39                	je     f0109f6c <del_page_table+0x5e>
		return ;

#if USE_KHEAP
	// directly remove the page table from the kernel heap
	kfree(ptr_page_table);
f0109f33:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0109f36:	83 ec 0c             	sub    $0xc,%esp
f0109f39:	50                   	push   %eax
f0109f3a:	e8 11 fd ff ff       	call   f0109c50 <kfree>
f0109f3f:	83 c4 10             	add    $0x10,%esp
	table_frame_info->references = 0;
	free_frame(table_frame_info);
#endif

	// set the corresponding entry in the directory to 0
	uint32 dir_index = PDX(va);
f0109f42:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f45:	c1 e8 16             	shr    $0x16,%eax
f0109f48:	89 45 f4             	mov    %eax,-0xc(%ebp)
	ptr_page_directory[dir_index] = 0;
f0109f4b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0109f50:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0109f53:	c1 e2 02             	shl    $0x2,%edx
f0109f56:	01 d0                	add    %edx,%eax
f0109f58:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109f5e:	0f 20 d8             	mov    %cr3,%eax
f0109f61:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109f64:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0109f67:	0f 22 d8             	mov    %eax,%cr3
f0109f6a:	eb 01                	jmp    f0109f6d <del_page_table+0x5f>
	// get the page table of the given virtual address
	uint32 * ptr_page_table ;
	get_page_table(ptr_page_directory, va, &ptr_page_table);

	if (ptr_page_table == NULL)
		return ;
f0109f6c:	90                   	nop
	uint32 dir_index = PDX(va);
	ptr_page_directory[dir_index] = 0;

	//clear the TLB cache
	tlbflush();
}
f0109f6d:	c9                   	leave  
f0109f6e:	c3                   	ret    

f0109f6f <pd_is_table_used>:

///============================================================================================
/// Dealing with page directory entry flags

inline uint32 pd_is_table_used(uint32* directory, uint32 virtual_address)
{
f0109f6f:	55                   	push   %ebp
f0109f70:	89 e5                	mov    %esp,%ebp
	return ( (directory[PDX(virtual_address)] & PERM_USED) == PERM_USED ? 1 : 0);
f0109f72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f75:	c1 e8 16             	shr    $0x16,%eax
f0109f78:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109f7f:	8b 45 08             	mov    0x8(%ebp),%eax
f0109f82:	01 d0                	add    %edx,%eax
f0109f84:	8b 00                	mov    (%eax),%eax
f0109f86:	83 e0 20             	and    $0x20,%eax
f0109f89:	85 c0                	test   %eax,%eax
f0109f8b:	0f 95 c0             	setne  %al
f0109f8e:	0f b6 c0             	movzbl %al,%eax
}
f0109f91:	5d                   	pop    %ebp
f0109f92:	c3                   	ret    

f0109f93 <pd_set_table_unused>:

inline void pd_set_table_unused(uint32* directory, uint32 virtual_address)
{
f0109f93:	55                   	push   %ebp
f0109f94:	89 e5                	mov    %esp,%ebp
f0109f96:	83 ec 08             	sub    $0x8,%esp
	directory[PDX(virtual_address)] &= (~PERM_USED);
f0109f99:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109f9c:	c1 e8 16             	shr    $0x16,%eax
f0109f9f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109fa6:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fa9:	01 d0                	add    %edx,%eax
f0109fab:	8b 55 0c             	mov    0xc(%ebp),%edx
f0109fae:	c1 ea 16             	shr    $0x16,%edx
f0109fb1:	8d 0c 95 00 00 00 00 	lea    0x0(,%edx,4),%ecx
f0109fb8:	8b 55 08             	mov    0x8(%ebp),%edx
f0109fbb:	01 ca                	add    %ecx,%edx
f0109fbd:	8b 12                	mov    (%edx),%edx
f0109fbf:	83 e2 df             	and    $0xffffffdf,%edx
f0109fc2:	89 10                	mov    %edx,(%eax)
	tlb_invalidate((void *)NULL, (void *)virtual_address);
f0109fc4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109fc7:	83 ec 08             	sub    $0x8,%esp
f0109fca:	50                   	push   %eax
f0109fcb:	6a 00                	push   $0x0
f0109fcd:	e8 4e ed ff ff       	call   f0108d20 <tlb_invalidate>
f0109fd2:	83 c4 10             	add    $0x10,%esp
}
f0109fd5:	90                   	nop
f0109fd6:	c9                   	leave  
f0109fd7:	c3                   	ret    

f0109fd8 <pd_clear_page_dir_entry>:

inline void pd_clear_page_dir_entry(uint32* directory, uint32 virtual_address)
{
f0109fd8:	55                   	push   %ebp
f0109fd9:	89 e5                	mov    %esp,%ebp
f0109fdb:	83 ec 10             	sub    $0x10,%esp
	directory[PDX(virtual_address)] = 0 ;
f0109fde:	8b 45 0c             	mov    0xc(%ebp),%eax
f0109fe1:	c1 e8 16             	shr    $0x16,%eax
f0109fe4:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0109feb:	8b 45 08             	mov    0x8(%ebp),%eax
f0109fee:	01 d0                	add    %edx,%eax
f0109ff0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f0109ff6:	0f 20 d8             	mov    %cr3,%eax
f0109ff9:	89 45 fc             	mov    %eax,-0x4(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f0109ffc:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0109fff:	0f 22 d8             	mov    %eax,%cr3
	tlbflush();
}
f010a002:	90                   	nop
f010a003:	c9                   	leave  
f010a004:	c3                   	ret    

f010a005 <env_page_ws_list_create_element>:
//==============================
// [1] CREATE A NEW WS ELEMENT
//==============================
//If failed to create a new one, kernel should panic()!
inline struct WorkingSetElement* env_page_ws_list_create_element(struct Env* e, uint32 virtual_address)
{
f010a005:	55                   	push   %ebp
f010a006:	89 e5                	mov    %esp,%ebp
f010a008:	83 ec 18             	sub    $0x18,%esp
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010a00b:	81 7d 0c ff ff bf ee 	cmpl   $0xeebfffff,0xc(%ebp)
f010a012:	76 16                	jbe    f010a02a <env_page_ws_list_create_element+0x25>
f010a014:	68 c8 f4 12 f0       	push   $0xf012f4c8
f010a019:	68 fb f4 12 f0       	push   $0xf012f4fb
f010a01e:	6a 16                	push   $0x16
f010a020:	68 10 f5 12 f0       	push   $0xf012f510
f010a025:	e8 85 6f ff ff       	call   f0100faf <_panic>
	struct WorkingSetElement *wse = kmalloc(sizeof(struct WorkingSetElement)) ;
f010a02a:	83 ec 0c             	sub    $0xc,%esp
f010a02d:	6a 18                	push   $0x18
f010a02f:	e8 02 fc ff ff       	call   f0109c36 <kmalloc>
f010a034:	83 c4 10             	add    $0x10,%esp
f010a037:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (wse == NULL)
f010a03a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a03e:	75 14                	jne    f010a054 <env_page_ws_list_create_element+0x4f>
	{
		panic("can't create a new WS element");
f010a040:	83 ec 04             	sub    $0x4,%esp
f010a043:	68 2f f5 12 f0       	push   $0xf012f52f
f010a048:	6a 1a                	push   $0x1a
f010a04a:	68 10 f5 12 f0       	push   $0xf012f510
f010a04f:	e8 5b 6f ff ff       	call   f0100faf <_panic>
	}
	wse->virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE);
f010a054:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a057:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a05a:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a05d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a062:	89 c2                	mov    %eax,%edx
f010a064:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a067:	89 10                	mov    %edx,(%eax)
	wse->sweeps_counter = 0;
f010a069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a06c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
	wse->time_stamp = 0x00000000;
f010a073:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a076:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	return wse;
f010a07d:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010a080:	c9                   	leave  
f010a081:	c3                   	ret    

f010a082 <env_page_ws_invalidate>:
inline void env_page_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a082:	55                   	push   %ebp
f010a083:	89 e5                	mov    %esp,%ebp
f010a085:	83 ec 38             	sub    $0x38,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a088:	83 ec 0c             	sub    $0xc,%esp
f010a08b:	6a 02                	push   $0x2
f010a08d:	e8 91 58 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010a092:	83 c4 10             	add    $0x10,%esp
f010a095:	85 c0                	test   %eax,%eax
f010a097:	0f 84 e5 03 00 00    	je     f010a482 <env_page_ws_invalidate+0x400>
	{
		bool found = 0;
f010a09d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct WorkingSetElement *ptr_WS_element = NULL;
f010a0a4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a0ab:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0ae:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a0b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a0b7:	e9 3b 02 00 00       	jmp    f010a2f7 <env_page_ws_invalidate+0x275>
		{
			if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a0bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0bf:	8b 00                	mov    (%eax),%eax
f010a0c1:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a0c4:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a0c7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a0cc:	89 c2                	mov    %eax,%edx
f010a0ce:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a0d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010a0d4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010a0d7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a0dc:	39 c2                	cmp    %eax,%edx
f010a0de:	0f 85 07 02 00 00    	jne    f010a2eb <env_page_ws_invalidate+0x269>
			{
				struct WorkingSetElement* ptr_tmp_WS_element = LIST_FIRST(&(e->SecondList));
f010a0e4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0e7:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a0ed:	89 45 e0             	mov    %eax,-0x20(%ebp)
				unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a0f0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a0f3:	8b 10                	mov    (%eax),%edx
f010a0f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a0f8:	8b 40 64             	mov    0x64(%eax),%eax
f010a0fb:	83 ec 08             	sub    $0x8,%esp
f010a0fe:	52                   	push   %edx
f010a0ff:	50                   	push   %eax
f010a100:	e8 4a f6 ff ff       	call   f010974f <unmap_frame>
f010a105:	83 c4 10             	add    $0x10,%esp

				LIST_REMOVE(&(e->ActiveList), ptr_WS_element);
f010a108:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a10c:	75 14                	jne    f010a122 <env_page_ws_invalidate+0xa0>
f010a10e:	83 ec 04             	sub    $0x4,%esp
f010a111:	68 4d f5 12 f0       	push   $0xf012f54d
f010a116:	6a 2e                	push   $0x2e
f010a118:	68 10 f5 12 f0       	push   $0xf012f510
f010a11d:	e8 8d 6e ff ff       	call   f0100faf <_panic>
f010a122:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a125:	8b 40 10             	mov    0x10(%eax),%eax
f010a128:	85 c0                	test   %eax,%eax
f010a12a:	74 11                	je     f010a13d <env_page_ws_invalidate+0xbb>
f010a12c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a12f:	8b 40 10             	mov    0x10(%eax),%eax
f010a132:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a135:	8b 52 14             	mov    0x14(%edx),%edx
f010a138:	89 50 14             	mov    %edx,0x14(%eax)
f010a13b:	eb 0f                	jmp    f010a14c <env_page_ws_invalidate+0xca>
f010a13d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a140:	8b 50 14             	mov    0x14(%eax),%edx
f010a143:	8b 45 08             	mov    0x8(%ebp),%eax
f010a146:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a14c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a14f:	8b 40 14             	mov    0x14(%eax),%eax
f010a152:	85 c0                	test   %eax,%eax
f010a154:	74 11                	je     f010a167 <env_page_ws_invalidate+0xe5>
f010a156:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a159:	8b 40 14             	mov    0x14(%eax),%eax
f010a15c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a15f:	8b 52 10             	mov    0x10(%edx),%edx
f010a162:	89 50 10             	mov    %edx,0x10(%eax)
f010a165:	eb 0f                	jmp    f010a176 <env_page_ws_invalidate+0xf4>
f010a167:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a16a:	8b 50 10             	mov    0x10(%eax),%edx
f010a16d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a170:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a176:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a179:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a180:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a183:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a18a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a18d:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a193:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a196:	8b 45 08             	mov    0x8(%ebp),%eax
f010a199:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)

				/*EDIT*/kfree(ptr_WS_element);
f010a19f:	83 ec 0c             	sub    $0xc,%esp
f010a1a2:	ff 75 f0             	pushl  -0x10(%ebp)
f010a1a5:	e8 a6 fa ff ff       	call   f0109c50 <kfree>
f010a1aa:	83 c4 10             	add    $0x10,%esp

				if(ptr_tmp_WS_element != NULL)
f010a1ad:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a1b1:	0f 84 2b 01 00 00    	je     f010a2e2 <env_page_ws_invalidate+0x260>
				{
					LIST_REMOVE(&(e->SecondList), ptr_tmp_WS_element);
f010a1b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a1bb:	75 14                	jne    f010a1d1 <env_page_ws_invalidate+0x14f>
f010a1bd:	83 ec 04             	sub    $0x4,%esp
f010a1c0:	68 4d f5 12 f0       	push   $0xf012f54d
f010a1c5:	6a 34                	push   $0x34
f010a1c7:	68 10 f5 12 f0       	push   $0xf012f510
f010a1cc:	e8 de 6d ff ff       	call   f0100faf <_panic>
f010a1d1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1d4:	8b 40 10             	mov    0x10(%eax),%eax
f010a1d7:	85 c0                	test   %eax,%eax
f010a1d9:	74 11                	je     f010a1ec <env_page_ws_invalidate+0x16a>
f010a1db:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1de:	8b 40 10             	mov    0x10(%eax),%eax
f010a1e1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a1e4:	8b 52 14             	mov    0x14(%edx),%edx
f010a1e7:	89 50 14             	mov    %edx,0x14(%eax)
f010a1ea:	eb 0f                	jmp    f010a1fb <env_page_ws_invalidate+0x179>
f010a1ec:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1ef:	8b 50 14             	mov    0x14(%eax),%edx
f010a1f2:	8b 45 08             	mov    0x8(%ebp),%eax
f010a1f5:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010a1fb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a1fe:	8b 40 14             	mov    0x14(%eax),%eax
f010a201:	85 c0                	test   %eax,%eax
f010a203:	74 11                	je     f010a216 <env_page_ws_invalidate+0x194>
f010a205:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a208:	8b 40 14             	mov    0x14(%eax),%eax
f010a20b:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a20e:	8b 52 10             	mov    0x10(%edx),%edx
f010a211:	89 50 10             	mov    %edx,0x10(%eax)
f010a214:	eb 0f                	jmp    f010a225 <env_page_ws_invalidate+0x1a3>
f010a216:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a219:	8b 50 10             	mov    0x10(%eax),%edx
f010a21c:	8b 45 08             	mov    0x8(%ebp),%eax
f010a21f:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a225:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a228:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a22f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a232:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a239:	8b 45 08             	mov    0x8(%ebp),%eax
f010a23c:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010a242:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a245:	8b 45 08             	mov    0x8(%ebp),%eax
f010a248:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
					LIST_INSERT_TAIL(&(e->ActiveList), ptr_tmp_WS_element);
f010a24e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010a252:	75 14                	jne    f010a268 <env_page_ws_invalidate+0x1e6>
f010a254:	83 ec 04             	sub    $0x4,%esp
f010a257:	68 6c f5 12 f0       	push   $0xf012f56c
f010a25c:	6a 35                	push   $0x35
f010a25e:	68 10 f5 12 f0       	push   $0xf012f510
f010a263:	e8 47 6d ff ff       	call   f0100faf <_panic>
f010a268:	8b 45 08             	mov    0x8(%ebp),%eax
f010a26b:	8b 90 6c 05 00 00    	mov    0x56c(%eax),%edx
f010a271:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a274:	89 50 14             	mov    %edx,0x14(%eax)
f010a277:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a27a:	8b 40 14             	mov    0x14(%eax),%eax
f010a27d:	85 c0                	test   %eax,%eax
f010a27f:	74 11                	je     f010a292 <env_page_ws_invalidate+0x210>
f010a281:	8b 45 08             	mov    0x8(%ebp),%eax
f010a284:	8b 80 6c 05 00 00    	mov    0x56c(%eax),%eax
f010a28a:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a28d:	89 50 10             	mov    %edx,0x10(%eax)
f010a290:	eb 0c                	jmp    f010a29e <env_page_ws_invalidate+0x21c>
f010a292:	8b 45 08             	mov    0x8(%ebp),%eax
f010a295:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a298:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010a29e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2a1:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010a2a4:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010a2aa:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a2ad:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a2b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2b7:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010a2bd:	8d 50 01             	lea    0x1(%eax),%edx
f010a2c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2c3:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
					pt_set_page_permissions(e->env_page_directory, ptr_tmp_WS_element->virtual_address, PERM_PRESENT, 0);
f010a2c9:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010a2cc:	8b 10                	mov    (%eax),%edx
f010a2ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2d1:	8b 40 64             	mov    0x64(%eax),%eax
f010a2d4:	6a 00                	push   $0x0
f010a2d6:	6a 01                	push   $0x1
f010a2d8:	52                   	push   %edx
f010a2d9:	50                   	push   %eax
f010a2da:	e8 20 fa ff ff       	call   f0109cff <pt_set_page_permissions>
f010a2df:	83 c4 10             	add    $0x10,%esp
				}
				found = 1;
f010a2e2:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
				break;
f010a2e9:	eb 43                	jmp    f010a32e <env_page_ws_invalidate+0x2ac>
{
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		bool found = 0;
		struct WorkingSetElement *ptr_WS_element = NULL;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a2eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a2ee:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a2f4:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a2f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a2fb:	74 08                	je     f010a305 <env_page_ws_invalidate+0x283>
f010a2fd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a300:	8b 40 10             	mov    0x10(%eax),%eax
f010a303:	eb 05                	jmp    f010a30a <env_page_ws_invalidate+0x288>
f010a305:	b8 00 00 00 00       	mov    $0x0,%eax
f010a30a:	8b 55 08             	mov    0x8(%ebp),%edx
f010a30d:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f010a313:	8b 45 08             	mov    0x8(%ebp),%eax
f010a316:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a31c:	85 c0                	test   %eax,%eax
f010a31e:	0f 85 98 fd ff ff    	jne    f010a0bc <env_page_ws_invalidate+0x3a>
f010a324:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a328:	0f 85 8e fd ff ff    	jne    f010a0bc <env_page_ws_invalidate+0x3a>
				found = 1;
				break;
			}
		}

		if (!found)
f010a32e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010a332:	0f 85 a4 02 00 00    	jne    f010a5dc <env_page_ws_invalidate+0x55a>
		{
			ptr_WS_element = NULL;
f010a338:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a33f:	8b 45 08             	mov    0x8(%ebp),%eax
f010a342:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a348:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a34b:	e9 f6 00 00 00       	jmp    f010a446 <env_page_ws_invalidate+0x3c4>
			{
				if(ROUNDDOWN(ptr_WS_element->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a350:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a353:	8b 00                	mov    (%eax),%eax
f010a355:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010a358:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a35b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a360:	89 c2                	mov    %eax,%edx
f010a362:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a365:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010a368:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010a36b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a370:	39 c2                	cmp    %eax,%edx
f010a372:	0f 85 c2 00 00 00    	jne    f010a43a <env_page_ws_invalidate+0x3b8>
				{
					unmap_frame(e->env_page_directory, ptr_WS_element->virtual_address);
f010a378:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a37b:	8b 10                	mov    (%eax),%edx
f010a37d:	8b 45 08             	mov    0x8(%ebp),%eax
f010a380:	8b 40 64             	mov    0x64(%eax),%eax
f010a383:	83 ec 08             	sub    $0x8,%esp
f010a386:	52                   	push   %edx
f010a387:	50                   	push   %eax
f010a388:	e8 c2 f3 ff ff       	call   f010974f <unmap_frame>
f010a38d:	83 c4 10             	add    $0x10,%esp
					LIST_REMOVE(&(e->SecondList), ptr_WS_element);
f010a390:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a394:	75 14                	jne    f010a3aa <env_page_ws_invalidate+0x328>
f010a396:	83 ec 04             	sub    $0x4,%esp
f010a399:	68 4d f5 12 f0       	push   $0xf012f54d
f010a39e:	6a 45                	push   $0x45
f010a3a0:	68 10 f5 12 f0       	push   $0xf012f510
f010a3a5:	e8 05 6c ff ff       	call   f0100faf <_panic>
f010a3aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3ad:	8b 40 10             	mov    0x10(%eax),%eax
f010a3b0:	85 c0                	test   %eax,%eax
f010a3b2:	74 11                	je     f010a3c5 <env_page_ws_invalidate+0x343>
f010a3b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3b7:	8b 40 10             	mov    0x10(%eax),%eax
f010a3ba:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a3bd:	8b 52 14             	mov    0x14(%edx),%edx
f010a3c0:	89 50 14             	mov    %edx,0x14(%eax)
f010a3c3:	eb 0f                	jmp    f010a3d4 <env_page_ws_invalidate+0x352>
f010a3c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3c8:	8b 50 14             	mov    0x14(%eax),%edx
f010a3cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3ce:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010a3d4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3d7:	8b 40 14             	mov    0x14(%eax),%eax
f010a3da:	85 c0                	test   %eax,%eax
f010a3dc:	74 11                	je     f010a3ef <env_page_ws_invalidate+0x36d>
f010a3de:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3e1:	8b 40 14             	mov    0x14(%eax),%eax
f010a3e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010a3e7:	8b 52 10             	mov    0x10(%edx),%edx
f010a3ea:	89 50 10             	mov    %edx,0x10(%eax)
f010a3ed:	eb 0f                	jmp    f010a3fe <env_page_ws_invalidate+0x37c>
f010a3ef:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a3f2:	8b 50 10             	mov    0x10(%eax),%edx
f010a3f5:	8b 45 08             	mov    0x8(%ebp),%eax
f010a3f8:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010a3fe:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a401:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a408:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a40b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a412:	8b 45 08             	mov    0x8(%ebp),%eax
f010a415:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010a41b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a41e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a421:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

					kfree(ptr_WS_element);
f010a427:	83 ec 0c             	sub    $0xc,%esp
f010a42a:	ff 75 f0             	pushl  -0x10(%ebp)
f010a42d:	e8 1e f8 ff ff       	call   f0109c50 <kfree>
f010a432:	83 c4 10             	add    $0x10,%esp

					/*EDIT*/break;
f010a435:	e9 a2 01 00 00       	jmp    f010a5dc <env_page_ws_invalidate+0x55a>
		}

		if (!found)
		{
			ptr_WS_element = NULL;
			LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a43a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a43d:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a443:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a446:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a44a:	74 08                	je     f010a454 <env_page_ws_invalidate+0x3d2>
f010a44c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a44f:	8b 40 10             	mov    0x10(%eax),%eax
f010a452:	eb 05                	jmp    f010a459 <env_page_ws_invalidate+0x3d7>
f010a454:	b8 00 00 00 00       	mov    $0x0,%eax
f010a459:	8b 55 08             	mov    0x8(%ebp),%edx
f010a45c:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f010a462:	8b 45 08             	mov    0x8(%ebp),%eax
f010a465:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a46b:	85 c0                	test   %eax,%eax
f010a46d:	0f 85 dd fe ff ff    	jne    f010a350 <env_page_ws_invalidate+0x2ce>
f010a473:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a477:	0f 85 d3 fe ff ff    	jne    f010a350 <env_page_ws_invalidate+0x2ce>

				break;
			}
		}
	}
}
f010a47d:	e9 5a 01 00 00       	jmp    f010a5dc <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a482:	8b 45 08             	mov    0x8(%ebp),%eax
f010a485:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a48b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a48e:	e9 10 01 00 00       	jmp    f010a5a3 <env_page_ws_invalidate+0x521>
		{
			if(ROUNDDOWN(wse->virtual_address,PAGE_SIZE) == ROUNDDOWN(virtual_address,PAGE_SIZE))
f010a493:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a496:	8b 00                	mov    (%eax),%eax
f010a498:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f010a49b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010a49e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a4a3:	89 c2                	mov    %eax,%edx
f010a4a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010a4a8:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010a4ab:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010a4ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010a4b3:	39 c2                	cmp    %eax,%edx
f010a4b5:	0f 85 dc 00 00 00    	jne    f010a597 <env_page_ws_invalidate+0x515>
			{
				unmap_frame(e->env_page_directory, wse->virtual_address);
f010a4bb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a4be:	8b 10                	mov    (%eax),%edx
f010a4c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4c3:	8b 40 64             	mov    0x64(%eax),%eax
f010a4c6:	83 ec 08             	sub    $0x8,%esp
f010a4c9:	52                   	push   %edx
f010a4ca:	50                   	push   %eax
f010a4cb:	e8 7f f2 ff ff       	call   f010974f <unmap_frame>
f010a4d0:	83 c4 10             	add    $0x10,%esp

				if (e->page_last_WS_element == wse)
f010a4d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4d6:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010a4dc:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a4df:	75 0f                	jne    f010a4f0 <env_page_ws_invalidate+0x46e>
				{
					e->page_last_WS_element = LIST_NEXT(wse);
f010a4e1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a4e4:	8b 50 10             	mov    0x10(%eax),%edx
f010a4e7:	8b 45 08             	mov    0x8(%ebp),%eax
f010a4ea:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
				}
				LIST_REMOVE(&(e->page_WS_list), wse);
f010a4f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a4f4:	75 14                	jne    f010a50a <env_page_ws_invalidate+0x488>
f010a4f6:	83 ec 04             	sub    $0x4,%esp
f010a4f9:	68 4d f5 12 f0       	push   $0xf012f54d
f010a4fe:	6a 5b                	push   $0x5b
f010a500:	68 10 f5 12 f0       	push   $0xf012f510
f010a505:	e8 a5 6a ff ff       	call   f0100faf <_panic>
f010a50a:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a50d:	8b 40 10             	mov    0x10(%eax),%eax
f010a510:	85 c0                	test   %eax,%eax
f010a512:	74 11                	je     f010a525 <env_page_ws_invalidate+0x4a3>
f010a514:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a517:	8b 40 10             	mov    0x10(%eax),%eax
f010a51a:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a51d:	8b 52 14             	mov    0x14(%edx),%edx
f010a520:	89 50 14             	mov    %edx,0x14(%eax)
f010a523:	eb 0f                	jmp    f010a534 <env_page_ws_invalidate+0x4b2>
f010a525:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a528:	8b 50 14             	mov    0x14(%eax),%edx
f010a52b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a52e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010a534:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a537:	8b 40 14             	mov    0x14(%eax),%eax
f010a53a:	85 c0                	test   %eax,%eax
f010a53c:	74 11                	je     f010a54f <env_page_ws_invalidate+0x4cd>
f010a53e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a541:	8b 40 14             	mov    0x14(%eax),%eax
f010a544:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010a547:	8b 52 10             	mov    0x10(%edx),%edx
f010a54a:	89 50 10             	mov    %edx,0x10(%eax)
f010a54d:	eb 0f                	jmp    f010a55e <env_page_ws_invalidate+0x4dc>
f010a54f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a552:	8b 50 10             	mov    0x10(%eax),%edx
f010a555:	8b 45 08             	mov    0x8(%ebp),%eax
f010a558:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010a55e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a561:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010a568:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a56b:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010a572:	8b 45 08             	mov    0x8(%ebp),%eax
f010a575:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010a57b:	8d 50 ff             	lea    -0x1(%eax),%edx
f010a57e:	8b 45 08             	mov    0x8(%ebp),%eax
f010a581:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)

				kfree(wse);
f010a587:	83 ec 0c             	sub    $0xc,%esp
f010a58a:	ff 75 ec             	pushl  -0x14(%ebp)
f010a58d:	e8 be f6 ff ff       	call   f0109c50 <kfree>
f010a592:	83 c4 10             	add    $0x10,%esp

				break;
f010a595:	eb 45                	jmp    f010a5dc <env_page_ws_invalidate+0x55a>
		}
	}
	else
	{
		struct WorkingSetElement *wse;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a597:	8b 45 08             	mov    0x8(%ebp),%eax
f010a59a:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a5a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010a5a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a5a7:	74 08                	je     f010a5b1 <env_page_ws_invalidate+0x52f>
f010a5a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010a5ac:	8b 40 10             	mov    0x10(%eax),%eax
f010a5af:	eb 05                	jmp    f010a5b6 <env_page_ws_invalidate+0x534>
f010a5b1:	b8 00 00 00 00       	mov    $0x0,%eax
f010a5b6:	8b 55 08             	mov    0x8(%ebp),%edx
f010a5b9:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010a5bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010a5c2:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a5c8:	85 c0                	test   %eax,%eax
f010a5ca:	0f 85 c3 fe ff ff    	jne    f010a493 <env_page_ws_invalidate+0x411>
f010a5d0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010a5d4:	0f 85 b9 fe ff ff    	jne    f010a493 <env_page_ws_invalidate+0x411>

				break;
			}
		}
	}
}
f010a5da:	eb 00                	jmp    f010a5dc <env_page_ws_invalidate+0x55a>
f010a5dc:	90                   	nop
f010a5dd:	c9                   	leave  
f010a5de:	c3                   	ret    

f010a5df <env_page_ws_print>:
void env_page_ws_print(struct Env *e)
{
f010a5df:	55                   	push   %ebp
f010a5e0:	89 e5                	mov    %esp,%ebp
f010a5e2:	53                   	push   %ebx
f010a5e3:	83 ec 24             	sub    $0x24,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010a5e6:	83 ec 0c             	sub    $0xc,%esp
f010a5e9:	6a 02                	push   $0x2
f010a5eb:	e8 33 53 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010a5f0:	83 c4 10             	add    $0x10,%esp
f010a5f3:	85 c0                	test   %eax,%eax
f010a5f5:	0f 84 fe 00 00 00    	je     f010a6f9 <env_page_ws_print+0x11a>
	{
		int i = 0;
f010a5fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		cprintf("ActiveList:\n============\n") ;
f010a602:	83 ec 0c             	sub    $0xc,%esp
f010a605:	68 8f f5 12 f0       	push   $0xf012f58f
f010a60a:	e8 4d 76 ff ff       	call   f0101c5c <cprintf>
f010a60f:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a612:	8b 45 08             	mov    0x8(%ebp),%eax
f010a615:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010a61b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a61e:	eb 2c                	jmp    f010a64c <env_page_ws_print+0x6d>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a620:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a623:	8b 10                	mov    (%eax),%edx
f010a625:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a628:	8d 48 01             	lea    0x1(%eax),%ecx
f010a62b:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a62e:	83 ec 04             	sub    $0x4,%esp
f010a631:	52                   	push   %edx
f010a632:	50                   	push   %eax
f010a633:	68 a9 f5 12 f0       	push   $0xf012f5a9
f010a638:	e8 1f 76 ff ff       	call   f0101c5c <cprintf>
f010a63d:	83 c4 10             	add    $0x10,%esp
	if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
	{
		int i = 0;
		cprintf("ActiveList:\n============\n") ;
		struct WorkingSetElement * ptr_WS_element ;
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
f010a640:	8b 45 08             	mov    0x8(%ebp),%eax
f010a643:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a649:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a64c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a650:	74 08                	je     f010a65a <env_page_ws_print+0x7b>
f010a652:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a655:	8b 40 10             	mov    0x10(%eax),%eax
f010a658:	eb 05                	jmp    f010a65f <env_page_ws_print+0x80>
f010a65a:	b8 00 00 00 00       	mov    $0x0,%eax
f010a65f:	8b 55 08             	mov    0x8(%ebp),%edx
f010a662:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f010a668:	8b 45 08             	mov    0x8(%ebp),%eax
f010a66b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f010a671:	85 c0                	test   %eax,%eax
f010a673:	75 ab                	jne    f010a620 <env_page_ws_print+0x41>
f010a675:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a679:	75 a5                	jne    f010a620 <env_page_ws_print+0x41>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
f010a67b:	83 ec 0c             	sub    $0xc,%esp
f010a67e:	68 b1 f5 12 f0       	push   $0xf012f5b1
f010a683:	e8 d4 75 ff ff       	call   f0101c5c <cprintf>
f010a688:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a68b:	8b 45 08             	mov    0x8(%ebp),%eax
f010a68e:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010a694:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a697:	eb 2c                	jmp    f010a6c5 <env_page_ws_print+0xe6>
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
f010a699:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a69c:	8b 10                	mov    (%eax),%edx
f010a69e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010a6a1:	8d 48 01             	lea    0x1(%eax),%ecx
f010a6a4:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f010a6a7:	83 ec 04             	sub    $0x4,%esp
f010a6aa:	52                   	push   %edx
f010a6ab:	50                   	push   %eax
f010a6ac:	68 a9 f5 12 f0       	push   $0xf012f5a9
f010a6b1:	e8 a6 75 ff ff       	call   f0101c5c <cprintf>
f010a6b6:	83 c4 10             	add    $0x10,%esp
		LIST_FOREACH(ptr_WS_element, &(e->ActiveList))
		{
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
		cprintf("\nSecondList:\n============\n") ;
		LIST_FOREACH(ptr_WS_element, &(e->SecondList))
f010a6b9:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6bc:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a6c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010a6c5:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a6c9:	74 08                	je     f010a6d3 <env_page_ws_print+0xf4>
f010a6cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010a6ce:	8b 40 10             	mov    0x10(%eax),%eax
f010a6d1:	eb 05                	jmp    f010a6d8 <env_page_ws_print+0xf9>
f010a6d3:	b8 00 00 00 00       	mov    $0x0,%eax
f010a6d8:	8b 55 08             	mov    0x8(%ebp),%edx
f010a6db:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f010a6e1:	8b 45 08             	mov    0x8(%ebp),%eax
f010a6e4:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010a6ea:	85 c0                	test   %eax,%eax
f010a6ec:	75 ab                	jne    f010a699 <env_page_ws_print+0xba>
f010a6ee:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010a6f2:	75 a5                	jne    f010a699 <env_page_ws_print+0xba>
		for (; i < e->page_WS_max_size; ++i)
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a6f4:	e9 5a 01 00 00       	jmp    f010a853 <env_page_ws_print+0x274>
			cprintf("%d:	%x\n", i++, ptr_WS_element->virtual_address);
		}
	}
	else
	{
		uint32 i=0;
f010a6f9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
		cprintf("PAGE WS:\n");
f010a700:	83 ec 0c             	sub    $0xc,%esp
f010a703:	68 cc f5 12 f0       	push   $0xf012f5cc
f010a708:	e8 4f 75 ff ff       	call   f0101c5c <cprintf>
f010a70d:	83 c4 10             	add    $0x10,%esp
		struct WorkingSetElement *wse = NULL;
f010a710:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a717:	8b 45 08             	mov    0x8(%ebp),%eax
f010a71a:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010a720:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a723:	e9 d1 00 00 00       	jmp    f010a7f9 <env_page_ws_print+0x21a>
		{
			uint32 virtual_address = wse->virtual_address;
f010a728:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a72b:	8b 00                	mov    (%eax),%eax
f010a72d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
			uint32 time_stamp = wse->time_stamp;
f010a730:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a733:	8b 40 08             	mov    0x8(%eax),%eax
f010a736:	89 45 e0             	mov    %eax,-0x20(%ebp)

			uint32 perm = pt_get_page_permissions(e->env_page_directory, virtual_address) ;
f010a739:	8b 45 08             	mov    0x8(%ebp),%eax
f010a73c:	8b 40 64             	mov    0x64(%eax),%eax
f010a73f:	83 ec 08             	sub    $0x8,%esp
f010a742:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a745:	50                   	push   %eax
f010a746:	e8 79 f6 ff ff       	call   f0109dc4 <pt_get_page_permissions>
f010a74b:	83 c4 10             	add    $0x10,%esp
f010a74e:	89 45 dc             	mov    %eax,-0x24(%ebp)
			char isModified = ((perm&PERM_MODIFIED) ? 1 : 0);
f010a751:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a754:	83 e0 40             	and    $0x40,%eax
f010a757:	85 c0                	test   %eax,%eax
f010a759:	0f 95 c0             	setne  %al
f010a75c:	88 45 db             	mov    %al,-0x25(%ebp)
			char isUsed= ((perm&PERM_USED) ? 1 : 0);
f010a75f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a762:	83 e0 20             	and    $0x20,%eax
f010a765:	85 c0                	test   %eax,%eax
f010a767:	0f 95 c0             	setne  %al
f010a76a:	88 45 da             	mov    %al,-0x26(%ebp)
			char isBuffered= ((perm&PERM_BUFFERED) ? 1 : 0);
f010a76d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010a770:	25 00 02 00 00       	and    $0x200,%eax
f010a775:	85 c0                	test   %eax,%eax
f010a777:	0f 95 c0             	setne  %al
f010a77a:	88 45 d9             	mov    %al,-0x27(%ebp)

			cprintf("%d: %x",i, virtual_address);
f010a77d:	83 ec 04             	sub    $0x4,%esp
f010a780:	ff 75 e4             	pushl  -0x1c(%ebp)
f010a783:	ff 75 ec             	pushl  -0x14(%ebp)
f010a786:	68 d6 f5 12 f0       	push   $0xf012f5d6
f010a78b:	e8 cc 74 ff ff       	call   f0101c5c <cprintf>
f010a790:	83 c4 10             	add    $0x10,%esp

			//2021
			cprintf(", used= %d, modified= %d, buffered= %d, time stamp= %x, sweeps_cnt= %d",
f010a793:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a796:	8b 58 0c             	mov    0xc(%eax),%ebx
f010a799:	0f be 4d d9          	movsbl -0x27(%ebp),%ecx
f010a79d:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f010a7a1:	0f be 45 da          	movsbl -0x26(%ebp),%eax
f010a7a5:	83 ec 08             	sub    $0x8,%esp
f010a7a8:	53                   	push   %ebx
f010a7a9:	ff 75 e0             	pushl  -0x20(%ebp)
f010a7ac:	51                   	push   %ecx
f010a7ad:	52                   	push   %edx
f010a7ae:	50                   	push   %eax
f010a7af:	68 e0 f5 12 f0       	push   $0xf012f5e0
f010a7b4:	e8 a3 74 ff ff       	call   f0101c5c <cprintf>
f010a7b9:	83 c4 20             	add    $0x20,%esp
					isUsed, isModified, isBuffered, time_stamp, wse->sweeps_counter) ;

			if(wse == e->page_last_WS_element)
f010a7bc:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7bf:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f010a7c5:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010a7c8:	75 10                	jne    f010a7da <env_page_ws_print+0x1fb>
			{
				cprintf(" <--");
f010a7ca:	83 ec 0c             	sub    $0xc,%esp
f010a7cd:	68 27 f6 12 f0       	push   $0xf012f627
f010a7d2:	e8 85 74 ff ff       	call   f0101c5c <cprintf>
f010a7d7:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a7da:	83 ec 0c             	sub    $0xc,%esp
f010a7dd:	68 2c f6 12 f0       	push   $0xf012f62c
f010a7e2:	e8 75 74 ff ff       	call   f0101c5c <cprintf>
f010a7e7:	83 c4 10             	add    $0x10,%esp
			i++;
f010a7ea:	ff 45 ec             	incl   -0x14(%ebp)
	else
	{
		uint32 i=0;
		cprintf("PAGE WS:\n");
		struct WorkingSetElement *wse = NULL;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010a7ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010a7f0:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a7f6:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010a7f9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a7fd:	74 08                	je     f010a807 <env_page_ws_print+0x228>
f010a7ff:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010a802:	8b 40 10             	mov    0x10(%eax),%eax
f010a805:	eb 05                	jmp    f010a80c <env_page_ws_print+0x22d>
f010a807:	b8 00 00 00 00       	mov    $0x0,%eax
f010a80c:	8b 55 08             	mov    0x8(%ebp),%edx
f010a80f:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010a815:	8b 45 08             	mov    0x8(%ebp),%eax
f010a818:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010a81e:	85 c0                	test   %eax,%eax
f010a820:	0f 85 02 ff ff ff    	jne    f010a728 <env_page_ws_print+0x149>
f010a826:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010a82a:	0f 85 f8 fe ff ff    	jne    f010a728 <env_page_ws_print+0x149>
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a830:	eb 13                	jmp    f010a845 <env_page_ws_print+0x266>
		{
			cprintf("EMPTY LOCATION\n");
f010a832:	83 ec 0c             	sub    $0xc,%esp
f010a835:	68 2e f6 12 f0       	push   $0xf012f62e
f010a83a:	e8 1d 74 ff ff       	call   f0101c5c <cprintf>
f010a83f:	83 c4 10             	add    $0x10,%esp
				cprintf(" <--");
			}
			cprintf("\n");
			i++;
		}
		for (; i < e->page_WS_max_size; ++i)
f010a842:	ff 45 ec             	incl   -0x14(%ebp)
f010a845:	8b 45 08             	mov    0x8(%ebp),%eax
f010a848:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010a84e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010a851:	77 df                	ja     f010a832 <env_page_ws_print+0x253>
		{
			cprintf("EMPTY LOCATION\n");
		}
	}
}
f010a853:	90                   	nop
f010a854:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a857:	c9                   	leave  
f010a858:	c3                   	ret    

f010a859 <env_table_ws_print>:
}
#endif
// Table Working Set =========================================================

void env_table_ws_print(struct Env *e)
{
f010a859:	55                   	push   %ebp
f010a85a:	89 e5                	mov    %esp,%ebp
f010a85c:	53                   	push   %ebx
f010a85d:	83 ec 14             	sub    $0x14,%esp
	uint32 i;
	cprintf("---------------------------------------------------\n");
f010a860:	83 ec 0c             	sub    $0xc,%esp
f010a863:	68 40 f6 12 f0       	push   $0xf012f640
f010a868:	e8 ef 73 ff ff       	call   f0101c5c <cprintf>
f010a86d:	83 c4 10             	add    $0x10,%esp
	cprintf("TABLE WS:\n");
f010a870:	83 ec 0c             	sub    $0xc,%esp
f010a873:	68 75 f6 12 f0       	push   $0xf012f675
f010a878:	e8 df 73 ff ff       	call   f0101c5c <cprintf>
f010a87d:	83 c4 10             	add    $0x10,%esp
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a880:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010a887:	e9 16 01 00 00       	jmp    f010a9a2 <env_table_ws_print+0x149>
	{
		if (e->__ptr_tws[i].empty)
f010a88c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a88f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a892:	89 d0                	mov    %edx,%eax
f010a894:	01 c0                	add    %eax,%eax
f010a896:	01 d0                	add    %edx,%eax
f010a898:	c1 e0 03             	shl    $0x3,%eax
f010a89b:	01 c8                	add    %ecx,%eax
f010a89d:	05 b8 00 00 00       	add    $0xb8,%eax
f010a8a2:	8a 00                	mov    (%eax),%al
f010a8a4:	84 c0                	test   %al,%al
f010a8a6:	74 43                	je     f010a8eb <env_table_ws_print+0x92>
		{
			cprintf("EMPTY LOCATION");
f010a8a8:	83 ec 0c             	sub    $0xc,%esp
f010a8ab:	68 80 f6 12 f0       	push   $0xf012f680
f010a8b0:	e8 a7 73 ff ff       	call   f0101c5c <cprintf>
f010a8b5:	83 c4 10             	add    $0x10,%esp
			if(i==e->table_last_WS_index )
f010a8b8:	8b 45 08             	mov    0x8(%ebp),%eax
f010a8bb:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a8c1:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a8c4:	75 10                	jne    f010a8d6 <env_table_ws_print+0x7d>
			{
				cprintf("		<--");
f010a8c6:	83 ec 0c             	sub    $0xc,%esp
f010a8c9:	68 8f f6 12 f0       	push   $0xf012f68f
f010a8ce:	e8 89 73 ff ff       	call   f0101c5c <cprintf>
f010a8d3:	83 c4 10             	add    $0x10,%esp
			}
			cprintf("\n");
f010a8d6:	83 ec 0c             	sub    $0xc,%esp
f010a8d9:	68 2c f6 12 f0       	push   $0xf012f62c
f010a8de:	e8 79 73 ff ff       	call   f0101c5c <cprintf>
f010a8e3:	83 c4 10             	add    $0x10,%esp
			continue;
f010a8e6:	e9 b4 00 00 00       	jmp    f010a99f <env_table_ws_print+0x146>
		}
		uint32 virtual_address = e->__ptr_tws[i].virtual_address;
f010a8eb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a8ee:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a8f1:	89 d0                	mov    %edx,%eax
f010a8f3:	01 c0                	add    %eax,%eax
f010a8f5:	01 d0                	add    %edx,%eax
f010a8f7:	c1 e0 03             	shl    $0x3,%eax
f010a8fa:	01 c8                	add    %ecx,%eax
f010a8fc:	05 b4 00 00 00       	add    $0xb4,%eax
f010a901:	8b 00                	mov    (%eax),%eax
f010a903:	89 45 f0             	mov    %eax,-0x10(%ebp)
		cprintf("env address at %d = %x",i, e->__ptr_tws[i].virtual_address);
f010a906:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a909:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a90c:	89 d0                	mov    %edx,%eax
f010a90e:	01 c0                	add    %eax,%eax
f010a910:	01 d0                	add    %edx,%eax
f010a912:	c1 e0 03             	shl    $0x3,%eax
f010a915:	01 c8                	add    %ecx,%eax
f010a917:	05 b4 00 00 00       	add    $0xb4,%eax
f010a91c:	8b 00                	mov    (%eax),%eax
f010a91e:	83 ec 04             	sub    $0x4,%esp
f010a921:	50                   	push   %eax
f010a922:	ff 75 f4             	pushl  -0xc(%ebp)
f010a925:	68 95 f6 12 f0       	push   $0xf012f695
f010a92a:	e8 2d 73 ff ff       	call   f0101c5c <cprintf>
f010a92f:	83 c4 10             	add    $0x10,%esp

		cprintf(", used bit = %d, time stamp = %d", pd_is_table_used(e->env_page_directory, virtual_address), e->__ptr_tws[i].time_stamp);
f010a932:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a935:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010a938:	89 d0                	mov    %edx,%eax
f010a93a:	01 c0                	add    %eax,%eax
f010a93c:	01 d0                	add    %edx,%eax
f010a93e:	c1 e0 03             	shl    $0x3,%eax
f010a941:	01 c8                	add    %ecx,%eax
f010a943:	05 bc 00 00 00       	add    $0xbc,%eax
f010a948:	8b 18                	mov    (%eax),%ebx
f010a94a:	8b 45 08             	mov    0x8(%ebp),%eax
f010a94d:	8b 40 64             	mov    0x64(%eax),%eax
f010a950:	83 ec 08             	sub    $0x8,%esp
f010a953:	ff 75 f0             	pushl  -0x10(%ebp)
f010a956:	50                   	push   %eax
f010a957:	e8 13 f6 ff ff       	call   f0109f6f <pd_is_table_used>
f010a95c:	83 c4 10             	add    $0x10,%esp
f010a95f:	83 ec 04             	sub    $0x4,%esp
f010a962:	53                   	push   %ebx
f010a963:	50                   	push   %eax
f010a964:	68 ac f6 12 f0       	push   $0xf012f6ac
f010a969:	e8 ee 72 ff ff       	call   f0101c5c <cprintf>
f010a96e:	83 c4 10             	add    $0x10,%esp
		if(i==e->table_last_WS_index )
f010a971:	8b 45 08             	mov    0x8(%ebp),%eax
f010a974:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010a97a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010a97d:	75 10                	jne    f010a98f <env_table_ws_print+0x136>
		{
			cprintf(" <--");
f010a97f:	83 ec 0c             	sub    $0xc,%esp
f010a982:	68 27 f6 12 f0       	push   $0xf012f627
f010a987:	e8 d0 72 ff ff       	call   f0101c5c <cprintf>
f010a98c:	83 c4 10             	add    $0x10,%esp
		}
		cprintf("\n");
f010a98f:	83 ec 0c             	sub    $0xc,%esp
f010a992:	68 2c f6 12 f0       	push   $0xf012f62c
f010a997:	e8 c0 72 ff ff       	call   f0101c5c <cprintf>
f010a99c:	83 c4 10             	add    $0x10,%esp
void env_table_ws_print(struct Env *e)
{
	uint32 i;
	cprintf("---------------------------------------------------\n");
	cprintf("TABLE WS:\n");
	for(i=0; i< __TWS_MAX_SIZE; i++ )
f010a99f:	ff 45 f4             	incl   -0xc(%ebp)
f010a9a2:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010a9a6:	0f 86 e0 fe ff ff    	jbe    f010a88c <env_table_ws_print+0x33>
		{
			cprintf(" <--");
		}
		cprintf("\n");
	}
}
f010a9ac:	90                   	nop
f010a9ad:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010a9b0:	c9                   	leave  
f010a9b1:	c3                   	ret    

f010a9b2 <env_table_ws_get_size>:

inline uint32 env_table_ws_get_size(struct Env *e)
{
f010a9b2:	55                   	push   %ebp
f010a9b3:	89 e5                	mov    %esp,%ebp
f010a9b5:	83 ec 10             	sub    $0x10,%esp
	int i=0, counter=0;
f010a9b8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f010a9bf:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for(;i<__TWS_MAX_SIZE; i++) if(e->__ptr_tws[i].empty == 0) counter++;
f010a9c6:	eb 22                	jmp    f010a9ea <env_table_ws_get_size+0x38>
f010a9c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010a9cb:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010a9ce:	89 d0                	mov    %edx,%eax
f010a9d0:	01 c0                	add    %eax,%eax
f010a9d2:	01 d0                	add    %edx,%eax
f010a9d4:	c1 e0 03             	shl    $0x3,%eax
f010a9d7:	01 c8                	add    %ecx,%eax
f010a9d9:	05 b8 00 00 00       	add    $0xb8,%eax
f010a9de:	8a 00                	mov    (%eax),%al
f010a9e0:	84 c0                	test   %al,%al
f010a9e2:	75 03                	jne    f010a9e7 <env_table_ws_get_size+0x35>
f010a9e4:	ff 45 f8             	incl   -0x8(%ebp)
f010a9e7:	ff 45 fc             	incl   -0x4(%ebp)
f010a9ea:	83 7d fc 31          	cmpl   $0x31,-0x4(%ebp)
f010a9ee:	7e d8                	jle    f010a9c8 <env_table_ws_get_size+0x16>
	return counter;
f010a9f0:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f010a9f3:	c9                   	leave  
f010a9f4:	c3                   	ret    

f010a9f5 <env_table_ws_invalidate>:

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
f010a9f5:	55                   	push   %ebp
f010a9f6:	89 e5                	mov    %esp,%ebp
f010a9f8:	83 ec 18             	sub    $0x18,%esp
	int i=0;
f010a9fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	for(;i<__TWS_MAX_SIZE; i++)
f010aa02:	eb 4e                	jmp    f010aa52 <env_table_ws_invalidate+0x5d>
	{
		if(ROUNDDOWN(e->__ptr_tws[i].virtual_address,PAGE_SIZE*1024) == ROUNDDOWN(virtual_address,PAGE_SIZE*1024))
f010aa04:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aa07:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aa0a:	89 d0                	mov    %edx,%eax
f010aa0c:	01 c0                	add    %eax,%eax
f010aa0e:	01 d0                	add    %edx,%eax
f010aa10:	c1 e0 03             	shl    $0x3,%eax
f010aa13:	01 c8                	add    %ecx,%eax
f010aa15:	05 b4 00 00 00       	add    $0xb4,%eax
f010aa1a:	8b 00                	mov    (%eax),%eax
f010aa1c:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010aa1f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010aa22:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010aa27:	89 c2                	mov    %eax,%edx
f010aa29:	8b 45 0c             	mov    0xc(%ebp),%eax
f010aa2c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010aa2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010aa32:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010aa37:	39 c2                	cmp    %eax,%edx
f010aa39:	75 14                	jne    f010aa4f <env_table_ws_invalidate+0x5a>
		{
			env_table_ws_clear_entry(e, i);
f010aa3b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aa3e:	83 ec 08             	sub    $0x8,%esp
f010aa41:	50                   	push   %eax
f010aa42:	ff 75 08             	pushl  0x8(%ebp)
f010aa45:	e8 bc 00 00 00       	call   f010ab06 <env_table_ws_clear_entry>
f010aa4a:	83 c4 10             	add    $0x10,%esp
			break;
f010aa4d:	eb 09                	jmp    f010aa58 <env_table_ws_invalidate+0x63>
}

inline void env_table_ws_invalidate(struct Env* e, uint32 virtual_address)
{
	int i=0;
	for(;i<__TWS_MAX_SIZE; i++)
f010aa4f:	ff 45 f4             	incl   -0xc(%ebp)
f010aa52:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010aa56:	7e ac                	jle    f010aa04 <env_table_ws_invalidate+0xf>
		{
			env_table_ws_clear_entry(e, i);
			break;
		}
	}
}
f010aa58:	90                   	nop
f010aa59:	c9                   	leave  
f010aa5a:	c3                   	ret    

f010aa5b <env_table_ws_set_entry>:

inline void env_table_ws_set_entry(struct Env* e, uint32 entry_index, uint32 virtual_address)
{
f010aa5b:	55                   	push   %ebp
f010aa5c:	89 e5                	mov    %esp,%ebp
f010aa5e:	53                   	push   %ebx
f010aa5f:	83 ec 14             	sub    $0x14,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010aa62:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010aa66:	76 19                	jbe    f010aa81 <env_table_ws_set_entry+0x26>
f010aa68:	68 d0 f6 12 f0       	push   $0xf012f6d0
f010aa6d:	68 fb f4 12 f0       	push   $0xf012f4fb
f010aa72:	68 3e 01 00 00       	push   $0x13e
f010aa77:	68 10 f5 12 f0       	push   $0xf012f510
f010aa7c:	e8 2e 65 ff ff       	call   f0100faf <_panic>
	assert(virtual_address >= 0 && virtual_address < USER_TOP);
f010aa81:	81 7d 10 ff ff bf ee 	cmpl   $0xeebfffff,0x10(%ebp)
f010aa88:	76 19                	jbe    f010aaa3 <env_table_ws_set_entry+0x48>
f010aa8a:	68 c8 f4 12 f0       	push   $0xf012f4c8
f010aa8f:	68 fb f4 12 f0       	push   $0xf012f4fb
f010aa94:	68 3f 01 00 00       	push   $0x13f
f010aa99:	68 10 f5 12 f0       	push   $0xf012f510
f010aa9e:	e8 0c 65 ff ff       	call   f0100faf <_panic>
	e->__ptr_tws[entry_index].virtual_address = ROUNDDOWN(virtual_address,PAGE_SIZE*1024);
f010aaa3:	8b 45 10             	mov    0x10(%ebp),%eax
f010aaa6:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010aaa9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010aaac:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010aab1:	89 c1                	mov    %eax,%ecx
f010aab3:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010aab6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aab9:	89 d0                	mov    %edx,%eax
f010aabb:	01 c0                	add    %eax,%eax
f010aabd:	01 d0                	add    %edx,%eax
f010aabf:	c1 e0 03             	shl    $0x3,%eax
f010aac2:	01 d8                	add    %ebx,%eax
f010aac4:	05 b4 00 00 00       	add    $0xb4,%eax
f010aac9:	89 08                	mov    %ecx,(%eax)
	e->__ptr_tws[entry_index].empty = 0;
f010aacb:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aace:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aad1:	89 d0                	mov    %edx,%eax
f010aad3:	01 c0                	add    %eax,%eax
f010aad5:	01 d0                	add    %edx,%eax
f010aad7:	c1 e0 03             	shl    $0x3,%eax
f010aada:	01 c8                	add    %ecx,%eax
f010aadc:	05 b8 00 00 00       	add    $0xb8,%eax
f010aae1:	c6 00 00             	movb   $0x0,(%eax)

	//e->__ptr_tws[entry_index].time_stamp = time;
	e->__ptr_tws[entry_index].time_stamp = 0x00000000;
f010aae4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aae7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010aaea:	89 d0                	mov    %edx,%eax
f010aaec:	01 c0                	add    %eax,%eax
f010aaee:	01 d0                	add    %edx,%eax
f010aaf0:	c1 e0 03             	shl    $0x3,%eax
f010aaf3:	01 c8                	add    %ecx,%eax
f010aaf5:	05 bc 00 00 00       	add    $0xbc,%eax
f010aafa:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return;
f010ab00:	90                   	nop
}
f010ab01:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ab04:	c9                   	leave  
f010ab05:	c3                   	ret    

f010ab06 <env_table_ws_clear_entry>:

inline void env_table_ws_clear_entry(struct Env* e, uint32 entry_index)
{
f010ab06:	55                   	push   %ebp
f010ab07:	89 e5                	mov    %esp,%ebp
f010ab09:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ab0c:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ab10:	76 19                	jbe    f010ab2b <env_table_ws_clear_entry+0x25>
f010ab12:	68 d0 f6 12 f0       	push   $0xf012f6d0
f010ab17:	68 fb f4 12 f0       	push   $0xf012f4fb
f010ab1c:	68 4a 01 00 00       	push   $0x14a
f010ab21:	68 10 f5 12 f0       	push   $0xf012f510
f010ab26:	e8 84 64 ff ff       	call   f0100faf <_panic>
	e->__ptr_tws[entry_index].virtual_address = 0;
f010ab2b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab2e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ab31:	89 d0                	mov    %edx,%eax
f010ab33:	01 c0                	add    %eax,%eax
f010ab35:	01 d0                	add    %edx,%eax
f010ab37:	c1 e0 03             	shl    $0x3,%eax
f010ab3a:	01 c8                	add    %ecx,%eax
f010ab3c:	05 b4 00 00 00       	add    $0xb4,%eax
f010ab41:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	e->__ptr_tws[entry_index].empty = 1;
f010ab47:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab4a:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ab4d:	89 d0                	mov    %edx,%eax
f010ab4f:	01 c0                	add    %eax,%eax
f010ab51:	01 d0                	add    %edx,%eax
f010ab53:	c1 e0 03             	shl    $0x3,%eax
f010ab56:	01 c8                	add    %ecx,%eax
f010ab58:	05 b8 00 00 00       	add    $0xb8,%eax
f010ab5d:	c6 00 01             	movb   $0x1,(%eax)
	e->__ptr_tws[entry_index].time_stamp = 0;
f010ab60:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ab63:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ab66:	89 d0                	mov    %edx,%eax
f010ab68:	01 c0                	add    %eax,%eax
f010ab6a:	01 d0                	add    %edx,%eax
f010ab6c:	c1 e0 03             	shl    $0x3,%eax
f010ab6f:	01 c8                	add    %ecx,%eax
f010ab71:	05 bc 00 00 00       	add    $0xbc,%eax
f010ab76:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
f010ab7c:	90                   	nop
f010ab7d:	c9                   	leave  
f010ab7e:	c3                   	ret    

f010ab7f <env_table_ws_get_virtual_address>:

inline uint32 env_table_ws_get_virtual_address(struct Env* e, uint32 entry_index)
{
f010ab7f:	55                   	push   %ebp
f010ab80:	89 e5                	mov    %esp,%ebp
f010ab82:	83 ec 18             	sub    $0x18,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010ab85:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010ab89:	76 19                	jbe    f010aba4 <env_table_ws_get_virtual_address+0x25>
f010ab8b:	68 d0 f6 12 f0       	push   $0xf012f6d0
f010ab90:	68 fb f4 12 f0       	push   $0xf012f4fb
f010ab95:	68 52 01 00 00       	push   $0x152
f010ab9a:	68 10 f5 12 f0       	push   $0xf012f510
f010ab9f:	e8 0b 64 ff ff       	call   f0100faf <_panic>
	return ROUNDDOWN(e->__ptr_tws[entry_index].virtual_address,PAGE_SIZE*1024);
f010aba4:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010aba7:	8b 55 0c             	mov    0xc(%ebp),%edx
f010abaa:	89 d0                	mov    %edx,%eax
f010abac:	01 c0                	add    %eax,%eax
f010abae:	01 d0                	add    %edx,%eax
f010abb0:	c1 e0 03             	shl    $0x3,%eax
f010abb3:	01 c8                	add    %ecx,%eax
f010abb5:	05 b4 00 00 00       	add    $0xb4,%eax
f010abba:	8b 00                	mov    (%eax),%eax
f010abbc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010abbf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010abc2:	25 00 00 c0 ff       	and    $0xffc00000,%eax
}
f010abc7:	c9                   	leave  
f010abc8:	c3                   	ret    

f010abc9 <env_table_ws_get_time_stamp>:


inline uint32 env_table_ws_get_time_stamp(struct Env* e, uint32 entry_index)
{
f010abc9:	55                   	push   %ebp
f010abca:	89 e5                	mov    %esp,%ebp
f010abcc:	83 ec 08             	sub    $0x8,%esp
	assert(entry_index >= 0 && entry_index < __TWS_MAX_SIZE);
f010abcf:	83 7d 0c 31          	cmpl   $0x31,0xc(%ebp)
f010abd3:	76 19                	jbe    f010abee <env_table_ws_get_time_stamp+0x25>
f010abd5:	68 d0 f6 12 f0       	push   $0xf012f6d0
f010abda:	68 fb f4 12 f0       	push   $0xf012f4fb
f010abdf:	68 59 01 00 00       	push   $0x159
f010abe4:	68 10 f5 12 f0       	push   $0xf012f510
f010abe9:	e8 c1 63 ff ff       	call   f0100faf <_panic>
	return e->__ptr_tws[entry_index].time_stamp;
f010abee:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010abf1:	8b 55 0c             	mov    0xc(%ebp),%edx
f010abf4:	89 d0                	mov    %edx,%eax
f010abf6:	01 c0                	add    %eax,%eax
f010abf8:	01 d0                	add    %edx,%eax
f010abfa:	c1 e0 03             	shl    $0x3,%eax
f010abfd:	01 c8                	add    %ecx,%eax
f010abff:	05 bc 00 00 00       	add    $0xbc,%eax
f010ac04:	8b 00                	mov    (%eax),%eax
}
f010ac06:	c9                   	leave  
f010ac07:	c3                   	ret    

f010ac08 <env_table_ws_is_entry_empty>:

inline uint32 env_table_ws_is_entry_empty(struct Env* e, uint32 entry_index)
{
f010ac08:	55                   	push   %ebp
f010ac09:	89 e5                	mov    %esp,%ebp
	return e->__ptr_tws[entry_index].empty;
f010ac0b:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010ac0e:	8b 55 0c             	mov    0xc(%ebp),%edx
f010ac11:	89 d0                	mov    %edx,%eax
f010ac13:	01 c0                	add    %eax,%eax
f010ac15:	01 d0                	add    %edx,%eax
f010ac17:	c1 e0 03             	shl    $0x3,%eax
f010ac1a:	01 c8                	add    %ecx,%eax
f010ac1c:	05 b8 00 00 00       	add    $0xb8,%eax
f010ac21:	8a 00                	mov    (%eax),%al
f010ac23:	0f b6 c0             	movzbl %al,%eax
}
f010ac26:	5d                   	pop    %ebp
f010ac27:	c3                   	ret    

f010ac28 <cut_paste_WS>:
///=================================================================================================

// Change WS Sizes For PRIORITY  =========================================================

void cut_paste_WS(struct WorkingSetElement* newWS, int newSize, struct Env* e)
{
f010ac28:	55                   	push   %ebp
f010ac29:	89 e5                	mov    %esp,%ebp
f010ac2b:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ac2e:	83 ec 04             	sub    $0x4,%esp
f010ac31:	68 01 f7 12 f0       	push   $0xf012f701
f010ac36:	68 6b 01 00 00       	push   $0x16b
f010ac3b:	68 10 f5 12 f0       	push   $0xf012f510
f010ac40:	e8 6a 63 ff ff       	call   f0100faf <_panic>

f010ac45 <double_WS_Size>:
}

void double_WS_Size(struct Env* e, int isOneTimeOnly)
{
f010ac45:	55                   	push   %ebp
f010ac46:	89 e5                	mov    %esp,%ebp
f010ac48:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ac4b:	83 ec 04             	sub    $0x4,%esp
f010ac4e:	68 01 f7 12 f0       	push   $0xf012f701
f010ac53:	68 70 01 00 00       	push   $0x170
f010ac58:	68 10 f5 12 f0       	push   $0xf012f510
f010ac5d:	e8 4d 63 ff ff       	call   f0100faf <_panic>

f010ac62 <half_WS_Size>:
}

void half_WS_Size(struct Env* e, int isImmidiate)
{
f010ac62:	55                   	push   %ebp
f010ac63:	89 e5                	mov    %esp,%ebp
f010ac65:	83 ec 08             	sub    $0x8,%esp
	panic("not handled yet");
f010ac68:	83 ec 04             	sub    $0x4,%esp
f010ac6b:	68 01 f7 12 f0       	push   $0xf012f701
f010ac70:	68 75 01 00 00       	push   $0x175
f010ac75:	68 10 f5 12 f0       	push   $0xf012f510
f010ac7a:	e8 30 63 ff ff       	call   f0100faf <_panic>

f010ac7f <cut_paste_pages>:
//	If the page table at any destination page in the range is not exist, it should create it
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, cut-paste the number of pages and return 0
//	ALL 12 permission bits of the destination should be TYPICAL to those of the source
//	The given addresses may be not aligned on 4 KB
int cut_paste_pages(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 num_of_pages)
{
f010ac7f:	55                   	push   %ebp
f010ac80:	89 e5                	mov    %esp,%ebp
f010ac82:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("cut_paste_pages() is not implemented yet...!!");
f010ac85:	83 ec 04             	sub    $0x4,%esp
f010ac88:	68 14 f7 12 f0       	push   $0xf012f714
f010ac8d:	6a 21                	push   $0x21
f010ac8f:	68 42 f7 12 f0       	push   $0xf012f742
f010ac94:	e8 16 63 ff ff       	call   f0100faf <_panic>

f010ac99 <copy_paste_chunk>:
//	Otherwise, just copy!
//		1. WRITABLE permission
//		2. USER/SUPERVISOR permission must be SAME as the one of the source
//	The given range(s) may be not aligned on 4 KB
int copy_paste_chunk(uint32* page_directory, uint32 source_va, uint32 dest_va, uint32 size)
{
f010ac99:	55                   	push   %ebp
f010ac9a:	89 e5                	mov    %esp,%ebp
f010ac9c:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("copy_paste_chunk() is not implemented yet...!!");
f010ac9f:	83 ec 04             	sub    $0x4,%esp
f010aca2:	68 60 f7 12 f0       	push   $0xf012f760
f010aca7:	6a 34                	push   $0x34
f010aca9:	68 42 f7 12 f0       	push   $0xf012f742
f010acae:	e8 fc 62 ff ff       	call   f0100faf <_panic>

f010acb3 <share_chunk>:
//	Otherwise, share the required range and return 0
//	During the share process:
//		1. If the page table at any destination page in the range is not exist, it should create it
//	The given range(s) may be not aligned on 4 KB
int share_chunk(uint32* page_directory, uint32 source_va,uint32 dest_va, uint32 size, uint32 perms)
{
f010acb3:	55                   	push   %ebp
f010acb4:	89 e5                	mov    %esp,%ebp
f010acb6:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("share_chunk() is not implemented yet...!!");
f010acb9:	83 ec 04             	sub    $0x4,%esp
f010acbc:	68 90 f7 12 f0       	push   $0xf012f790
f010acc1:	6a 46                	push   $0x46
f010acc3:	68 42 f7 12 f0       	push   $0xf012f742
f010acc8:	e8 e2 62 ff ff       	call   f0100faf <_panic>

f010accd <allocate_chunk>:
//This function should allocate the given virtual range [<va>, <va> + <size>) in the given address space  <page_directory> with the given permissions <perms>.
//	If ANY of the destination pages exists, deny the entire process and return -1. Otherwise, allocate the required range and return 0
//	If the page table at any destination page in the range is not exist, it should create it
//	Allocation should be aligned on page boundary. However, the given range may be not aligned.
int allocate_chunk(uint32* page_directory, uint32 va, uint32 size, uint32 perms)
{
f010accd:	55                   	push   %ebp
f010acce:	89 e5                	mov    %esp,%ebp
f010acd0:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("allocate_chunk() is not implemented yet...!!");
f010acd3:	83 ec 04             	sub    $0x4,%esp
f010acd6:	68 bc f7 12 f0       	push   $0xf012f7bc
f010acdb:	6a 54                	push   $0x54
f010acdd:	68 42 f7 12 f0       	push   $0xf012f742
f010ace2:	e8 c8 62 ff ff       	call   f0100faf <_panic>

f010ace7 <calculate_free_space>:
//=====================================
//It should count the number of free pages in the given range [va1, va2)
//(i.e. number of pages that are not mapped).
//Addresses may not be aligned on page boundaries
uint32 calculate_free_space(uint32* page_directory, uint32 sva, uint32 eva)
{
f010ace7:	55                   	push   %ebp
f010ace8:	89 e5                	mov    %esp,%ebp
f010acea:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_free_space() is not implemented yet...!!");
f010aced:	83 ec 04             	sub    $0x4,%esp
f010acf0:	68 ec f7 12 f0       	push   $0xf012f7ec
f010acf5:	6a 62                	push   $0x62
f010acf7:	68 42 f7 12 f0       	push   $0xf012f742
f010acfc:	e8 ae 62 ff ff       	call   f0100faf <_panic>

f010ad01 <calculate_allocated_space>:

//=====================================
// 6) CALCULATE ALLOCATED SPACE:
//=====================================
void calculate_allocated_space(uint32* page_directory, uint32 sva, uint32 eva, uint32 *num_tables, uint32 *num_pages)
{
f010ad01:	55                   	push   %ebp
f010ad02:	89 e5                	mov    %esp,%ebp
f010ad04:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_allocated_space() is not implemented yet...!!");
f010ad07:	83 ec 04             	sub    $0x4,%esp
f010ad0a:	68 20 f8 12 f0       	push   $0xf012f820
f010ad0f:	6a 6c                	push   $0x6c
f010ad11:	68 42 f7 12 f0       	push   $0xf012f742
f010ad16:	e8 94 62 ff ff       	call   f0100faf <_panic>

f010ad1b <calculate_required_frames>:
//=====================================
//This function should calculate the required number of pages for allocating and mapping the given range [start va, start va + size) (either for the pages themselves or for the page tables required for mapping)
//	Pages and/or page tables that are already exist in the range SHOULD NOT be counted.
//	The given range(s) may be not aligned on 4 KB
uint32 calculate_required_frames(uint32* page_directory, uint32 sva, uint32 size)
{
f010ad1b:	55                   	push   %ebp
f010ad1c:	89 e5                	mov    %esp,%ebp
f010ad1e:	83 ec 08             	sub    $0x8,%esp
	//TODO: PRACTICE: fill this function.
	//Comment the following line
	panic("calculate_required_frames() is not implemented yet...!!");
f010ad21:	83 ec 04             	sub    $0x4,%esp
f010ad24:	68 58 f8 12 f0       	push   $0xf012f858
f010ad29:	6a 79                	push   $0x79
f010ad2b:	68 42 f7 12 f0       	push   $0xf012f742
f010ad30:	e8 7a 62 ff ff       	call   f0100faf <_panic>

f010ad35 <sys_sbrk>:
//=====================================
/* DYNAMIC ALLOCATOR SYSTEM CALLS */
//=====================================
/*2024*/
void* sys_sbrk(int numOfPages)
{
f010ad35:	55                   	push   %ebp
f010ad36:	89 e5                	mov    %esp,%ebp
f010ad38:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f010ad3b:	83 ec 04             	sub    $0x4,%esp
f010ad3e:	68 90 f8 12 f0       	push   $0xf012f890
f010ad43:	68 8e 00 00 00       	push   $0x8e
f010ad48:	68 42 f7 12 f0       	push   $0xf012f742
f010ad4d:	e8 5d 62 ff ff       	call   f0100faf <_panic>

f010ad52 <allocate_user_mem>:

//=====================================
// 1) ALLOCATE USER MEMORY:
//=====================================
void allocate_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ad52:	55                   	push   %ebp
f010ad53:	89 e5                	mov    %esp,%ebp
f010ad55:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/

	//TODO: [PROJECT'25.IM#2] USER HEAP - #2 allocate_user_mem
	//Your code is here
	//Comment the following line
	panic("allocate_user_mem() is not implemented yet...!!");
f010ad58:	83 ec 04             	sub    $0x4,%esp
f010ad5b:	68 ac f8 12 f0       	push   $0xf012f8ac
f010ad60:	68 9f 00 00 00       	push   $0x9f
f010ad65:	68 42 f7 12 f0       	push   $0xf012f742
f010ad6a:	e8 40 62 ff ff       	call   f0100faf <_panic>

f010ad6f <free_user_mem>:

//=====================================
// 2) FREE USER MEMORY:
//=====================================
void free_user_mem(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ad6f:	55                   	push   %ebp
f010ad70:	89 e5                	mov    %esp,%ebp
f010ad72:	83 ec 08             	sub    $0x8,%esp
	/*====================================*/

	//TODO: [PROJECT'25.IM#2] USER HEAP - #4 free_user_mem
	//Your code is here
	//Comment the following line
	panic("free_user_mem() is not implemented yet...!!");
f010ad75:	83 ec 04             	sub    $0x4,%esp
f010ad78:	68 dc f8 12 f0       	push   $0xf012f8dc
f010ad7d:	68 b0 00 00 00       	push   $0xb0
f010ad82:	68 42 f7 12 f0       	push   $0xf012f742
f010ad87:	e8 23 62 ff ff       	call   f0100faf <_panic>

f010ad8c <__free_user_mem_with_buffering>:

//=====================================
// 4) FREE USER MEMORY (BUFFERING):
//=====================================
void __free_user_mem_with_buffering(struct Env* e, uint32 virtual_address, uint32 size)
{
f010ad8c:	55                   	push   %ebp
f010ad8d:	89 e5                	mov    %esp,%ebp
f010ad8f:	83 ec 08             	sub    $0x8,%esp
	// your code is here, remove the panic and write your code
	panic("__free_user_mem_with_buffering() is not implemented yet...!!");
f010ad92:	83 ec 04             	sub    $0x4,%esp
f010ad95:	68 08 f9 12 f0       	push   $0xf012f908
f010ad9a:	68 b9 00 00 00       	push   $0xb9
f010ad9f:	68 42 f7 12 f0       	push   $0xf012f742
f010ada4:	e8 06 62 ff ff       	call   f0100faf <_panic>

f010ada9 <move_user_mem>:

//=====================================
// 3) MOVE USER MEMORY:
//=====================================
void move_user_mem(struct Env* e, uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ada9:	55                   	push   %ebp
f010adaa:	89 e5                	mov    %esp,%ebp
f010adac:	83 ec 08             	sub    $0x8,%esp
	panic("move_user_mem() is not implemented yet...!!");
f010adaf:	83 ec 04             	sub    $0x4,%esp
f010adb2:	68 48 f9 12 f0       	push   $0xf012f948
f010adb7:	68 c1 00 00 00       	push   $0xc1
f010adbc:	68 42 f7 12 f0       	push   $0xf012f742
f010adc1:	e8 e9 61 ff ff       	call   f0100faf <_panic>

f010adc6 <env_init>:
// and insert them into the env_free_list.
// Insert in reverse order, so that the first call to allocate_environment()
// returns envs[0].
//
void env_init(void)
{
f010adc6:	55                   	push   %ebp
f010adc7:	89 e5                	mov    %esp,%ebp
f010adc9:	53                   	push   %ebx
f010adca:	83 ec 14             	sub    $0x14,%esp
	int iEnv = NENV-1;
f010adcd:	c7 45 f4 c5 02 00 00 	movl   $0x2c5,-0xc(%ebp)
	for(; iEnv >= 0; iEnv--)
f010add4:	e9 78 01 00 00       	jmp    f010af51 <env_init+0x18b>
	{
		envs[iEnv].env_status = ENV_FREE;
f010add9:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010addf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ade2:	89 d0                	mov    %edx,%eax
f010ade4:	c1 e0 02             	shl    $0x2,%eax
f010ade7:	01 d0                	add    %edx,%eax
f010ade9:	c1 e0 03             	shl    $0x3,%eax
f010adec:	01 d0                	add    %edx,%eax
f010adee:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010adf5:	01 d0                	add    %edx,%eax
f010adf7:	c1 e0 02             	shl    $0x2,%eax
f010adfa:	01 c8                	add    %ecx,%eax
f010adfc:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
		envs[iEnv].env_id = 0;
f010ae03:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ae09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae0c:	89 d0                	mov    %edx,%eax
f010ae0e:	c1 e0 02             	shl    $0x2,%eax
f010ae11:	01 d0                	add    %edx,%eax
f010ae13:	c1 e0 03             	shl    $0x3,%eax
f010ae16:	01 d0                	add    %edx,%eax
f010ae18:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae1f:	01 d0                	add    %edx,%eax
f010ae21:	c1 e0 02             	shl    $0x2,%eax
f010ae24:	01 c8                	add    %ecx,%eax
f010ae26:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
f010ae2d:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ae33:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae36:	89 d0                	mov    %edx,%eax
f010ae38:	c1 e0 02             	shl    $0x2,%eax
f010ae3b:	01 d0                	add    %edx,%eax
f010ae3d:	c1 e0 03             	shl    $0x3,%eax
f010ae40:	01 d0                	add    %edx,%eax
f010ae42:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae49:	01 d0                	add    %edx,%eax
f010ae4b:	c1 e0 02             	shl    $0x2,%eax
f010ae4e:	01 c8                	add    %ecx,%eax
f010ae50:	85 c0                	test   %eax,%eax
f010ae52:	75 14                	jne    f010ae68 <env_init+0xa2>
f010ae54:	83 ec 04             	sub    $0x4,%esp
f010ae57:	68 74 f9 12 f0       	push   $0xf012f974
f010ae5c:	6a 65                	push   $0x65
f010ae5e:	68 97 f9 12 f0       	push   $0xf012f997
f010ae63:	e8 47 61 ff ff       	call   f0100faf <_panic>
f010ae68:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010ae6e:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ae71:	89 d0                	mov    %edx,%eax
f010ae73:	c1 e0 02             	shl    $0x2,%eax
f010ae76:	01 d0                	add    %edx,%eax
f010ae78:	c1 e0 03             	shl    $0x3,%eax
f010ae7b:	01 d0                	add    %edx,%eax
f010ae7d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010ae84:	01 d0                	add    %edx,%eax
f010ae86:	c1 e0 02             	shl    $0x2,%eax
f010ae89:	01 c8                	add    %ecx,%eax
f010ae8b:	8b 15 94 5b 81 f0    	mov    0xf0815b94,%edx
f010ae91:	89 50 08             	mov    %edx,0x8(%eax)
f010ae94:	8b 40 08             	mov    0x8(%eax),%eax
f010ae97:	85 c0                	test   %eax,%eax
f010ae99:	74 2e                	je     f010aec9 <env_init+0x103>
f010ae9b:	8b 0d 94 5b 81 f0    	mov    0xf0815b94,%ecx
f010aea1:	8b 1d 90 5b 81 f0    	mov    0xf0815b90,%ebx
f010aea7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aeaa:	89 d0                	mov    %edx,%eax
f010aeac:	c1 e0 02             	shl    $0x2,%eax
f010aeaf:	01 d0                	add    %edx,%eax
f010aeb1:	c1 e0 03             	shl    $0x3,%eax
f010aeb4:	01 d0                	add    %edx,%eax
f010aeb6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010aebd:	01 d0                	add    %edx,%eax
f010aebf:	c1 e0 02             	shl    $0x2,%eax
f010aec2:	01 d8                	add    %ebx,%eax
f010aec4:	89 41 0c             	mov    %eax,0xc(%ecx)
f010aec7:	eb 28                	jmp    f010aef1 <env_init+0x12b>
f010aec9:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010aecf:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aed2:	89 d0                	mov    %edx,%eax
f010aed4:	c1 e0 02             	shl    $0x2,%eax
f010aed7:	01 d0                	add    %edx,%eax
f010aed9:	c1 e0 03             	shl    $0x3,%eax
f010aedc:	01 d0                	add    %edx,%eax
f010aede:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010aee5:	01 d0                	add    %edx,%eax
f010aee7:	c1 e0 02             	shl    $0x2,%eax
f010aeea:	01 c8                	add    %ecx,%eax
f010aeec:	a3 98 5b 81 f0       	mov    %eax,0xf0815b98
f010aef1:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010aef7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010aefa:	89 d0                	mov    %edx,%eax
f010aefc:	c1 e0 02             	shl    $0x2,%eax
f010aeff:	01 d0                	add    %edx,%eax
f010af01:	c1 e0 03             	shl    $0x3,%eax
f010af04:	01 d0                	add    %edx,%eax
f010af06:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010af0d:	01 d0                	add    %edx,%eax
f010af0f:	c1 e0 02             	shl    $0x2,%eax
f010af12:	01 c8                	add    %ecx,%eax
f010af14:	a3 94 5b 81 f0       	mov    %eax,0xf0815b94
f010af19:	8b 0d 90 5b 81 f0    	mov    0xf0815b90,%ecx
f010af1f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010af22:	89 d0                	mov    %edx,%eax
f010af24:	c1 e0 02             	shl    $0x2,%eax
f010af27:	01 d0                	add    %edx,%eax
f010af29:	c1 e0 03             	shl    $0x3,%eax
f010af2c:	01 d0                	add    %edx,%eax
f010af2e:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010af35:	01 d0                	add    %edx,%eax
f010af37:	c1 e0 02             	shl    $0x2,%eax
f010af3a:	01 c8                	add    %ecx,%eax
f010af3c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010af43:	a1 a0 5b 81 f0       	mov    0xf0815ba0,%eax
f010af48:	40                   	inc    %eax
f010af49:	a3 a0 5b 81 f0       	mov    %eax,0xf0815ba0
// returns envs[0].
//
void env_init(void)
{
	int iEnv = NENV-1;
	for(; iEnv >= 0; iEnv--)
f010af4e:	ff 4d f4             	decl   -0xc(%ebp)
f010af51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010af55:	0f 89 7e fe ff ff    	jns    f010add9 <env_init+0x13>
	{
		envs[iEnv].env_status = ENV_FREE;
		envs[iEnv].env_id = 0;
		LIST_INSERT_HEAD(&env_free_list, &envs[iEnv]);
	}
}
f010af5b:	90                   	nop
f010af5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010af5f:	c9                   	leave  
f010af60:	c3                   	ret    

f010af61 <env_create>:
//===============================
// 1) CREATE NEW ENV & LOAD IT:
//===============================
// Allocates a new env and loads the named user program into it.
struct Env* env_create(char* user_program_name, unsigned int page_WS_size, unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010af61:	55                   	push   %ebp
f010af62:	89 e5                	mov    %esp,%ebp
f010af64:	57                   	push   %edi
f010af65:	56                   	push   %esi
f010af66:	53                   	push   %ebx
f010af67:	81 ec fc 00 00 00    	sub    $0xfc,%esp
	//[0] 2024: Disable the interrupt through the entire function to avoid concurrency issues while:
	//		1. switching the directories
	//		2. between allocate_environment and removing it later in complete_env..._initi...
	/*THANKS to T58 - 2024/2025*/

	struct Env* e = NULL;
f010af6d:	c7 85 44 ff ff ff 00 	movl   $0x0,-0xbc(%ebp)
f010af74:	00 00 00 

	pushcli();
f010af77:	e8 b4 d1 ff ff       	call   f0108130 <pushcli>
	{
		//[1] get pointer to the start of the "user_program_name" program in memory
		// Hint: use "get_user_program_info" function,
		// you should set the following "ptr_program_start" by the start address of the user program
		uint8* ptr_program_start = 0;
f010af7c:	c7 45 b0 00 00 00 00 	movl   $0x0,-0x50(%ebp)

		struct UserProgramInfo* ptr_user_program_info = get_user_program_info(user_program_name);
f010af83:	83 ec 0c             	sub    $0xc,%esp
f010af86:	ff 75 08             	pushl  0x8(%ebp)
f010af89:	e8 f0 1e 00 00       	call   f010ce7e <get_user_program_info>
f010af8e:	83 c4 10             	add    $0x10,%esp
f010af91:	89 45 ac             	mov    %eax,-0x54(%ebp)
		if(ptr_user_program_info == 0)
f010af94:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
f010af98:	75 0f                	jne    f010afa9 <env_create+0x48>
		{
			popcli();
f010af9a:	e8 e3 d1 ff ff       	call   f0108182 <popcli>
			return NULL;
f010af9f:	b8 00 00 00 00       	mov    $0x0,%eax
f010afa4:	e9 b6 0a 00 00       	jmp    f010ba5f <env_create+0xafe>
		}
		ptr_program_start = ptr_user_program_info->ptr_start ;
f010afa9:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010afac:	8b 40 08             	mov    0x8(%eax),%eax
f010afaf:	89 45 b0             	mov    %eax,-0x50(%ebp)

		//[2] allocate new environment, (from the free environment list)
		//if there's no one, return NULL
		// Hint: use "allocate_environment" function
		if(allocate_environment(&e) < 0)
f010afb2:	83 ec 0c             	sub    $0xc,%esp
f010afb5:	8d 85 44 ff ff ff    	lea    -0xbc(%ebp),%eax
f010afbb:	50                   	push   %eax
f010afbc:	e8 bd 0f 00 00       	call   f010bf7e <allocate_environment>
f010afc1:	83 c4 10             	add    $0x10,%esp
f010afc4:	85 c0                	test   %eax,%eax
f010afc6:	79 0f                	jns    f010afd7 <env_create+0x76>
		{
			popcli();
f010afc8:	e8 b5 d1 ff ff       	call   f0108182 <popcli>
			return NULL;
f010afcd:	b8 00 00 00 00       	mov    $0x0,%eax
f010afd2:	e9 88 0a 00 00       	jmp    f010ba5f <env_create+0xafe>
		}

		//[2.5 - 2012] Set program name inside the environment
		//e->prog_name = ptr_user_program_info->name ;
		//2017: changed to fixed size array to be abale to access it from user side
		if (strlen(ptr_user_program_info->name) < PROGNAMELEN)
f010afd7:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010afda:	8b 00                	mov    (%eax),%eax
f010afdc:	83 ec 0c             	sub    $0xc,%esp
f010afdf:	50                   	push   %eax
f010afe0:	e8 96 fb 00 00       	call   f011ab7b <strlen>
f010afe5:	83 c4 10             	add    $0x10,%esp
f010afe8:	83 f8 3f             	cmp    $0x3f,%eax
f010afeb:	7f 1d                	jg     f010b00a <env_create+0xa9>
			strcpy(e->prog_name, ptr_user_program_info->name);
f010afed:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010aff0:	8b 00                	mov    (%eax),%eax
f010aff2:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010aff8:	83 c2 20             	add    $0x20,%edx
f010affb:	83 ec 08             	sub    $0x8,%esp
f010affe:	50                   	push   %eax
f010afff:	52                   	push   %edx
f010b000:	e8 c5 fb 00 00       	call   f011abca <strcpy>
f010b005:	83 c4 10             	add    $0x10,%esp
f010b008:	eb 1d                	jmp    f010b027 <env_create+0xc6>
		else
			strncpy(e->prog_name, ptr_user_program_info->name, PROGNAMELEN-1);
f010b00a:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b00d:	8b 00                	mov    (%eax),%eax
f010b00f:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b015:	83 c2 20             	add    $0x20,%edx
f010b018:	83 ec 04             	sub    $0x4,%esp
f010b01b:	6a 3f                	push   $0x3f
f010b01d:	50                   	push   %eax
f010b01e:	52                   	push   %edx
f010b01f:	e8 d4 fb 00 00       	call   f011abf8 <strncpy>
f010b024:	83 c4 10             	add    $0x10,%esp
		//REMEMBER: "allocate_frame" should always return a free frame
		uint32* ptr_user_page_directory;
		unsigned int phys_user_page_directory;
#if USE_KHEAP
		{
			ptr_user_page_directory = create_user_directory();
f010b027:	e8 1e 15 00 00       	call   f010c54a <create_user_directory>
f010b02c:	89 45 a8             	mov    %eax,-0x58(%ebp)
			phys_user_page_directory = kheap_physical_address((uint32)ptr_user_page_directory);
f010b02f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f010b032:	83 ec 0c             	sub    $0xc,%esp
f010b035:	50                   	push   %eax
f010b036:	e8 49 ec ff ff       	call   f0109c84 <kheap_physical_address>
f010b03b:	83 c4 10             	add    $0x10,%esp
f010b03e:	89 45 a4             	mov    %eax,-0x5c(%ebp)
#endif
		//[4] initialize the new environment by the virtual address of the page directory
		// Hint: use "initialize_environment" function

		//2016
		e->page_WS_max_size = page_WS_size;
f010b041:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b047:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b04a:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)

		//2020
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b050:	83 ec 0c             	sub    $0xc,%esp
f010b053:	6a 02                	push   $0x2
f010b055:	e8 c9 48 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010b05a:	83 c4 10             	add    $0x10,%esp
f010b05d:	85 c0                	test   %eax,%eax
f010b05f:	74 21                	je     f010b082 <env_create+0x121>
		{
			e->SecondListSize = LRU_second_list_size;
f010b061:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b067:	8b 55 10             	mov    0x10(%ebp),%edx
f010b06a:	89 90 8c 05 00 00    	mov    %edx,0x58c(%eax)
			e->ActiveListSize = page_WS_size - LRU_second_list_size;
f010b070:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b076:	8b 55 0c             	mov    0xc(%ebp),%edx
f010b079:	2b 55 10             	sub    0x10(%ebp),%edx
f010b07c:	89 90 88 05 00 00    	mov    %edx,0x588(%eax)
		}

		//2018
		if (percent_WS_pages_to_remove == 0)	// If not entered as input, 0 as default value
f010b082:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f010b086:	75 12                	jne    f010b09a <env_create+0x139>
			e->percentage_of_WS_pages_to_be_removed = DEFAULT_PERCENT_OF_PAGE_WS_TO_REMOVE;
f010b088:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b08e:	c7 80 94 05 00 00 0a 	movl   $0xa,0x594(%eax)
f010b095:	00 00 00 
f010b098:	eb 0f                	jmp    f010b0a9 <env_create+0x148>
		else
			e->percentage_of_WS_pages_to_be_removed = percent_WS_pages_to_remove;
f010b09a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b0a0:	8b 55 14             	mov    0x14(%ebp),%edx
f010b0a3:	89 90 94 05 00 00    	mov    %edx,0x594(%eax)

		initialize_environment(e, ptr_user_page_directory, phys_user_page_directory);
f010b0a9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b0af:	83 ec 04             	sub    $0x4,%esp
f010b0b2:	ff 75 a4             	pushl  -0x5c(%ebp)
f010b0b5:	ff 75 a8             	pushl  -0x58(%ebp)
f010b0b8:	50                   	push   %eax
f010b0b9:	e8 01 15 00 00       	call   f010c5bf <initialize_environment>
f010b0be:	83 c4 10             	add    $0x10,%esp

static __inline uint32
rcr3(void)
{
	uint32 val;
	__asm __volatile("movl %%cr3,%0" : "=r" (val));
f010b0c1:	0f 20 d8             	mov    %cr3,%eax
f010b0c4:	89 45 98             	mov    %eax,-0x68(%ebp)
	return val;
f010b0c7:	8b 45 98             	mov    -0x68(%ebp),%eax
		//	3- uint32 size_in_memory: actual size required by this segment in memory
		// 	usually size_in_file < or = size_in_memory
		//	4- uint8 *virtual_address: start virtual address that this segment should be copied to it

		//[6] switch to user page directory
		uint32 cur_phys_pgdir = rcr3() ;
f010b0ca:	89 45 9c             	mov    %eax,-0x64(%ebp)
		lcr3(e->env_cr3) ;
f010b0cd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b0d3:	8b 40 68             	mov    0x68(%eax),%eax
f010b0d6:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010b0dc:	8b 85 48 ff ff ff    	mov    -0xb8(%ebp),%eax
f010b0e2:	0f 22 d8             	mov    %eax,%cr3

		//[7] load each program segment into user virtual space
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
f010b0e5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		int segment_counter=0;
f010b0ec:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
f010b0f3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b0f9:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b0ff:	48                   	dec    %eax
f010b100:	89 45 dc             	mov    %eax,-0x24(%ebp)
		uint32 lastTableNumber=0xffffffff;
f010b103:	c7 85 40 ff ff ff ff 	movl   $0xffffffff,-0xc0(%ebp)
f010b10a:	ff ff ff 

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b10d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
f010b113:	83 ec 08             	sub    $0x8,%esp
f010b116:	ff 75 b0             	pushl  -0x50(%ebp)
f010b119:	50                   	push   %eax
f010b11a:	e8 6e 1a 00 00       	call   f010cb8d <PROGRAM_SEGMENT_FIRST>
f010b11f:	83 c4 0c             	add    $0xc,%esp
f010b122:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010b128:	8d 95 f8 fe ff ff    	lea    -0x108(%ebp),%edx
f010b12e:	b9 05 00 00 00       	mov    $0x5,%ecx
f010b133:	89 c7                	mov    %eax,%edi
f010b135:	89 d6                	mov    %edx,%esi
f010b137:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010b139:	8d 85 2c ff ff ff    	lea    -0xd4(%ebp),%eax
f010b13f:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010b142:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b145:	8b 40 10             	mov    0x10(%eax),%eax
f010b148:	83 f8 ff             	cmp    $0xffffffff,%eax
f010b14b:	75 07                	jne    f010b154 <env_create+0x1f3>
f010b14d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f010b154:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010b157:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b15a:	e9 2d 03 00 00       	jmp    f010b48c <env_create+0x52b>
		{
			segment_counter++;
f010b15f:	ff 45 e0             	incl   -0x20(%ebp)
			LOG_STRING("===============================================================================");
			LOG_STATMENT(cprintf("SEGMENT #%d, size_in_file = %d, size_in_memory= %d, dest va = %x",segment_counter,seg->size_in_file,
					seg->size_in_memory, seg->virtual_address));
			LOG_STRING("===============================================================================");

			uint32 allocated_pages=0;
f010b162:	c7 85 28 ff ff ff 00 	movl   $0x0,-0xd8(%ebp)
f010b169:	00 00 00 
			program_segment_alloc_map_copy_workingset(e, seg, &allocated_pages, remaining_ws_pages, &lastTableNumber);
f010b16c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b172:	83 ec 0c             	sub    $0xc,%esp
f010b175:	8d 95 40 ff ff ff    	lea    -0xc0(%ebp),%edx
f010b17b:	52                   	push   %edx
f010b17c:	ff 75 dc             	pushl  -0x24(%ebp)
f010b17f:	8d 95 28 ff ff ff    	lea    -0xd8(%ebp),%edx
f010b185:	52                   	push   %edx
f010b186:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b189:	50                   	push   %eax
f010b18a:	e8 ad 0e 00 00       	call   f010c03c <program_segment_alloc_map_copy_workingset>
f010b18f:	83 c4 20             	add    $0x20,%esp

			remaining_ws_pages -= allocated_pages;
f010b192:	8b 85 28 ff ff ff    	mov    -0xd8(%ebp),%eax
f010b198:	29 45 dc             	sub    %eax,-0x24(%ebp)
			LOG_STATMENT(cprintf("SEGMENT: allocated pages in WS = %d",allocated_pages));
			LOG_STATMENT(cprintf("SEGMENT: remaining WS pages after allocation = %d",remaining_ws_pages));


			/// 7.2) temporary initialize 1st page in memory then writing it on page file
			uint32 dataSrc_va = (uint32) seg->ptr_start;
f010b19b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b19e:	8b 00                	mov    (%eax),%eax
f010b1a0:	89 45 94             	mov    %eax,-0x6c(%ebp)
			uint32 seg_va = (uint32) seg->virtual_address ;
f010b1a3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b1a6:	8b 40 0c             	mov    0xc(%eax),%eax
f010b1a9:	89 45 90             	mov    %eax,-0x70(%ebp)

			uint32 start_first_page = ROUNDDOWN(seg_va , PAGE_SIZE);
f010b1ac:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b1af:	89 45 8c             	mov    %eax,-0x74(%ebp)
f010b1b2:	8b 45 8c             	mov    -0x74(%ebp),%eax
f010b1b5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b1ba:	89 45 88             	mov    %eax,-0x78(%ebp)
			uint32 end_first_page = ROUNDUP(seg_va , PAGE_SIZE);
f010b1bd:	c7 45 84 00 10 00 00 	movl   $0x1000,-0x7c(%ebp)
f010b1c4:	8b 55 90             	mov    -0x70(%ebp),%edx
f010b1c7:	8b 45 84             	mov    -0x7c(%ebp),%eax
f010b1ca:	01 d0                	add    %edx,%eax
f010b1cc:	48                   	dec    %eax
f010b1cd:	89 45 80             	mov    %eax,-0x80(%ebp)
f010b1d0:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b1d3:	ba 00 00 00 00       	mov    $0x0,%edx
f010b1d8:	f7 75 84             	divl   -0x7c(%ebp)
f010b1db:	8b 45 80             	mov    -0x80(%ebp),%eax
f010b1de:	29 d0                	sub    %edx,%eax
f010b1e0:	89 85 7c ff ff ff    	mov    %eax,-0x84(%ebp)
			uint32 offset_first_page = seg_va  - start_first_page ;
f010b1e6:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b1e9:	2b 45 88             	sub    -0x78(%ebp),%eax
f010b1ec:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

			uint8 *src_ptr =  (uint8*) dataSrc_va;
f010b1f2:	8b 45 94             	mov    -0x6c(%ebp),%eax
f010b1f5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
f010b1f8:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f010b1fe:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f010b204:	01 d0                	add    %edx,%eax
f010b206:	89 45 d0             	mov    %eax,-0x30(%ebp)
			int i;
			if (offset_first_page)
f010b209:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f010b210:	74 76                	je     f010b288 <env_create+0x327>
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
f010b212:	a1 64 6d 85 f0       	mov    0xf0856d64,%eax
f010b217:	83 ec 04             	sub    $0x4,%esp
f010b21a:	68 00 10 00 00       	push   $0x1000
f010b21f:	6a 00                	push   $0x0
f010b221:	50                   	push   %eax
f010b222:	e8 42 fb 00 00       	call   f011ad69 <memset>
f010b227:	83 c4 10             	add    $0x10,%esp
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b22a:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b22d:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b230:	eb 13                	jmp    f010b245 <env_create+0x2e4>
				{
					*dst_ptr = *src_ptr ;
f010b232:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b235:	8a 10                	mov    (%eax),%dl
f010b237:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b23a:	88 10                	mov    %dl,(%eax)
			uint8 *dst_ptr =  (uint8*) (ptr_temp_page + offset_first_page);
			int i;
			if (offset_first_page)
			{
				memset(ptr_temp_page , 0, PAGE_SIZE);
				for (i = seg_va ; i < end_first_page ; i++, src_ptr++,dst_ptr++ )
f010b23c:	ff 45 cc             	incl   -0x34(%ebp)
f010b23f:	ff 45 d4             	incl   -0x2c(%ebp)
f010b242:	ff 45 d0             	incl   -0x30(%ebp)
f010b245:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b248:	3b 85 7c ff ff ff    	cmp    -0x84(%ebp),%eax
f010b24e:	72 e2                	jb     f010b232 <env_create+0x2d1>
				{
					*dst_ptr = *src_ptr ;
				}

				if (pf_add_env_page(e, start_first_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b250:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f010b256:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b25c:	83 ec 04             	sub    $0x4,%esp
f010b25f:	52                   	push   %edx
f010b260:	ff 75 88             	pushl  -0x78(%ebp)
f010b263:	50                   	push   %eax
f010b264:	e8 8e a0 ff ff       	call   f01052f7 <pf_add_env_page>
f010b269:	83 c4 10             	add    $0x10,%esp
f010b26c:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b26f:	75 17                	jne    f010b288 <env_create+0x327>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b271:	83 ec 04             	sub    $0x4,%esp
f010b274:	68 b4 f9 12 f0       	push   $0xf012f9b4
f010b279:	68 fe 00 00 00       	push   $0xfe
f010b27e:	68 97 f9 12 f0       	push   $0xf012f997
f010b283:	e8 27 5d ff ff       	call   f0100faf <_panic>
				//LOG_STRING(" -------------------- PAGE FILE: 1st page is written");
			}

			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
f010b288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b28b:	8b 50 04             	mov    0x4(%eax),%edx
f010b28e:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b291:	01 d0                	add    %edx,%eax
f010b293:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f010b299:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f010b29f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010b2a4:	89 85 70 ff ff ff    	mov    %eax,-0x90(%ebp)
			uint32 end_last_page = seg_va  + seg->size_in_file;
f010b2aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b2ad:	8b 50 04             	mov    0x4(%eax),%edx
f010b2b0:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b2b3:	01 d0                	add    %edx,%eax
f010b2b5:	89 85 6c ff ff ff    	mov    %eax,-0x94(%ebp)

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b2bb:	8b 85 7c ff ff ff    	mov    -0x84(%ebp),%eax
f010b2c1:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b2c4:	eb 43                	jmp    f010b309 <env_create+0x3a8>
			{
				if (pf_add_env_page(e, i, src_ptr) == E_NO_PAGE_FILE_SPACE)
f010b2c6:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010b2c9:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b2cf:	83 ec 04             	sub    $0x4,%esp
f010b2d2:	ff 75 d4             	pushl  -0x2c(%ebp)
f010b2d5:	52                   	push   %edx
f010b2d6:	50                   	push   %eax
f010b2d7:	e8 1b a0 ff ff       	call   f01052f7 <pf_add_env_page>
f010b2dc:	83 c4 10             	add    $0x10,%esp
f010b2df:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b2e2:	75 17                	jne    f010b2fb <env_create+0x39a>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b2e4:	83 ec 04             	sub    $0x4,%esp
f010b2e7:	68 b4 f9 12 f0       	push   $0xf012f9b4
f010b2ec:	68 0b 01 00 00       	push   $0x10b
f010b2f1:	68 97 f9 12 f0       	push   $0xf012f997
f010b2f6:	e8 b4 5c ff ff       	call   f0100faf <_panic>
			/// 7.3) Start writing the segment ,from 2nd page until before last page, to page file ...

			uint32 start_last_page = ROUNDDOWN(seg_va  + seg->size_in_file, PAGE_SIZE) ;
			uint32 end_last_page = seg_va  + seg->size_in_file;

			for (i = end_first_page ; i < start_last_page ; i+= PAGE_SIZE, src_ptr+= PAGE_SIZE)
f010b2fb:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b302:	81 45 d4 00 10 00 00 	addl   $0x1000,-0x2c(%ebp)
f010b309:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b30c:	3b 85 70 ff ff ff    	cmp    -0x90(%ebp),%eax
f010b312:	72 b2                	jb     f010b2c6 <env_create+0x365>
			}
			//LOG_STRING(" -------------------- PAGE FILE: 2nd page --> before last page are written");

			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
f010b314:	a1 64 6d 85 f0       	mov    0xf0856d64,%eax
f010b319:	89 45 d0             	mov    %eax,-0x30(%ebp)
			memset(dst_ptr, 0, PAGE_SIZE);
f010b31c:	83 ec 04             	sub    $0x4,%esp
f010b31f:	68 00 10 00 00       	push   $0x1000
f010b324:	6a 00                	push   $0x0
f010b326:	ff 75 d0             	pushl  -0x30(%ebp)
f010b329:	e8 3b fa 00 00       	call   f011ad69 <memset>
f010b32e:	83 c4 10             	add    $0x10,%esp

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b331:	8b 85 70 ff ff ff    	mov    -0x90(%ebp),%eax
f010b337:	89 45 cc             	mov    %eax,-0x34(%ebp)
f010b33a:	eb 13                	jmp    f010b34f <env_create+0x3ee>
			{
				*dst_ptr = *src_ptr;
f010b33c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010b33f:	8a 10                	mov    (%eax),%dl
f010b341:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010b344:	88 10                	mov    %dl,(%eax)
			/// 7.4) temporary initialize last page in memory then writing it on page file

			dst_ptr =  (uint8*) ptr_temp_page;
			memset(dst_ptr, 0, PAGE_SIZE);

			for (i = start_last_page ; i < end_last_page ; i++, src_ptr++,dst_ptr++ )
f010b346:	ff 45 cc             	incl   -0x34(%ebp)
f010b349:	ff 45 d4             	incl   -0x2c(%ebp)
f010b34c:	ff 45 d0             	incl   -0x30(%ebp)
f010b34f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b352:	3b 85 6c ff ff ff    	cmp    -0x94(%ebp),%eax
f010b358:	72 e2                	jb     f010b33c <env_create+0x3db>
			{
				*dst_ptr = *src_ptr;
			}
			if (pf_add_env_page(e, start_last_page, ptr_temp_page) == E_NO_PAGE_FILE_SPACE)
f010b35a:	8b 15 64 6d 85 f0    	mov    0xf0856d64,%edx
f010b360:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b366:	83 ec 04             	sub    $0x4,%esp
f010b369:	52                   	push   %edx
f010b36a:	ff b5 70 ff ff ff    	pushl  -0x90(%ebp)
f010b370:	50                   	push   %eax
f010b371:	e8 81 9f ff ff       	call   f01052f7 <pf_add_env_page>
f010b376:	83 c4 10             	add    $0x10,%esp
f010b379:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b37c:	75 17                	jne    f010b395 <env_create+0x434>
				panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b37e:	83 ec 04             	sub    $0x4,%esp
f010b381:	68 b4 f9 12 f0       	push   $0xf012f9b4
f010b386:	68 1a 01 00 00       	push   $0x11a
f010b38b:	68 97 f9 12 f0       	push   $0xf012f997
f010b390:	e8 1a 5c ff ff       	call   f0100faf <_panic>

			//LOG_STRING(" -------------------- PAGE FILE: last page is written");

			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
f010b395:	c7 85 68 ff ff ff 00 	movl   $0x1000,-0x98(%ebp)
f010b39c:	10 00 00 
f010b39f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b3a2:	8b 50 04             	mov    0x4(%eax),%edx
f010b3a5:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b3a8:	01 c2                	add    %eax,%edx
f010b3aa:	8b 85 68 ff ff ff    	mov    -0x98(%ebp),%eax
f010b3b0:	01 d0                	add    %edx,%eax
f010b3b2:	48                   	dec    %eax
f010b3b3:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
f010b3b9:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b3bf:	ba 00 00 00 00       	mov    $0x0,%edx
f010b3c4:	f7 b5 68 ff ff ff    	divl   -0x98(%ebp)
f010b3ca:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f010b3d0:	29 d0                	sub    %edx,%eax
f010b3d2:	89 45 c8             	mov    %eax,-0x38(%ebp)
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;
f010b3d5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010b3d8:	8b 50 08             	mov    0x8(%eax),%edx
f010b3db:	8b 45 90             	mov    -0x70(%ebp),%eax
f010b3de:	01 d0                	add    %edx,%eax
f010b3e0:	2b 45 c8             	sub    -0x38(%ebp),%eax
f010b3e3:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b3e9:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
f010b3f0:	eb 41                	jmp    f010b433 <env_create+0x4d2>
			{
				if (pf_add_empty_env_page(e, start_remaining_area, 1) == E_NO_PAGE_FILE_SPACE)
f010b3f2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b3f8:	83 ec 04             	sub    $0x4,%esp
f010b3fb:	6a 01                	push   $0x1
f010b3fd:	ff 75 c8             	pushl  -0x38(%ebp)
f010b400:	50                   	push   %eax
f010b401:	e8 c3 9d ff ff       	call   f01051c9 <pf_add_empty_env_page>
f010b406:	83 c4 10             	add    $0x10,%esp
f010b409:	83 f8 f8             	cmp    $0xfffffff8,%eax
f010b40c:	75 17                	jne    f010b425 <env_create+0x4c4>
					panic("ERROR: Page File OUT OF SPACE. can't load the program in Page file!!");
f010b40e:	83 ec 04             	sub    $0x4,%esp
f010b411:	68 b4 f9 12 f0       	push   $0xf012f9b4
f010b416:	68 27 01 00 00       	push   $0x127
f010b41b:	68 97 f9 12 f0       	push   $0xf012f997
f010b420:	e8 8a 5b ff ff       	call   f0100faf <_panic>
			/// 7.5) writing the remaining seg->size_in_memory pages to disk

			uint32 start_remaining_area = ROUNDUP(seg_va + seg->size_in_file,PAGE_SIZE) ;
			uint32 remainingLength = (seg_va + seg->size_in_memory) - start_remaining_area ;

			for (i=0 ; i < ROUNDUP(remainingLength,PAGE_SIZE) ;i+= PAGE_SIZE, start_remaining_area += PAGE_SIZE)
f010b425:	81 45 cc 00 10 00 00 	addl   $0x1000,-0x34(%ebp)
f010b42c:	81 45 c8 00 10 00 00 	addl   $0x1000,-0x38(%ebp)
f010b433:	c7 85 5c ff ff ff 00 	movl   $0x1000,-0xa4(%ebp)
f010b43a:	10 00 00 
f010b43d:	8b 95 60 ff ff ff    	mov    -0xa0(%ebp),%edx
f010b443:	8b 85 5c ff ff ff    	mov    -0xa4(%ebp),%eax
f010b449:	01 d0                	add    %edx,%eax
f010b44b:	48                   	dec    %eax
f010b44c:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%ebp)
f010b452:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b458:	ba 00 00 00 00       	mov    $0x0,%edx
f010b45d:	f7 b5 5c ff ff ff    	divl   -0xa4(%ebp)
f010b463:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f010b469:	29 d0                	sub    %edx,%eax
f010b46b:	89 c2                	mov    %eax,%edx
f010b46d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010b470:	39 c2                	cmp    %eax,%edx
f010b472:	0f 87 7a ff ff ff    	ja     f010b3f2 <env_create+0x491>
		struct ProgramSegment* seg = NULL;  //use inside PROGRAM_SEGMENT_FOREACH as current segment information
		int segment_counter=0;
		uint32 remaining_ws_pages = (e->page_WS_max_size)-1; // we are reserving 1 page of WS for the stack that will be allocated just before the end of this function
		uint32 lastTableNumber=0xffffffff;

		PROGRAM_SEGMENT_FOREACH(seg, ptr_program_start)
f010b478:	83 ec 08             	sub    $0x8,%esp
f010b47b:	ff 75 b0             	pushl  -0x50(%ebp)
f010b47e:	ff 75 e4             	pushl  -0x1c(%ebp)
f010b481:	e8 fc 15 00 00       	call   f010ca82 <PROGRAM_SEGMENT_NEXT>
f010b486:	83 c4 10             	add    $0x10,%esp
f010b489:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010b48c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f010b490:	0f 85 c9 fc ff ff    	jne    f010b15f <env_create+0x1fe>


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b496:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b49c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010b4a2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b4a5:	eb 77                	jmp    f010b51e <env_create+0x5bd>
		{
			uint32 virtual_address = wse->virtual_address;
f010b4a7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b4aa:	8b 00                	mov    (%eax),%eax
f010b4ac:	89 85 54 ff ff ff    	mov    %eax,-0xac(%ebp)
			uint32* ptr_page_table;

			//Here, page tables of all working set pages should be exist in memory
			//So, get_page_table should return the existing table
			get_page_table(e->env_page_directory, virtual_address, &ptr_page_table);
f010b4b2:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b4b8:	8b 40 64             	mov    0x64(%eax),%eax
f010b4bb:	83 ec 04             	sub    $0x4,%esp
f010b4be:	8d 95 24 ff ff ff    	lea    -0xdc(%ebp),%edx
f010b4c4:	52                   	push   %edx
f010b4c5:	ff b5 54 ff ff ff    	pushl  -0xac(%ebp)
f010b4cb:	50                   	push   %eax
f010b4cc:	e8 82 de ff ff       	call   f0109353 <get_page_table>
f010b4d1:	83 c4 10             	add    $0x10,%esp
			ptr_page_table[PTX(virtual_address)] &= (~PERM_MODIFIED);
f010b4d4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f010b4da:	8b 95 54 ff ff ff    	mov    -0xac(%ebp),%edx
f010b4e0:	c1 ea 0c             	shr    $0xc,%edx
f010b4e3:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f010b4e9:	c1 e2 02             	shl    $0x2,%edx
f010b4ec:	01 d0                	add    %edx,%eax
f010b4ee:	8b 95 24 ff ff ff    	mov    -0xdc(%ebp),%edx
f010b4f4:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
f010b4fa:	c1 e9 0c             	shr    $0xc,%ecx
f010b4fd:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
f010b503:	c1 e1 02             	shl    $0x2,%ecx
f010b506:	01 ca                	add    %ecx,%edx
f010b508:	8b 12                	mov    (%edx),%edx
f010b50a:	83 e2 bf             	and    $0xffffffbf,%edx
f010b50d:	89 10                	mov    %edx,(%eax)


		///[8] Clear the modified bit of each page in the pageWorkingSet to indicate it's a clean version
#if USE_KHEAP
		struct WorkingSetElement* wse ;
		LIST_FOREACH(wse, &(e->page_WS_list))
f010b50f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b515:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b51b:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010b51e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b524:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b528:	74 08                	je     f010b532 <env_create+0x5d1>
f010b52a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b52d:	8b 52 10             	mov    0x10(%edx),%edx
f010b530:	eb 05                	jmp    f010b537 <env_create+0x5d6>
f010b532:	ba 00 00 00 00       	mov    $0x0,%edx
f010b537:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010b53d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b543:	85 c0                	test   %eax,%eax
f010b545:	0f 85 5c ff ff ff    	jne    f010b4a7 <env_create+0x546>
f010b54b:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b54f:	0f 85 52 ff ff ff    	jne    f010b4a7 <env_create+0x546>
			}
		}
#endif

		//[9] now set the entry point of the environment
		set_environment_entry_point(e, ptr_user_program_info->ptr_start);
f010b555:	8b 45 ac             	mov    -0x54(%ebp),%eax
f010b558:	8b 50 08             	mov    0x8(%eax),%edx
f010b55b:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b561:	83 ec 08             	sub    $0x8,%esp
f010b564:	52                   	push   %edx
f010b565:	50                   	push   %eax
f010b566:	e8 d7 14 00 00       	call   f010ca42 <set_environment_entry_point>
f010b56b:	83 c4 10             	add    $0x10,%esp

		//[10] Allocate and map ONE page for the program's initial stack
		// at virtual address USTACKTOP - PAGE_SIZE.
		// we assume that the stack is counted in the environment working set

		e->initNumStackPages = 1;
f010b56e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b574:	c7 40 6c 01 00 00 00 	movl   $0x1,0x6c(%eax)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);
f010b57b:	c7 85 50 ff ff ff 00 	movl   $0xeebfd000,-0xb0(%ebp)
f010b582:	d0 bf ee 

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
f010b585:	c7 45 c0 00 d0 bf ee 	movl   $0xeebfd000,-0x40(%ebp)
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b58c:	e9 42 03 00 00       	jmp    f010b8d3 <env_create+0x972>
		{
			//allocate and map
			struct FrameInfo *pp = NULL;
f010b591:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f010b598:	00 00 00 
			allocate_frame(&pp);
f010b59b:	83 ec 0c             	sub    $0xc,%esp
f010b59e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f010b5a4:	50                   	push   %eax
f010b5a5:	e8 98 db ff ff       	call   f0109142 <allocate_frame>
f010b5aa:	83 c4 10             	add    $0x10,%esp
			loadtime_map_frame(e->env_page_directory, pp, stackVa, PERM_USER | PERM_WRITEABLE);
f010b5ad:	8b 95 20 ff ff ff    	mov    -0xe0(%ebp),%edx
f010b5b3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b5b9:	8b 40 64             	mov    0x64(%eax),%eax
f010b5bc:	6a 06                	push   $0x6
f010b5be:	ff 75 c0             	pushl  -0x40(%ebp)
f010b5c1:	52                   	push   %edx
f010b5c2:	50                   	push   %eax
f010b5c3:	e8 2b e2 ff ff       	call   f01097f3 <loadtime_map_frame>
f010b5c8:	83 c4 10             	add    $0x10,%esp

			//initialize new page by 0's
			memset((void*)stackVa, 0, PAGE_SIZE);
f010b5cb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b5ce:	83 ec 04             	sub    $0x4,%esp
f010b5d1:	68 00 10 00 00       	push   $0x1000
f010b5d6:	6a 00                	push   $0x0
f010b5d8:	50                   	push   %eax
f010b5d9:	e8 8b f7 00 00       	call   f011ad69 <memset>
f010b5de:	83 c4 10             	add    $0x10,%esp

			//now add it to the working set and the page table
			{
#if USE_KHEAP
				wse = env_page_ws_list_create_element(e, (uint32) stackVa);
f010b5e1:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b5e7:	83 ec 08             	sub    $0x8,%esp
f010b5ea:	ff 75 c0             	pushl  -0x40(%ebp)
f010b5ed:	50                   	push   %eax
f010b5ee:	e8 12 ea ff ff       	call   f010a005 <env_page_ws_list_create_element>
f010b5f3:	83 c4 10             	add    $0x10,%esp
f010b5f6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
				LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010b5f9:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b5fd:	75 17                	jne    f010b616 <env_create+0x6b5>
f010b5ff:	83 ec 04             	sub    $0x4,%esp
f010b602:	68 fc f9 12 f0       	push   $0xf012f9fc
f010b607:	68 66 01 00 00       	push   $0x166
f010b60c:	68 97 f9 12 f0       	push   $0xf012f997
f010b611:	e8 99 59 ff ff       	call   f0100faf <_panic>
f010b616:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b61c:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010b622:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b625:	89 50 14             	mov    %edx,0x14(%eax)
f010b628:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b62b:	8b 40 14             	mov    0x14(%eax),%eax
f010b62e:	85 c0                	test   %eax,%eax
f010b630:	74 14                	je     f010b646 <env_create+0x6e5>
f010b632:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b638:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010b63e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b641:	89 50 10             	mov    %edx,0x10(%eax)
f010b644:	eb 0f                	jmp    f010b655 <env_create+0x6f4>
f010b646:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b64c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b64f:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b655:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b65b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b65e:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b664:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b667:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b66e:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b674:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b67a:	42                   	inc    %edx
f010b67b:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
				if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010b681:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b687:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b68d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b693:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010b699:	39 c2                	cmp    %eax,%edx
f010b69b:	75 1a                	jne    f010b6b7 <env_create+0x756>
				{
					e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010b69d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6a3:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b6a9:	8b 92 88 00 00 00    	mov    0x88(%edx),%edx
f010b6af:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010b6b5:	eb 10                	jmp    f010b6c7 <env_create+0x766>
				}
				else
				{
					e->page_last_WS_element = NULL;
f010b6b7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b6bd:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010b6c4:	00 00 00 
				}
				//2020
				if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b6c7:	83 ec 0c             	sub    $0xc,%esp
f010b6ca:	6a 02                	push   $0x2
f010b6cc:	e8 52 42 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010b6d1:	83 c4 10             	add    $0x10,%esp
f010b6d4:	85 c0                	test   %eax,%eax
f010b6d6:	0f 84 d3 01 00 00    	je     f010b8af <env_create+0x94e>
				{
					//Remove wse from page_WS_list
					LIST_REMOVE(&(e->page_WS_list), wse);
f010b6dc:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b6e0:	75 17                	jne    f010b6f9 <env_create+0x798>
f010b6e2:	83 ec 04             	sub    $0x4,%esp
f010b6e5:	68 1f fa 12 f0       	push   $0xf012fa1f
f010b6ea:	68 73 01 00 00       	push   $0x173
f010b6ef:	68 97 f9 12 f0       	push   $0xf012f997
f010b6f4:	e8 b6 58 ff ff       	call   f0100faf <_panic>
f010b6f9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b6fc:	8b 40 10             	mov    0x10(%eax),%eax
f010b6ff:	85 c0                	test   %eax,%eax
f010b701:	74 11                	je     f010b714 <env_create+0x7b3>
f010b703:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b706:	8b 40 10             	mov    0x10(%eax),%eax
f010b709:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b70c:	8b 52 14             	mov    0x14(%edx),%edx
f010b70f:	89 50 14             	mov    %edx,0x14(%eax)
f010b712:	eb 12                	jmp    f010b726 <env_create+0x7c5>
f010b714:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b71a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b71d:	8b 52 14             	mov    0x14(%edx),%edx
f010b720:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010b726:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b729:	8b 40 14             	mov    0x14(%eax),%eax
f010b72c:	85 c0                	test   %eax,%eax
f010b72e:	74 11                	je     f010b741 <env_create+0x7e0>
f010b730:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b733:	8b 40 14             	mov    0x14(%eax),%eax
f010b736:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b739:	8b 52 10             	mov    0x10(%edx),%edx
f010b73c:	89 50 10             	mov    %edx,0x10(%eax)
f010b73f:	eb 12                	jmp    f010b753 <env_create+0x7f2>
f010b741:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b747:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b74a:	8b 52 10             	mov    0x10(%edx),%edx
f010b74d:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010b753:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b756:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010b75d:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b760:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b767:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b76d:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010b773:	4a                   	dec    %edx
f010b774:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
					//Now: we are sure that at least the top page in the stack will be added to Active list
					//Since we left 1 empty location in the Active list when we loaded the program segments
					if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize)
f010b77a:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b780:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010b786:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b78c:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010b792:	39 c2                	cmp    %eax,%edx
f010b794:	0f 83 8d 00 00 00    	jae    f010b827 <env_create+0x8c6>
					{
						LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010b79a:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b79e:	75 17                	jne    f010b7b7 <env_create+0x856>
f010b7a0:	83 ec 04             	sub    $0x4,%esp
f010b7a3:	68 74 f9 12 f0       	push   $0xf012f974
f010b7a8:	68 78 01 00 00       	push   $0x178
f010b7ad:	68 97 f9 12 f0       	push   $0xf012f997
f010b7b2:	e8 f8 57 ff ff       	call   f0100faf <_panic>
f010b7b7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7bd:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010b7c3:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b7c6:	89 50 10             	mov    %edx,0x10(%eax)
f010b7c9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b7cc:	8b 40 10             	mov    0x10(%eax),%eax
f010b7cf:	85 c0                	test   %eax,%eax
f010b7d1:	74 14                	je     f010b7e7 <env_create+0x886>
f010b7d3:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7d9:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010b7df:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b7e2:	89 50 14             	mov    %edx,0x14(%eax)
f010b7e5:	eb 0f                	jmp    f010b7f6 <env_create+0x895>
f010b7e7:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7ed:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b7f0:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010b7f6:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b7fc:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b7ff:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010b805:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b808:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b80f:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b815:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010b81b:	42                   	inc    %edx
f010b81c:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010b822:	e9 88 00 00 00       	jmp    f010b8af <env_create+0x94e>
					}
					else
					{
						LIST_INSERT_HEAD(&(e->SecondList), wse);
f010b827:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f010b82b:	75 17                	jne    f010b844 <env_create+0x8e3>
f010b82d:	83 ec 04             	sub    $0x4,%esp
f010b830:	68 74 f9 12 f0       	push   $0xf012f974
f010b835:	68 7c 01 00 00       	push   $0x17c
f010b83a:	68 97 f9 12 f0       	push   $0xf012f997
f010b83f:	e8 6b 57 ff ff       	call   f0100faf <_panic>
f010b844:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b84a:	8b 90 78 05 00 00    	mov    0x578(%eax),%edx
f010b850:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b853:	89 50 10             	mov    %edx,0x10(%eax)
f010b856:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b859:	8b 40 10             	mov    0x10(%eax),%eax
f010b85c:	85 c0                	test   %eax,%eax
f010b85e:	74 14                	je     f010b874 <env_create+0x913>
f010b860:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b866:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b86c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b86f:	89 50 14             	mov    %edx,0x14(%eax)
f010b872:	eb 0f                	jmp    f010b883 <env_create+0x922>
f010b874:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b87a:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b87d:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010b883:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b889:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f010b88c:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010b892:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010b895:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010b89c:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8a2:	8b 90 84 05 00 00    	mov    0x584(%eax),%edx
f010b8a8:	42                   	inc    %edx
f010b8a9:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)

				//addTableToTableWorkingSet(e, ROUNDDOWN((uint32)stackVa, PAGE_SIZE*1024));
			}

			//add this page to the page file
			int success = pf_add_empty_env_page(e, (uint32)stackVa, 1);
f010b8af:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b8b5:	83 ec 04             	sub    $0x4,%esp
f010b8b8:	6a 01                	push   $0x1
f010b8ba:	ff 75 c0             	pushl  -0x40(%ebp)
f010b8bd:	50                   	push   %eax
f010b8be:	e8 06 99 ff ff       	call   f01051c9 <pf_add_empty_env_page>
f010b8c3:	83 c4 10             	add    $0x10,%esp
f010b8c6:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%ebp)

		//cprintf("\nwill allocate stack pages\n");
		uint32 ptr_user_stack_bottom = (USTACKTOP - 1*PAGE_SIZE);

		uint32 stackVa = USTACKTOP - PAGE_SIZE;
		for(;stackVa >= ptr_user_stack_bottom; stackVa -= PAGE_SIZE)
f010b8cc:	81 6d c0 00 10 00 00 	subl   $0x1000,-0x40(%ebp)
f010b8d3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010b8d6:	3b 85 50 ff ff ff    	cmp    -0xb0(%ebp),%eax
f010b8dc:	0f 83 af fc ff ff    	jae    f010b591 <env_create+0x630>
			//if(success == 0) LOG_STATMENT(cprintf("STACK Page added to page file successfully\n"));
		}

		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010b8e2:	83 ec 0c             	sub    $0xc,%esp
f010b8e5:	6a 02                	push   $0x2
f010b8e7:	e8 37 40 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010b8ec:	83 c4 10             	add    $0x10,%esp
f010b8ef:	85 c0                	test   %eax,%eax
f010b8f1:	74 72                	je     f010b965 <env_create+0xa04>
		{
			struct WorkingSetElement * elm = NULL;
f010b8f3:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
			LIST_FOREACH(elm, &(e->SecondList))
f010b8fa:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b900:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010b906:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010b909:	eb 2b                	jmp    f010b936 <env_create+0x9d5>
			{
				//set it's PRESENT bit to 0
				pt_set_page_permissions(e->env_page_directory, elm->virtual_address, 0, PERM_PRESENT);
f010b90b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f010b90e:	8b 10                	mov    (%eax),%edx
f010b910:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b916:	8b 40 64             	mov    0x64(%eax),%eax
f010b919:	6a 01                	push   $0x1
f010b91b:	6a 00                	push   $0x0
f010b91d:	52                   	push   %edx
f010b91e:	50                   	push   %eax
f010b91f:	e8 db e3 ff ff       	call   f0109cff <pt_set_page_permissions>
f010b924:	83 c4 10             	add    $0x10,%esp
		//2020
		//LRU Lists: Reset PRESENT bit of all pages in Second List
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
		{
			struct WorkingSetElement * elm = NULL;
			LIST_FOREACH(elm, &(e->SecondList))
f010b927:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b92d:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b933:	89 45 bc             	mov    %eax,-0x44(%ebp)
f010b936:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b93c:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b940:	74 08                	je     f010b94a <env_create+0x9e9>
f010b942:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010b945:	8b 52 10             	mov    0x10(%edx),%edx
f010b948:	eb 05                	jmp    f010b94f <env_create+0x9ee>
f010b94a:	ba 00 00 00 00       	mov    $0x0,%edx
f010b94f:	89 90 80 05 00 00    	mov    %edx,0x580(%eax)
f010b955:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f010b95b:	85 c0                	test   %eax,%eax
f010b95d:	75 ac                	jne    f010b90b <env_create+0x9aa>
f010b95f:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
f010b963:	75 a6                	jne    f010b90b <env_create+0x9aa>
f010b965:	8b 45 9c             	mov    -0x64(%ebp),%eax
f010b968:	89 45 a0             	mov    %eax,-0x60(%ebp)
f010b96b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f010b96e:	0f 22 d8             	mov    %eax,%cr3

		///[11] switch back to the page directory exists before segment loading
		lcr3(cur_phys_pgdir) ;
	}
	//[12] Re-enable the interrupt (if it was too)
	popcli();
f010b971:	e8 0c c8 ff ff       	call   f0108182 <popcli>

	//[13] Copy the prepaged VAs into the corresponding array
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
f010b976:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b97c:	8b 95 44 ff ff ff    	mov    -0xbc(%ebp),%edx
f010b982:	8b 92 94 00 00 00    	mov    0x94(%edx),%edx
f010b988:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
f010b98e:	8b 9d 44 ff ff ff    	mov    -0xbc(%ebp),%ebx
f010b994:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b99a:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010b9a0:	c1 e0 02             	shl    $0x2,%eax
f010b9a3:	83 ec 0c             	sub    $0xc,%esp
f010b9a6:	50                   	push   %eax
f010b9a7:	e8 8a e2 ff ff       	call   f0109c36 <kmalloc>
f010b9ac:	83 c4 10             	add    $0x10,%esp
f010b9af:	89 83 ac 00 00 00    	mov    %eax,0xac(%ebx)
	struct WorkingSetElement *ptrWSE;
	int w = 0;
f010b9b5:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%ebp)
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010b9bc:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b9c2:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010b9c8:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b9cb:	eb 31                	jmp    f010b9fe <env_create+0xa9d>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
f010b9cd:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b9d3:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
f010b9d9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010b9dc:	8d 50 01             	lea    0x1(%eax),%edx
f010b9df:	89 55 b4             	mov    %edx,-0x4c(%ebp)
f010b9e2:	c1 e0 02             	shl    $0x2,%eax
f010b9e5:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f010b9e8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f010b9eb:	8b 00                	mov    (%eax),%eax
f010b9ed:	89 02                	mov    %eax,(%edx)
#if USE_KHEAP
	e->numOfPrepagedVAs = LIST_SIZE(&(e->page_WS_list));
	e->prepagedVAs = kmalloc(sizeof(uint32) * e->numOfPrepagedVAs);
	struct WorkingSetElement *ptrWSE;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(e->page_WS_list))
f010b9ef:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010b9f5:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010b9fb:	89 45 b8             	mov    %eax,-0x48(%ebp)
f010b9fe:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010ba04:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010ba08:	74 08                	je     f010ba12 <env_create+0xab1>
f010ba0a:	8b 55 b8             	mov    -0x48(%ebp),%edx
f010ba0d:	8b 52 10             	mov    0x10(%edx),%edx
f010ba10:	eb 05                	jmp    f010ba17 <env_create+0xab6>
f010ba12:	ba 00 00 00 00       	mov    $0x0,%edx
f010ba17:	89 90 90 00 00 00    	mov    %edx,0x90(%eax)
f010ba1d:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010ba23:	85 c0                	test   %eax,%eax
f010ba25:	75 a6                	jne    f010b9cd <env_create+0xa6c>
f010ba27:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
f010ba2b:	75 a0                	jne    f010b9cd <env_create+0xa6c>
	{
		e->prepagedVAs[w++] = ptrWSE->virtual_address;
	}
	assert(w == e->numOfPrepagedVAs);
f010ba2d:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
f010ba33:	8b 90 b0 00 00 00    	mov    0xb0(%eax),%edx
f010ba39:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f010ba3c:	39 c2                	cmp    %eax,%edx
f010ba3e:	74 19                	je     f010ba59 <env_create+0xaf8>
f010ba40:	68 3d fa 12 f0       	push   $0xf012fa3d
f010ba45:	68 56 fa 12 f0       	push   $0xf012fa56
f010ba4a:	68 b9 01 00 00       	push   $0x1b9
f010ba4f:	68 97 f9 12 f0       	push   $0xf012f997
f010ba54:	e8 56 55 ff ff       	call   f0100faf <_panic>
		//env_page_ws_print(e);

		//	cprintf("Table working set after loading the program...\n");
		//	env_table_ws_print(e);
	}
	return e;
f010ba59:	8b 85 44 ff ff ff    	mov    -0xbc(%ebp),%eax
}
f010ba5f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010ba62:	5b                   	pop    %ebx
f010ba63:	5e                   	pop    %esi
f010ba64:	5f                   	pop    %edi
f010ba65:	5d                   	pop    %ebp
f010ba66:	c3                   	ret    

f010ba67 <env_start>:
// 2) START EXECUTING THE PROCESS:
//===============================
// called only at the very first scheduling by scheduler()
// will context_switch() here.  "Return" to user space.
void env_start(void)
{
f010ba67:	55                   	push   %ebp
f010ba68:	89 e5                	mov    %esp,%ebp
f010ba6a:	83 ec 18             	sub    $0x18,%esp
	static int first = 1;
	// Still holding q.lock from scheduler.
	release_kspinlock(&ProcessQueues.qlock);
f010ba6d:	83 ec 0c             	sub    $0xc,%esp
f010ba70:	68 20 e7 83 f0       	push   $0xf083e720
f010ba75:	e8 a6 44 00 00       	call   f010ff20 <release_kspinlock>
f010ba7a:	83 c4 10             	add    $0x10,%esp

	if (first)
f010ba7d:	a1 c4 fb 17 f0       	mov    0xf017fbc4,%eax
f010ba82:	85 c0                	test   %eax,%eax
f010ba84:	74 30                	je     f010bab6 <env_start+0x4f>
	{
		struct Env* p = get_cpu_proc();
f010ba86:	e8 8d 00 00 00       	call   f010bb18 <get_cpu_proc>
f010ba8b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		cprintf("\n[ENV_START] %s - %d\n", p->prog_name, p->env_id);
f010ba8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ba91:	8b 40 10             	mov    0x10(%eax),%eax
f010ba94:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ba97:	83 c2 20             	add    $0x20,%edx
f010ba9a:	83 ec 04             	sub    $0x4,%esp
f010ba9d:	50                   	push   %eax
f010ba9e:	52                   	push   %edx
f010ba9f:	68 6b fa 12 f0       	push   $0xf012fa6b
f010baa4:	e8 b3 61 ff ff       	call   f0101c5c <cprintf>
f010baa9:	83 c4 10             	add    $0x10,%esp

		// Some initialization functions must be run in the context
		// of a regular process (e.g., they call sleep), and thus cannot
		// be run from main().
		first = 0;
f010baac:	c7 05 c4 fb 17 f0 00 	movl   $0x0,0xf017fbc4
f010bab3:	00 00 00 
	}

	// Return to "caller", actually trapret (see initialize_environment()).
}
f010bab6:	90                   	nop
f010bab7:	c9                   	leave  
f010bab8:	c3                   	ret    

f010bab9 <env_free>:
// 3) FREE ENV FROM THE SYSTEM:
//===============================
// Frees environment "e" and all memory it uses.
//
void env_free(struct Env *e)
{
f010bab9:	55                   	push   %ebp
f010baba:	89 e5                	mov    %esp,%ebp
f010babc:	83 ec 08             	sub    $0x8,%esp
#endif
	/*****************************************/
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - env_free
	//Your code is here
	//Comment the following line
	panic("env_free() is not implemented yet...!!");
f010babf:	83 ec 04             	sub    $0x4,%esp
f010bac2:	68 84 fa 12 f0       	push   $0xf012fa84
f010bac7:	68 f3 01 00 00       	push   $0x1f3
f010bacc:	68 97 f9 12 f0       	push   $0xf012f997
f010bad1:	e8 d9 54 ff ff       	call   f0100faf <_panic>

f010bad6 <env_exit>:
//============================
// 4) PLACE ENV IN EXIT QUEUE:
//============================
//Just add the "curenv" to the EXIT list, then reinvoke the scheduler
void env_exit(void)
{
f010bad6:	55                   	push   %ebp
f010bad7:	89 e5                	mov    %esp,%ebp
f010bad9:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010badc:	e8 37 00 00 00       	call   f010bb18 <get_cpu_proc>
f010bae1:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010bae4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bae8:	75 19                	jne    f010bb03 <env_exit+0x2d>
f010baea:	68 ab fa 12 f0       	push   $0xf012faab
f010baef:	68 56 fa 12 f0       	push   $0xf012fa56
f010baf4:	68 0e 02 00 00       	push   $0x20e
f010baf9:	68 97 f9 12 f0       	push   $0xf012f997
f010bafe:	e8 ac 54 ff ff       	call   f0100faf <_panic>
	sched_exit_env(cur_env->env_id);
f010bb03:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb06:	8b 40 10             	mov    0x10(%eax),%eax
f010bb09:	83 ec 0c             	sub    $0xc,%esp
f010bb0c:	50                   	push   %eax
f010bb0d:	e8 84 ad ff ff       	call   f0106896 <sched_exit_env>
f010bb12:	83 c4 10             	add    $0x10,%esp
	//2024: Replaced by context switch in the sched() function which will be called in sched_exit_env()
	//fos_scheduler();
}
f010bb15:	90                   	nop
f010bb16:	c9                   	leave  
f010bb17:	c3                   	ret    

f010bb18 <get_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while reading proc from the cpu structure
// Ref: xv6-x86 OS
struct Env* get_cpu_proc(void)
{
f010bb18:	55                   	push   %ebp
f010bb19:	89 e5                	mov    %esp,%ebp
f010bb1b:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	struct Env *p;
	pushcli();
f010bb1e:	e8 0d c6 ff ff       	call   f0108130 <pushcli>
	c = mycpu();
f010bb23:	e8 48 c5 ff ff       	call   f0108070 <mycpu>
f010bb28:	89 45 f4             	mov    %eax,-0xc(%ebp)
	p = c->proc;
f010bb2b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb2e:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bb34:	89 45 f0             	mov    %eax,-0x10(%ebp)
	popcli();
f010bb37:	e8 46 c6 ff ff       	call   f0108182 <popcli>
	return p;
f010bb3c:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f010bb3f:	c9                   	leave  
f010bb40:	c3                   	ret    

f010bb41 <set_cpu_proc>:
//===================================
// Disable interrupts so that we are not rescheduled
// while setting proc into the cpu structure
// Ref: xv6-x86 OS
void set_cpu_proc(struct Env* p)
{
f010bb41:	55                   	push   %ebp
f010bb42:	89 e5                	mov    %esp,%ebp
f010bb44:	83 ec 18             	sub    $0x18,%esp
	struct cpu *c;
	pushcli();
f010bb47:	e8 e4 c5 ff ff       	call   f0108130 <pushcli>
	c = mycpu();
f010bb4c:	e8 1f c5 ff ff       	call   f0108070 <mycpu>
f010bb51:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = p;
f010bb54:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bb57:	8b 55 08             	mov    0x8(%ebp),%edx
f010bb5a:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)
	popcli();
f010bb60:	e8 1d c6 ff ff       	call   f0108182 <popcli>
}
f010bb65:	90                   	nop
f010bb66:	c9                   	leave  
f010bb67:	c3                   	ret    

f010bb68 <envid2env>:
//   0 on success, -E_BAD_ENV on error.
//   On success, sets *penv to the environment.
//   On error, sets *penv to NULL.
//
int envid2env(int32  envid, struct Env **env_store, bool checkperm)
{
f010bb68:	55                   	push   %ebp
f010bb69:	89 e5                	mov    %esp,%ebp
f010bb6b:	53                   	push   %ebx
f010bb6c:	83 ec 14             	sub    $0x14,%esp
	struct Env *e;

	// If envid is zero, return the current environment.
	if (envid == 0) {
f010bb6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bb73:	75 16                	jne    f010bb8b <envid2env+0x23>
		*env_store = get_cpu_proc();
f010bb75:	e8 9e ff ff ff       	call   f010bb18 <get_cpu_proc>
f010bb7a:	89 c2                	mov    %eax,%edx
f010bb7c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bb7f:	89 10                	mov    %edx,(%eax)
		return 0;
f010bb81:	b8 00 00 00 00       	mov    $0x0,%eax
f010bb86:	e9 a3 00 00 00       	jmp    f010bc2e <envid2env+0xc6>
	// Look up the Env structure via the index part of the envid,
	// then check the env_id field in that struct Env
	// to ensure that the envid is not stale
	// (i.e., does not refer to a _previous_ environment
	// that used the same slot in the envs[] array).
	e = &envs[ENVX(envid)];
f010bb8b:	8b 1d 90 5b 81 f0    	mov    0xf0815b90,%ebx
f010bb91:	83 ec 0c             	sub    $0xc,%esp
f010bb94:	68 c6 02 00 00       	push   $0x2c6
f010bb99:	e8 7d d0 00 00       	call   f0118c1b <nearest_pow2_ceil>
f010bb9e:	83 c4 10             	add    $0x10,%esp
f010bba1:	8d 50 ff             	lea    -0x1(%eax),%edx
f010bba4:	8b 45 08             	mov    0x8(%ebp),%eax
f010bba7:	21 c2                	and    %eax,%edx
f010bba9:	89 d0                	mov    %edx,%eax
f010bbab:	c1 e0 02             	shl    $0x2,%eax
f010bbae:	01 d0                	add    %edx,%eax
f010bbb0:	c1 e0 03             	shl    $0x3,%eax
f010bbb3:	01 d0                	add    %edx,%eax
f010bbb5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f010bbbc:	01 d0                	add    %edx,%eax
f010bbbe:	c1 e0 02             	shl    $0x2,%eax
f010bbc1:	01 d8                	add    %ebx,%eax
f010bbc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (e->env_status == ENV_FREE || e->env_id != envid) {
f010bbc6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbc9:	8b 40 18             	mov    0x18(%eax),%eax
f010bbcc:	85 c0                	test   %eax,%eax
f010bbce:	74 0b                	je     f010bbdb <envid2env+0x73>
f010bbd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbd3:	8b 40 10             	mov    0x10(%eax),%eax
f010bbd6:	3b 45 08             	cmp    0x8(%ebp),%eax
f010bbd9:	74 10                	je     f010bbeb <envid2env+0x83>
		*env_store = 0;
f010bbdb:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bbde:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bbe4:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bbe9:	eb 43                	jmp    f010bc2e <envid2env+0xc6>
	// Check that the calling environment has legitimate permission
	// to manipulate the specified environment.
	// If checkperm is set, the specified environment
	// must be either the current environment
	// or an immediate child of the current environment.
	struct Env* cur_env = get_cpu_proc();
f010bbeb:	e8 28 ff ff ff       	call   f010bb18 <get_cpu_proc>
f010bbf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (checkperm && e != cur_env && e->env_parent_id != cur_env->env_id) {
f010bbf3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f010bbf7:	74 28                	je     f010bc21 <envid2env+0xb9>
f010bbf9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bbfc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010bbff:	74 20                	je     f010bc21 <envid2env+0xb9>
f010bc01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc04:	8b 50 14             	mov    0x14(%eax),%edx
f010bc07:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010bc0a:	8b 40 10             	mov    0x10(%eax),%eax
f010bc0d:	39 c2                	cmp    %eax,%edx
f010bc0f:	74 10                	je     f010bc21 <envid2env+0xb9>
		*env_store = 0;
f010bc11:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc14:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		return E_BAD_ENV;
f010bc1a:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010bc1f:	eb 0d                	jmp    f010bc2e <envid2env+0xc6>
	}

	*env_store = e;
f010bc21:	8b 45 0c             	mov    0xc(%ebp),%eax
f010bc24:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bc27:	89 10                	mov    %edx,(%eax)
	return 0;
f010bc29:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bc2e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bc31:	c9                   	leave  
f010bc32:	c3                   	ret    

f010bc33 <yield>:
// 7) GIVE-UP CPU TO THE SCHEDULER:
//=================================
// Give up the CPU for one scheduling round.
// Ref: xv6-x86 OS
void yield(void)
{
f010bc33:	55                   	push   %ebp
f010bc34:	89 e5                	mov    %esp,%ebp
f010bc36:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\n[YIELD] acquire: lock status before acquire = %d\n", qlock.locked);
	acquire_kspinlock(&ProcessQueues.qlock);  //lock: to protect process Qs in multi-CPU
f010bc39:	83 ec 0c             	sub    $0xc,%esp
f010bc3c:	68 20 e7 83 f0       	push   $0xf083e720
f010bc41:	e8 35 42 00 00       	call   f010fe7b <acquire_kspinlock>
f010bc46:	83 c4 10             	add    $0x10,%esp
	{
		struct Env* p = get_cpu_proc();
f010bc49:	e8 ca fe ff ff       	call   f010bb18 <get_cpu_proc>
f010bc4e:	89 45 f4             	mov    %eax,-0xc(%ebp)
		assert(p != NULL);
f010bc51:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bc55:	75 19                	jne    f010bc70 <yield+0x3d>
f010bc57:	68 bb fa 12 f0       	push   $0xf012fabb
f010bc5c:	68 56 fa 12 f0       	push   $0xf012fa56
f010bc61:	68 6c 02 00 00       	push   $0x26c
f010bc66:	68 97 f9 12 f0       	push   $0xf012f997
f010bc6b:	e8 3f 53 ff ff       	call   f0100faf <_panic>
		p->env_status = ENV_READY;
f010bc70:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bc73:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%eax)
		sched();
f010bc7a:	e8 13 00 00 00       	call   f010bc92 <sched>
	}
	release_kspinlock(&ProcessQueues.qlock); ////release lock
f010bc7f:	83 ec 0c             	sub    $0xc,%esp
f010bc82:	68 20 e7 83 f0       	push   $0xf083e720
f010bc87:	e8 94 42 00 00       	call   f010ff20 <release_kspinlock>
f010bc8c:	83 c4 10             	add    $0x10,%esp
	//cprintf("\n[YIELD] release: lock status after release = %d\n", qlock.locked);
}
f010bc8f:	90                   	nop
f010bc90:	c9                   	leave  
f010bc91:	c3                   	ret    

f010bc92 <sched>:
// Saves and restores intena because intena is a property of this kernel thread, not this CPU.
// It should be proc->intena and proc->ncli, but that would break in the few places
// where a lock is held but there's no process.
// Ref: xv6-x86 OS
void sched(void)
{
f010bc92:	55                   	push   %ebp
f010bc93:	89 e5                	mov    %esp,%ebp
f010bc95:	83 ec 18             	sub    $0x18,%esp
	int intena;
	struct Env *p = get_cpu_proc();
f010bc98:	e8 7b fe ff ff       	call   f010bb18 <get_cpu_proc>
f010bc9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(p != NULL);
f010bca0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010bca4:	75 19                	jne    f010bcbf <sched+0x2d>
f010bca6:	68 bb fa 12 f0       	push   $0xf012fabb
f010bcab:	68 56 fa 12 f0       	push   $0xf012fa56
f010bcb0:	68 80 02 00 00       	push   $0x280
f010bcb5:	68 97 f9 12 f0       	push   $0xf012f997
f010bcba:	e8 f0 52 ff ff       	call   f0100faf <_panic>

	/*To protect process Qs (or info of current process) in multi-CPU*/
	if(!holding_kspinlock(&ProcessQueues.qlock))
f010bcbf:	83 ec 0c             	sub    $0xc,%esp
f010bcc2:	68 20 e7 83 f0       	push   $0xf083e720
f010bcc7:	e8 04 44 00 00       	call   f01100d0 <holding_kspinlock>
f010bccc:	83 c4 10             	add    $0x10,%esp
f010bccf:	85 c0                	test   %eax,%eax
f010bcd1:	75 17                	jne    f010bcea <sched+0x58>
		panic("sched: q.lock is not held by this CPU while it's expected to be. ");
f010bcd3:	83 ec 04             	sub    $0x4,%esp
f010bcd6:	68 c8 fa 12 f0       	push   $0xf012fac8
f010bcdb:	68 84 02 00 00       	push   $0x284
f010bce0:	68 97 f9 12 f0       	push   $0xf012f997
f010bce5:	e8 c5 52 ff ff       	call   f0100faf <_panic>
	/*Should ensure that the ncli = 1 so that the interrupt will be released after scheduling the next proc*/
	if(mycpu()->ncli != 1)
f010bcea:	e8 81 c3 ff ff       	call   f0108070 <mycpu>
f010bcef:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bcf5:	83 f8 01             	cmp    $0x1,%eax
f010bcf8:	74 20                	je     f010bd1a <sched+0x88>
		panic("sched locks: ncli = %d", mycpu()->ncli);
f010bcfa:	e8 71 c3 ff ff       	call   f0108070 <mycpu>
f010bcff:	8b 80 a8 00 00 00    	mov    0xa8(%eax),%eax
f010bd05:	50                   	push   %eax
f010bd06:	68 0a fb 12 f0       	push   $0xf012fb0a
f010bd0b:	68 87 02 00 00       	push   $0x287
f010bd10:	68 97 f9 12 f0       	push   $0xf012f997
f010bd15:	e8 95 52 ff ff       	call   f0100faf <_panic>
	/*********************************************************************/
	if(p->env_status == ENV_RUNNING)
f010bd1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bd1d:	8b 40 18             	mov    0x18(%eax),%eax
f010bd20:	83 f8 02             	cmp    $0x2,%eax
f010bd23:	75 17                	jne    f010bd3c <sched+0xaa>
		panic("sched a running process");
f010bd25:	83 ec 04             	sub    $0x4,%esp
f010bd28:	68 21 fb 12 f0       	push   $0xf012fb21
f010bd2d:	68 8a 02 00 00       	push   $0x28a
f010bd32:	68 97 f9 12 f0       	push   $0xf012f997
f010bd37:	e8 73 52 ff ff       	call   f0100faf <_panic>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010bd3c:	9c                   	pushf  
f010bd3d:	58                   	pop    %eax
f010bd3e:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010bd41:	8b 45 ec             	mov    -0x14(%ebp),%eax
	if(read_eflags()&FL_IF)
f010bd44:	25 00 02 00 00       	and    $0x200,%eax
f010bd49:	85 c0                	test   %eax,%eax
f010bd4b:	74 17                	je     f010bd64 <sched+0xd2>
		panic("sched is interruptible!");
f010bd4d:	83 ec 04             	sub    $0x4,%esp
f010bd50:	68 39 fb 12 f0       	push   $0xf012fb39
f010bd55:	68 8c 02 00 00       	push   $0x28c
f010bd5a:	68 97 f9 12 f0       	push   $0xf012f997
f010bd5f:	e8 4b 52 ff ff       	call   f0100faf <_panic>
	intena = mycpu()->intena;
f010bd64:	e8 07 c3 ff ff       	call   f0108070 <mycpu>
f010bd69:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
f010bd6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	context_switch(&(p->context), mycpu()->scheduler);
f010bd72:	e8 f9 c2 ff ff       	call   f0108070 <mycpu>
f010bd77:	8b 40 04             	mov    0x4(%eax),%eax
f010bd7a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010bd7d:	83 c2 04             	add    $0x4,%edx
f010bd80:	83 ec 08             	sub    $0x8,%esp
f010bd83:	50                   	push   %eax
f010bd84:	52                   	push   %edx
f010bd85:	e8 48 9e ff ff       	call   f0105bd2 <context_switch>
f010bd8a:	83 c4 10             	add    $0x10,%esp
	mycpu()->intena = intena;
f010bd8d:	e8 de c2 ff ff       	call   f0108070 <mycpu>
f010bd92:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010bd95:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)
}
f010bd9b:	90                   	nop
f010bd9c:	c9                   	leave  
f010bd9d:	c3                   	ret    

f010bd9e <switchkvm>:
// 9) SWITCH VIRTUAL MEMORYs:
//===============================
// [9.1] Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void switchkvm(void)
{
f010bd9e:	55                   	push   %ebp
f010bd9f:	89 e5                	mov    %esp,%ebp
f010bda1:	83 ec 10             	sub    $0x10,%esp
	lcr3(phys_page_directory);   // switch to the kernel page table
f010bda4:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f010bda9:	89 45 fc             	mov    %eax,-0x4(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bdac:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010bdaf:	0f 22 d8             	mov    %eax,%cr3
}
f010bdb2:	90                   	nop
f010bdb3:	c9                   	leave  
f010bdb4:	c3                   	ret    

f010bdb5 <switchuvm>:

// [9.2] Switch TSS and h/w page table to correspond to process p.
void switchuvm(struct Env *proc)
{
f010bdb5:	55                   	push   %ebp
f010bdb6:	89 e5                	mov    %esp,%ebp
f010bdb8:	53                   	push   %ebx
f010bdb9:	83 ec 14             	sub    $0x14,%esp
	if(proc == 0)
f010bdbc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bdc0:	75 17                	jne    f010bdd9 <switchuvm+0x24>
		panic("switchuvm: no process");
f010bdc2:	83 ec 04             	sub    $0x4,%esp
f010bdc5:	68 51 fb 12 f0       	push   $0xf012fb51
f010bdca:	68 a1 02 00 00       	push   $0x2a1
f010bdcf:	68 97 f9 12 f0       	push   $0xf012f997
f010bdd4:	e8 d6 51 ff ff       	call   f0100faf <_panic>
	if(proc->kstack == 0)
f010bdd9:	8b 45 08             	mov    0x8(%ebp),%eax
f010bddc:	8b 40 70             	mov    0x70(%eax),%eax
f010bddf:	85 c0                	test   %eax,%eax
f010bde1:	75 17                	jne    f010bdfa <switchuvm+0x45>
		panic("switchuvm: no kstack");
f010bde3:	83 ec 04             	sub    $0x4,%esp
f010bde6:	68 67 fb 12 f0       	push   $0xf012fb67
f010bdeb:	68 a3 02 00 00       	push   $0x2a3
f010bdf0:	68 97 f9 12 f0       	push   $0xf012f997
f010bdf5:	e8 b5 51 ff ff       	call   f0100faf <_panic>
	if(proc->env_page_directory == 0)
f010bdfa:	8b 45 08             	mov    0x8(%ebp),%eax
f010bdfd:	8b 40 64             	mov    0x64(%eax),%eax
f010be00:	85 c0                	test   %eax,%eax
f010be02:	75 17                	jne    f010be1b <switchuvm+0x66>
		panic("switchuvm: no pgdir");
f010be04:	83 ec 04             	sub    $0x4,%esp
f010be07:	68 7c fb 12 f0       	push   $0xf012fb7c
f010be0c:	68 a5 02 00 00       	push   $0x2a5
f010be11:	68 97 f9 12 f0       	push   $0xf012f997
f010be16:	e8 94 51 ff ff       	call   f0100faf <_panic>

	pushcli();	//disable interrupt - lock: to protect CPU info
f010be1b:	e8 10 c3 ff ff       	call   f0108130 <pushcli>
	struct cpu* c = mycpu();
f010be20:	e8 4b c2 ff ff       	call   f0108070 <mycpu>
f010be25:	89 45 f4             	mov    %eax,-0xc(%ebp)
	c->proc = proc;
f010be28:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be2b:	8b 55 08             	mov    0x8(%ebp),%edx
f010be2e:	89 90 b0 00 00 00    	mov    %edx,0xb0(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010be34:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be37:	83 c0 0c             	add    $0xc,%eax
f010be3a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be3d:	83 c2 0c             	add    $0xc,%edx
f010be40:	c1 ea 10             	shr    $0x10,%edx
f010be43:	88 d3                	mov    %dl,%bl
f010be45:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be48:	83 c2 0c             	add    $0xc,%edx
f010be4b:	c1 ea 18             	shr    $0x18,%edx
f010be4e:	88 d1                	mov    %dl,%cl
f010be50:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be53:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010be5a:	68 00 
f010be5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010be5f:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010be66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be69:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010be6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be72:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be78:	83 e2 f0             	and    $0xfffffff0,%edx
f010be7b:	83 ca 09             	or     $0x9,%edx
f010be7e:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be84:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be87:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be8d:	83 ca 10             	or     $0x10,%edx
f010be90:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010be96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010be99:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010be9f:	83 e2 9f             	and    $0xffffff9f,%edx
f010bea2:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010bea8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010beab:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010beb1:	83 ca 80             	or     $0xffffff80,%edx
f010beb4:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010beba:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bebd:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bec3:	83 e2 f0             	and    $0xfffffff0,%edx
f010bec6:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010becc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010becf:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bed5:	83 e2 ef             	and    $0xffffffef,%edx
f010bed8:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bede:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bee1:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bee7:	83 e2 df             	and    $0xffffffdf,%edx
f010beea:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bef0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bef3:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bef9:	83 ca 40             	or     $0x40,%edx
f010befc:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bf02:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf05:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010bf0b:	83 e2 7f             	and    $0x7f,%edx
f010bf0e:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010bf14:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf17:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010bf1d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf20:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010bf26:	83 e2 ef             	and    $0xffffffef,%edx
f010bf29:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	//adjust the default stack for the trap to be the user kernel stack
	c->ts.ts_esp0 = (uint32)(c->proc->kstack + KERNEL_STACK_SIZE);
f010bf2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf32:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bf38:	8b 40 70             	mov    0x70(%eax),%eax
f010bf3b:	05 00 80 00 00       	add    $0x8000,%eax
f010bf40:	89 c2                	mov    %eax,%edx
f010bf42:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf45:	89 50 10             	mov    %edx,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010bf48:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf4b:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)
f010bf51:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010bf57:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010bf5b:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);

	//load the user page directory
	lcr3(c->proc->env_cr3) ;
f010bf5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010bf61:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
f010bf67:	8b 40 68             	mov    0x68(%eax),%eax
f010bf6a:	89 45 ec             	mov    %eax,-0x14(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f010bf6d:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010bf70:	0f 22 d8             	mov    %eax,%cr3

	popcli();	//enable interrupt
f010bf73:	e8 0a c2 ff ff       	call   f0108182 <popcli>
}
f010bf78:	90                   	nop
f010bf79:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010bf7c:	c9                   	leave  
f010bf7d:	c3                   	ret    

f010bf7e <allocate_environment>:
//
// Returns 0 on success, < 0 on failure.  Errors include:
//	E_NO_FREE_ENV if all NENVS environments are allocated
//
int allocate_environment(struct Env** e)
{
f010bf7e:	55                   	push   %ebp
f010bf7f:	89 e5                	mov    %esp,%ebp
	if (!(*e = LIST_FIRST(&env_free_list)))
f010bf81:	8b 15 94 5b 81 f0    	mov    0xf0815b94,%edx
f010bf87:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf8a:	89 10                	mov    %edx,(%eax)
f010bf8c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf8f:	8b 00                	mov    (%eax),%eax
f010bf91:	85 c0                	test   %eax,%eax
f010bf93:	75 07                	jne    f010bf9c <allocate_environment+0x1e>
		return E_NO_FREE_ENV;
f010bf95:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
f010bf9a:	eb 11                	jmp    f010bfad <allocate_environment+0x2f>
	(*e)->env_status = ENV_UNKNOWN;
f010bf9c:	8b 45 08             	mov    0x8(%ebp),%eax
f010bf9f:	8b 00                	mov    (%eax),%eax
f010bfa1:	c7 40 18 07 00 00 00 	movl   $0x7,0x18(%eax)
	return 0;
f010bfa8:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010bfad:	5d                   	pop    %ebp
f010bfae:	c3                   	ret    

f010bfaf <free_environment>:
//===============================
// 3) FREE ENV STRUCT:
//===============================
// Free the given environment "e", simply by adding it to the free environment list.
void free_environment(struct Env* e)
{
f010bfaf:	55                   	push   %ebp
f010bfb0:	89 e5                	mov    %esp,%ebp
f010bfb2:	83 ec 08             	sub    $0x8,%esp
	memset(e, 0, sizeof(*e));
f010bfb5:	83 ec 04             	sub    $0x4,%esp
f010bfb8:	68 c4 05 00 00       	push   $0x5c4
f010bfbd:	6a 00                	push   $0x0
f010bfbf:	ff 75 08             	pushl  0x8(%ebp)
f010bfc2:	e8 a2 ed 00 00       	call   f011ad69 <memset>
f010bfc7:	83 c4 10             	add    $0x10,%esp
	e->env_status = ENV_FREE;
f010bfca:	8b 45 08             	mov    0x8(%ebp),%eax
f010bfcd:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
	LIST_INSERT_HEAD(&env_free_list, e);
f010bfd4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010bfd8:	75 17                	jne    f010bff1 <free_environment+0x42>
f010bfda:	83 ec 04             	sub    $0x4,%esp
f010bfdd:	68 74 f9 12 f0       	push   $0xf012f974
f010bfe2:	68 e4 02 00 00       	push   $0x2e4
f010bfe7:	68 97 f9 12 f0       	push   $0xf012f997
f010bfec:	e8 be 4f ff ff       	call   f0100faf <_panic>
f010bff1:	8b 15 94 5b 81 f0    	mov    0xf0815b94,%edx
f010bff7:	8b 45 08             	mov    0x8(%ebp),%eax
f010bffa:	89 50 08             	mov    %edx,0x8(%eax)
f010bffd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c000:	8b 40 08             	mov    0x8(%eax),%eax
f010c003:	85 c0                	test   %eax,%eax
f010c005:	74 0d                	je     f010c014 <free_environment+0x65>
f010c007:	a1 94 5b 81 f0       	mov    0xf0815b94,%eax
f010c00c:	8b 55 08             	mov    0x8(%ebp),%edx
f010c00f:	89 50 0c             	mov    %edx,0xc(%eax)
f010c012:	eb 08                	jmp    f010c01c <free_environment+0x6d>
f010c014:	8b 45 08             	mov    0x8(%ebp),%eax
f010c017:	a3 98 5b 81 f0       	mov    %eax,0xf0815b98
f010c01c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c01f:	a3 94 5b 81 f0       	mov    %eax,0xf0815b94
f010c024:	8b 45 08             	mov    0x8(%ebp),%eax
f010c027:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010c02e:	a1 a0 5b 81 f0       	mov    0xf0815ba0,%eax
f010c033:	40                   	inc    %eax
f010c034:	a3 a0 5b 81 f0       	mov    %eax,0xf0815ba0
}
f010c039:	90                   	nop
f010c03a:	c9                   	leave  
f010c03b:	c3                   	ret    

f010c03c <program_segment_alloc_map_copy_workingset>:
//
// The allocation shouldn't failed
// return 0
//
static int program_segment_alloc_map_copy_workingset(struct Env *e, struct ProgramSegment* seg, uint32* allocated_pages, uint32 remaining_ws_pages, uint32* lastTableNumber)
{
f010c03c:	55                   	push   %ebp
f010c03d:	89 e5                	mov    %esp,%ebp
f010c03f:	53                   	push   %ebx
f010c040:	83 ec 44             	sub    $0x44,%esp
	void *vaddr = seg->virtual_address;
f010c043:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c046:	8b 40 0c             	mov    0xc(%eax),%eax
f010c049:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	uint32 length = seg->size_in_memory;
f010c04c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c04f:	8b 40 08             	mov    0x8(%eax),%eax
f010c052:	89 45 e0             	mov    %eax,-0x20(%ebp)

	uint32 end_vaddr = ROUNDUP((uint32)vaddr + length,PAGE_SIZE) ;
f010c055:	c7 45 dc 00 10 00 00 	movl   $0x1000,-0x24(%ebp)
f010c05c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010c05f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010c062:	01 c2                	add    %eax,%edx
f010c064:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010c067:	01 d0                	add    %edx,%eax
f010c069:	48                   	dec    %eax
f010c06a:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010c06d:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c070:	ba 00 00 00 00       	mov    $0x0,%edx
f010c075:	f7 75 dc             	divl   -0x24(%ebp)
f010c078:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010c07b:	29 d0                	sub    %edx,%eax
f010c07d:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	uint32 iVA = ROUNDDOWN((uint32)vaddr,PAGE_SIZE) ;
f010c080:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c083:	89 45 d0             	mov    %eax,-0x30(%ebp)
f010c086:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010c089:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c08e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int r ;
	uint32 i = 0 ;
f010c091:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	struct FrameInfo *p = NULL;
f010c098:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)

	*allocated_pages = 0;
f010c09f:	8b 45 10             	mov    0x10(%ebp),%eax
f010c0a2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
f010c0a8:	81 7d f4 00 00 20 00 	cmpl   $0x200000,-0xc(%ebp)
f010c0af:	0f 85 f5 03 00 00    	jne    f010c4aa <program_segment_alloc_map_copy_workingset+0x46e>
f010c0b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0b8:	83 c0 20             	add    $0x20,%eax
f010c0bb:	83 ec 08             	sub    $0x8,%esp
f010c0be:	68 90 fb 12 f0       	push   $0xf012fb90
f010c0c3:	50                   	push   %eax
f010c0c4:	e8 be eb 00 00       	call   f011ac87 <strcmp>
f010c0c9:	83 c4 10             	add    $0x10,%esp
f010c0cc:	85 c0                	test   %eax,%eax
f010c0ce:	0f 84 d6 03 00 00    	je     f010c4aa <program_segment_alloc_map_copy_workingset+0x46e>
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
f010c0d4:	8b 45 14             	mov    0x14(%ebp),%eax
f010c0d7:	83 f8 06             	cmp    $0x6,%eax
f010c0da:	76 05                	jbe    f010c0e1 <program_segment_alloc_map_copy_workingset+0xa5>
f010c0dc:	b8 06 00 00 00       	mov    $0x6,%eax
f010c0e1:	89 45 14             	mov    %eax,0x14(%ebp)
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c0e4:	e9 c1 03 00 00       	jmp    f010c4aa <program_segment_alloc_map_copy_workingset+0x46e>
	{
		// Allocate a page
		allocate_frame(&p) ;
f010c0e9:	83 ec 0c             	sub    $0xc,%esp
f010c0ec:	8d 45 bc             	lea    -0x44(%ebp),%eax
f010c0ef:	50                   	push   %eax
f010c0f0:	e8 4d d0 ff ff       	call   f0109142 <allocate_frame>
f010c0f5:	83 c4 10             	add    $0x10,%esp

		LOG_STRING("segment page allocated");
		loadtime_map_frame(e->env_page_directory, p, iVA, PERM_USER | PERM_WRITEABLE);
f010c0f8:	8b 55 bc             	mov    -0x44(%ebp),%edx
f010c0fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c0fe:	8b 40 64             	mov    0x64(%eax),%eax
f010c101:	6a 06                	push   $0x6
f010c103:	ff 75 f4             	pushl  -0xc(%ebp)
f010c106:	52                   	push   %edx
f010c107:	50                   	push   %eax
f010c108:	e8 e6 d6 ff ff       	call   f01097f3 <loadtime_map_frame>
f010c10d:	83 c4 10             	add    $0x10,%esp
		LOG_STRING("segment page mapped");

#if USE_KHEAP
		struct WorkingSetElement* wse = env_page_ws_list_create_element(e, iVA);
f010c110:	83 ec 08             	sub    $0x8,%esp
f010c113:	ff 75 f4             	pushl  -0xc(%ebp)
f010c116:	ff 75 08             	pushl  0x8(%ebp)
f010c119:	e8 e7 de ff ff       	call   f010a005 <env_page_ws_list_create_element>
f010c11e:	83 c4 10             	add    $0x10,%esp
f010c121:	89 45 cc             	mov    %eax,-0x34(%ebp)
		wse->time_stamp = 0;
f010c124:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c127:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
		LIST_INSERT_TAIL(&(e->page_WS_list), wse);
f010c12e:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c132:	75 17                	jne    f010c14b <program_segment_alloc_map_copy_workingset+0x10f>
f010c134:	83 ec 04             	sub    $0x4,%esp
f010c137:	68 fc f9 12 f0       	push   $0xf012f9fc
f010c13c:	68 0e 03 00 00       	push   $0x30e
f010c141:	68 97 f9 12 f0       	push   $0xf012f997
f010c146:	e8 64 4e ff ff       	call   f0100faf <_panic>
f010c14b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c14e:	8b 90 8c 00 00 00    	mov    0x8c(%eax),%edx
f010c154:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c157:	89 50 14             	mov    %edx,0x14(%eax)
f010c15a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c15d:	8b 40 14             	mov    0x14(%eax),%eax
f010c160:	85 c0                	test   %eax,%eax
f010c162:	74 11                	je     f010c175 <program_segment_alloc_map_copy_workingset+0x139>
f010c164:	8b 45 08             	mov    0x8(%ebp),%eax
f010c167:	8b 80 8c 00 00 00    	mov    0x8c(%eax),%eax
f010c16d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c170:	89 50 10             	mov    %edx,0x10(%eax)
f010c173:	eb 0c                	jmp    f010c181 <program_segment_alloc_map_copy_workingset+0x145>
f010c175:	8b 45 08             	mov    0x8(%ebp),%eax
f010c178:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c17b:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010c181:	8b 45 08             	mov    0x8(%ebp),%eax
f010c184:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c187:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010c18d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c190:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c197:	8b 45 08             	mov    0x8(%ebp),%eax
f010c19a:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010c1a0:	8d 50 01             	lea    0x1(%eax),%edx
f010c1a3:	8b 45 08             	mov    0x8(%ebp),%eax
f010c1a6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
		e->ptr_pageWorkingSet[e->page_last_WS_index].virtual_address = iVA;
		e->ptr_pageWorkingSet[e->page_last_WS_index].empty = 0;
		e->ptr_pageWorkingSet[e->page_last_WS_index].time_stamp = 0;
#endif
		//2020
		if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c1ac:	83 ec 0c             	sub    $0xc,%esp
f010c1af:	6a 02                	push   $0x2
f010c1b1:	e8 6d 37 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010c1b6:	83 c4 10             	add    $0x10,%esp
f010c1b9:	85 c0                	test   %eax,%eax
f010c1bb:	0f 84 b3 01 00 00    	je     f010c374 <program_segment_alloc_map_copy_workingset+0x338>
		{
#if USE_KHEAP
			//Remove wse from page_WS_list
			LIST_REMOVE(&(e->page_WS_list), wse);
f010c1c1:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c1c5:	75 17                	jne    f010c1de <program_segment_alloc_map_copy_workingset+0x1a2>
f010c1c7:	83 ec 04             	sub    $0x4,%esp
f010c1ca:	68 1f fa 12 f0       	push   $0xf012fa1f
f010c1cf:	68 1b 03 00 00       	push   $0x31b
f010c1d4:	68 97 f9 12 f0       	push   $0xf012f997
f010c1d9:	e8 d1 4d ff ff       	call   f0100faf <_panic>
f010c1de:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1e1:	8b 40 10             	mov    0x10(%eax),%eax
f010c1e4:	85 c0                	test   %eax,%eax
f010c1e6:	74 11                	je     f010c1f9 <program_segment_alloc_map_copy_workingset+0x1bd>
f010c1e8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1eb:	8b 40 10             	mov    0x10(%eax),%eax
f010c1ee:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c1f1:	8b 52 14             	mov    0x14(%edx),%edx
f010c1f4:	89 50 14             	mov    %edx,0x14(%eax)
f010c1f7:	eb 0f                	jmp    f010c208 <program_segment_alloc_map_copy_workingset+0x1cc>
f010c1f9:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c1fc:	8b 50 14             	mov    0x14(%eax),%edx
f010c1ff:	8b 45 08             	mov    0x8(%ebp),%eax
f010c202:	89 90 8c 00 00 00    	mov    %edx,0x8c(%eax)
f010c208:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c20b:	8b 40 14             	mov    0x14(%eax),%eax
f010c20e:	85 c0                	test   %eax,%eax
f010c210:	74 11                	je     f010c223 <program_segment_alloc_map_copy_workingset+0x1e7>
f010c212:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c215:	8b 40 14             	mov    0x14(%eax),%eax
f010c218:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c21b:	8b 52 10             	mov    0x10(%edx),%edx
f010c21e:	89 50 10             	mov    %edx,0x10(%eax)
f010c221:	eb 0f                	jmp    f010c232 <program_segment_alloc_map_copy_workingset+0x1f6>
f010c223:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c226:	8b 50 10             	mov    0x10(%eax),%edx
f010c229:	8b 45 08             	mov    0x8(%ebp),%eax
f010c22c:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
f010c232:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c235:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
f010c23c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c23f:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c246:	8b 45 08             	mov    0x8(%ebp),%eax
f010c249:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010c24f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010c252:	8b 45 08             	mov    0x8(%ebp),%eax
f010c255:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
			//Always leave 1 page in Active list for the stack
			if (LIST_SIZE(&(e->ActiveList)) < e->ActiveListSize - 1)
f010c25b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c25e:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f010c264:	8b 45 08             	mov    0x8(%ebp),%eax
f010c267:	8b 80 88 05 00 00    	mov    0x588(%eax),%eax
f010c26d:	48                   	dec    %eax
f010c26e:	39 c2                	cmp    %eax,%edx
f010c270:	0f 83 80 00 00 00    	jae    f010c2f6 <program_segment_alloc_map_copy_workingset+0x2ba>
			{
				LIST_INSERT_HEAD(&(e->ActiveList), wse);
f010c276:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c27a:	75 17                	jne    f010c293 <program_segment_alloc_map_copy_workingset+0x257>
f010c27c:	83 ec 04             	sub    $0x4,%esp
f010c27f:	68 74 f9 12 f0       	push   $0xf012f974
f010c284:	68 1f 03 00 00       	push   $0x31f
f010c289:	68 97 f9 12 f0       	push   $0xf012f997
f010c28e:	e8 1c 4d ff ff       	call   f0100faf <_panic>
f010c293:	8b 45 08             	mov    0x8(%ebp),%eax
f010c296:	8b 90 68 05 00 00    	mov    0x568(%eax),%edx
f010c29c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c29f:	89 50 10             	mov    %edx,0x10(%eax)
f010c2a2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2a5:	8b 40 10             	mov    0x10(%eax),%eax
f010c2a8:	85 c0                	test   %eax,%eax
f010c2aa:	74 11                	je     f010c2bd <program_segment_alloc_map_copy_workingset+0x281>
f010c2ac:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2af:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f010c2b5:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2b8:	89 50 14             	mov    %edx,0x14(%eax)
f010c2bb:	eb 0c                	jmp    f010c2c9 <program_segment_alloc_map_copy_workingset+0x28d>
f010c2bd:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2c0:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2c3:	89 90 6c 05 00 00    	mov    %edx,0x56c(%eax)
f010c2c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2cc:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c2cf:	89 90 68 05 00 00    	mov    %edx,0x568(%eax)
f010c2d5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c2d8:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c2df:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2e2:	8b 80 74 05 00 00    	mov    0x574(%eax),%eax
f010c2e8:	8d 50 01             	lea    0x1(%eax),%edx
f010c2eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010c2ee:	89 90 74 05 00 00    	mov    %edx,0x574(%eax)
f010c2f4:	eb 7e                	jmp    f010c374 <program_segment_alloc_map_copy_workingset+0x338>
			}
			else
			{
				//Add to LRU Second list
				LIST_INSERT_HEAD(&(e->SecondList), wse);
f010c2f6:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010c2fa:	75 17                	jne    f010c313 <program_segment_alloc_map_copy_workingset+0x2d7>
f010c2fc:	83 ec 04             	sub    $0x4,%esp
f010c2ff:	68 74 f9 12 f0       	push   $0xf012f974
f010c304:	68 24 03 00 00       	push   $0x324
f010c309:	68 97 f9 12 f0       	push   $0xf012f997
f010c30e:	e8 9c 4c ff ff       	call   f0100faf <_panic>
f010c313:	8b 45 08             	mov    0x8(%ebp),%eax
f010c316:	8b 90 78 05 00 00    	mov    0x578(%eax),%edx
f010c31c:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c31f:	89 50 10             	mov    %edx,0x10(%eax)
f010c322:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c325:	8b 40 10             	mov    0x10(%eax),%eax
f010c328:	85 c0                	test   %eax,%eax
f010c32a:	74 11                	je     f010c33d <program_segment_alloc_map_copy_workingset+0x301>
f010c32c:	8b 45 08             	mov    0x8(%ebp),%eax
f010c32f:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f010c335:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c338:	89 50 14             	mov    %edx,0x14(%eax)
f010c33b:	eb 0c                	jmp    f010c349 <program_segment_alloc_map_copy_workingset+0x30d>
f010c33d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c340:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c343:	89 90 7c 05 00 00    	mov    %edx,0x57c(%eax)
f010c349:	8b 45 08             	mov    0x8(%ebp),%eax
f010c34c:	8b 55 cc             	mov    -0x34(%ebp),%edx
f010c34f:	89 90 78 05 00 00    	mov    %edx,0x578(%eax)
f010c355:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010c358:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c35f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c362:	8b 80 84 05 00 00    	mov    0x584(%eax),%eax
f010c368:	8d 50 01             	lea    0x1(%eax),%edx
f010c36b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c36e:	89 90 84 05 00 00    	mov    %edx,0x584(%eax)
			}
#endif
		}
		//=======================
#if USE_KHEAP
		if (LIST_SIZE(&(e->page_WS_list)) == e->page_WS_max_size)
f010c374:	8b 45 08             	mov    0x8(%ebp),%eax
f010c377:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f010c37d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c380:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010c386:	39 c2                	cmp    %eax,%edx
f010c388:	75 14                	jne    f010c39e <program_segment_alloc_map_copy_workingset+0x362>
		{
			e->page_last_WS_element = LIST_FIRST(&(e->page_WS_list));
f010c38a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c38d:	8b 90 88 00 00 00    	mov    0x88(%eax),%edx
f010c393:	8b 45 08             	mov    0x8(%ebp),%eax
f010c396:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
f010c39c:	eb 0d                	jmp    f010c3ab <program_segment_alloc_map_copy_workingset+0x36f>
		}
		else
		{
			e->page_last_WS_element = NULL;
f010c39e:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3a1:	c7 80 98 00 00 00 00 	movl   $0x0,0x98(%eax)
f010c3a8:	00 00 00 
#else
		e->page_last_WS_index ++;
		e->page_last_WS_index %= (e->page_WS_max_size);
#endif
		//if a new table is created during the mapping, add it to the table working set
		if(PDX(iVA) != (*lastTableNumber))
f010c3ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3ae:	c1 e8 16             	shr    $0x16,%eax
f010c3b1:	89 c2                	mov    %eax,%edx
f010c3b3:	8b 45 18             	mov    0x18(%ebp),%eax
f010c3b6:	8b 00                	mov    (%eax),%eax
f010c3b8:	39 c2                	cmp    %eax,%edx
f010c3ba:	0f 84 d3 00 00 00    	je     f010c493 <program_segment_alloc_map_copy_workingset+0x457>
		{
			e->__ptr_tws[e->table_last_WS_index].virtual_address = ROUNDDOWN(iVA, PAGE_SIZE*1024);;
f010c3c0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3c3:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c3c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c3cc:	89 45 c8             	mov    %eax,-0x38(%ebp)
f010c3cf:	8b 45 c8             	mov    -0x38(%ebp),%eax
f010c3d2:	25 00 00 c0 ff       	and    $0xffc00000,%eax
f010c3d7:	89 c1                	mov    %eax,%ecx
f010c3d9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010c3dc:	89 d0                	mov    %edx,%eax
f010c3de:	01 c0                	add    %eax,%eax
f010c3e0:	01 d0                	add    %edx,%eax
f010c3e2:	c1 e0 03             	shl    $0x3,%eax
f010c3e5:	01 d8                	add    %ebx,%eax
f010c3e7:	05 b4 00 00 00       	add    $0xb4,%eax
f010c3ec:	89 08                	mov    %ecx,(%eax)
			e->__ptr_tws[e->table_last_WS_index].empty = 0;
f010c3ee:	8b 45 08             	mov    0x8(%ebp),%eax
f010c3f1:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c3f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c3fa:	89 d0                	mov    %edx,%eax
f010c3fc:	01 c0                	add    %eax,%eax
f010c3fe:	01 d0                	add    %edx,%eax
f010c400:	c1 e0 03             	shl    $0x3,%eax
f010c403:	01 c8                	add    %ecx,%eax
f010c405:	05 b8 00 00 00       	add    $0xb8,%eax
f010c40a:	c6 00 00             	movb   $0x0,(%eax)
			e->__ptr_tws[e->table_last_WS_index].time_stamp = 0x00000000;
f010c40d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c410:	8b 90 64 05 00 00    	mov    0x564(%eax),%edx
f010c416:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c419:	89 d0                	mov    %edx,%eax
f010c41b:	01 c0                	add    %eax,%eax
f010c41d:	01 d0                	add    %edx,%eax
f010c41f:	c1 e0 03             	shl    $0x3,%eax
f010c422:	01 c8                	add    %ecx,%eax
f010c424:	05 bc 00 00 00       	add    $0xbc,%eax
f010c429:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			e->table_last_WS_index ++;
f010c42f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c432:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c438:	8d 50 01             	lea    0x1(%eax),%edx
f010c43b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c43e:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
			e->table_last_WS_index %= __TWS_MAX_SIZE;
f010c444:	8b 45 08             	mov    0x8(%ebp),%eax
f010c447:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c44d:	b9 32 00 00 00       	mov    $0x32,%ecx
f010c452:	ba 00 00 00 00       	mov    $0x0,%edx
f010c457:	f7 f1                	div    %ecx
f010c459:	8b 45 08             	mov    0x8(%ebp),%eax
f010c45c:	89 90 64 05 00 00    	mov    %edx,0x564(%eax)
			if (e->table_last_WS_index == 0)
f010c462:	8b 45 08             	mov    0x8(%ebp),%eax
f010c465:	8b 80 64 05 00 00    	mov    0x564(%eax),%eax
f010c46b:	85 c0                	test   %eax,%eax
f010c46d:	75 17                	jne    f010c486 <program_segment_alloc_map_copy_workingset+0x44a>
				panic("\nenv_create: Table working set become FULL during the application loading. Please increase the table working set size to be able to load the program successfully\n");
f010c46f:	83 ec 04             	sub    $0x4,%esp
f010c472:	68 94 fb 12 f0       	push   $0xf012fb94
f010c477:	68 4b 03 00 00       	push   $0x34b
f010c47c:	68 97 f9 12 f0       	push   $0xf012f997
f010c481:	e8 29 4b ff ff       	call   f0100faf <_panic>
			(*lastTableNumber) = PDX(iVA);
f010c486:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c489:	c1 e8 16             	shr    $0x16,%eax
f010c48c:	89 c2                	mov    %eax,%edx
f010c48e:	8b 45 18             	mov    0x18(%ebp),%eax
f010c491:	89 10                	mov    %edx,(%eax)
		}

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
f010c493:	8b 45 10             	mov    0x10(%ebp),%eax
f010c496:	8b 00                	mov    (%eax),%eax
f010c498:	8d 50 01             	lea    0x1(%eax),%edx
f010c49b:	8b 45 10             	mov    0x10(%ebp),%eax
f010c49e:	89 10                	mov    %edx,(%eax)
	*allocated_pages = 0;
	/*2015*/// Load max of 6 pages only for the segment that start with va = 200000 [EXCEPT tpp]
	if (iVA == 0x200000 && strcmp(e->prog_name, "tpp")!=0)
		remaining_ws_pages = remaining_ws_pages < 6 ? remaining_ws_pages:6 ;
	/*==========================================================================================*/
	for (; iVA < end_vaddr && i<remaining_ws_pages; i++, iVA += PAGE_SIZE)
f010c4a0:	ff 45 f0             	incl   -0x10(%ebp)
f010c4a3:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f010c4aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c4ad:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f010c4b0:	73 0c                	jae    f010c4be <program_segment_alloc_map_copy_workingset+0x482>
f010c4b2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c4b5:	3b 45 14             	cmp    0x14(%ebp),%eax
f010c4b8:	0f 82 2b fc ff ff    	jb     f010c0e9 <program_segment_alloc_map_copy_workingset+0xad>

		/// TAKE CARE !!!! this was an destructive error
		/// DON'T MAKE IT " *allocated_pages ++ " EVER !
		(*allocated_pages) ++;
	}
	uint8 *src_ptr = (uint8 *)(seg->ptr_start) ;
f010c4be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c4c1:	8b 00                	mov    (%eax),%eax
f010c4c3:	89 45 ec             	mov    %eax,-0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;
f010c4c6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c4c9:	8b 40 0c             	mov    0xc(%eax),%eax
f010c4cc:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c4cf:	eb 10                	jmp    f010c4e1 <program_segment_alloc_map_copy_workingset+0x4a5>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
	{
		*dst_ptr = *src_ptr ;
f010c4d1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010c4d4:	8a 10                	mov    (%eax),%dl
f010c4d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c4d9:	88 10                	mov    %dl,(%eax)
		dst_ptr++ ;
f010c4db:	ff 45 e8             	incl   -0x18(%ebp)
		src_ptr++ ;
f010c4de:	ff 45 ec             	incl   -0x14(%ebp)
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c4e1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c4e4:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010c4e7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f010c4ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c4ef:	89 c2                	mov    %eax,%edx
f010c4f1:	8b 45 10             	mov    0x10(%ebp),%eax
f010c4f4:	8b 00                	mov    (%eax),%eax
f010c4f6:	c1 e0 0c             	shl    $0xc,%eax
f010c4f9:	01 c2                	add    %eax,%edx
f010c4fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c4fe:	39 c2                	cmp    %eax,%edx
f010c500:	76 1d                	jbe    f010c51f <program_segment_alloc_map_copy_workingset+0x4e3>
			((uint32)dst_ptr< ((uint32)vaddr+ seg->size_in_file)) )
f010c502:	8b 45 0c             	mov    0xc(%ebp),%eax
f010c505:	8b 50 04             	mov    0x4(%eax),%edx
f010c508:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c50b:	01 c2                	add    %eax,%edx
f010c50d:	8b 45 e8             	mov    -0x18(%ebp),%eax
	uint8 *dst_ptr = (uint8 *) seg->virtual_address;

	//copy program segment page from (seg->ptr_start) to (seg->virtual_address)

	LOG_STATMENT(cprintf("copying data to allocated area VA %x from source %x",dst_ptr,src_ptr));
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) &&
f010c510:	39 c2                	cmp    %eax,%edx
f010c512:	77 bd                	ja     f010c4d1 <program_segment_alloc_map_copy_workingset+0x495>
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c514:	eb 09                	jmp    f010c51f <program_segment_alloc_map_copy_workingset+0x4e3>
	{
		*dst_ptr = 0;
f010c516:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c519:	c6 00 00             	movb   $0x0,(%eax)
		dst_ptr++ ;
f010c51c:	ff 45 e8             	incl   -0x18(%ebp)
		dst_ptr++ ;
		src_ptr++ ;
	}

	LOG_STRING("zeroing remaining page space");
	while((uint32)dst_ptr < (ROUNDDOWN((uint32)vaddr,PAGE_SIZE) + (*allocated_pages)*PAGE_SIZE) )
f010c51f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010c522:	89 45 c0             	mov    %eax,-0x40(%ebp)
f010c525:	8b 45 c0             	mov    -0x40(%ebp),%eax
f010c528:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010c52d:	89 c2                	mov    %eax,%edx
f010c52f:	8b 45 10             	mov    0x10(%ebp),%eax
f010c532:	8b 00                	mov    (%eax),%eax
f010c534:	c1 e0 0c             	shl    $0xc,%eax
f010c537:	01 c2                	add    %eax,%edx
f010c539:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010c53c:	39 c2                	cmp    %eax,%edx
f010c53e:	77 d6                	ja     f010c516 <program_segment_alloc_map_copy_workingset+0x4da>
	{
		*dst_ptr = 0;
		dst_ptr++ ;
	}

	return 0;
f010c540:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010c545:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010c548:	c9                   	leave  
f010c549:	c3                   	ret    

f010c54a <create_user_directory>:

//==================================================
// 5) DYNAMICALLY ALLOCATE SPACE FOR USER DIRECTORY:
//==================================================
void * create_user_directory()
{
f010c54a:	55                   	push   %ebp
f010c54b:	89 e5                	mov    %esp,%ebp
f010c54d:	83 ec 18             	sub    $0x18,%esp
	//panic("create_user_directory() is not implemented yet...!!");

	//Use kmalloc() to allocate a new directory

	//change this "return" according to your answer
	uint32* ptr_user_page_directory = kmalloc(PAGE_SIZE);
f010c550:	83 ec 0c             	sub    $0xc,%esp
f010c553:	68 00 10 00 00       	push   $0x1000
f010c558:	e8 d9 d6 ff ff       	call   f0109c36 <kmalloc>
f010c55d:	83 c4 10             	add    $0x10,%esp
f010c560:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(ptr_user_page_directory == NULL)
f010c563:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c567:	75 17                	jne    f010c580 <create_user_directory+0x36>
	{
		panic("NOT ENOUGH KERNEL HEAP SPACE");
f010c569:	83 ec 04             	sub    $0x4,%esp
f010c56c:	68 37 fc 12 f0       	push   $0xf012fc37
f010c571:	68 7b 03 00 00       	push   $0x37b
f010c576:	68 97 f9 12 f0       	push   $0xf012f997
f010c57b:	e8 2f 4a ff ff       	call   f0100faf <_panic>
	}
	return ptr_user_page_directory;
f010c580:	8b 45 f4             	mov    -0xc(%ebp),%eax
	//return 0;
}
f010c583:	c9                   	leave  
f010c584:	c3                   	ret    

f010c585 <create_user_kern_stack>:
uint32 __cur_k_stk = KERNEL_HEAP_START;
//===========================================================
// 6) ALLOCATE SPACE FOR USER KERNEL STACK (One Per Process):
//===========================================================
void* create_user_kern_stack(uint32* ptr_user_page_directory)
{
f010c585:	55                   	push   %ebp
f010c586:	89 e5                	mov    %esp,%ebp
f010c588:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #1 create_user_kern_stack
	//Your code is here
	//Comment the following line
	panic("create_user_kern_stack() is not implemented yet...!!");
f010c58b:	83 ec 04             	sub    $0x4,%esp
f010c58e:	68 54 fc 12 f0       	push   $0xf012fc54
f010c593:	68 8b 03 00 00       	push   $0x38b
f010c598:	68 97 f9 12 f0       	push   $0xf012f997
f010c59d:	e8 0d 4a ff ff       	call   f0100faf <_panic>

f010c5a2 <delete_user_kern_stack>:
/*2024*/
//===========================================================
// 6) DELETE USER KERNEL STACK (One Per Process):
//===========================================================
void delete_user_kern_stack(struct Env* e)
{
f010c5a2:	55                   	push   %ebp
f010c5a3:	89 e5                	mov    %esp,%ebp
f010c5a5:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	//TODO: [PROJECT'25.BONUS#4] EXIT #1 & #2 - delete_user_kern_stack
	// Write your code here, remove the panic and write your code
	panic("delete_user_kern_stack() is not implemented yet...!!");
f010c5a8:	83 ec 04             	sub    $0x4,%esp
f010c5ab:	68 8c fc 12 f0       	push   $0xf012fc8c
f010c5b0:	68 9b 03 00 00       	push   $0x39b
f010c5b5:	68 97 f9 12 f0       	push   $0xf012f997
f010c5ba:	e8 f0 49 ff ff       	call   f0100faf <_panic>

f010c5bf <initialize_environment>:
//	  3.3 Setup the context to return to env_start() at the early first run from the scheduler
// 4. Initialize the working set
// 5. Initialize the user dynamic allocator
//
void initialize_environment(struct Env* e, uint32* ptr_user_page_directory, unsigned int phys_user_page_directory)
{
f010c5bf:	55                   	push   %ebp
f010c5c0:	89 e5                	mov    %esp,%ebp
f010c5c2:	83 ec 18             	sub    $0x18,%esp
	//panic("initialize_environment function is not completed yet") ;
	// [1] initialize the kernel portion of the new environment's address space.
	// [2] set e->env_pgdir and e->env_cr3 accordingly,
	int i;
	e->env_page_directory = ptr_user_page_directory;
f010c5c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5c8:	8b 55 0c             	mov    0xc(%ebp),%edx
f010c5cb:	89 50 64             	mov    %edx,0x64(%eax)
	e->env_cr3 = phys_user_page_directory;
f010c5ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5d1:	8b 55 10             	mov    0x10(%ebp),%edx
f010c5d4:	89 50 68             	mov    %edx,0x68(%eax)

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c5d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c5de:	eb 17                	jmp    f010c5f7 <initialize_environment+0x38>
	{
		e->env_page_directory[i] = 0 ;
f010c5e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010c5e3:	8b 40 64             	mov    0x64(%eax),%eax
f010c5e6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c5e9:	c1 e2 02             	shl    $0x2,%edx
f010c5ec:	01 d0                	add    %edx,%eax
f010c5ee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	int i;
	e->env_page_directory = ptr_user_page_directory;
	e->env_cr3 = phys_user_page_directory;

	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
f010c5f4:	ff 45 f4             	incl   -0xc(%ebp)
f010c5f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010c5fa:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f010c5ff:	76 df                	jbe    f010c5e0 <initialize_environment+0x21>
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c601:	c7 45 f4 bb 03 00 00 	movl   $0x3bb,-0xc(%ebp)
f010c608:	eb 22                	jmp    f010c62c <initialize_environment+0x6d>
	{
		e->env_page_directory[i] = ptr_page_directory[i] ;
f010c60a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c60d:	8b 40 64             	mov    0x64(%eax),%eax
f010c610:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c613:	c1 e2 02             	shl    $0x2,%edx
f010c616:	01 c2                	add    %eax,%edx
f010c618:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f010c61d:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f010c620:	c1 e1 02             	shl    $0x2,%ecx
f010c623:	01 c8                	add    %ecx,%eax
f010c625:	8b 00                	mov    (%eax),%eax
f010c627:	89 02                	mov    %eax,(%edx)
	//copy the kernel area only (to avoid copying the currently shared objects)
	for (i = 0 ; i < PDX(USER_TOP) ; i++)
	{
		e->env_page_directory[i] = 0 ;
	}
	for (i = PDX(USER_TOP) ; i < 1024 ; i++)
f010c629:	ff 45 f4             	incl   -0xc(%ebp)
f010c62c:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f010c633:	7e d5                	jle    f010c60a <initialize_environment+0x4b>
	 * Setup the new context to start executing at the env_start() to do some initializations then
	 * returns to trapret() to pop the trap frame and invoke iret
	 */
	{
		//[1] Create the stack
		e->kstack = create_user_kern_stack(e->env_page_directory);
f010c635:	8b 45 08             	mov    0x8(%ebp),%eax
f010c638:	8b 40 64             	mov    0x64(%eax),%eax
f010c63b:	83 ec 0c             	sub    $0xc,%esp
f010c63e:	50                   	push   %eax
f010c63f:	e8 41 ff ff ff       	call   f010c585 <create_user_kern_stack>
f010c644:	83 c4 10             	add    $0x10,%esp
f010c647:	89 c2                	mov    %eax,%edx
f010c649:	8b 45 08             	mov    0x8(%ebp),%eax
f010c64c:	89 50 70             	mov    %edx,0x70(%eax)

		//[2] Leave room for the trap frame
		void* sp = e->kstack + KERNEL_STACK_SIZE;
f010c64f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c652:	8b 40 70             	mov    0x70(%eax),%eax
f010c655:	05 00 80 00 00       	add    $0x8000,%eax
f010c65a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		sp -= sizeof(struct Trapframe);
f010c65d:	83 6d f0 44          	subl   $0x44,-0x10(%ebp)
		e->env_tf = (struct Trapframe *) sp;
f010c661:	8b 45 08             	mov    0x8(%ebp),%eax
f010c664:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c667:	89 10                	mov    %edx,(%eax)

		//[3] Set the address of trapret() first - to return on it after env_start() is returned,
		sp -= 4;
f010c669:	83 6d f0 04          	subl   $0x4,-0x10(%ebp)
		*(uint32*)sp = (uint32)trapret;
f010c66d:	ba 68 e7 10 f0       	mov    $0xf010e768,%edx
f010c672:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c675:	89 10                	mov    %edx,(%eax)

		//[4] Place the context next
		sp -= sizeof(struct Context);
f010c677:	83 6d f0 20          	subl   $0x20,-0x10(%ebp)
		e->context = (struct Context *) sp;
f010c67b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c67e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010c681:	89 50 04             	mov    %edx,0x4(%eax)

		//[4] Setup the context to return to env_start() at the early first run from the scheduler
		memset(e->context, 0, sizeof(*(e->context)));
f010c684:	8b 45 08             	mov    0x8(%ebp),%eax
f010c687:	8b 40 04             	mov    0x4(%eax),%eax
f010c68a:	83 ec 04             	sub    $0x4,%esp
f010c68d:	6a 20                	push   $0x20
f010c68f:	6a 00                	push   $0x0
f010c691:	50                   	push   %eax
f010c692:	e8 d2 e6 00 00       	call   f011ad69 <memset>
f010c697:	83 c4 10             	add    $0x10,%esp
		e->context->eip = (uint32) (env_start);
f010c69a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c69d:	8b 40 04             	mov    0x4(%eax),%eax
f010c6a0:	ba 67 ba 10 f0       	mov    $0xf010ba67,%edx
f010c6a5:	89 50 1c             	mov    %edx,0x1c(%eax)
	}

	// Allocate the page working set
#if USE_KHEAP == 1
	{
		LIST_INIT(&(e->page_WS_list));
f010c6a8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ab:	c7 80 88 00 00 00 00 	movl   $0x0,0x88(%eax)
f010c6b2:	00 00 00 
f010c6b5:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6b8:	c7 80 8c 00 00 00 00 	movl   $0x0,0x8c(%eax)
f010c6bf:	00 00 00 
f010c6c2:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6c5:	c7 80 94 00 00 00 00 	movl   $0x0,0x94(%eax)
f010c6cc:	00 00 00 
		LIST_INIT(&(e->referenceStreamList));
f010c6cf:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6d2:	c7 80 9c 00 00 00 00 	movl   $0x0,0x9c(%eax)
f010c6d9:	00 00 00 
f010c6dc:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6df:	c7 80 a0 00 00 00 00 	movl   $0x0,0xa0(%eax)
f010c6e6:	00 00 00 
f010c6e9:	8b 45 08             	mov    0x8(%ebp),%eax
f010c6ec:	c7 80 a8 00 00 00 00 	movl   $0x0,0xa8(%eax)
f010c6f3:	00 00 00 
	}
#endif

	//2020
	// Add its elements to the "e->PageWorkingSetList"
	if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX))
f010c6f6:	83 ec 0c             	sub    $0xc,%esp
f010c6f9:	6a 02                	push   $0x2
f010c6fb:	e8 23 32 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010c700:	83 c4 10             	add    $0x10,%esp
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c703:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010c70a:	eb 54                	jmp    f010c760 <initialize_environment+0x1a1>
	{
		e->__ptr_tws[i].virtual_address = 0;
f010c70c:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c70f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c712:	89 d0                	mov    %edx,%eax
f010c714:	01 c0                	add    %eax,%eax
f010c716:	01 d0                	add    %edx,%eax
f010c718:	c1 e0 03             	shl    $0x3,%eax
f010c71b:	01 c8                	add    %ecx,%eax
f010c71d:	05 b4 00 00 00       	add    $0xb4,%eax
f010c722:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->__ptr_tws[i].empty = 1;
f010c728:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c72b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c72e:	89 d0                	mov    %edx,%eax
f010c730:	01 c0                	add    %eax,%eax
f010c732:	01 d0                	add    %edx,%eax
f010c734:	c1 e0 03             	shl    $0x3,%eax
f010c737:	01 c8                	add    %ecx,%eax
f010c739:	05 b8 00 00 00       	add    $0xb8,%eax
f010c73e:	c6 00 01             	movb   $0x1,(%eax)
		e->__ptr_tws[i].time_stamp = 0 ;
f010c741:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010c744:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010c747:	89 d0                	mov    %edx,%eax
f010c749:	01 c0                	add    %eax,%eax
f010c74b:	01 d0                	add    %edx,%eax
f010c74d:	c1 e0 03             	shl    $0x3,%eax
f010c750:	01 c8                	add    %ecx,%eax
f010c752:	05 bc 00 00 00       	add    $0xbc,%eax
f010c757:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		e->ptr_pageWorkingSet[i].time_stamp = 0 ;
	}
	e->page_last_WS_index = 0;
#endif

	for(i=0; i< __TWS_MAX_SIZE; i++)
f010c75d:	ff 45 f4             	incl   -0xc(%ebp)
f010c760:	83 7d f4 31          	cmpl   $0x31,-0xc(%ebp)
f010c764:	7e a6                	jle    f010c70c <initialize_environment+0x14d>
		e->__ptr_tws[i].virtual_address = 0;
		e->__ptr_tws[i].empty = 1;
		e->__ptr_tws[i].time_stamp = 0 ;
	}

	e->table_last_WS_index = 0;
f010c766:	8b 45 08             	mov    0x8(%ebp),%eax
f010c769:	c7 80 64 05 00 00 00 	movl   $0x0,0x564(%eax)
f010c770:	00 00 00 

	e->pageFaultsCounter=0;
f010c773:	8b 45 08             	mov    0x8(%ebp),%eax
f010c776:	c7 80 98 05 00 00 00 	movl   $0x0,0x598(%eax)
f010c77d:	00 00 00 
	e->tableFaultsCounter=0;
f010c780:	8b 45 08             	mov    0x8(%ebp),%eax
f010c783:	c7 80 9c 05 00 00 00 	movl   $0x0,0x59c(%eax)
f010c78a:	00 00 00 

	e->freeingFullWSCounter = 0;
f010c78d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c790:	c7 80 a0 05 00 00 00 	movl   $0x0,0x5a0(%eax)
f010c797:	00 00 00 
	e->freeingScarceMemCounter = 0;
f010c79a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c79d:	c7 80 a4 05 00 00 00 	movl   $0x0,0x5a4(%eax)
f010c7a4:	00 00 00 

	e->nModifiedPages=0;
f010c7a7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7aa:	c7 80 a8 05 00 00 00 	movl   $0x0,0x5a8(%eax)
f010c7b1:	00 00 00 
	e->nNotModifiedPages=0;
f010c7b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7b7:	c7 80 ac 05 00 00 00 	movl   $0x0,0x5ac(%eax)
f010c7be:	00 00 00 
	e->nClocks = 0;
f010c7c1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7c4:	c7 80 c0 05 00 00 00 	movl   $0x0,0x5c0(%eax)
f010c7cb:	00 00 00 

	//2020
	e->nPageIn = 0;
f010c7ce:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7d1:	c7 80 b4 05 00 00 00 	movl   $0x0,0x5b4(%eax)
f010c7d8:	00 00 00 
	e->nPageOut = 0;
f010c7db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7de:	c7 80 b8 05 00 00 00 	movl   $0x0,0x5b8(%eax)
f010c7e5:	00 00 00 
	e->nNewPageAdded = 0;
f010c7e8:	8b 45 08             	mov    0x8(%ebp),%eax
f010c7eb:	c7 80 bc 05 00 00 00 	movl   $0x0,0x5bc(%eax)
f010c7f2:	00 00 00 

	//e->shared_free_address = USER_SHARED_MEM_START;

	//Completes other environment initializations, (envID, status and most of registers)
	complete_environment_initialization(e);
f010c7f5:	83 ec 0c             	sub    $0xc,%esp
f010c7f8:	ff 75 08             	pushl  0x8(%ebp)
f010c7fb:	e8 06 00 00 00       	call   f010c806 <complete_environment_initialization>
f010c800:	83 c4 10             	add    $0x10,%esp
}
f010c803:	90                   	nop
f010c804:	c9                   	leave  
f010c805:	c3                   	ret    

f010c806 <complete_environment_initialization>:

//========================================================
// 9) COMPLETE INITIALIZATION [OTHERS: ID, REGS, STATUS...):
//========================================================
void complete_environment_initialization(struct Env* e)
{
f010c806:	55                   	push   %ebp
f010c807:	89 e5                	mov    %esp,%ebp
f010c809:	53                   	push   %ebx
f010c80a:	83 ec 14             	sub    $0x14,%esp
	//VPT and UVPT map the env's own page table, with
	//different permissions.
	e->env_page_directory[PDX(VPT)]  = e->env_cr3 | PERM_PRESENT | PERM_WRITEABLE;
f010c80d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c810:	8b 40 64             	mov    0x64(%eax),%eax
f010c813:	8d 90 fc 0e 00 00    	lea    0xefc(%eax),%edx
f010c819:	8b 45 08             	mov    0x8(%ebp),%eax
f010c81c:	8b 40 68             	mov    0x68(%eax),%eax
f010c81f:	83 c8 03             	or     $0x3,%eax
f010c822:	89 02                	mov    %eax,(%edx)
	e->env_page_directory[PDX(UVPT)] = e->env_cr3 | PERM_PRESENT | PERM_USER;
f010c824:	8b 45 08             	mov    0x8(%ebp),%eax
f010c827:	8b 40 64             	mov    0x64(%eax),%eax
f010c82a:	8d 90 f4 0e 00 00    	lea    0xef4(%eax),%edx
f010c830:	8b 45 08             	mov    0x8(%ebp),%eax
f010c833:	8b 40 68             	mov    0x68(%eax),%eax
f010c836:	83 c8 05             	or     $0x5,%eax
f010c839:	89 02                	mov    %eax,(%edx)

	// page file directory initialization
	e->disk_env_pgdir= 0;
f010c83b:	8b 45 08             	mov    0x8(%ebp),%eax
f010c83e:	c7 40 74 00 00 00 00 	movl   $0x0,0x74(%eax)
	e->disk_env_pgdir_PA= 0;
f010c845:	8b 45 08             	mov    0x8(%ebp),%eax
f010c848:	c7 40 78 00 00 00 00 	movl   $0x0,0x78(%eax)
	e->disk_env_tabledir = 0;
f010c84f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c852:	c7 40 7c 00 00 00 00 	movl   $0x0,0x7c(%eax)
	e->disk_env_tabledir_PA = 0;
f010c859:	8b 45 08             	mov    0x8(%ebp),%eax
f010c85c:	c7 80 80 00 00 00 00 	movl   $0x0,0x80(%eax)
f010c863:	00 00 00 

	int32 generation;
	// Generate an env_id for this environment.
	/*2022: UPDATED*/generation = (e->env_id + (1 << ENVGENSHIFT)) & ~(NEARPOW2NENV - 1);
f010c866:	8b 45 08             	mov    0x8(%ebp),%eax
f010c869:	8b 58 10             	mov    0x10(%eax),%ebx
f010c86c:	83 ec 0c             	sub    $0xc,%esp
f010c86f:	68 c6 02 00 00       	push   $0x2c6
f010c874:	e8 d7 c3 00 00       	call   f0118c50 <log2_ceil>
f010c879:	83 c4 10             	add    $0x10,%esp
f010c87c:	ba 01 00 00 00       	mov    $0x1,%edx
f010c881:	88 c1                	mov    %al,%cl
f010c883:	d3 e2                	shl    %cl,%edx
f010c885:	89 d0                	mov    %edx,%eax
f010c887:	01 d8                	add    %ebx,%eax
f010c889:	89 c3                	mov    %eax,%ebx
f010c88b:	83 ec 0c             	sub    $0xc,%esp
f010c88e:	68 c6 02 00 00       	push   $0x2c6
f010c893:	e8 83 c3 00 00       	call   f0118c1b <nearest_pow2_ceil>
f010c898:	83 c4 10             	add    $0x10,%esp
f010c89b:	f7 d8                	neg    %eax
f010c89d:	21 d8                	and    %ebx,%eax
f010c89f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (generation <= 0)	// Don't create a negative env_id.
f010c8a2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010c8a6:	7f 1e                	jg     f010c8c6 <complete_environment_initialization+0xc0>
		generation = 1 << ENVGENSHIFT;
f010c8a8:	83 ec 0c             	sub    $0xc,%esp
f010c8ab:	68 c6 02 00 00       	push   $0x2c6
f010c8b0:	e8 9b c3 00 00       	call   f0118c50 <log2_ceil>
f010c8b5:	83 c4 10             	add    $0x10,%esp
f010c8b8:	ba 01 00 00 00       	mov    $0x1,%edx
f010c8bd:	88 c1                	mov    %al,%cl
f010c8bf:	d3 e2                	shl    %cl,%edx
f010c8c1:	89 d0                	mov    %edx,%eax
f010c8c3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	e->env_id = generation | (e - envs);
f010c8c6:	8b 45 08             	mov    0x8(%ebp),%eax
f010c8c9:	8b 15 90 5b 81 f0    	mov    0xf0815b90,%edx
f010c8cf:	29 d0                	sub    %edx,%eax
f010c8d1:	c1 f8 02             	sar    $0x2,%eax
f010c8d4:	89 c1                	mov    %eax,%ecx
f010c8d6:	89 ca                	mov    %ecx,%edx
f010c8d8:	c1 e2 02             	shl    $0x2,%edx
f010c8db:	01 ca                	add    %ecx,%edx
f010c8dd:	c1 e2 02             	shl    $0x2,%edx
f010c8e0:	01 ca                	add    %ecx,%edx
f010c8e2:	c1 e2 03             	shl    $0x3,%edx
f010c8e5:	01 ca                	add    %ecx,%edx
f010c8e7:	89 d0                	mov    %edx,%eax
f010c8e9:	c1 e0 05             	shl    $0x5,%eax
f010c8ec:	29 d0                	sub    %edx,%eax
f010c8ee:	c1 e0 02             	shl    $0x2,%eax
f010c8f1:	01 c8                	add    %ecx,%eax
f010c8f3:	c1 e0 02             	shl    $0x2,%eax
f010c8f6:	01 c8                	add    %ecx,%eax
f010c8f8:	c1 e0 02             	shl    $0x2,%eax
f010c8fb:	01 c8                	add    %ecx,%eax
f010c8fd:	c1 e0 06             	shl    $0x6,%eax
f010c900:	29 c8                	sub    %ecx,%eax
f010c902:	c1 e0 03             	shl    $0x3,%eax
f010c905:	01 c8                	add    %ecx,%eax
f010c907:	c1 e0 04             	shl    $0x4,%eax
f010c90a:	01 c8                	add    %ecx,%eax
f010c90c:	0b 45 f4             	or     -0xc(%ebp),%eax
f010c90f:	89 c2                	mov    %eax,%edx
f010c911:	8b 45 08             	mov    0x8(%ebp),%eax
f010c914:	89 50 10             	mov    %edx,0x10(%eax)
	//cprintf("\n[%d] user kernel stack located in [%x,%x)\n", e->env_id, e->kstack, e->kstack + KERNEL_STACK_SIZE);
	//cprintf("ENV_CREATE: envID = %d, orig index in envs = %d, calc index using ENVX = %d\n", e->env_id, (e - envs), ENVX(e->env_id));

	// Set the basic status variables.
	//2017====================================================
	struct Env* cur_env = get_cpu_proc();
f010c917:	e8 fc f1 ff ff       	call   f010bb18 <get_cpu_proc>
f010c91c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env == NULL)
f010c91f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010c923:	75 0c                	jne    f010c931 <complete_environment_initialization+0x12b>
		e->env_parent_id = 0;//no parent;
f010c925:	8b 45 08             	mov    0x8(%ebp),%eax
f010c928:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
f010c92f:	eb 0c                	jmp    f010c93d <complete_environment_initialization+0x137>
	else
		e->env_parent_id = cur_env->env_id;//curenv is the parent;
f010c931:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010c934:	8b 50 10             	mov    0x10(%eax),%edx
f010c937:	8b 45 08             	mov    0x8(%ebp),%eax
f010c93a:	89 50 14             	mov    %edx,0x14(%eax)
	//========================================================
	e->env_status = ENV_NEW;
f010c93d:	8b 45 08             	mov    0x8(%ebp),%eax
f010c940:	c7 40 18 04 00 00 00 	movl   $0x4,0x18(%eax)
	e->env_runs = 0;
f010c947:	8b 45 08             	mov    0x8(%ebp),%eax
f010c94a:	c7 80 b0 05 00 00 00 	movl   $0x0,0x5b0(%eax)
f010c951:	00 00 00 

	// Clear out all the saved register state,
	// to prevent the register values
	// of a prior environment inhabiting this Env structure
	// from "leaking" into our new environment.
	memset(e->env_tf, 0, sizeof(*(e->env_tf)));
f010c954:	8b 45 08             	mov    0x8(%ebp),%eax
f010c957:	8b 00                	mov    (%eax),%eax
f010c959:	83 ec 04             	sub    $0x4,%esp
f010c95c:	6a 44                	push   $0x44
f010c95e:	6a 00                	push   $0x0
f010c960:	50                   	push   %eax
f010c961:	e8 03 e4 00 00       	call   f011ad69 <memset>
f010c966:	83 c4 10             	add    $0x10,%esp
	// GD_UD is the user data segment selector in the GDT, and
	// GD_UT is the user text segment selector (see inc/memlayout.h).
	// The low 2 bits of each segment register contains the
	// Requester Privilege Level (RPL); 3 means user mode.

	e->env_tf->tf_ds = GD_UD | 3;
f010c969:	8b 45 08             	mov    0x8(%ebp),%eax
f010c96c:	8b 00                	mov    (%eax),%eax
f010c96e:	66 c7 40 24 23 00    	movw   $0x23,0x24(%eax)
	e->env_tf->tf_es = GD_UD | 3;
f010c974:	8b 45 08             	mov    0x8(%ebp),%eax
f010c977:	8b 00                	mov    (%eax),%eax
f010c979:	66 c7 40 20 23 00    	movw   $0x23,0x20(%eax)
	e->env_tf->tf_ss = GD_UD | 3;
f010c97f:	8b 45 08             	mov    0x8(%ebp),%eax
f010c982:	8b 00                	mov    (%eax),%eax
f010c984:	66 c7 40 40 23 00    	movw   $0x23,0x40(%eax)
	e->env_tf->tf_esp = (uint32*)USTACKTOP;
f010c98a:	8b 45 08             	mov    0x8(%ebp),%eax
f010c98d:	8b 00                	mov    (%eax),%eax
f010c98f:	c7 40 3c 00 e0 bf ee 	movl   $0xeebfe000,0x3c(%eax)
	e->env_tf->tf_cs = GD_UT | 3;
f010c996:	8b 45 08             	mov    0x8(%ebp),%eax
f010c999:	8b 00                	mov    (%eax),%eax
f010c99b:	66 c7 40 34 1b 00    	movw   $0x1b,0x34(%eax)
	e->env_tf->tf_eflags |= FL_IF;
f010c9a1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9a4:	8b 00                	mov    (%eax),%eax
f010c9a6:	8b 55 08             	mov    0x8(%ebp),%edx
f010c9a9:	8b 12                	mov    (%edx),%edx
f010c9ab:	8b 52 38             	mov    0x38(%edx),%edx
f010c9ae:	80 ce 02             	or     $0x2,%dh
f010c9b1:	89 50 38             	mov    %edx,0x38(%eax)

	// You will set e->env_tf.tf_eip later.

	// commit the allocation
	LIST_REMOVE(&env_free_list ,e);
f010c9b4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010c9b8:	75 17                	jne    f010c9d1 <complete_environment_initialization+0x1cb>
f010c9ba:	83 ec 04             	sub    $0x4,%esp
f010c9bd:	68 1f fa 12 f0       	push   $0xf012fa1f
f010c9c2:	68 65 04 00 00       	push   $0x465
f010c9c7:	68 97 f9 12 f0       	push   $0xf012f997
f010c9cc:	e8 de 45 ff ff       	call   f0100faf <_panic>
f010c9d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9d4:	8b 40 08             	mov    0x8(%eax),%eax
f010c9d7:	85 c0                	test   %eax,%eax
f010c9d9:	74 11                	je     f010c9ec <complete_environment_initialization+0x1e6>
f010c9db:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9de:	8b 40 08             	mov    0x8(%eax),%eax
f010c9e1:	8b 55 08             	mov    0x8(%ebp),%edx
f010c9e4:	8b 52 0c             	mov    0xc(%edx),%edx
f010c9e7:	89 50 0c             	mov    %edx,0xc(%eax)
f010c9ea:	eb 0b                	jmp    f010c9f7 <complete_environment_initialization+0x1f1>
f010c9ec:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9ef:	8b 40 0c             	mov    0xc(%eax),%eax
f010c9f2:	a3 98 5b 81 f0       	mov    %eax,0xf0815b98
f010c9f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010c9fa:	8b 40 0c             	mov    0xc(%eax),%eax
f010c9fd:	85 c0                	test   %eax,%eax
f010c9ff:	74 11                	je     f010ca12 <complete_environment_initialization+0x20c>
f010ca01:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca04:	8b 40 0c             	mov    0xc(%eax),%eax
f010ca07:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca0a:	8b 52 08             	mov    0x8(%edx),%edx
f010ca0d:	89 50 08             	mov    %edx,0x8(%eax)
f010ca10:	eb 0b                	jmp    f010ca1d <complete_environment_initialization+0x217>
f010ca12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca15:	8b 40 08             	mov    0x8(%eax),%eax
f010ca18:	a3 94 5b 81 f0       	mov    %eax,0xf0815b94
f010ca1d:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca20:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
f010ca27:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca2a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
f010ca31:	a1 a0 5b 81 f0       	mov    0xf0815ba0,%eax
f010ca36:	48                   	dec    %eax
f010ca37:	a3 a0 5b 81 f0       	mov    %eax,0xf0815ba0
	return ;
f010ca3c:	90                   	nop
}
f010ca3d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ca40:	c9                   	leave  
f010ca41:	c3                   	ret    

f010ca42 <set_environment_entry_point>:

//===============================================
// 10) SET EIP REG VALUE BY ENV ENTRY POINT:
//===============================================
void set_environment_entry_point(struct Env* e, uint8* ptr_program_start)
{
f010ca42:	55                   	push   %ebp
f010ca43:	89 e5                	mov    %esp,%ebp
f010ca45:	83 ec 18             	sub    $0x18,%esp
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca48:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca4b:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010ca4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ca51:	8b 00                	mov    (%eax),%eax
f010ca53:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010ca58:	74 17                	je     f010ca71 <set_environment_entry_point+0x2f>
		panic("Matafa2nash 3ala Keda");
f010ca5a:	83 ec 04             	sub    $0x4,%esp
f010ca5d:	68 c1 fc 12 f0       	push   $0xf012fcc1
f010ca62:	68 71 04 00 00       	push   $0x471
f010ca67:	68 97 f9 12 f0       	push   $0xf012f997
f010ca6c:	e8 3e 45 ff ff       	call   f0100faf <_panic>
	e->env_tf->tf_eip = (uint32*)pELFHDR->e_entry ;
f010ca71:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca74:	8b 00                	mov    (%eax),%eax
f010ca76:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ca79:	8b 52 18             	mov    0x18(%edx),%edx
f010ca7c:	89 50 30             	mov    %edx,0x30(%eax)
}
f010ca7f:	90                   	nop
f010ca80:	c9                   	leave  
f010ca81:	c3                   	ret    

f010ca82 <PROGRAM_SEGMENT_NEXT>:

//===============================================
// 13) SEG NEXT [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment* PROGRAM_SEGMENT_NEXT(struct ProgramSegment* seg, uint8* ptr_program_start)
{
f010ca82:	55                   	push   %ebp
f010ca83:	89 e5                	mov    %esp,%ebp
f010ca85:	83 ec 18             	sub    $0x18,%esp
	int index = (*seg).segment_id++;
f010ca88:	8b 45 08             	mov    0x8(%ebp),%eax
f010ca8b:	8b 40 10             	mov    0x10(%eax),%eax
f010ca8e:	8d 48 01             	lea    0x1(%eax),%ecx
f010ca91:	8b 55 08             	mov    0x8(%ebp),%edx
f010ca94:	89 4a 10             	mov    %ecx,0x10(%edx)
f010ca97:	89 45 f4             	mov    %eax,-0xc(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010ca9a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ca9d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010caa0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010caa3:	8b 00                	mov    (%eax),%eax
f010caa5:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010caaa:	74 17                	je     f010cac3 <PROGRAM_SEGMENT_NEXT+0x41>
		panic("Matafa2nash 3ala Keda");
f010caac:	83 ec 04             	sub    $0x4,%esp
f010caaf:	68 c1 fc 12 f0       	push   $0xf012fcc1
f010cab4:	68 7f 04 00 00       	push   $0x47f
f010cab9:	68 97 f9 12 f0       	push   $0xf012f997
f010cabe:	e8 ec 44 ff ff       	call   f0100faf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cac3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cac6:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cac9:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cacc:	01 d0                	add    %edx,%eax
f010cace:	89 45 ec             	mov    %eax,-0x14(%ebp)

	while (ph[(*seg).segment_id].p_type != ELF_PROG_LOAD && ((*seg).segment_id < pELFHDR->e_phnum)) (*seg).segment_id++;
f010cad1:	eb 0f                	jmp    f010cae2 <PROGRAM_SEGMENT_NEXT+0x60>
f010cad3:	8b 45 08             	mov    0x8(%ebp),%eax
f010cad6:	8b 40 10             	mov    0x10(%eax),%eax
f010cad9:	8d 50 01             	lea    0x1(%eax),%edx
f010cadc:	8b 45 08             	mov    0x8(%ebp),%eax
f010cadf:	89 50 10             	mov    %edx,0x10(%eax)
f010cae2:	8b 45 08             	mov    0x8(%ebp),%eax
f010cae5:	8b 40 10             	mov    0x10(%eax),%eax
f010cae8:	c1 e0 05             	shl    $0x5,%eax
f010caeb:	89 c2                	mov    %eax,%edx
f010caed:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010caf0:	01 d0                	add    %edx,%eax
f010caf2:	8b 00                	mov    (%eax),%eax
f010caf4:	83 f8 01             	cmp    $0x1,%eax
f010caf7:	74 13                	je     f010cb0c <PROGRAM_SEGMENT_NEXT+0x8a>
f010caf9:	8b 45 08             	mov    0x8(%ebp),%eax
f010cafc:	8b 50 10             	mov    0x10(%eax),%edx
f010caff:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb02:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb05:	0f b7 c0             	movzwl %ax,%eax
f010cb08:	39 c2                	cmp    %eax,%edx
f010cb0a:	72 c7                	jb     f010cad3 <PROGRAM_SEGMENT_NEXT+0x51>
	index = (*seg).segment_id;
f010cb0c:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb0f:	8b 40 10             	mov    0x10(%eax),%eax
f010cb12:	89 45 f4             	mov    %eax,-0xc(%ebp)

	if(index < pELFHDR->e_phnum)
f010cb15:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010cb18:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cb1b:	0f b7 c0             	movzwl %ax,%eax
f010cb1e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010cb21:	7e 63                	jle    f010cb86 <PROGRAM_SEGMENT_NEXT+0x104>
	{
		(*seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cb23:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb26:	c1 e0 05             	shl    $0x5,%eax
f010cb29:	89 c2                	mov    %eax,%edx
f010cb2b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb2e:	01 d0                	add    %edx,%eax
f010cb30:	8b 50 04             	mov    0x4(%eax),%edx
f010cb33:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cb36:	01 c2                	add    %eax,%edx
f010cb38:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb3b:	89 10                	mov    %edx,(%eax)
		(*seg).size_in_memory =  ph[index].p_memsz;
f010cb3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb40:	c1 e0 05             	shl    $0x5,%eax
f010cb43:	89 c2                	mov    %eax,%edx
f010cb45:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb48:	01 d0                	add    %edx,%eax
f010cb4a:	8b 50 14             	mov    0x14(%eax),%edx
f010cb4d:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb50:	89 50 08             	mov    %edx,0x8(%eax)
		(*seg).size_in_file = ph[index].p_filesz;
f010cb53:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb56:	c1 e0 05             	shl    $0x5,%eax
f010cb59:	89 c2                	mov    %eax,%edx
f010cb5b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb5e:	01 d0                	add    %edx,%eax
f010cb60:	8b 50 10             	mov    0x10(%eax),%edx
f010cb63:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb66:	89 50 04             	mov    %edx,0x4(%eax)
		(*seg).virtual_address = (uint8*)ph[index].p_va;
f010cb69:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cb6c:	c1 e0 05             	shl    $0x5,%eax
f010cb6f:	89 c2                	mov    %eax,%edx
f010cb71:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010cb74:	01 d0                	add    %edx,%eax
f010cb76:	8b 40 08             	mov    0x8(%eax),%eax
f010cb79:	89 c2                	mov    %eax,%edx
f010cb7b:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb7e:	89 50 0c             	mov    %edx,0xc(%eax)
		return seg;
f010cb81:	8b 45 08             	mov    0x8(%ebp),%eax
f010cb84:	eb 05                	jmp    f010cb8b <PROGRAM_SEGMENT_NEXT+0x109>
	}
	return 0;
f010cb86:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010cb8b:	c9                   	leave  
f010cb8c:	c3                   	ret    

f010cb8d <PROGRAM_SEGMENT_FIRST>:

//===============================================
// 14) SEG FIRST [TO BE USED IN PROG_SEG_FOREACH]:
//===============================================
struct ProgramSegment PROGRAM_SEGMENT_FIRST( uint8* ptr_program_start)
{
f010cb8d:	55                   	push   %ebp
f010cb8e:	89 e5                	mov    %esp,%ebp
f010cb90:	57                   	push   %edi
f010cb91:	56                   	push   %esi
f010cb92:	53                   	push   %ebx
f010cb93:	83 ec 2c             	sub    $0x2c,%esp
	struct ProgramSegment seg;
	seg.segment_id = 0;
f010cb96:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)

	struct Proghdr *ph, *eph;
	struct Elf * pELFHDR = (struct Elf *)ptr_program_start ;
f010cb9d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cba0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (pELFHDR->e_magic != ELF_MAGIC)
f010cba3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cba6:	8b 00                	mov    (%eax),%eax
f010cba8:	3d 7f 45 4c 46       	cmp    $0x464c457f,%eax
f010cbad:	74 17                	je     f010cbc6 <PROGRAM_SEGMENT_FIRST+0x39>
		panic("Matafa2nash 3ala Keda");
f010cbaf:	83 ec 04             	sub    $0x4,%esp
f010cbb2:	68 c1 fc 12 f0       	push   $0xf012fcc1
f010cbb7:	68 9b 04 00 00       	push   $0x49b
f010cbbc:	68 97 f9 12 f0       	push   $0xf012f997
f010cbc1:	e8 e9 43 ff ff       	call   f0100faf <_panic>
	ph = (struct Proghdr *) ( ((uint8 *) ptr_program_start) + pELFHDR->e_phoff);
f010cbc6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cbc9:	8b 50 1c             	mov    0x1c(%eax),%edx
f010cbcc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cbcf:	01 d0                	add    %edx,%eax
f010cbd1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	while (ph[(seg).segment_id].p_type != ELF_PROG_LOAD && ((seg).segment_id < pELFHDR->e_phnum)) (seg).segment_id++;
f010cbd4:	eb 07                	jmp    f010cbdd <PROGRAM_SEGMENT_FIRST+0x50>
f010cbd6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cbd9:	40                   	inc    %eax
f010cbda:	89 45 d8             	mov    %eax,-0x28(%ebp)
f010cbdd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cbe0:	c1 e0 05             	shl    $0x5,%eax
f010cbe3:	89 c2                	mov    %eax,%edx
f010cbe5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cbe8:	01 d0                	add    %edx,%eax
f010cbea:	8b 00                	mov    (%eax),%eax
f010cbec:	83 f8 01             	cmp    $0x1,%eax
f010cbef:	74 10                	je     f010cc01 <PROGRAM_SEGMENT_FIRST+0x74>
f010cbf1:	8b 55 d8             	mov    -0x28(%ebp),%edx
f010cbf4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cbf7:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cbfa:	0f b7 c0             	movzwl %ax,%eax
f010cbfd:	39 c2                	cmp    %eax,%edx
f010cbff:	72 d5                	jb     f010cbd6 <PROGRAM_SEGMENT_FIRST+0x49>
	int index = (seg).segment_id;
f010cc01:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010cc04:	89 45 dc             	mov    %eax,-0x24(%ebp)

	if(index < pELFHDR->e_phnum)
f010cc07:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010cc0a:	8b 40 2c             	mov    0x2c(%eax),%eax
f010cc0d:	0f b7 c0             	movzwl %ax,%eax
f010cc10:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f010cc13:	7e 68                	jle    f010cc7d <PROGRAM_SEGMENT_FIRST+0xf0>
	{
		(seg).ptr_start = (uint8 *) ptr_program_start + ph[index].p_offset;
f010cc15:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc18:	c1 e0 05             	shl    $0x5,%eax
f010cc1b:	89 c2                	mov    %eax,%edx
f010cc1d:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc20:	01 d0                	add    %edx,%eax
f010cc22:	8b 50 04             	mov    0x4(%eax),%edx
f010cc25:	8b 45 0c             	mov    0xc(%ebp),%eax
f010cc28:	01 d0                	add    %edx,%eax
f010cc2a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		(seg).size_in_memory =  ph[index].p_memsz;
f010cc2d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc30:	c1 e0 05             	shl    $0x5,%eax
f010cc33:	89 c2                	mov    %eax,%edx
f010cc35:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc38:	01 d0                	add    %edx,%eax
f010cc3a:	8b 40 14             	mov    0x14(%eax),%eax
f010cc3d:	89 45 d0             	mov    %eax,-0x30(%ebp)
		(seg).size_in_file = ph[index].p_filesz;
f010cc40:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc43:	c1 e0 05             	shl    $0x5,%eax
f010cc46:	89 c2                	mov    %eax,%edx
f010cc48:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc4b:	01 d0                	add    %edx,%eax
f010cc4d:	8b 40 10             	mov    0x10(%eax),%eax
f010cc50:	89 45 cc             	mov    %eax,-0x34(%ebp)
		(seg).virtual_address = (uint8*)ph[index].p_va;
f010cc53:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010cc56:	c1 e0 05             	shl    $0x5,%eax
f010cc59:	89 c2                	mov    %eax,%edx
f010cc5b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010cc5e:	01 d0                	add    %edx,%eax
f010cc60:	8b 40 08             	mov    0x8(%eax),%eax
f010cc63:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		return seg;
f010cc66:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc69:	89 c3                	mov    %eax,%ebx
f010cc6b:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cc6e:	ba 05 00 00 00       	mov    $0x5,%edx
f010cc73:	89 df                	mov    %ebx,%edi
f010cc75:	89 c6                	mov    %eax,%esi
f010cc77:	89 d1                	mov    %edx,%ecx
f010cc79:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f010cc7b:	eb 1c                	jmp    f010cc99 <PROGRAM_SEGMENT_FIRST+0x10c>
	}
	seg.segment_id = -1;
f010cc7d:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
	return seg;
f010cc84:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc87:	89 c3                	mov    %eax,%ebx
f010cc89:	8d 45 c8             	lea    -0x38(%ebp),%eax
f010cc8c:	ba 05 00 00 00       	mov    $0x5,%edx
f010cc91:	89 df                	mov    %ebx,%edi
f010cc93:	89 c6                	mov    %eax,%esi
f010cc95:	89 d1                	mov    %edx,%ecx
f010cc97:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
f010cc99:	8b 45 08             	mov    0x8(%ebp),%eax
f010cc9c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010cc9f:	5b                   	pop    %ebx
f010cca0:	5e                   	pop    %esi
f010cca1:	5f                   	pop    %edi
f010cca2:	5d                   	pop    %ebp
f010cca3:	c2 04 00             	ret    $0x4

f010cca6 <cleanup_buffers>:

//===============================================================================
// 15) CLEANUP MODIFIED BUFFER [TO BE USED AS LAST STEP WHEN ADD ENV TO EXIT Q]:
//===============================================================================
void cleanup_buffers(struct Env* e)
{
f010cca6:	55                   	push   %ebp
f010cca7:	89 e5                	mov    %esp,%ebp
f010cca9:	83 ec 18             	sub    $0x18,%esp
	//NEW !! 2016, remove remaining pages in the modified list
	struct FrameInfo *ptr_fi=NULL ;
f010ccac:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	//	cprintf("[%s] deleting modified at end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc = calculate_available_frames();
	//	cprintf("[%s] bef, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc.modified, ffc.freeBuffered, ffc.freeNotBuffered);

	bool lock_already_held = holding_kspinlock(&MemFrameLists.mfllock);
f010ccb3:	83 ec 0c             	sub    $0xc,%esp
f010ccb6:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010ccbb:	e8 10 34 00 00       	call   f01100d0 <holding_kspinlock>
f010ccc0:	83 c4 10             	add    $0x10,%esp
f010ccc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (!lock_already_held)
f010ccc6:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ccca:	75 10                	jne    f010ccdc <cleanup_buffers+0x36>
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
f010cccc:	83 ec 0c             	sub    $0xc,%esp
f010cccf:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010ccd4:	e8 a2 31 00 00       	call   f010fe7b <acquire_kspinlock>
f010ccd9:	83 c4 10             	add    $0x10,%esp
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010ccdc:	a1 d0 e7 83 f0       	mov    0xf083e7d0,%eax
f010cce1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cce4:	e9 a7 00 00 00       	jmp    f010cd90 <cleanup_buffers+0xea>
						{
			if(ptr_fi->proc == e)
f010cce9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ccec:	8b 40 0c             	mov    0xc(%eax),%eax
f010ccef:	3b 45 08             	cmp    0x8(%ebp),%eax
f010ccf2:	0f 85 90 00 00 00    	jne    f010cd88 <cleanup_buffers+0xe2>
				/*MUST UN-COMMENT THIS LINE*/
				//pt_clear_page_table_entry(ptr_fi->proc->env_page_directory,ptr_fi->va);

				//cprintf("==================\n");
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x \n",curenv->prog_name, ptr_fi, LIST_NEXT(ptr_fi));
				LIST_REMOVE(&MemFrameLists.modified_frame_list, ptr_fi);
f010ccf8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ccfc:	75 17                	jne    f010cd15 <cleanup_buffers+0x6f>
f010ccfe:	83 ec 04             	sub    $0x4,%esp
f010cd01:	68 1f fa 12 f0       	push   $0xf012fa1f
f010cd06:	68 c9 04 00 00       	push   $0x4c9
f010cd0b:	68 97 f9 12 f0       	push   $0xf012f997
f010cd10:	e8 9a 42 ff ff       	call   f0100faf <_panic>
f010cd15:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd18:	8b 00                	mov    (%eax),%eax
f010cd1a:	85 c0                	test   %eax,%eax
f010cd1c:	74 10                	je     f010cd2e <cleanup_buffers+0x88>
f010cd1e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd21:	8b 00                	mov    (%eax),%eax
f010cd23:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd26:	8b 52 04             	mov    0x4(%edx),%edx
f010cd29:	89 50 04             	mov    %edx,0x4(%eax)
f010cd2c:	eb 0b                	jmp    f010cd39 <cleanup_buffers+0x93>
f010cd2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd31:	8b 40 04             	mov    0x4(%eax),%eax
f010cd34:	a3 d4 e7 83 f0       	mov    %eax,0xf083e7d4
f010cd39:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd3c:	8b 40 04             	mov    0x4(%eax),%eax
f010cd3f:	85 c0                	test   %eax,%eax
f010cd41:	74 0f                	je     f010cd52 <cleanup_buffers+0xac>
f010cd43:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd46:	8b 40 04             	mov    0x4(%eax),%eax
f010cd49:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cd4c:	8b 12                	mov    (%edx),%edx
f010cd4e:	89 10                	mov    %edx,(%eax)
f010cd50:	eb 0a                	jmp    f010cd5c <cleanup_buffers+0xb6>
f010cd52:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd55:	8b 00                	mov    (%eax),%eax
f010cd57:	a3 d0 e7 83 f0       	mov    %eax,0xf083e7d0
f010cd5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd5f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f010cd65:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd68:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
f010cd6f:	a1 dc e7 83 f0       	mov    0xf083e7dc,%eax
f010cd74:	48                   	dec    %eax
f010cd75:	a3 dc e7 83 f0       	mov    %eax,0xf083e7dc

				free_frame(ptr_fi);
f010cd7a:	83 ec 0c             	sub    $0xc,%esp
f010cd7d:	ff 75 f4             	pushl  -0xc(%ebp)
f010cd80:	e8 e5 c4 ff ff       	call   f010926a <free_frame>
f010cd85:	83 c4 10             	add    $0x10,%esp
	if (!lock_already_held)
	{
		acquire_kspinlock(&MemFrameLists.mfllock);
	}
	{
		LIST_FOREACH(ptr_fi, &MemFrameLists.modified_frame_list)
f010cd88:	a1 d8 e7 83 f0       	mov    0xf083e7d8,%eax
f010cd8d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010cd90:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cd94:	74 07                	je     f010cd9d <cleanup_buffers+0xf7>
f010cd96:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cd99:	8b 00                	mov    (%eax),%eax
f010cd9b:	eb 05                	jmp    f010cda2 <cleanup_buffers+0xfc>
f010cd9d:	b8 00 00 00 00       	mov    $0x0,%eax
f010cda2:	a3 d8 e7 83 f0       	mov    %eax,0xf083e7d8
f010cda7:	a1 d8 e7 83 f0       	mov    0xf083e7d8,%eax
f010cdac:	85 c0                	test   %eax,%eax
f010cdae:	0f 85 35 ff ff ff    	jne    f010cce9 <cleanup_buffers+0x43>
f010cdb4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010cdb8:	0f 85 2b ff ff ff    	jne    f010cce9 <cleanup_buffers+0x43>
				//cprintf("[%s] ptr_fi = %x, ptr_fi next = %x, saved next = %x \n", curenv->prog_name ,ptr_fi, LIST_NEXT(ptr_fi), ___ptr_next);
				//cprintf("==================\n");
			}
						}
	}
	if (!lock_already_held)
f010cdbe:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010cdc2:	75 10                	jne    f010cdd4 <cleanup_buffers+0x12e>
	{
		release_kspinlock(&MemFrameLists.mfllock);
f010cdc4:	83 ec 0c             	sub    $0xc,%esp
f010cdc7:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010cdcc:	e8 4f 31 00 00       	call   f010ff20 <release_kspinlock>
f010cdd1:	83 c4 10             	add    $0x10,%esp
	}
	//	cprintf("[%s] finished deleting modified frames at the end of env\n", curenv->prog_name);
	//	struct freeFramesCounters ffc2 = calculate_available_frames();
	//	cprintf("[%s] aft, mod = %d, fb = %d, fnb = %d\n",curenv->prog_name, ffc2.modified, ffc2.freeBuffered, ffc2.freeNotBuffered);
}
f010cdd4:	90                   	nop
f010cdd5:	c9                   	leave  
f010cdd6:	c3                   	ret    

f010cdd7 <set_program_priority>:
#include "../mem/kheap.h"
#include "../mem/memory_manager.h"


void set_program_priority(struct Env* env, int priority)
{
f010cdd7:	55                   	push   %ebp
f010cdd8:	89 e5                	mov    %esp,%ebp
f010cdda:	83 ec 08             	sub    $0x8,%esp
	//[PROGRAM PRIORITY] set_program_priority
	//[ALREADY IMPLEMENTED]

	if(priority < 1 || priority > 5)
f010cddd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f010cde1:	7e 06                	jle    f010cde9 <set_program_priority+0x12>
f010cde3:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010cde7:	7e 14                	jle    f010cdfd <set_program_priority+0x26>
	{
		panic("Please enter valid priority (1->5)\n");
f010cde9:	83 ec 04             	sub    $0x4,%esp
f010cdec:	68 d8 fc 12 f0       	push   $0xf012fcd8
f010cdf1:	6a 11                	push   $0x11
f010cdf3:	68 fc fc 12 f0       	push   $0xf012fcfc
f010cdf8:	e8 b2 41 ff ff       	call   f0100faf <_panic>
		return;
	}
	if(env == NULL)
f010cdfd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ce01:	74 78                	je     f010ce7b <set_program_priority+0xa4>
		return;
	switch(priority)
f010ce03:	83 7d 0c 05          	cmpl   $0x5,0xc(%ebp)
f010ce07:	77 56                	ja     f010ce5f <set_program_priority+0x88>
f010ce09:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ce0c:	c1 e0 02             	shl    $0x2,%eax
f010ce0f:	05 38 fd 12 f0       	add    $0xf012fd38,%eax
f010ce14:	8b 00                	mov    (%eax),%eax
f010ce16:	ff e0                	jmp    *%eax
	{
		case PRIORITY_LOW:
			half_WS_Size(env, 1);
f010ce18:	83 ec 08             	sub    $0x8,%esp
f010ce1b:	6a 01                	push   $0x1
f010ce1d:	ff 75 08             	pushl  0x8(%ebp)
f010ce20:	e8 3d de ff ff       	call   f010ac62 <half_WS_Size>
f010ce25:	83 c4 10             	add    $0x10,%esp
			break;
f010ce28:	eb 35                	jmp    f010ce5f <set_program_priority+0x88>
		case PRIORITY_BELOWNORMAL:
			half_WS_Size(env, 0);
f010ce2a:	83 ec 08             	sub    $0x8,%esp
f010ce2d:	6a 00                	push   $0x0
f010ce2f:	ff 75 08             	pushl  0x8(%ebp)
f010ce32:	e8 2b de ff ff       	call   f010ac62 <half_WS_Size>
f010ce37:	83 c4 10             	add    $0x10,%esp
			break;
f010ce3a:	eb 23                	jmp    f010ce5f <set_program_priority+0x88>
		case PRIORITY_NORMAL:
			// Do Nothing
			break;
		case PRIORITY_ABOVENORMAL:
			double_WS_Size(env, 1);
f010ce3c:	83 ec 08             	sub    $0x8,%esp
f010ce3f:	6a 01                	push   $0x1
f010ce41:	ff 75 08             	pushl  0x8(%ebp)
f010ce44:	e8 fc dd ff ff       	call   f010ac45 <double_WS_Size>
f010ce49:	83 c4 10             	add    $0x10,%esp
			break;
f010ce4c:	eb 11                	jmp    f010ce5f <set_program_priority+0x88>
		case PRIORITY_HIGH:
			double_WS_Size(env, 0);
f010ce4e:	83 ec 08             	sub    $0x8,%esp
f010ce51:	6a 00                	push   $0x0
f010ce53:	ff 75 08             	pushl  0x8(%ebp)
f010ce56:	e8 ea dd ff ff       	call   f010ac45 <double_WS_Size>
f010ce5b:	83 c4 10             	add    $0x10,%esp
			break;
f010ce5e:	90                   	nop
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
f010ce5f:	8b 45 08             	mov    0x8(%ebp),%eax
f010ce62:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010ce68:	83 ec 08             	sub    $0x8,%esp
f010ce6b:	50                   	push   %eax
f010ce6c:	68 19 fd 12 f0       	push   $0xf012fd19
f010ce71:	e8 e6 4d ff ff       	call   f0101c5c <cprintf>
f010ce76:	83 c4 10             	add    $0x10,%esp
f010ce79:	eb 01                	jmp    f010ce7c <set_program_priority+0xa5>
	{
		panic("Please enter valid priority (1->5)\n");
		return;
	}
	if(env == NULL)
		return;
f010ce7b:	90                   	nop
			double_WS_Size(env, 0);
			break;
	}

	cprintf("The new size of the ws is %d\n", env->page_WS_max_size);
}
f010ce7c:	c9                   	leave  
f010ce7d:	c3                   	ret    

f010ce7e <get_user_program_info>:

// Number of user programs in the program table
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
f010ce7e:	55                   	push   %ebp
f010ce7f:	89 e5                	mov    %esp,%ebp
f010ce81:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ce84:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ce8b:	eb 29                	jmp    f010ceb6 <get_user_program_info+0x38>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
f010ce8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ce90:	89 d0                	mov    %edx,%eax
f010ce92:	01 c0                	add    %eax,%eax
f010ce94:	01 d0                	add    %edx,%eax
f010ce96:	c1 e0 02             	shl    $0x2,%eax
f010ce99:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
f010ce9e:	8b 00                	mov    (%eax),%eax
f010cea0:	83 ec 08             	sub    $0x8,%esp
f010cea3:	50                   	push   %eax
f010cea4:	ff 75 08             	pushl  0x8(%ebp)
f010cea7:	e8 db dd 00 00       	call   f011ac87 <strcmp>
f010ceac:	83 c4 10             	add    $0x10,%esp
f010ceaf:	85 c0                	test   %eax,%eax
f010ceb1:	74 0f                	je     f010cec2 <get_user_program_info+0x44>
int NUM_USER_PROGS = (sizeof(userPrograms)/sizeof(userPrograms[0]));

struct UserProgramInfo* get_user_program_info(char* user_program_name)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010ceb3:	ff 45 f4             	incl   -0xc(%ebp)
f010ceb6:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cebb:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cebe:	7c cd                	jl     f010ce8d <get_user_program_info+0xf>
f010cec0:	eb 01                	jmp    f010cec3 <get_user_program_info+0x45>
		if (strcmp(user_program_name, userPrograms[i].name) == 0)
			break;
f010cec2:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cec3:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cec8:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cecb:	75 1a                	jne    f010cee7 <get_user_program_info+0x69>
	{
		cprintf("Unknown user program '%s'\n", user_program_name);
f010cecd:	83 ec 08             	sub    $0x8,%esp
f010ced0:	ff 75 08             	pushl  0x8(%ebp)
f010ced3:	68 9c 0e 13 f0       	push   $0xf0130e9c
f010ced8:	e8 7f 4d ff ff       	call   f0101c5c <cprintf>
f010cedd:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cee0:	b8 00 00 00 00       	mov    $0x0,%eax
f010cee5:	eb 11                	jmp    f010cef8 <get_user_program_info+0x7a>
	}

	return &userPrograms[i];
f010cee7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010ceea:	89 d0                	mov    %edx,%eax
f010ceec:	01 c0                	add    %eax,%eax
f010ceee:	01 d0                	add    %edx,%eax
f010cef0:	c1 e0 02             	shl    $0x2,%eax
f010cef3:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
}
f010cef8:	c9                   	leave  
f010cef9:	c3                   	ret    

f010cefa <get_user_program_info_by_env>:

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
f010cefa:	55                   	push   %ebp
f010cefb:	89 e5                	mov    %esp,%ebp
f010cefd:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cf00:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010cf07:	eb 2d                	jmp    f010cf36 <get_user_program_info_by_env+0x3c>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
f010cf09:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf0c:	89 d0                	mov    %edx,%eax
f010cf0e:	01 c0                	add    %eax,%eax
f010cf10:	01 d0                	add    %edx,%eax
f010cf12:	c1 e0 02             	shl    $0x2,%eax
f010cf15:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
f010cf1a:	8b 00                	mov    (%eax),%eax
f010cf1c:	8b 55 08             	mov    0x8(%ebp),%edx
f010cf1f:	83 c2 20             	add    $0x20,%edx
f010cf22:	83 ec 08             	sub    $0x8,%esp
f010cf25:	50                   	push   %eax
f010cf26:	52                   	push   %edx
f010cf27:	e8 5b dd 00 00       	call   f011ac87 <strcmp>
f010cf2c:	83 c4 10             	add    $0x10,%esp
f010cf2f:	85 c0                	test   %eax,%eax
f010cf31:	74 0f                	je     f010cf42 <get_user_program_info_by_env+0x48>
}

struct UserProgramInfo* get_user_program_info_by_env(struct Env* e)
{
	int i;
	for (i = 0; i < NUM_USER_PROGS; i++) {
f010cf33:	ff 45 f4             	incl   -0xc(%ebp)
f010cf36:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cf3b:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf3e:	7c c9                	jl     f010cf09 <get_user_program_info_by_env+0xf>
f010cf40:	eb 01                	jmp    f010cf43 <get_user_program_info_by_env+0x49>
		if ( strcmp( e->prog_name , userPrograms[i].name) ==0)
			break;
f010cf42:	90                   	nop
	}
	if(i==NUM_USER_PROGS)
f010cf43:	a1 a0 00 18 f0       	mov    0xf01800a0,%eax
f010cf48:	39 45 f4             	cmp    %eax,-0xc(%ebp)
f010cf4b:	75 17                	jne    f010cf64 <get_user_program_info_by_env+0x6a>
	{
		cprintf("Unknown user program \n");
f010cf4d:	83 ec 0c             	sub    $0xc,%esp
f010cf50:	68 b7 0e 13 f0       	push   $0xf0130eb7
f010cf55:	e8 02 4d ff ff       	call   f0101c5c <cprintf>
f010cf5a:	83 c4 10             	add    $0x10,%esp
		return 0;
f010cf5d:	b8 00 00 00 00       	mov    $0x0,%eax
f010cf62:	eb 11                	jmp    f010cf75 <get_user_program_info_by_env+0x7b>
	}

	return &userPrograms[i];
f010cf64:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cf67:	89 d0                	mov    %edx,%eax
f010cf69:	01 c0                	add    %eax,%eax
f010cf6b:	01 d0                	add    %edx,%eax
f010cf6d:	c1 e0 02             	shl    $0x2,%eax
f010cf70:	05 e0 fb 17 f0       	add    $0xf017fbe0,%eax
}
f010cf75:	c9                   	leave  
f010cf76:	c3                   	ret    

f010cf77 <trapname>:
extern  void (*ALL_FAULTS47)();



static const char *trapname(int trapno)
{
f010cf77:	55                   	push   %ebp
f010cf78:	89 e5                	mov    %esp,%ebp
			"Alignment Check",
			"Machine-Check",
			"SIMD Floating-Point Exception"
	};

	if (trapno < sizeof(excnames)/sizeof(excnames[0]))
f010cf7a:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf7d:	83 f8 13             	cmp    $0x13,%eax
f010cf80:	77 0c                	ja     f010cf8e <trapname+0x17>
		return excnames[trapno];
f010cf82:	8b 45 08             	mov    0x8(%ebp),%eax
f010cf85:	8b 04 85 40 13 13 f0 	mov    -0xfececc0(,%eax,4),%eax
f010cf8c:	eb 2c                	jmp    f010cfba <trapname+0x43>
	if (trapno == T_SYSCALL)
f010cf8e:	83 7d 08 30          	cmpl   $0x30,0x8(%ebp)
f010cf92:	75 07                	jne    f010cf9b <trapname+0x24>
		return "System call";
f010cf94:	b8 e0 0e 13 f0       	mov    $0xf0130ee0,%eax
f010cf99:	eb 1f                	jmp    f010cfba <trapname+0x43>
	else if (trapno == IRQ0_Clock)
f010cf9b:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
f010cf9f:	75 07                	jne    f010cfa8 <trapname+0x31>
		return "Clock Interrupt";
f010cfa1:	b8 ec 0e 13 f0       	mov    $0xf0130eec,%eax
f010cfa6:	eb 12                	jmp    f010cfba <trapname+0x43>
	else if (trapno == IRQ1_KB)
f010cfa8:	83 7d 08 21          	cmpl   $0x21,0x8(%ebp)
f010cfac:	75 07                	jne    f010cfb5 <trapname+0x3e>
		return "Keyboard Interrupt";
f010cfae:	b8 fc 0e 13 f0       	mov    $0xf0130efc,%eax
f010cfb3:	eb 05                	jmp    f010cfba <trapname+0x43>
	return "(unknown trap)";
f010cfb5:	b8 0f 0f 13 f0       	mov    $0xf0130f0f,%eax
}
f010cfba:	5d                   	pop    %ebp
f010cfbb:	c3                   	ret    

f010cfbc <ts_init>:


void ts_init(void)
{
f010cfbc:	55                   	push   %ebp
f010cfbd:	89 e5                	mov    %esp,%ebp
f010cfbf:	53                   	push   %ebx
f010cfc0:	83 ec 14             	sub    $0x14,%esp
	pushcli();	//disable interrupt - lock: to protect CPU info in multi-CPU
f010cfc3:	e8 68 b1 ff ff       	call   f0108130 <pushcli>

	struct cpu* c = mycpu();
f010cfc8:	e8 a3 b0 ff ff       	call   f0108070 <mycpu>
f010cfcd:	89 45 f4             	mov    %eax,-0xc(%ebp)

	// Setup a TSS so that we get the right user kernel stack
	// when we trap to the kernel.
	// 2024: for now, temporarily set it to 0
	// since the scheduler will run first then switch to the first process
	c->ts.ts_esp0 = 0;
f010cfd0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfd3:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	c->ts.ts_ss0 = GD_KD;
f010cfda:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfdd:	66 c7 40 14 10 00    	movw   $0x10,0x14(%eax)

	// Initialize the TSS field of the gdt.
	c->gdt[GD_TSS >> 3] = SEG16(STS_T32A, (uint32) (&(c->ts)), sizeof(struct Taskstate), 0);
f010cfe3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010cfe6:	83 c0 0c             	add    $0xc,%eax
f010cfe9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cfec:	83 c2 0c             	add    $0xc,%edx
f010cfef:	c1 ea 10             	shr    $0x10,%edx
f010cff2:	88 d3                	mov    %dl,%bl
f010cff4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010cff7:	83 c2 0c             	add    $0xc,%edx
f010cffa:	c1 ea 18             	shr    $0x18,%edx
f010cffd:	88 d1                	mov    %dl,%cl
f010cfff:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d002:	66 c7 82 9c 00 00 00 	movw   $0x68,0x9c(%edx)
f010d009:	68 00 
f010d00b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010d00e:	66 89 82 9e 00 00 00 	mov    %ax,0x9e(%edx)
f010d015:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d018:	88 98 a0 00 00 00    	mov    %bl,0xa0(%eax)
f010d01e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d021:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d027:	83 e2 f0             	and    $0xfffffff0,%edx
f010d02a:	83 ca 09             	or     $0x9,%edx
f010d02d:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d033:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d036:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d03c:	83 ca 10             	or     $0x10,%edx
f010d03f:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d045:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d048:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d04e:	83 e2 9f             	and    $0xffffff9f,%edx
f010d051:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d057:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d05a:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d060:	83 ca 80             	or     $0xffffff80,%edx
f010d063:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)
f010d069:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d06c:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d072:	83 e2 f0             	and    $0xfffffff0,%edx
f010d075:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d07b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d07e:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d084:	83 e2 ef             	and    $0xffffffef,%edx
f010d087:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d08d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d090:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d096:	83 e2 df             	and    $0xffffffdf,%edx
f010d099:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d09f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0a2:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0a8:	83 ca 40             	or     $0x40,%edx
f010d0ab:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0b4:	8a 90 a2 00 00 00    	mov    0xa2(%eax),%dl
f010d0ba:	83 e2 7f             	and    $0x7f,%edx
f010d0bd:	88 90 a2 00 00 00    	mov    %dl,0xa2(%eax)
f010d0c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0c6:	88 88 a3 00 00 00    	mov    %cl,0xa3(%eax)
	c->gdt[GD_TSS >> 3].sd_s = 0;
f010d0cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010d0cf:	8a 90 a1 00 00 00    	mov    0xa1(%eax),%dl
f010d0d5:	83 e2 ef             	and    $0xffffffef,%edx
f010d0d8:	88 90 a1 00 00 00    	mov    %dl,0xa1(%eax)

	popcli();	//enable interrupt - lock: to protect CPU info in multi-CPU
f010d0de:	e8 9f b0 ff ff       	call   f0108182 <popcli>
f010d0e3:	66 c7 45 f2 28 00    	movw   $0x28,-0xe(%ebp)
}

static __inline void
ltr(uint16 sel)
{
	__asm __volatile("ltr %0" : : "r" (sel));
f010d0e9:	66 8b 45 f2          	mov    -0xe(%ebp),%ax
f010d0ed:	0f 00 d8             	ltr    %ax

	// Load the TSS
	ltr(GD_TSS);
}
f010d0f0:	90                   	nop
f010d0f1:	83 c4 14             	add    $0x14,%esp
f010d0f4:	5b                   	pop    %ebx
f010d0f5:	5d                   	pop    %ebp
f010d0f6:	c3                   	ret    

f010d0f7 <idt_init>:
/// shifted function addresses can't be represented in relocation records.)
///
struct Gatedesc idt[256] = { { 0 } };

void idt_init(void)
{
f010d0f7:	55                   	push   %ebp
f010d0f8:	89 e5                	mov    %esp,%ebp
f010d0fa:	83 ec 10             	sub    $0x10,%esp
	//initialize idt
	SETGATE(idt[T_DBLFLT  ], 0, GD_KT , &DBL_FAULT, 0) ;		//8
f010d0fd:	b8 62 e6 10 f0       	mov    $0xf010e662,%eax
f010d102:	66 a3 00 5c 81 f0    	mov    %ax,0xf0815c00
f010d108:	66 c7 05 02 5c 81 f0 	movw   $0x8,0xf0815c02
f010d10f:	08 00 
f010d111:	a0 04 5c 81 f0       	mov    0xf0815c04,%al
f010d116:	83 e0 e0             	and    $0xffffffe0,%eax
f010d119:	a2 04 5c 81 f0       	mov    %al,0xf0815c04
f010d11e:	a0 04 5c 81 f0       	mov    0xf0815c04,%al
f010d123:	83 e0 1f             	and    $0x1f,%eax
f010d126:	a2 04 5c 81 f0       	mov    %al,0xf0815c04
f010d12b:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d130:	83 e0 f0             	and    $0xfffffff0,%eax
f010d133:	83 c8 0e             	or     $0xe,%eax
f010d136:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d13b:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d140:	83 e0 ef             	and    $0xffffffef,%eax
f010d143:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d148:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d14d:	83 e0 9f             	and    $0xffffff9f,%eax
f010d150:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d155:	a0 05 5c 81 f0       	mov    0xf0815c05,%al
f010d15a:	83 c8 80             	or     $0xffffff80,%eax
f010d15d:	a2 05 5c 81 f0       	mov    %al,0xf0815c05
f010d162:	b8 62 e6 10 f0       	mov    $0xf010e662,%eax
f010d167:	c1 e8 10             	shr    $0x10,%eax
f010d16a:	66 a3 06 5c 81 f0    	mov    %ax,0xf0815c06
	SETGATE(idt[T_PGFLT   ], 0, GD_KT , &PAGE_FAULT, 0) ;		//14
f010d170:	b8 6a e6 10 f0       	mov    $0xf010e66a,%eax
f010d175:	66 a3 30 5c 81 f0    	mov    %ax,0xf0815c30
f010d17b:	66 c7 05 32 5c 81 f0 	movw   $0x8,0xf0815c32
f010d182:	08 00 
f010d184:	a0 34 5c 81 f0       	mov    0xf0815c34,%al
f010d189:	83 e0 e0             	and    $0xffffffe0,%eax
f010d18c:	a2 34 5c 81 f0       	mov    %al,0xf0815c34
f010d191:	a0 34 5c 81 f0       	mov    0xf0815c34,%al
f010d196:	83 e0 1f             	and    $0x1f,%eax
f010d199:	a2 34 5c 81 f0       	mov    %al,0xf0815c34
f010d19e:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d1a3:	83 e0 f0             	and    $0xfffffff0,%eax
f010d1a6:	83 c8 0e             	or     $0xe,%eax
f010d1a9:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d1ae:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d1b3:	83 e0 ef             	and    $0xffffffef,%eax
f010d1b6:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d1bb:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d1c0:	83 e0 9f             	and    $0xffffff9f,%eax
f010d1c3:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d1c8:	a0 35 5c 81 f0       	mov    0xf0815c35,%al
f010d1cd:	83 c8 80             	or     $0xffffff80,%eax
f010d1d0:	a2 35 5c 81 f0       	mov    %al,0xf0815c35
f010d1d5:	b8 6a e6 10 f0       	mov    $0xf010e66a,%eax
f010d1da:	c1 e8 10             	shr    $0x10,%eax
f010d1dd:	66 a3 36 5c 81 f0    	mov    %ax,0xf0815c36
	SETGATE(idt[IRQ0_Clock], 0, GD_KT , &IRQ0_CLK_HANDLER, 3) ;	//32
f010d1e3:	b8 72 e6 10 f0       	mov    $0xf010e672,%eax
f010d1e8:	66 a3 c0 5c 81 f0    	mov    %ax,0xf0815cc0
f010d1ee:	66 c7 05 c2 5c 81 f0 	movw   $0x8,0xf0815cc2
f010d1f5:	08 00 
f010d1f7:	a0 c4 5c 81 f0       	mov    0xf0815cc4,%al
f010d1fc:	83 e0 e0             	and    $0xffffffe0,%eax
f010d1ff:	a2 c4 5c 81 f0       	mov    %al,0xf0815cc4
f010d204:	a0 c4 5c 81 f0       	mov    0xf0815cc4,%al
f010d209:	83 e0 1f             	and    $0x1f,%eax
f010d20c:	a2 c4 5c 81 f0       	mov    %al,0xf0815cc4
f010d211:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d216:	83 e0 f0             	and    $0xfffffff0,%eax
f010d219:	83 c8 0e             	or     $0xe,%eax
f010d21c:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d221:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d226:	83 e0 ef             	and    $0xffffffef,%eax
f010d229:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d22e:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d233:	83 c8 60             	or     $0x60,%eax
f010d236:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d23b:	a0 c5 5c 81 f0       	mov    0xf0815cc5,%al
f010d240:	83 c8 80             	or     $0xffffff80,%eax
f010d243:	a2 c5 5c 81 f0       	mov    %al,0xf0815cc5
f010d248:	b8 72 e6 10 f0       	mov    $0xf010e672,%eax
f010d24d:	c1 e8 10             	shr    $0x10,%eax
f010d250:	66 a3 c6 5c 81 f0    	mov    %ax,0xf0815cc6
	SETGATE(idt[IRQ1_KB	  ], 0, GD_KT , &IRQ1_KBD_HANDLER, 3) ;	//33
f010d256:	b8 7c e6 10 f0       	mov    $0xf010e67c,%eax
f010d25b:	66 a3 c8 5c 81 f0    	mov    %ax,0xf0815cc8
f010d261:	66 c7 05 ca 5c 81 f0 	movw   $0x8,0xf0815cca
f010d268:	08 00 
f010d26a:	a0 cc 5c 81 f0       	mov    0xf0815ccc,%al
f010d26f:	83 e0 e0             	and    $0xffffffe0,%eax
f010d272:	a2 cc 5c 81 f0       	mov    %al,0xf0815ccc
f010d277:	a0 cc 5c 81 f0       	mov    0xf0815ccc,%al
f010d27c:	83 e0 1f             	and    $0x1f,%eax
f010d27f:	a2 cc 5c 81 f0       	mov    %al,0xf0815ccc
f010d284:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d289:	83 e0 f0             	and    $0xfffffff0,%eax
f010d28c:	83 c8 0e             	or     $0xe,%eax
f010d28f:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d294:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d299:	83 e0 ef             	and    $0xffffffef,%eax
f010d29c:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d2a1:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d2a6:	83 c8 60             	or     $0x60,%eax
f010d2a9:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d2ae:	a0 cd 5c 81 f0       	mov    0xf0815ccd,%al
f010d2b3:	83 c8 80             	or     $0xffffff80,%eax
f010d2b6:	a2 cd 5c 81 f0       	mov    %al,0xf0815ccd
f010d2bb:	b8 7c e6 10 f0       	mov    $0xf010e67c,%eax
f010d2c0:	c1 e8 10             	shr    $0x10,%eax
f010d2c3:	66 a3 ce 5c 81 f0    	mov    %ax,0xf0815cce
	SETGATE(idt[T_SYSCALL ], 0, GD_KT , &SYSCALL_HANDLER, 3) ;	//48
f010d2c9:	b8 86 e6 10 f0       	mov    $0xf010e686,%eax
f010d2ce:	66 a3 40 5d 81 f0    	mov    %ax,0xf0815d40
f010d2d4:	66 c7 05 42 5d 81 f0 	movw   $0x8,0xf0815d42
f010d2db:	08 00 
f010d2dd:	a0 44 5d 81 f0       	mov    0xf0815d44,%al
f010d2e2:	83 e0 e0             	and    $0xffffffe0,%eax
f010d2e5:	a2 44 5d 81 f0       	mov    %al,0xf0815d44
f010d2ea:	a0 44 5d 81 f0       	mov    0xf0815d44,%al
f010d2ef:	83 e0 1f             	and    $0x1f,%eax
f010d2f2:	a2 44 5d 81 f0       	mov    %al,0xf0815d44
f010d2f7:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d2fc:	83 e0 f0             	and    $0xfffffff0,%eax
f010d2ff:	83 c8 0e             	or     $0xe,%eax
f010d302:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d307:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d30c:	83 e0 ef             	and    $0xffffffef,%eax
f010d30f:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d314:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d319:	83 c8 60             	or     $0x60,%eax
f010d31c:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d321:	a0 45 5d 81 f0       	mov    0xf0815d45,%al
f010d326:	83 c8 80             	or     $0xffffff80,%eax
f010d329:	a2 45 5d 81 f0       	mov    %al,0xf0815d45
f010d32e:	b8 86 e6 10 f0       	mov    $0xf010e686,%eax
f010d333:	c1 e8 10             	shr    $0x10,%eax
f010d336:	66 a3 46 5d 81 f0    	mov    %ax,0xf0815d46

	//S/W Exceptions
	SETGATE(idt[T_DIVIDE   ], 0, GD_KT , &ALL_FAULTS0, 3) ;
f010d33c:	b8 90 e6 10 f0       	mov    $0xf010e690,%eax
f010d341:	66 a3 c0 5b 81 f0    	mov    %ax,0xf0815bc0
f010d347:	66 c7 05 c2 5b 81 f0 	movw   $0x8,0xf0815bc2
f010d34e:	08 00 
f010d350:	a0 c4 5b 81 f0       	mov    0xf0815bc4,%al
f010d355:	83 e0 e0             	and    $0xffffffe0,%eax
f010d358:	a2 c4 5b 81 f0       	mov    %al,0xf0815bc4
f010d35d:	a0 c4 5b 81 f0       	mov    0xf0815bc4,%al
f010d362:	83 e0 1f             	and    $0x1f,%eax
f010d365:	a2 c4 5b 81 f0       	mov    %al,0xf0815bc4
f010d36a:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d36f:	83 e0 f0             	and    $0xfffffff0,%eax
f010d372:	83 c8 0e             	or     $0xe,%eax
f010d375:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d37a:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d37f:	83 e0 ef             	and    $0xffffffef,%eax
f010d382:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d387:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d38c:	83 c8 60             	or     $0x60,%eax
f010d38f:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d394:	a0 c5 5b 81 f0       	mov    0xf0815bc5,%al
f010d399:	83 c8 80             	or     $0xffffff80,%eax
f010d39c:	a2 c5 5b 81 f0       	mov    %al,0xf0815bc5
f010d3a1:	b8 90 e6 10 f0       	mov    $0xf010e690,%eax
f010d3a6:	c1 e8 10             	shr    $0x10,%eax
f010d3a9:	66 a3 c6 5b 81 f0    	mov    %ax,0xf0815bc6
	SETGATE(idt[T_DEBUG    ], 1, GD_KT , &ALL_FAULTS1, 3) ;
f010d3af:	b8 9a e6 10 f0       	mov    $0xf010e69a,%eax
f010d3b4:	66 a3 c8 5b 81 f0    	mov    %ax,0xf0815bc8
f010d3ba:	66 c7 05 ca 5b 81 f0 	movw   $0x8,0xf0815bca
f010d3c1:	08 00 
f010d3c3:	a0 cc 5b 81 f0       	mov    0xf0815bcc,%al
f010d3c8:	83 e0 e0             	and    $0xffffffe0,%eax
f010d3cb:	a2 cc 5b 81 f0       	mov    %al,0xf0815bcc
f010d3d0:	a0 cc 5b 81 f0       	mov    0xf0815bcc,%al
f010d3d5:	83 e0 1f             	and    $0x1f,%eax
f010d3d8:	a2 cc 5b 81 f0       	mov    %al,0xf0815bcc
f010d3dd:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d3e2:	83 c8 0f             	or     $0xf,%eax
f010d3e5:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d3ea:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d3ef:	83 e0 ef             	and    $0xffffffef,%eax
f010d3f2:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d3f7:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d3fc:	83 c8 60             	or     $0x60,%eax
f010d3ff:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d404:	a0 cd 5b 81 f0       	mov    0xf0815bcd,%al
f010d409:	83 c8 80             	or     $0xffffff80,%eax
f010d40c:	a2 cd 5b 81 f0       	mov    %al,0xf0815bcd
f010d411:	b8 9a e6 10 f0       	mov    $0xf010e69a,%eax
f010d416:	c1 e8 10             	shr    $0x10,%eax
f010d419:	66 a3 ce 5b 81 f0    	mov    %ax,0xf0815bce
	SETGATE(idt[T_NMI      ], 0, GD_KT , &ALL_FAULTS2, 3) ;
f010d41f:	b8 a4 e6 10 f0       	mov    $0xf010e6a4,%eax
f010d424:	66 a3 d0 5b 81 f0    	mov    %ax,0xf0815bd0
f010d42a:	66 c7 05 d2 5b 81 f0 	movw   $0x8,0xf0815bd2
f010d431:	08 00 
f010d433:	a0 d4 5b 81 f0       	mov    0xf0815bd4,%al
f010d438:	83 e0 e0             	and    $0xffffffe0,%eax
f010d43b:	a2 d4 5b 81 f0       	mov    %al,0xf0815bd4
f010d440:	a0 d4 5b 81 f0       	mov    0xf0815bd4,%al
f010d445:	83 e0 1f             	and    $0x1f,%eax
f010d448:	a2 d4 5b 81 f0       	mov    %al,0xf0815bd4
f010d44d:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d452:	83 e0 f0             	and    $0xfffffff0,%eax
f010d455:	83 c8 0e             	or     $0xe,%eax
f010d458:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d45d:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d462:	83 e0 ef             	and    $0xffffffef,%eax
f010d465:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d46a:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d46f:	83 c8 60             	or     $0x60,%eax
f010d472:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d477:	a0 d5 5b 81 f0       	mov    0xf0815bd5,%al
f010d47c:	83 c8 80             	or     $0xffffff80,%eax
f010d47f:	a2 d5 5b 81 f0       	mov    %al,0xf0815bd5
f010d484:	b8 a4 e6 10 f0       	mov    $0xf010e6a4,%eax
f010d489:	c1 e8 10             	shr    $0x10,%eax
f010d48c:	66 a3 d6 5b 81 f0    	mov    %ax,0xf0815bd6
	SETGATE(idt[T_BRKPT    ], 1, GD_KT , &ALL_FAULTS3, 3) ;
f010d492:	b8 ae e6 10 f0       	mov    $0xf010e6ae,%eax
f010d497:	66 a3 d8 5b 81 f0    	mov    %ax,0xf0815bd8
f010d49d:	66 c7 05 da 5b 81 f0 	movw   $0x8,0xf0815bda
f010d4a4:	08 00 
f010d4a6:	a0 dc 5b 81 f0       	mov    0xf0815bdc,%al
f010d4ab:	83 e0 e0             	and    $0xffffffe0,%eax
f010d4ae:	a2 dc 5b 81 f0       	mov    %al,0xf0815bdc
f010d4b3:	a0 dc 5b 81 f0       	mov    0xf0815bdc,%al
f010d4b8:	83 e0 1f             	and    $0x1f,%eax
f010d4bb:	a2 dc 5b 81 f0       	mov    %al,0xf0815bdc
f010d4c0:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d4c5:	83 c8 0f             	or     $0xf,%eax
f010d4c8:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d4cd:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d4d2:	83 e0 ef             	and    $0xffffffef,%eax
f010d4d5:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d4da:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d4df:	83 c8 60             	or     $0x60,%eax
f010d4e2:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d4e7:	a0 dd 5b 81 f0       	mov    0xf0815bdd,%al
f010d4ec:	83 c8 80             	or     $0xffffff80,%eax
f010d4ef:	a2 dd 5b 81 f0       	mov    %al,0xf0815bdd
f010d4f4:	b8 ae e6 10 f0       	mov    $0xf010e6ae,%eax
f010d4f9:	c1 e8 10             	shr    $0x10,%eax
f010d4fc:	66 a3 de 5b 81 f0    	mov    %ax,0xf0815bde
	SETGATE(idt[T_OFLOW    ], 1, GD_KT , &ALL_FAULTS4, 3) ;
f010d502:	b8 b8 e6 10 f0       	mov    $0xf010e6b8,%eax
f010d507:	66 a3 e0 5b 81 f0    	mov    %ax,0xf0815be0
f010d50d:	66 c7 05 e2 5b 81 f0 	movw   $0x8,0xf0815be2
f010d514:	08 00 
f010d516:	a0 e4 5b 81 f0       	mov    0xf0815be4,%al
f010d51b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d51e:	a2 e4 5b 81 f0       	mov    %al,0xf0815be4
f010d523:	a0 e4 5b 81 f0       	mov    0xf0815be4,%al
f010d528:	83 e0 1f             	and    $0x1f,%eax
f010d52b:	a2 e4 5b 81 f0       	mov    %al,0xf0815be4
f010d530:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d535:	83 c8 0f             	or     $0xf,%eax
f010d538:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d53d:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d542:	83 e0 ef             	and    $0xffffffef,%eax
f010d545:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d54a:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d54f:	83 c8 60             	or     $0x60,%eax
f010d552:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d557:	a0 e5 5b 81 f0       	mov    0xf0815be5,%al
f010d55c:	83 c8 80             	or     $0xffffff80,%eax
f010d55f:	a2 e5 5b 81 f0       	mov    %al,0xf0815be5
f010d564:	b8 b8 e6 10 f0       	mov    $0xf010e6b8,%eax
f010d569:	c1 e8 10             	shr    $0x10,%eax
f010d56c:	66 a3 e6 5b 81 f0    	mov    %ax,0xf0815be6
	SETGATE(idt[T_BOUND    ], 0, GD_KT , &ALL_FAULTS5, 3) ;
f010d572:	b8 c2 e6 10 f0       	mov    $0xf010e6c2,%eax
f010d577:	66 a3 e8 5b 81 f0    	mov    %ax,0xf0815be8
f010d57d:	66 c7 05 ea 5b 81 f0 	movw   $0x8,0xf0815bea
f010d584:	08 00 
f010d586:	a0 ec 5b 81 f0       	mov    0xf0815bec,%al
f010d58b:	83 e0 e0             	and    $0xffffffe0,%eax
f010d58e:	a2 ec 5b 81 f0       	mov    %al,0xf0815bec
f010d593:	a0 ec 5b 81 f0       	mov    0xf0815bec,%al
f010d598:	83 e0 1f             	and    $0x1f,%eax
f010d59b:	a2 ec 5b 81 f0       	mov    %al,0xf0815bec
f010d5a0:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d5a5:	83 e0 f0             	and    $0xfffffff0,%eax
f010d5a8:	83 c8 0e             	or     $0xe,%eax
f010d5ab:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d5b0:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d5b5:	83 e0 ef             	and    $0xffffffef,%eax
f010d5b8:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d5bd:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d5c2:	83 c8 60             	or     $0x60,%eax
f010d5c5:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d5ca:	a0 ed 5b 81 f0       	mov    0xf0815bed,%al
f010d5cf:	83 c8 80             	or     $0xffffff80,%eax
f010d5d2:	a2 ed 5b 81 f0       	mov    %al,0xf0815bed
f010d5d7:	b8 c2 e6 10 f0       	mov    $0xf010e6c2,%eax
f010d5dc:	c1 e8 10             	shr    $0x10,%eax
f010d5df:	66 a3 ee 5b 81 f0    	mov    %ax,0xf0815bee
	SETGATE(idt[T_ILLOP    ], 0, GD_KT , &ALL_FAULTS6, 3) ;
f010d5e5:	b8 cc e6 10 f0       	mov    $0xf010e6cc,%eax
f010d5ea:	66 a3 f0 5b 81 f0    	mov    %ax,0xf0815bf0
f010d5f0:	66 c7 05 f2 5b 81 f0 	movw   $0x8,0xf0815bf2
f010d5f7:	08 00 
f010d5f9:	a0 f4 5b 81 f0       	mov    0xf0815bf4,%al
f010d5fe:	83 e0 e0             	and    $0xffffffe0,%eax
f010d601:	a2 f4 5b 81 f0       	mov    %al,0xf0815bf4
f010d606:	a0 f4 5b 81 f0       	mov    0xf0815bf4,%al
f010d60b:	83 e0 1f             	and    $0x1f,%eax
f010d60e:	a2 f4 5b 81 f0       	mov    %al,0xf0815bf4
f010d613:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d618:	83 e0 f0             	and    $0xfffffff0,%eax
f010d61b:	83 c8 0e             	or     $0xe,%eax
f010d61e:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d623:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d628:	83 e0 ef             	and    $0xffffffef,%eax
f010d62b:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d630:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d635:	83 c8 60             	or     $0x60,%eax
f010d638:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d63d:	a0 f5 5b 81 f0       	mov    0xf0815bf5,%al
f010d642:	83 c8 80             	or     $0xffffff80,%eax
f010d645:	a2 f5 5b 81 f0       	mov    %al,0xf0815bf5
f010d64a:	b8 cc e6 10 f0       	mov    $0xf010e6cc,%eax
f010d64f:	c1 e8 10             	shr    $0x10,%eax
f010d652:	66 a3 f6 5b 81 f0    	mov    %ax,0xf0815bf6
	SETGATE(idt[T_DEVICE   ], 0, GD_KT , &ALL_FAULTS7, 3) ;
f010d658:	b8 d6 e6 10 f0       	mov    $0xf010e6d6,%eax
f010d65d:	66 a3 f8 5b 81 f0    	mov    %ax,0xf0815bf8
f010d663:	66 c7 05 fa 5b 81 f0 	movw   $0x8,0xf0815bfa
f010d66a:	08 00 
f010d66c:	a0 fc 5b 81 f0       	mov    0xf0815bfc,%al
f010d671:	83 e0 e0             	and    $0xffffffe0,%eax
f010d674:	a2 fc 5b 81 f0       	mov    %al,0xf0815bfc
f010d679:	a0 fc 5b 81 f0       	mov    0xf0815bfc,%al
f010d67e:	83 e0 1f             	and    $0x1f,%eax
f010d681:	a2 fc 5b 81 f0       	mov    %al,0xf0815bfc
f010d686:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d68b:	83 e0 f0             	and    $0xfffffff0,%eax
f010d68e:	83 c8 0e             	or     $0xe,%eax
f010d691:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d696:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d69b:	83 e0 ef             	and    $0xffffffef,%eax
f010d69e:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d6a3:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d6a8:	83 c8 60             	or     $0x60,%eax
f010d6ab:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d6b0:	a0 fd 5b 81 f0       	mov    0xf0815bfd,%al
f010d6b5:	83 c8 80             	or     $0xffffff80,%eax
f010d6b8:	a2 fd 5b 81 f0       	mov    %al,0xf0815bfd
f010d6bd:	b8 d6 e6 10 f0       	mov    $0xf010e6d6,%eax
f010d6c2:	c1 e8 10             	shr    $0x10,%eax
f010d6c5:	66 a3 fe 5b 81 f0    	mov    %ax,0xf0815bfe
	//SETGATE(idt[T_DBLFLT ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_TSS      ], 0, GD_KT , &ALL_FAULTS10, 3) ;
f010d6cb:	b8 dc e6 10 f0       	mov    $0xf010e6dc,%eax
f010d6d0:	66 a3 10 5c 81 f0    	mov    %ax,0xf0815c10
f010d6d6:	66 c7 05 12 5c 81 f0 	movw   $0x8,0xf0815c12
f010d6dd:	08 00 
f010d6df:	a0 14 5c 81 f0       	mov    0xf0815c14,%al
f010d6e4:	83 e0 e0             	and    $0xffffffe0,%eax
f010d6e7:	a2 14 5c 81 f0       	mov    %al,0xf0815c14
f010d6ec:	a0 14 5c 81 f0       	mov    0xf0815c14,%al
f010d6f1:	83 e0 1f             	and    $0x1f,%eax
f010d6f4:	a2 14 5c 81 f0       	mov    %al,0xf0815c14
f010d6f9:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d6fe:	83 e0 f0             	and    $0xfffffff0,%eax
f010d701:	83 c8 0e             	or     $0xe,%eax
f010d704:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d709:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d70e:	83 e0 ef             	and    $0xffffffef,%eax
f010d711:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d716:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d71b:	83 c8 60             	or     $0x60,%eax
f010d71e:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d723:	a0 15 5c 81 f0       	mov    0xf0815c15,%al
f010d728:	83 c8 80             	or     $0xffffff80,%eax
f010d72b:	a2 15 5c 81 f0       	mov    %al,0xf0815c15
f010d730:	b8 dc e6 10 f0       	mov    $0xf010e6dc,%eax
f010d735:	c1 e8 10             	shr    $0x10,%eax
f010d738:	66 a3 16 5c 81 f0    	mov    %ax,0xf0815c16
	SETGATE(idt[T_SEGNP    ], 0, GD_KT , &ALL_FAULTS11, 3) ;
f010d73e:	b8 e0 e6 10 f0       	mov    $0xf010e6e0,%eax
f010d743:	66 a3 18 5c 81 f0    	mov    %ax,0xf0815c18
f010d749:	66 c7 05 1a 5c 81 f0 	movw   $0x8,0xf0815c1a
f010d750:	08 00 
f010d752:	a0 1c 5c 81 f0       	mov    0xf0815c1c,%al
f010d757:	83 e0 e0             	and    $0xffffffe0,%eax
f010d75a:	a2 1c 5c 81 f0       	mov    %al,0xf0815c1c
f010d75f:	a0 1c 5c 81 f0       	mov    0xf0815c1c,%al
f010d764:	83 e0 1f             	and    $0x1f,%eax
f010d767:	a2 1c 5c 81 f0       	mov    %al,0xf0815c1c
f010d76c:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d771:	83 e0 f0             	and    $0xfffffff0,%eax
f010d774:	83 c8 0e             	or     $0xe,%eax
f010d777:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d77c:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d781:	83 e0 ef             	and    $0xffffffef,%eax
f010d784:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d789:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d78e:	83 c8 60             	or     $0x60,%eax
f010d791:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d796:	a0 1d 5c 81 f0       	mov    0xf0815c1d,%al
f010d79b:	83 c8 80             	or     $0xffffff80,%eax
f010d79e:	a2 1d 5c 81 f0       	mov    %al,0xf0815c1d
f010d7a3:	b8 e0 e6 10 f0       	mov    $0xf010e6e0,%eax
f010d7a8:	c1 e8 10             	shr    $0x10,%eax
f010d7ab:	66 a3 1e 5c 81 f0    	mov    %ax,0xf0815c1e
	SETGATE(idt[T_STACK    ], 0, GD_KT , &ALL_FAULTS12, 3) ;
f010d7b1:	b8 e4 e6 10 f0       	mov    $0xf010e6e4,%eax
f010d7b6:	66 a3 20 5c 81 f0    	mov    %ax,0xf0815c20
f010d7bc:	66 c7 05 22 5c 81 f0 	movw   $0x8,0xf0815c22
f010d7c3:	08 00 
f010d7c5:	a0 24 5c 81 f0       	mov    0xf0815c24,%al
f010d7ca:	83 e0 e0             	and    $0xffffffe0,%eax
f010d7cd:	a2 24 5c 81 f0       	mov    %al,0xf0815c24
f010d7d2:	a0 24 5c 81 f0       	mov    0xf0815c24,%al
f010d7d7:	83 e0 1f             	and    $0x1f,%eax
f010d7da:	a2 24 5c 81 f0       	mov    %al,0xf0815c24
f010d7df:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d7e4:	83 e0 f0             	and    $0xfffffff0,%eax
f010d7e7:	83 c8 0e             	or     $0xe,%eax
f010d7ea:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d7ef:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d7f4:	83 e0 ef             	and    $0xffffffef,%eax
f010d7f7:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d7fc:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d801:	83 c8 60             	or     $0x60,%eax
f010d804:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d809:	a0 25 5c 81 f0       	mov    0xf0815c25,%al
f010d80e:	83 c8 80             	or     $0xffffff80,%eax
f010d811:	a2 25 5c 81 f0       	mov    %al,0xf0815c25
f010d816:	b8 e4 e6 10 f0       	mov    $0xf010e6e4,%eax
f010d81b:	c1 e8 10             	shr    $0x10,%eax
f010d81e:	66 a3 26 5c 81 f0    	mov    %ax,0xf0815c26
	SETGATE(idt[T_GPFLT    ], 0, GD_KT , &ALL_FAULTS13, 3) ;
f010d824:	b8 e8 e6 10 f0       	mov    $0xf010e6e8,%eax
f010d829:	66 a3 28 5c 81 f0    	mov    %ax,0xf0815c28
f010d82f:	66 c7 05 2a 5c 81 f0 	movw   $0x8,0xf0815c2a
f010d836:	08 00 
f010d838:	a0 2c 5c 81 f0       	mov    0xf0815c2c,%al
f010d83d:	83 e0 e0             	and    $0xffffffe0,%eax
f010d840:	a2 2c 5c 81 f0       	mov    %al,0xf0815c2c
f010d845:	a0 2c 5c 81 f0       	mov    0xf0815c2c,%al
f010d84a:	83 e0 1f             	and    $0x1f,%eax
f010d84d:	a2 2c 5c 81 f0       	mov    %al,0xf0815c2c
f010d852:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d857:	83 e0 f0             	and    $0xfffffff0,%eax
f010d85a:	83 c8 0e             	or     $0xe,%eax
f010d85d:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d862:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d867:	83 e0 ef             	and    $0xffffffef,%eax
f010d86a:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d86f:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d874:	83 c8 60             	or     $0x60,%eax
f010d877:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d87c:	a0 2d 5c 81 f0       	mov    0xf0815c2d,%al
f010d881:	83 c8 80             	or     $0xffffff80,%eax
f010d884:	a2 2d 5c 81 f0       	mov    %al,0xf0815c2d
f010d889:	b8 e8 e6 10 f0       	mov    $0xf010e6e8,%eax
f010d88e:	c1 e8 10             	shr    $0x10,%eax
f010d891:	66 a3 2e 5c 81 f0    	mov    %ax,0xf0815c2e
	//SETGATE(idt[T_PGFLT    ], 0, GD_KT , &ALL_FAULTS, 3) ;
	//SETGATE(idt[ne T_RES   ], 0, GD_KT , &ALL_FAULTS, 3) ;
	SETGATE(idt[T_FPERR    ], 0, GD_KT , &ALL_FAULTS16, 3) ;
f010d897:	b8 ec e6 10 f0       	mov    $0xf010e6ec,%eax
f010d89c:	66 a3 40 5c 81 f0    	mov    %ax,0xf0815c40
f010d8a2:	66 c7 05 42 5c 81 f0 	movw   $0x8,0xf0815c42
f010d8a9:	08 00 
f010d8ab:	a0 44 5c 81 f0       	mov    0xf0815c44,%al
f010d8b0:	83 e0 e0             	and    $0xffffffe0,%eax
f010d8b3:	a2 44 5c 81 f0       	mov    %al,0xf0815c44
f010d8b8:	a0 44 5c 81 f0       	mov    0xf0815c44,%al
f010d8bd:	83 e0 1f             	and    $0x1f,%eax
f010d8c0:	a2 44 5c 81 f0       	mov    %al,0xf0815c44
f010d8c5:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d8ca:	83 e0 f0             	and    $0xfffffff0,%eax
f010d8cd:	83 c8 0e             	or     $0xe,%eax
f010d8d0:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d8d5:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d8da:	83 e0 ef             	and    $0xffffffef,%eax
f010d8dd:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d8e2:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d8e7:	83 c8 60             	or     $0x60,%eax
f010d8ea:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d8ef:	a0 45 5c 81 f0       	mov    0xf0815c45,%al
f010d8f4:	83 c8 80             	or     $0xffffff80,%eax
f010d8f7:	a2 45 5c 81 f0       	mov    %al,0xf0815c45
f010d8fc:	b8 ec e6 10 f0       	mov    $0xf010e6ec,%eax
f010d901:	c1 e8 10             	shr    $0x10,%eax
f010d904:	66 a3 46 5c 81 f0    	mov    %ax,0xf0815c46
	SETGATE(idt[T_ALIGN    ], 0, GD_KT , &ALL_FAULTS17, 3) ;
f010d90a:	b8 f2 e6 10 f0       	mov    $0xf010e6f2,%eax
f010d90f:	66 a3 48 5c 81 f0    	mov    %ax,0xf0815c48
f010d915:	66 c7 05 4a 5c 81 f0 	movw   $0x8,0xf0815c4a
f010d91c:	08 00 
f010d91e:	a0 4c 5c 81 f0       	mov    0xf0815c4c,%al
f010d923:	83 e0 e0             	and    $0xffffffe0,%eax
f010d926:	a2 4c 5c 81 f0       	mov    %al,0xf0815c4c
f010d92b:	a0 4c 5c 81 f0       	mov    0xf0815c4c,%al
f010d930:	83 e0 1f             	and    $0x1f,%eax
f010d933:	a2 4c 5c 81 f0       	mov    %al,0xf0815c4c
f010d938:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d93d:	83 e0 f0             	and    $0xfffffff0,%eax
f010d940:	83 c8 0e             	or     $0xe,%eax
f010d943:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d948:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d94d:	83 e0 ef             	and    $0xffffffef,%eax
f010d950:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d955:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d95a:	83 c8 60             	or     $0x60,%eax
f010d95d:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d962:	a0 4d 5c 81 f0       	mov    0xf0815c4d,%al
f010d967:	83 c8 80             	or     $0xffffff80,%eax
f010d96a:	a2 4d 5c 81 f0       	mov    %al,0xf0815c4d
f010d96f:	b8 f2 e6 10 f0       	mov    $0xf010e6f2,%eax
f010d974:	c1 e8 10             	shr    $0x10,%eax
f010d977:	66 a3 4e 5c 81 f0    	mov    %ax,0xf0815c4e
	SETGATE(idt[T_MCHK     ], 0, GD_KT , &ALL_FAULTS18, 3) ;
f010d97d:	b8 f6 e6 10 f0       	mov    $0xf010e6f6,%eax
f010d982:	66 a3 50 5c 81 f0    	mov    %ax,0xf0815c50
f010d988:	66 c7 05 52 5c 81 f0 	movw   $0x8,0xf0815c52
f010d98f:	08 00 
f010d991:	a0 54 5c 81 f0       	mov    0xf0815c54,%al
f010d996:	83 e0 e0             	and    $0xffffffe0,%eax
f010d999:	a2 54 5c 81 f0       	mov    %al,0xf0815c54
f010d99e:	a0 54 5c 81 f0       	mov    0xf0815c54,%al
f010d9a3:	83 e0 1f             	and    $0x1f,%eax
f010d9a6:	a2 54 5c 81 f0       	mov    %al,0xf0815c54
f010d9ab:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d9b0:	83 e0 f0             	and    $0xfffffff0,%eax
f010d9b3:	83 c8 0e             	or     $0xe,%eax
f010d9b6:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d9bb:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d9c0:	83 e0 ef             	and    $0xffffffef,%eax
f010d9c3:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d9c8:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d9cd:	83 c8 60             	or     $0x60,%eax
f010d9d0:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d9d5:	a0 55 5c 81 f0       	mov    0xf0815c55,%al
f010d9da:	83 c8 80             	or     $0xffffff80,%eax
f010d9dd:	a2 55 5c 81 f0       	mov    %al,0xf0815c55
f010d9e2:	b8 f6 e6 10 f0       	mov    $0xf010e6f6,%eax
f010d9e7:	c1 e8 10             	shr    $0x10,%eax
f010d9ea:	66 a3 56 5c 81 f0    	mov    %ax,0xf0815c56
	SETGATE(idt[T_SIMDERR  ], 0, GD_KT , &ALL_FAULTS19, 3) ;
f010d9f0:	b8 fc e6 10 f0       	mov    $0xf010e6fc,%eax
f010d9f5:	66 a3 58 5c 81 f0    	mov    %ax,0xf0815c58
f010d9fb:	66 c7 05 5a 5c 81 f0 	movw   $0x8,0xf0815c5a
f010da02:	08 00 
f010da04:	a0 5c 5c 81 f0       	mov    0xf0815c5c,%al
f010da09:	83 e0 e0             	and    $0xffffffe0,%eax
f010da0c:	a2 5c 5c 81 f0       	mov    %al,0xf0815c5c
f010da11:	a0 5c 5c 81 f0       	mov    0xf0815c5c,%al
f010da16:	83 e0 1f             	and    $0x1f,%eax
f010da19:	a2 5c 5c 81 f0       	mov    %al,0xf0815c5c
f010da1e:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010da23:	83 e0 f0             	and    $0xfffffff0,%eax
f010da26:	83 c8 0e             	or     $0xe,%eax
f010da29:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010da2e:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010da33:	83 e0 ef             	and    $0xffffffef,%eax
f010da36:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010da3b:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010da40:	83 c8 60             	or     $0x60,%eax
f010da43:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010da48:	a0 5d 5c 81 f0       	mov    0xf0815c5d,%al
f010da4d:	83 c8 80             	or     $0xffffff80,%eax
f010da50:	a2 5d 5c 81 f0       	mov    %al,0xf0815c5d
f010da55:	b8 fc e6 10 f0       	mov    $0xf010e6fc,%eax
f010da5a:	c1 e8 10             	shr    $0x10,%eax
f010da5d:	66 a3 5e 5c 81 f0    	mov    %ax,0xf0815c5e

	//IRQs
	SETGATE(idt[34], 0, GD_KT , &ALL_FAULTS34, 3) ;
f010da63:	b8 02 e7 10 f0       	mov    $0xf010e702,%eax
f010da68:	66 a3 d0 5c 81 f0    	mov    %ax,0xf0815cd0
f010da6e:	66 c7 05 d2 5c 81 f0 	movw   $0x8,0xf0815cd2
f010da75:	08 00 
f010da77:	a0 d4 5c 81 f0       	mov    0xf0815cd4,%al
f010da7c:	83 e0 e0             	and    $0xffffffe0,%eax
f010da7f:	a2 d4 5c 81 f0       	mov    %al,0xf0815cd4
f010da84:	a0 d4 5c 81 f0       	mov    0xf0815cd4,%al
f010da89:	83 e0 1f             	and    $0x1f,%eax
f010da8c:	a2 d4 5c 81 f0       	mov    %al,0xf0815cd4
f010da91:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010da96:	83 e0 f0             	and    $0xfffffff0,%eax
f010da99:	83 c8 0e             	or     $0xe,%eax
f010da9c:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010daa1:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010daa6:	83 e0 ef             	and    $0xffffffef,%eax
f010daa9:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010daae:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010dab3:	83 c8 60             	or     $0x60,%eax
f010dab6:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010dabb:	a0 d5 5c 81 f0       	mov    0xf0815cd5,%al
f010dac0:	83 c8 80             	or     $0xffffff80,%eax
f010dac3:	a2 d5 5c 81 f0       	mov    %al,0xf0815cd5
f010dac8:	b8 02 e7 10 f0       	mov    $0xf010e702,%eax
f010dacd:	c1 e8 10             	shr    $0x10,%eax
f010dad0:	66 a3 d6 5c 81 f0    	mov    %ax,0xf0815cd6
	SETGATE(idt[35], 0, GD_KT , &ALL_FAULTS35, 3) ;
f010dad6:	b8 08 e7 10 f0       	mov    $0xf010e708,%eax
f010dadb:	66 a3 d8 5c 81 f0    	mov    %ax,0xf0815cd8
f010dae1:	66 c7 05 da 5c 81 f0 	movw   $0x8,0xf0815cda
f010dae8:	08 00 
f010daea:	a0 dc 5c 81 f0       	mov    0xf0815cdc,%al
f010daef:	83 e0 e0             	and    $0xffffffe0,%eax
f010daf2:	a2 dc 5c 81 f0       	mov    %al,0xf0815cdc
f010daf7:	a0 dc 5c 81 f0       	mov    0xf0815cdc,%al
f010dafc:	83 e0 1f             	and    $0x1f,%eax
f010daff:	a2 dc 5c 81 f0       	mov    %al,0xf0815cdc
f010db04:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010db09:	83 e0 f0             	and    $0xfffffff0,%eax
f010db0c:	83 c8 0e             	or     $0xe,%eax
f010db0f:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010db14:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010db19:	83 e0 ef             	and    $0xffffffef,%eax
f010db1c:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010db21:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010db26:	83 c8 60             	or     $0x60,%eax
f010db29:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010db2e:	a0 dd 5c 81 f0       	mov    0xf0815cdd,%al
f010db33:	83 c8 80             	or     $0xffffff80,%eax
f010db36:	a2 dd 5c 81 f0       	mov    %al,0xf0815cdd
f010db3b:	b8 08 e7 10 f0       	mov    $0xf010e708,%eax
f010db40:	c1 e8 10             	shr    $0x10,%eax
f010db43:	66 a3 de 5c 81 f0    	mov    %ax,0xf0815cde
	SETGATE(idt[36], 0, GD_KT , &ALL_FAULTS36, 3) ;
f010db49:	b8 0e e7 10 f0       	mov    $0xf010e70e,%eax
f010db4e:	66 a3 e0 5c 81 f0    	mov    %ax,0xf0815ce0
f010db54:	66 c7 05 e2 5c 81 f0 	movw   $0x8,0xf0815ce2
f010db5b:	08 00 
f010db5d:	a0 e4 5c 81 f0       	mov    0xf0815ce4,%al
f010db62:	83 e0 e0             	and    $0xffffffe0,%eax
f010db65:	a2 e4 5c 81 f0       	mov    %al,0xf0815ce4
f010db6a:	a0 e4 5c 81 f0       	mov    0xf0815ce4,%al
f010db6f:	83 e0 1f             	and    $0x1f,%eax
f010db72:	a2 e4 5c 81 f0       	mov    %al,0xf0815ce4
f010db77:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010db7c:	83 e0 f0             	and    $0xfffffff0,%eax
f010db7f:	83 c8 0e             	or     $0xe,%eax
f010db82:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010db87:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010db8c:	83 e0 ef             	and    $0xffffffef,%eax
f010db8f:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010db94:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010db99:	83 c8 60             	or     $0x60,%eax
f010db9c:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010dba1:	a0 e5 5c 81 f0       	mov    0xf0815ce5,%al
f010dba6:	83 c8 80             	or     $0xffffff80,%eax
f010dba9:	a2 e5 5c 81 f0       	mov    %al,0xf0815ce5
f010dbae:	b8 0e e7 10 f0       	mov    $0xf010e70e,%eax
f010dbb3:	c1 e8 10             	shr    $0x10,%eax
f010dbb6:	66 a3 e6 5c 81 f0    	mov    %ax,0xf0815ce6
	SETGATE(idt[37], 0, GD_KT , &ALL_FAULTS37, 3) ;
f010dbbc:	b8 14 e7 10 f0       	mov    $0xf010e714,%eax
f010dbc1:	66 a3 e8 5c 81 f0    	mov    %ax,0xf0815ce8
f010dbc7:	66 c7 05 ea 5c 81 f0 	movw   $0x8,0xf0815cea
f010dbce:	08 00 
f010dbd0:	a0 ec 5c 81 f0       	mov    0xf0815cec,%al
f010dbd5:	83 e0 e0             	and    $0xffffffe0,%eax
f010dbd8:	a2 ec 5c 81 f0       	mov    %al,0xf0815cec
f010dbdd:	a0 ec 5c 81 f0       	mov    0xf0815cec,%al
f010dbe2:	83 e0 1f             	and    $0x1f,%eax
f010dbe5:	a2 ec 5c 81 f0       	mov    %al,0xf0815cec
f010dbea:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010dbef:	83 e0 f0             	and    $0xfffffff0,%eax
f010dbf2:	83 c8 0e             	or     $0xe,%eax
f010dbf5:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010dbfa:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010dbff:	83 e0 ef             	and    $0xffffffef,%eax
f010dc02:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010dc07:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010dc0c:	83 c8 60             	or     $0x60,%eax
f010dc0f:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010dc14:	a0 ed 5c 81 f0       	mov    0xf0815ced,%al
f010dc19:	83 c8 80             	or     $0xffffff80,%eax
f010dc1c:	a2 ed 5c 81 f0       	mov    %al,0xf0815ced
f010dc21:	b8 14 e7 10 f0       	mov    $0xf010e714,%eax
f010dc26:	c1 e8 10             	shr    $0x10,%eax
f010dc29:	66 a3 ee 5c 81 f0    	mov    %ax,0xf0815cee
	SETGATE(idt[38], 0, GD_KT , &ALL_FAULTS38, 3) ;
f010dc2f:	b8 1a e7 10 f0       	mov    $0xf010e71a,%eax
f010dc34:	66 a3 f0 5c 81 f0    	mov    %ax,0xf0815cf0
f010dc3a:	66 c7 05 f2 5c 81 f0 	movw   $0x8,0xf0815cf2
f010dc41:	08 00 
f010dc43:	a0 f4 5c 81 f0       	mov    0xf0815cf4,%al
f010dc48:	83 e0 e0             	and    $0xffffffe0,%eax
f010dc4b:	a2 f4 5c 81 f0       	mov    %al,0xf0815cf4
f010dc50:	a0 f4 5c 81 f0       	mov    0xf0815cf4,%al
f010dc55:	83 e0 1f             	and    $0x1f,%eax
f010dc58:	a2 f4 5c 81 f0       	mov    %al,0xf0815cf4
f010dc5d:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010dc62:	83 e0 f0             	and    $0xfffffff0,%eax
f010dc65:	83 c8 0e             	or     $0xe,%eax
f010dc68:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010dc6d:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010dc72:	83 e0 ef             	and    $0xffffffef,%eax
f010dc75:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010dc7a:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010dc7f:	83 c8 60             	or     $0x60,%eax
f010dc82:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010dc87:	a0 f5 5c 81 f0       	mov    0xf0815cf5,%al
f010dc8c:	83 c8 80             	or     $0xffffff80,%eax
f010dc8f:	a2 f5 5c 81 f0       	mov    %al,0xf0815cf5
f010dc94:	b8 1a e7 10 f0       	mov    $0xf010e71a,%eax
f010dc99:	c1 e8 10             	shr    $0x10,%eax
f010dc9c:	66 a3 f6 5c 81 f0    	mov    %ax,0xf0815cf6
	SETGATE(idt[39], 0, GD_KT , &ALL_FAULTS39, 3) ;
f010dca2:	b8 20 e7 10 f0       	mov    $0xf010e720,%eax
f010dca7:	66 a3 f8 5c 81 f0    	mov    %ax,0xf0815cf8
f010dcad:	66 c7 05 fa 5c 81 f0 	movw   $0x8,0xf0815cfa
f010dcb4:	08 00 
f010dcb6:	a0 fc 5c 81 f0       	mov    0xf0815cfc,%al
f010dcbb:	83 e0 e0             	and    $0xffffffe0,%eax
f010dcbe:	a2 fc 5c 81 f0       	mov    %al,0xf0815cfc
f010dcc3:	a0 fc 5c 81 f0       	mov    0xf0815cfc,%al
f010dcc8:	83 e0 1f             	and    $0x1f,%eax
f010dccb:	a2 fc 5c 81 f0       	mov    %al,0xf0815cfc
f010dcd0:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dcd5:	83 e0 f0             	and    $0xfffffff0,%eax
f010dcd8:	83 c8 0e             	or     $0xe,%eax
f010dcdb:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dce0:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dce5:	83 e0 ef             	and    $0xffffffef,%eax
f010dce8:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dced:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dcf2:	83 c8 60             	or     $0x60,%eax
f010dcf5:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dcfa:	a0 fd 5c 81 f0       	mov    0xf0815cfd,%al
f010dcff:	83 c8 80             	or     $0xffffff80,%eax
f010dd02:	a2 fd 5c 81 f0       	mov    %al,0xf0815cfd
f010dd07:	b8 20 e7 10 f0       	mov    $0xf010e720,%eax
f010dd0c:	c1 e8 10             	shr    $0x10,%eax
f010dd0f:	66 a3 fe 5c 81 f0    	mov    %ax,0xf0815cfe
	SETGATE(idt[40], 0, GD_KT , &ALL_FAULTS40, 3) ;
f010dd15:	b8 26 e7 10 f0       	mov    $0xf010e726,%eax
f010dd1a:	66 a3 00 5d 81 f0    	mov    %ax,0xf0815d00
f010dd20:	66 c7 05 02 5d 81 f0 	movw   $0x8,0xf0815d02
f010dd27:	08 00 
f010dd29:	a0 04 5d 81 f0       	mov    0xf0815d04,%al
f010dd2e:	83 e0 e0             	and    $0xffffffe0,%eax
f010dd31:	a2 04 5d 81 f0       	mov    %al,0xf0815d04
f010dd36:	a0 04 5d 81 f0       	mov    0xf0815d04,%al
f010dd3b:	83 e0 1f             	and    $0x1f,%eax
f010dd3e:	a2 04 5d 81 f0       	mov    %al,0xf0815d04
f010dd43:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dd48:	83 e0 f0             	and    $0xfffffff0,%eax
f010dd4b:	83 c8 0e             	or     $0xe,%eax
f010dd4e:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dd53:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dd58:	83 e0 ef             	and    $0xffffffef,%eax
f010dd5b:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dd60:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dd65:	83 c8 60             	or     $0x60,%eax
f010dd68:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dd6d:	a0 05 5d 81 f0       	mov    0xf0815d05,%al
f010dd72:	83 c8 80             	or     $0xffffff80,%eax
f010dd75:	a2 05 5d 81 f0       	mov    %al,0xf0815d05
f010dd7a:	b8 26 e7 10 f0       	mov    $0xf010e726,%eax
f010dd7f:	c1 e8 10             	shr    $0x10,%eax
f010dd82:	66 a3 06 5d 81 f0    	mov    %ax,0xf0815d06
	SETGATE(idt[41], 0, GD_KT , &ALL_FAULTS41, 3) ;
f010dd88:	b8 2c e7 10 f0       	mov    $0xf010e72c,%eax
f010dd8d:	66 a3 08 5d 81 f0    	mov    %ax,0xf0815d08
f010dd93:	66 c7 05 0a 5d 81 f0 	movw   $0x8,0xf0815d0a
f010dd9a:	08 00 
f010dd9c:	a0 0c 5d 81 f0       	mov    0xf0815d0c,%al
f010dda1:	83 e0 e0             	and    $0xffffffe0,%eax
f010dda4:	a2 0c 5d 81 f0       	mov    %al,0xf0815d0c
f010dda9:	a0 0c 5d 81 f0       	mov    0xf0815d0c,%al
f010ddae:	83 e0 1f             	and    $0x1f,%eax
f010ddb1:	a2 0c 5d 81 f0       	mov    %al,0xf0815d0c
f010ddb6:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010ddbb:	83 e0 f0             	and    $0xfffffff0,%eax
f010ddbe:	83 c8 0e             	or     $0xe,%eax
f010ddc1:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010ddc6:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010ddcb:	83 e0 ef             	and    $0xffffffef,%eax
f010ddce:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010ddd3:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010ddd8:	83 c8 60             	or     $0x60,%eax
f010dddb:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010dde0:	a0 0d 5d 81 f0       	mov    0xf0815d0d,%al
f010dde5:	83 c8 80             	or     $0xffffff80,%eax
f010dde8:	a2 0d 5d 81 f0       	mov    %al,0xf0815d0d
f010dded:	b8 2c e7 10 f0       	mov    $0xf010e72c,%eax
f010ddf2:	c1 e8 10             	shr    $0x10,%eax
f010ddf5:	66 a3 0e 5d 81 f0    	mov    %ax,0xf0815d0e
	SETGATE(idt[42], 0, GD_KT , &ALL_FAULTS42, 3) ;
f010ddfb:	b8 32 e7 10 f0       	mov    $0xf010e732,%eax
f010de00:	66 a3 10 5d 81 f0    	mov    %ax,0xf0815d10
f010de06:	66 c7 05 12 5d 81 f0 	movw   $0x8,0xf0815d12
f010de0d:	08 00 
f010de0f:	a0 14 5d 81 f0       	mov    0xf0815d14,%al
f010de14:	83 e0 e0             	and    $0xffffffe0,%eax
f010de17:	a2 14 5d 81 f0       	mov    %al,0xf0815d14
f010de1c:	a0 14 5d 81 f0       	mov    0xf0815d14,%al
f010de21:	83 e0 1f             	and    $0x1f,%eax
f010de24:	a2 14 5d 81 f0       	mov    %al,0xf0815d14
f010de29:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010de2e:	83 e0 f0             	and    $0xfffffff0,%eax
f010de31:	83 c8 0e             	or     $0xe,%eax
f010de34:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010de39:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010de3e:	83 e0 ef             	and    $0xffffffef,%eax
f010de41:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010de46:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010de4b:	83 c8 60             	or     $0x60,%eax
f010de4e:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010de53:	a0 15 5d 81 f0       	mov    0xf0815d15,%al
f010de58:	83 c8 80             	or     $0xffffff80,%eax
f010de5b:	a2 15 5d 81 f0       	mov    %al,0xf0815d15
f010de60:	b8 32 e7 10 f0       	mov    $0xf010e732,%eax
f010de65:	c1 e8 10             	shr    $0x10,%eax
f010de68:	66 a3 16 5d 81 f0    	mov    %ax,0xf0815d16
	SETGATE(idt[43], 0, GD_KT , &ALL_FAULTS43, 3) ;
f010de6e:	b8 38 e7 10 f0       	mov    $0xf010e738,%eax
f010de73:	66 a3 18 5d 81 f0    	mov    %ax,0xf0815d18
f010de79:	66 c7 05 1a 5d 81 f0 	movw   $0x8,0xf0815d1a
f010de80:	08 00 
f010de82:	a0 1c 5d 81 f0       	mov    0xf0815d1c,%al
f010de87:	83 e0 e0             	and    $0xffffffe0,%eax
f010de8a:	a2 1c 5d 81 f0       	mov    %al,0xf0815d1c
f010de8f:	a0 1c 5d 81 f0       	mov    0xf0815d1c,%al
f010de94:	83 e0 1f             	and    $0x1f,%eax
f010de97:	a2 1c 5d 81 f0       	mov    %al,0xf0815d1c
f010de9c:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010dea1:	83 e0 f0             	and    $0xfffffff0,%eax
f010dea4:	83 c8 0e             	or     $0xe,%eax
f010dea7:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010deac:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010deb1:	83 e0 ef             	and    $0xffffffef,%eax
f010deb4:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010deb9:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010debe:	83 c8 60             	or     $0x60,%eax
f010dec1:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010dec6:	a0 1d 5d 81 f0       	mov    0xf0815d1d,%al
f010decb:	83 c8 80             	or     $0xffffff80,%eax
f010dece:	a2 1d 5d 81 f0       	mov    %al,0xf0815d1d
f010ded3:	b8 38 e7 10 f0       	mov    $0xf010e738,%eax
f010ded8:	c1 e8 10             	shr    $0x10,%eax
f010dedb:	66 a3 1e 5d 81 f0    	mov    %ax,0xf0815d1e
	SETGATE(idt[44], 0, GD_KT , &ALL_FAULTS44, 3) ;
f010dee1:	b8 3e e7 10 f0       	mov    $0xf010e73e,%eax
f010dee6:	66 a3 20 5d 81 f0    	mov    %ax,0xf0815d20
f010deec:	66 c7 05 22 5d 81 f0 	movw   $0x8,0xf0815d22
f010def3:	08 00 
f010def5:	a0 24 5d 81 f0       	mov    0xf0815d24,%al
f010defa:	83 e0 e0             	and    $0xffffffe0,%eax
f010defd:	a2 24 5d 81 f0       	mov    %al,0xf0815d24
f010df02:	a0 24 5d 81 f0       	mov    0xf0815d24,%al
f010df07:	83 e0 1f             	and    $0x1f,%eax
f010df0a:	a2 24 5d 81 f0       	mov    %al,0xf0815d24
f010df0f:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010df14:	83 e0 f0             	and    $0xfffffff0,%eax
f010df17:	83 c8 0e             	or     $0xe,%eax
f010df1a:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010df1f:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010df24:	83 e0 ef             	and    $0xffffffef,%eax
f010df27:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010df2c:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010df31:	83 c8 60             	or     $0x60,%eax
f010df34:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010df39:	a0 25 5d 81 f0       	mov    0xf0815d25,%al
f010df3e:	83 c8 80             	or     $0xffffff80,%eax
f010df41:	a2 25 5d 81 f0       	mov    %al,0xf0815d25
f010df46:	b8 3e e7 10 f0       	mov    $0xf010e73e,%eax
f010df4b:	c1 e8 10             	shr    $0x10,%eax
f010df4e:	66 a3 26 5d 81 f0    	mov    %ax,0xf0815d26
	SETGATE(idt[45], 0, GD_KT , &ALL_FAULTS45, 3) ;
f010df54:	b8 44 e7 10 f0       	mov    $0xf010e744,%eax
f010df59:	66 a3 28 5d 81 f0    	mov    %ax,0xf0815d28
f010df5f:	66 c7 05 2a 5d 81 f0 	movw   $0x8,0xf0815d2a
f010df66:	08 00 
f010df68:	a0 2c 5d 81 f0       	mov    0xf0815d2c,%al
f010df6d:	83 e0 e0             	and    $0xffffffe0,%eax
f010df70:	a2 2c 5d 81 f0       	mov    %al,0xf0815d2c
f010df75:	a0 2c 5d 81 f0       	mov    0xf0815d2c,%al
f010df7a:	83 e0 1f             	and    $0x1f,%eax
f010df7d:	a2 2c 5d 81 f0       	mov    %al,0xf0815d2c
f010df82:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010df87:	83 e0 f0             	and    $0xfffffff0,%eax
f010df8a:	83 c8 0e             	or     $0xe,%eax
f010df8d:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010df92:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010df97:	83 e0 ef             	and    $0xffffffef,%eax
f010df9a:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010df9f:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010dfa4:	83 c8 60             	or     $0x60,%eax
f010dfa7:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010dfac:	a0 2d 5d 81 f0       	mov    0xf0815d2d,%al
f010dfb1:	83 c8 80             	or     $0xffffff80,%eax
f010dfb4:	a2 2d 5d 81 f0       	mov    %al,0xf0815d2d
f010dfb9:	b8 44 e7 10 f0       	mov    $0xf010e744,%eax
f010dfbe:	c1 e8 10             	shr    $0x10,%eax
f010dfc1:	66 a3 2e 5d 81 f0    	mov    %ax,0xf0815d2e
	SETGATE(idt[46], 0, GD_KT , &ALL_FAULTS46, 3) ;
f010dfc7:	b8 4a e7 10 f0       	mov    $0xf010e74a,%eax
f010dfcc:	66 a3 30 5d 81 f0    	mov    %ax,0xf0815d30
f010dfd2:	66 c7 05 32 5d 81 f0 	movw   $0x8,0xf0815d32
f010dfd9:	08 00 
f010dfdb:	a0 34 5d 81 f0       	mov    0xf0815d34,%al
f010dfe0:	83 e0 e0             	and    $0xffffffe0,%eax
f010dfe3:	a2 34 5d 81 f0       	mov    %al,0xf0815d34
f010dfe8:	a0 34 5d 81 f0       	mov    0xf0815d34,%al
f010dfed:	83 e0 1f             	and    $0x1f,%eax
f010dff0:	a2 34 5d 81 f0       	mov    %al,0xf0815d34
f010dff5:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010dffa:	83 e0 f0             	and    $0xfffffff0,%eax
f010dffd:	83 c8 0e             	or     $0xe,%eax
f010e000:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010e005:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010e00a:	83 e0 ef             	and    $0xffffffef,%eax
f010e00d:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010e012:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010e017:	83 c8 60             	or     $0x60,%eax
f010e01a:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010e01f:	a0 35 5d 81 f0       	mov    0xf0815d35,%al
f010e024:	83 c8 80             	or     $0xffffff80,%eax
f010e027:	a2 35 5d 81 f0       	mov    %al,0xf0815d35
f010e02c:	b8 4a e7 10 f0       	mov    $0xf010e74a,%eax
f010e031:	c1 e8 10             	shr    $0x10,%eax
f010e034:	66 a3 36 5d 81 f0    	mov    %ax,0xf0815d36
	SETGATE(idt[47], 0, GD_KT , &ALL_FAULTS47, 3) ;
f010e03a:	b8 50 e7 10 f0       	mov    $0xf010e750,%eax
f010e03f:	66 a3 38 5d 81 f0    	mov    %ax,0xf0815d38
f010e045:	66 c7 05 3a 5d 81 f0 	movw   $0x8,0xf0815d3a
f010e04c:	08 00 
f010e04e:	a0 3c 5d 81 f0       	mov    0xf0815d3c,%al
f010e053:	83 e0 e0             	and    $0xffffffe0,%eax
f010e056:	a2 3c 5d 81 f0       	mov    %al,0xf0815d3c
f010e05b:	a0 3c 5d 81 f0       	mov    0xf0815d3c,%al
f010e060:	83 e0 1f             	and    $0x1f,%eax
f010e063:	a2 3c 5d 81 f0       	mov    %al,0xf0815d3c
f010e068:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010e06d:	83 e0 f0             	and    $0xfffffff0,%eax
f010e070:	83 c8 0e             	or     $0xe,%eax
f010e073:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010e078:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010e07d:	83 e0 ef             	and    $0xffffffef,%eax
f010e080:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010e085:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010e08a:	83 c8 60             	or     $0x60,%eax
f010e08d:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010e092:	a0 3d 5d 81 f0       	mov    0xf0815d3d,%al
f010e097:	83 c8 80             	or     $0xffffff80,%eax
f010e09a:	a2 3d 5d 81 f0       	mov    %al,0xf0815d3d
f010e09f:	b8 50 e7 10 f0       	mov    $0xf010e750,%eax
f010e0a4:	c1 e8 10             	shr    $0x10,%eax
f010e0a7:	66 a3 3e 5d 81 f0    	mov    %ax,0xf0815d3e
f010e0ad:	c7 45 fc c0 5b 81 f0 	movl   $0xf0815bc0,-0x4(%ebp)
f010e0b4:	c7 45 f8 00 08 00 00 	movl   $0x800,-0x8(%ebp)
//load IDT register
static __inline void lidt(struct Gatedesc *p, int size)
{
  volatile unsigned short pd[3];

  pd[0] = size-1;
f010e0bb:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010e0be:	48                   	dec    %eax
f010e0bf:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
  pd[1] = (uint32)p;
f010e0c3:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e0c6:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  pd[2] = (uint32)p >> 16;
f010e0ca:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010e0cd:	c1 e8 10             	shr    $0x10,%eax
f010e0d0:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  asm volatile("lidt (%0)" : : "r" (pd));
f010e0d4:	8d 45 f2             	lea    -0xe(%ebp),%eax
f010e0d7:	0f 01 18             	lidtl  (%eax)

	// Load the IDT
	//asm volatile("lidt idt_pd");
	lidt(idt, sizeof(idt));

}
f010e0da:	90                   	nop
f010e0db:	c9                   	leave  
f010e0dc:	c3                   	ret    

f010e0dd <print_trapframe>:

void print_trapframe(struct Trapframe *tf)
{
f010e0dd:	55                   	push   %ebp
f010e0de:	89 e5                	mov    %esp,%ebp
f010e0e0:	53                   	push   %ebx
f010e0e1:	83 ec 04             	sub    $0x4,%esp
	cprintf("TRAP frame at %p\n", tf);
f010e0e4:	83 ec 08             	sub    $0x8,%esp
f010e0e7:	ff 75 08             	pushl  0x8(%ebp)
f010e0ea:	68 1e 0f 13 f0       	push   $0xf0130f1e
f010e0ef:	e8 68 3b ff ff       	call   f0101c5c <cprintf>
f010e0f4:	83 c4 10             	add    $0x10,%esp
	print_regs(&tf->tf_regs);
f010e0f7:	8b 45 08             	mov    0x8(%ebp),%eax
f010e0fa:	83 ec 0c             	sub    $0xc,%esp
f010e0fd:	50                   	push   %eax
f010e0fe:	e8 fd 00 00 00       	call   f010e200 <print_regs>
f010e103:	83 c4 10             	add    $0x10,%esp
	cprintf("  es   0x----%04x\n", tf->tf_es);
f010e106:	8b 45 08             	mov    0x8(%ebp),%eax
f010e109:	8b 40 20             	mov    0x20(%eax),%eax
f010e10c:	0f b7 c0             	movzwl %ax,%eax
f010e10f:	83 ec 08             	sub    $0x8,%esp
f010e112:	50                   	push   %eax
f010e113:	68 30 0f 13 f0       	push   $0xf0130f30
f010e118:	e8 3f 3b ff ff       	call   f0101c5c <cprintf>
f010e11d:	83 c4 10             	add    $0x10,%esp
	cprintf("  ds   0x----%04x\n", tf->tf_ds);
f010e120:	8b 45 08             	mov    0x8(%ebp),%eax
f010e123:	8b 40 24             	mov    0x24(%eax),%eax
f010e126:	0f b7 c0             	movzwl %ax,%eax
f010e129:	83 ec 08             	sub    $0x8,%esp
f010e12c:	50                   	push   %eax
f010e12d:	68 43 0f 13 f0       	push   $0xf0130f43
f010e132:	e8 25 3b ff ff       	call   f0101c5c <cprintf>
f010e137:	83 c4 10             	add    $0x10,%esp
	cprintf("  trap 0x%08x %s - %d\n", tf->tf_trapno, trapname(tf->tf_trapno), tf->tf_trapno);
f010e13a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e13d:	8b 58 28             	mov    0x28(%eax),%ebx
f010e140:	8b 45 08             	mov    0x8(%ebp),%eax
f010e143:	8b 40 28             	mov    0x28(%eax),%eax
f010e146:	83 ec 0c             	sub    $0xc,%esp
f010e149:	50                   	push   %eax
f010e14a:	e8 28 ee ff ff       	call   f010cf77 <trapname>
f010e14f:	83 c4 10             	add    $0x10,%esp
f010e152:	89 c2                	mov    %eax,%edx
f010e154:	8b 45 08             	mov    0x8(%ebp),%eax
f010e157:	8b 40 28             	mov    0x28(%eax),%eax
f010e15a:	53                   	push   %ebx
f010e15b:	52                   	push   %edx
f010e15c:	50                   	push   %eax
f010e15d:	68 56 0f 13 f0       	push   $0xf0130f56
f010e162:	e8 f5 3a ff ff       	call   f0101c5c <cprintf>
f010e167:	83 c4 10             	add    $0x10,%esp
	cprintf("  err  0x%08x\n", tf->tf_err);
f010e16a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e16d:	8b 40 2c             	mov    0x2c(%eax),%eax
f010e170:	83 ec 08             	sub    $0x8,%esp
f010e173:	50                   	push   %eax
f010e174:	68 6d 0f 13 f0       	push   $0xf0130f6d
f010e179:	e8 de 3a ff ff       	call   f0101c5c <cprintf>
f010e17e:	83 c4 10             	add    $0x10,%esp
	cprintf("  eip  0x%08x\n", tf->tf_eip);
f010e181:	8b 45 08             	mov    0x8(%ebp),%eax
f010e184:	8b 40 30             	mov    0x30(%eax),%eax
f010e187:	83 ec 08             	sub    $0x8,%esp
f010e18a:	50                   	push   %eax
f010e18b:	68 7c 0f 13 f0       	push   $0xf0130f7c
f010e190:	e8 c7 3a ff ff       	call   f0101c5c <cprintf>
f010e195:	83 c4 10             	add    $0x10,%esp
	cprintf("  cs   0x----%04x\n", tf->tf_cs);
f010e198:	8b 45 08             	mov    0x8(%ebp),%eax
f010e19b:	8b 40 34             	mov    0x34(%eax),%eax
f010e19e:	0f b7 c0             	movzwl %ax,%eax
f010e1a1:	83 ec 08             	sub    $0x8,%esp
f010e1a4:	50                   	push   %eax
f010e1a5:	68 8b 0f 13 f0       	push   $0xf0130f8b
f010e1aa:	e8 ad 3a ff ff       	call   f0101c5c <cprintf>
f010e1af:	83 c4 10             	add    $0x10,%esp
	cprintf("  flag 0x%08x\n", tf->tf_eflags);
f010e1b2:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1b5:	8b 40 38             	mov    0x38(%eax),%eax
f010e1b8:	83 ec 08             	sub    $0x8,%esp
f010e1bb:	50                   	push   %eax
f010e1bc:	68 9e 0f 13 f0       	push   $0xf0130f9e
f010e1c1:	e8 96 3a ff ff       	call   f0101c5c <cprintf>
f010e1c6:	83 c4 10             	add    $0x10,%esp
	cprintf("  esp  0x%08x\n", tf->tf_esp);
f010e1c9:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1cc:	8b 40 3c             	mov    0x3c(%eax),%eax
f010e1cf:	83 ec 08             	sub    $0x8,%esp
f010e1d2:	50                   	push   %eax
f010e1d3:	68 ad 0f 13 f0       	push   $0xf0130fad
f010e1d8:	e8 7f 3a ff ff       	call   f0101c5c <cprintf>
f010e1dd:	83 c4 10             	add    $0x10,%esp
	cprintf("  ss   0x----%04x\n", tf->tf_ss);
f010e1e0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e1e3:	8b 40 40             	mov    0x40(%eax),%eax
f010e1e6:	0f b7 c0             	movzwl %ax,%eax
f010e1e9:	83 ec 08             	sub    $0x8,%esp
f010e1ec:	50                   	push   %eax
f010e1ed:	68 bc 0f 13 f0       	push   $0xf0130fbc
f010e1f2:	e8 65 3a ff ff       	call   f0101c5c <cprintf>
f010e1f7:	83 c4 10             	add    $0x10,%esp
}
f010e1fa:	90                   	nop
f010e1fb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010e1fe:	c9                   	leave  
f010e1ff:	c3                   	ret    

f010e200 <print_regs>:

void print_regs(struct PushRegs *regs)
{
f010e200:	55                   	push   %ebp
f010e201:	89 e5                	mov    %esp,%ebp
f010e203:	83 ec 08             	sub    $0x8,%esp
	cprintf("  edi  0x%08x\n", regs->reg_edi);
f010e206:	8b 45 08             	mov    0x8(%ebp),%eax
f010e209:	8b 00                	mov    (%eax),%eax
f010e20b:	83 ec 08             	sub    $0x8,%esp
f010e20e:	50                   	push   %eax
f010e20f:	68 cf 0f 13 f0       	push   $0xf0130fcf
f010e214:	e8 43 3a ff ff       	call   f0101c5c <cprintf>
f010e219:	83 c4 10             	add    $0x10,%esp
	cprintf("  esi  0x%08x\n", regs->reg_esi);
f010e21c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e21f:	8b 40 04             	mov    0x4(%eax),%eax
f010e222:	83 ec 08             	sub    $0x8,%esp
f010e225:	50                   	push   %eax
f010e226:	68 de 0f 13 f0       	push   $0xf0130fde
f010e22b:	e8 2c 3a ff ff       	call   f0101c5c <cprintf>
f010e230:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebp  0x%08x\n", regs->reg_ebp);
f010e233:	8b 45 08             	mov    0x8(%ebp),%eax
f010e236:	8b 40 08             	mov    0x8(%eax),%eax
f010e239:	83 ec 08             	sub    $0x8,%esp
f010e23c:	50                   	push   %eax
f010e23d:	68 ed 0f 13 f0       	push   $0xf0130fed
f010e242:	e8 15 3a ff ff       	call   f0101c5c <cprintf>
f010e247:	83 c4 10             	add    $0x10,%esp
	cprintf("  oesp 0x%08x\n", regs->reg_oesp);
f010e24a:	8b 45 08             	mov    0x8(%ebp),%eax
f010e24d:	8b 40 0c             	mov    0xc(%eax),%eax
f010e250:	83 ec 08             	sub    $0x8,%esp
f010e253:	50                   	push   %eax
f010e254:	68 fc 0f 13 f0       	push   $0xf0130ffc
f010e259:	e8 fe 39 ff ff       	call   f0101c5c <cprintf>
f010e25e:	83 c4 10             	add    $0x10,%esp
	cprintf("  ebx  0x%08x\n", regs->reg_ebx);
f010e261:	8b 45 08             	mov    0x8(%ebp),%eax
f010e264:	8b 40 10             	mov    0x10(%eax),%eax
f010e267:	83 ec 08             	sub    $0x8,%esp
f010e26a:	50                   	push   %eax
f010e26b:	68 0b 10 13 f0       	push   $0xf013100b
f010e270:	e8 e7 39 ff ff       	call   f0101c5c <cprintf>
f010e275:	83 c4 10             	add    $0x10,%esp
	cprintf("  edx  0x%08x\n", regs->reg_edx);
f010e278:	8b 45 08             	mov    0x8(%ebp),%eax
f010e27b:	8b 40 14             	mov    0x14(%eax),%eax
f010e27e:	83 ec 08             	sub    $0x8,%esp
f010e281:	50                   	push   %eax
f010e282:	68 1a 10 13 f0       	push   $0xf013101a
f010e287:	e8 d0 39 ff ff       	call   f0101c5c <cprintf>
f010e28c:	83 c4 10             	add    $0x10,%esp
	cprintf("  ecx  0x%08x\n", regs->reg_ecx);
f010e28f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e292:	8b 40 18             	mov    0x18(%eax),%eax
f010e295:	83 ec 08             	sub    $0x8,%esp
f010e298:	50                   	push   %eax
f010e299:	68 29 10 13 f0       	push   $0xf0131029
f010e29e:	e8 b9 39 ff ff       	call   f0101c5c <cprintf>
f010e2a3:	83 c4 10             	add    $0x10,%esp
	cprintf("  eax  0x%08x\n", regs->reg_eax);
f010e2a6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2a9:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e2ac:	83 ec 08             	sub    $0x8,%esp
f010e2af:	50                   	push   %eax
f010e2b0:	68 38 10 13 f0       	push   $0xf0131038
f010e2b5:	e8 a2 39 ff ff       	call   f0101c5c <cprintf>
f010e2ba:	83 c4 10             	add    $0x10,%esp
}
f010e2bd:	90                   	nop
f010e2be:	c9                   	leave  
f010e2bf:	c3                   	ret    

f010e2c0 <irq_install_handler>:


void *irq_handlers[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} ;
void irq_install_handler(int irq, void (*handler)(struct Trapframe *tf))
{
f010e2c0:	55                   	push   %ebp
f010e2c1:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = handler;
f010e2c3:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2c6:	8b 55 0c             	mov    0xc(%ebp),%edx
f010e2c9:	89 14 85 c0 63 81 f0 	mov    %edx,-0xf7e9c40(,%eax,4)
}
f010e2d0:	90                   	nop
f010e2d1:	5d                   	pop    %ebp
f010e2d2:	c3                   	ret    

f010e2d3 <irq_uninstall_handler>:
void irq_uninstall_handler(int irq)
{
f010e2d3:	55                   	push   %ebp
f010e2d4:	89 e5                	mov    %esp,%ebp
	irq_handlers[irq] = NULL;
f010e2d6:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2d9:	c7 04 85 c0 63 81 f0 	movl   $0x0,-0xf7e9c40(,%eax,4)
f010e2e0:	00 00 00 00 
}
f010e2e4:	90                   	nop
f010e2e5:	5d                   	pop    %ebp
f010e2e6:	c3                   	ret    

f010e2e7 <irq_dispatch>:
void irq_dispatch(struct Trapframe *tf)
{
f010e2e7:	55                   	push   %ebp
f010e2e8:	89 e5                	mov    %esp,%ebp
f010e2ea:	83 ec 18             	sub    $0x18,%esp
	void (*handler)(struct Trapframe *tf);
	int IRQNum = tf->tf_trapno - IRQ_OFFSET;
f010e2ed:	8b 45 08             	mov    0x8(%ebp),%eax
f010e2f0:	8b 40 28             	mov    0x28(%eax),%eax
f010e2f3:	83 e8 20             	sub    $0x20,%eax
f010e2f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	handler = irq_handlers[IRQNum] ;
f010e2f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e2fc:	8b 04 85 c0 63 81 f0 	mov    -0xf7e9c40(,%eax,4),%eax
f010e303:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (handler)
f010e306:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e30a:	74 0e                	je     f010e31a <irq_dispatch+0x33>
	{
		handler(tf);
f010e30c:	83 ec 0c             	sub    $0xc,%esp
f010e30f:	ff 75 08             	pushl  0x8(%ebp)
f010e312:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e315:	ff d0                	call   *%eax
f010e317:	83 c4 10             	add    $0x10,%esp
	}

	//Send End Of Interrupt CMD to PIC
	pic_sendEOI(IRQNum);
f010e31a:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e31d:	0f b6 c0             	movzbl %al,%eax
f010e320:	83 ec 0c             	sub    $0xc,%esp
f010e323:	50                   	push   %eax
f010e324:	e8 0e 9d ff ff       	call   f0108037 <pic_sendEOI>
f010e329:	83 c4 10             	add    $0x10,%esp
}
f010e32c:	90                   	nop
f010e32d:	c9                   	leave  
f010e32e:	c3                   	ret    

f010e32f <trap_dispatch>:

static void trap_dispatch(struct Trapframe *tf)
{
f010e32f:	55                   	push   %ebp
f010e330:	89 e5                	mov    %esp,%ebp
f010e332:	57                   	push   %edi
f010e333:	56                   	push   %esi
f010e334:	53                   	push   %ebx
f010e335:	83 ec 1c             	sub    $0x1c,%esp
	// Handle processor exceptions.
	// LAB 3: Your code here.

	if(tf->tf_trapno == T_PGFLT)
f010e338:	8b 45 08             	mov    0x8(%ebp),%eax
f010e33b:	8b 40 28             	mov    0x28(%eax),%eax
f010e33e:	83 f8 0e             	cmp    $0xe,%eax
f010e341:	75 51                	jne    f010e394 <trap_dispatch+0x65>
	{
		//2016: Bypass the faulted instruction [used for some tests in which we need to resume the execution after an intended page fault]
		if (bypassInstrLength != 0)
f010e343:	a0 00 64 81 f0       	mov    0xf0816400,%al
f010e348:	84 c0                	test   %al,%al
f010e34a:	74 1f                	je     f010e36b <trap_dispatch+0x3c>
		{
			tf->tf_eip = (uint32*)((uint32)(tf->tf_eip) + bypassInstrLength);
f010e34c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e34f:	8b 40 30             	mov    0x30(%eax),%eax
f010e352:	89 c2                	mov    %eax,%edx
f010e354:	a0 00 64 81 f0       	mov    0xf0816400,%al
f010e359:	0f b6 c0             	movzbl %al,%eax
f010e35c:	01 d0                	add    %edx,%eax
f010e35e:	89 c2                	mov    %eax,%edx
f010e360:	8b 45 08             	mov    0x8(%ebp),%eax
f010e363:	89 50 30             	mov    %edx,0x30(%eax)
			/*2024: commented. already will be returned to the trapret() in trapentry.S which return to the user/kernel caller code*/
			//kclock_resume();
			//env_pop_tf(tf);
			return;
f010e366:	e9 0c 01 00 00       	jmp    f010e477 <trap_dispatch+0x148>
		}

		//print_trapframe(tf);
		if(isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010e36b:	83 ec 0c             	sub    $0xc,%esp
f010e36e:	6a 01                	push   $0x1
f010e370:	e8 ae 15 00 00       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010e375:	83 c4 10             	add    $0x10,%esp
f010e378:	85 c0                	test   %eax,%eax
f010e37a:	74 05                	je     f010e381 <trap_dispatch+0x52>
		{
			//cprintf("===========Table WS before updating time stamp========\n");
			//env_table_ws_print(curenv) ;
			update_WS_time_stamps();
f010e37c:	e8 c8 99 ff ff       	call   f0107d49 <update_WS_time_stamps>
		}
		fault_handler(tf);
f010e381:	83 ec 0c             	sub    $0xc,%esp
f010e384:	ff 75 08             	pushl  0x8(%ebp)
f010e387:	e8 c3 16 00 00       	call   f010fa4f <fault_handler>
f010e38c:	83 c4 10             	add    $0x10,%esp
f010e38f:	e9 e3 00 00 00       	jmp    f010e477 <trap_dispatch+0x148>
	}
	else if (tf->tf_trapno == T_SYSCALL)
f010e394:	8b 45 08             	mov    0x8(%ebp),%eax
f010e397:	8b 40 28             	mov    0x28(%eax),%eax
f010e39a:	83 f8 30             	cmp    $0x30,%eax
f010e39d:	75 6e                	jne    f010e40d <trap_dispatch+0xde>
	{
		/* If the original status of the interrupt is ENABLED (before getting into kernel),
		 * Then, re-enable the interrupts & resume the clock during the system calls
		 * to allow switching between processes
		 */
		if (tf->tf_eflags & FL_IF)
f010e39f:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3a2:	8b 40 38             	mov    0x38(%eax),%eax
f010e3a5:	25 00 02 00 00       	and    $0x200,%eax
f010e3aa:	85 c0                	test   %eax,%eax
f010e3ac:	74 06                	je     f010e3b4 <trap_dispatch+0x85>

//set interrupt flag
static __inline void
sti(void)
{
	__asm __volatile("sti");
f010e3ae:	fb                   	sti    
		{
			sti();
			kclock_resume();
f010e3af:	e8 8f 79 ff ff       	call   f0105d43 <kclock_resume>
		}
		//cprintf("\nserving system call #%d\n", tf->tf_regs.reg_eax);
		uint32 ret = syscall(tf->tf_regs.reg_eax
f010e3b4:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3b7:	8b 78 04             	mov    0x4(%eax),%edi
f010e3ba:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3bd:	8b 30                	mov    (%eax),%esi
f010e3bf:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3c2:	8b 58 10             	mov    0x10(%eax),%ebx
f010e3c5:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3c8:	8b 48 18             	mov    0x18(%eax),%ecx
f010e3cb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3ce:	8b 50 14             	mov    0x14(%eax),%edx
f010e3d1:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3d4:	8b 40 1c             	mov    0x1c(%eax),%eax
f010e3d7:	83 ec 08             	sub    $0x8,%esp
f010e3da:	57                   	push   %edi
f010e3db:	56                   	push   %esi
f010e3dc:	53                   	push   %ebx
f010e3dd:	51                   	push   %ecx
f010e3de:	52                   	push   %edx
f010e3df:	50                   	push   %eax
f010e3e0:	e8 9d 0c 00 00       	call   f010f082 <syscall>
f010e3e5:	83 c4 20             	add    $0x20,%esp
f010e3e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
				,tf->tf_regs.reg_ecx
				,tf->tf_regs.reg_ebx
				,tf->tf_regs.reg_edi
				,tf->tf_regs.reg_esi);

		tf->tf_regs.reg_eax = ret;
f010e3eb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e3ee:	8b 55 e0             	mov    -0x20(%ebp),%edx
f010e3f1:	89 50 1c             	mov    %edx,0x1c(%eax)

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e3f4:	9c                   	pushf  
f010e3f5:	58                   	pop    %eax
f010e3f6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        return eflags;
f010e3f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax

		/*If still enabled, Disable the interrupt & stop clock before getting into user again
		 */
		if (read_eflags() & FL_IF)
f010e3fc:	25 00 02 00 00       	and    $0x200,%eax
f010e401:	85 c0                	test   %eax,%eax
f010e403:	74 72                	je     f010e477 <trap_dispatch+0x148>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f010e405:	fa                   	cli    
		{
			cli();
			kclock_stop();
f010e406:	e8 10 79 ff ff       	call   f0105d1b <kclock_stop>
f010e40b:	eb 6a                	jmp    f010e477 <trap_dispatch+0x148>
		}
		//cprintf("ret val form syscall = %d\n", ret);
	}
	else if(tf->tf_trapno == T_DBLFLT)
f010e40d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e410:	8b 40 28             	mov    0x28(%eax),%eax
f010e413:	83 f8 08             	cmp    $0x8,%eax
f010e416:	75 17                	jne    f010e42f <trap_dispatch+0x100>
	{
		panic("double fault!!");
f010e418:	83 ec 04             	sub    $0x4,%esp
f010e41b:	68 47 10 13 f0       	push   $0xf0131047
f010e420:	68 29 01 00 00       	push   $0x129
f010e425:	68 56 10 13 f0       	push   $0xf0131056
f010e42a:	e8 80 2b ff ff       	call   f0100faf <_panic>
	}
	else
	{
		// Unexpected trap: The user process or the kernel has a bug.
		print_trapframe(tf);
f010e42f:	83 ec 0c             	sub    $0xc,%esp
f010e432:	ff 75 08             	pushl  0x8(%ebp)
f010e435:	e8 a3 fc ff ff       	call   f010e0dd <print_trapframe>
f010e43a:	83 c4 10             	add    $0x10,%esp
		if (tf->tf_cs == GD_KT)
f010e43d:	8b 45 08             	mov    0x8(%ebp),%eax
f010e440:	8b 40 34             	mov    0x34(%eax),%eax
f010e443:	66 83 f8 08          	cmp    $0x8,%ax
f010e447:	75 17                	jne    f010e460 <trap_dispatch+0x131>
		{
			panic("unhandled trap in kernel");
f010e449:	83 ec 04             	sub    $0x4,%esp
f010e44c:	68 67 10 13 f0       	push   $0xf0131067
f010e451:	68 31 01 00 00       	push   $0x131
f010e456:	68 56 10 13 f0       	push   $0xf0131056
f010e45b:	e8 4f 2b ff ff       	call   f0100faf <_panic>
		}
		else
		{
			//env_destroy(curenv);
			panic("unhandled trap in user program");
f010e460:	83 ec 04             	sub    $0x4,%esp
f010e463:	68 80 10 13 f0       	push   $0xf0131080
f010e468:	68 36 01 00 00       	push   $0x136
f010e46d:	68 56 10 13 f0       	push   $0xf0131056
f010e472:	e8 38 2b ff ff       	call   f0100faf <_panic>
		}
	}
}
f010e477:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e47a:	5b                   	pop    %ebx
f010e47b:	5e                   	pop    %esi
f010e47c:	5f                   	pop    %edi
f010e47d:	5d                   	pop    %ebp
f010e47e:	c3                   	ret    

f010e47f <trap>:

void trap(struct Trapframe *tf)
{
f010e47f:	55                   	push   %ebp
f010e480:	89 e5                	mov    %esp,%ebp
f010e482:	57                   	push   %edi
f010e483:	56                   	push   %esi
f010e484:	53                   	push   %ebx
f010e485:	83 ec 3c             	sub    $0x3c,%esp
	/* to avoid counting down on the current process while handling exceptions
	 * This avoid pending clock interrupt after returning from the trap.
	 * NOTE: interrupt is automatically disabled by the interrupt cycle (by marking all traps as "Interrupt Gates").
	 * Resume the clock and Re-enable the interrupt whenever required (e.g. in system calls).
	 */
	kclock_stop();
f010e488:	e8 8e 78 ff ff       	call   f0105d1b <kclock_stop>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e48d:	9c                   	pushf  
f010e48e:	58                   	pop    %eax
f010e48f:	89 45 c8             	mov    %eax,-0x38(%ebp)
        return eflags;
f010e492:	8b 45 c8             	mov    -0x38(%ebp),%eax

	//[2] Some validations

	//2024 check if interrupt is enabled during the trap handler, then panic
	uint32 flags = read_eflags();
f010e495:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (flags & FL_IF)
f010e498:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010e49b:	25 00 02 00 00       	and    $0x200,%eax
f010e4a0:	85 c0                	test   %eax,%eax
f010e4a2:	74 25                	je     f010e4c9 <trap+0x4a>
	{
		print_trapframe(tf);
f010e4a4:	83 ec 0c             	sub    $0xc,%esp
f010e4a7:	ff 75 08             	pushl  0x8(%ebp)
f010e4aa:	e8 2e fc ff ff       	call   f010e0dd <print_trapframe>
f010e4af:	83 c4 10             	add    $0x10,%esp
		panic("trap(): interrupt is enabled while it's expected to be disabled\n");
f010e4b2:	83 ec 04             	sub    $0x4,%esp
f010e4b5:	68 a0 10 13 f0       	push   $0xf01310a0
f010e4ba:	68 4c 01 00 00       	push   $0x14c
f010e4bf:	68 56 10 13 f0       	push   $0xf0131056
f010e4c4:	e8 e6 2a ff ff       	call   f0100faf <_panic>
	}

	int userTrap = 0;
f010e4c9:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	struct Env* cur_env = get_cpu_proc(); //the current running Environment (if any)
f010e4d0:	e8 43 d6 ff ff       	call   f010bb18 <get_cpu_proc>
f010e4d5:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if ((tf->tf_cs & 3) == 3)
f010e4d8:	8b 45 08             	mov    0x8(%ebp),%eax
f010e4db:	8b 40 34             	mov    0x34(%eax),%eax
f010e4de:	0f b7 c0             	movzwl %ax,%eax
f010e4e1:	83 e0 03             	and    $0x3,%eax
f010e4e4:	83 f8 03             	cmp    $0x3,%eax
f010e4e7:	0f 85 03 01 00 00    	jne    f010e5f0 <trap+0x171>
	{
		userTrap = 1;
f010e4ed:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		assert(cur_env && cur_env->env_status == ENV_RUNNING);	//environment should be exist & run
f010e4f4:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f010e4f8:	74 0b                	je     f010e505 <trap+0x86>
f010e4fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e4fd:	8b 40 18             	mov    0x18(%eax),%eax
f010e500:	83 f8 02             	cmp    $0x2,%eax
f010e503:	74 19                	je     f010e51e <trap+0x9f>
f010e505:	68 e4 10 13 f0       	push   $0xf01310e4
f010e50a:	68 12 11 13 f0       	push   $0xf0131112
f010e50f:	68 55 01 00 00       	push   $0x155
f010e514:	68 56 10 13 f0       	push   $0xf0131056
f010e519:	e8 91 2a ff ff       	call   f0100faf <_panic>
		//cprintf("curenv->env_tf @ %x, tf param @ %x\n", curenv->env_tf , tf);
		//assert(cur_env->env_tf == tf);	//tf should be placed in the kernel stack of this process (@e->env_tf)
		if (cur_env->env_tf != tf)
f010e51e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e521:	8b 00                	mov    (%eax),%eax
f010e523:	3b 45 08             	cmp    0x8(%ebp),%eax
f010e526:	0f 84 c4 00 00 00    	je     f010e5f0 <trap+0x171>

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e52c:	9c                   	pushf  
f010e52d:	58                   	pop    %eax
f010e52e:	89 45 d0             	mov    %eax,-0x30(%ebp)
        return eflags;
f010e531:	8b 45 d0             	mov    -0x30(%ebp),%eax
		{
			cprintf("\n[%s - %d] trap #%d - %s (cr2 = %x) tf va = %x - eip = %x - IEN = %d\n", userTrap == 1? "USER" : "KERNEL", userTrap == 1? cur_env->env_id : 0, tf->tf_trapno, trapname(tf->tf_trapno), rcr2(), tf, tf->tf_eip, (read_eflags() & FL_IF) == 0? 0 : 1);
f010e534:	25 00 02 00 00       	and    $0x200,%eax
f010e539:	85 c0                	test   %eax,%eax
f010e53b:	0f 95 c0             	setne  %al
f010e53e:	0f b6 c0             	movzbl %al,%eax
f010e541:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f010e544:	8b 45 08             	mov    0x8(%ebp),%eax
f010e547:	8b 78 30             	mov    0x30(%eax),%edi

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010e54a:	0f 20 d0             	mov    %cr2,%eax
f010e54d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	return val;
f010e550:	8b 75 e4             	mov    -0x1c(%ebp),%esi
f010e553:	8b 45 08             	mov    0x8(%ebp),%eax
f010e556:	8b 40 28             	mov    0x28(%eax),%eax
f010e559:	83 ec 0c             	sub    $0xc,%esp
f010e55c:	50                   	push   %eax
f010e55d:	e8 15 ea ff ff       	call   f010cf77 <trapname>
f010e562:	83 c4 10             	add    $0x10,%esp
f010e565:	89 c3                	mov    %eax,%ebx
f010e567:	8b 45 08             	mov    0x8(%ebp),%eax
f010e56a:	8b 48 28             	mov    0x28(%eax),%ecx
f010e56d:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010e571:	75 08                	jne    f010e57b <trap+0xfc>
f010e573:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e576:	8b 40 10             	mov    0x10(%eax),%eax
f010e579:	eb 05                	jmp    f010e580 <trap+0x101>
f010e57b:	b8 00 00 00 00       	mov    $0x0,%eax
f010e580:	83 7d dc 01          	cmpl   $0x1,-0x24(%ebp)
f010e584:	75 07                	jne    f010e58d <trap+0x10e>
f010e586:	ba 27 11 13 f0       	mov    $0xf0131127,%edx
f010e58b:	eb 05                	jmp    f010e592 <trap+0x113>
f010e58d:	ba 2c 11 13 f0       	mov    $0xf013112c,%edx
f010e592:	83 ec 0c             	sub    $0xc,%esp
f010e595:	ff 75 c4             	pushl  -0x3c(%ebp)
f010e598:	57                   	push   %edi
f010e599:	ff 75 08             	pushl  0x8(%ebp)
f010e59c:	56                   	push   %esi
f010e59d:	53                   	push   %ebx
f010e59e:	51                   	push   %ecx
f010e59f:	50                   	push   %eax
f010e5a0:	52                   	push   %edx
f010e5a1:	68 34 11 13 f0       	push   $0xf0131134
f010e5a6:	e8 b1 36 ff ff       	call   f0101c5c <cprintf>
f010e5ab:	83 c4 30             	add    $0x30,%esp
			panic("USER TRAP [%d:%s]: unexpected trapframe! cur_env->env_tf (%x) != tf (%x). Kernel stack [%x, %x)",
f010e5ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5b1:	8b 40 70             	mov    0x70(%eax),%eax
f010e5b4:	8d b0 00 80 00 00    	lea    0x8000(%eax),%esi
f010e5ba:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5bd:	8b 48 70             	mov    0x70(%eax),%ecx
f010e5c0:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5c3:	8b 10                	mov    (%eax),%edx
f010e5c5:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5c8:	8d 58 20             	lea    0x20(%eax),%ebx
f010e5cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010e5ce:	8b 40 10             	mov    0x10(%eax),%eax
f010e5d1:	83 ec 0c             	sub    $0xc,%esp
f010e5d4:	56                   	push   %esi
f010e5d5:	51                   	push   %ecx
f010e5d6:	ff 75 08             	pushl  0x8(%ebp)
f010e5d9:	52                   	push   %edx
f010e5da:	53                   	push   %ebx
f010e5db:	50                   	push   %eax
f010e5dc:	68 7c 11 13 f0       	push   $0xf013117c
f010e5e1:	68 5c 01 00 00       	push   $0x15c
f010e5e6:	68 56 10 13 f0       	push   $0xf0131056
f010e5eb:	e8 bf 29 ff ff       	call   f0100faf <_panic>
	//	if (tf->tf_trapno == T_SYSCALL)
	//	{
	//		cprintf("System Call #%d\n", tf->tf_regs.reg_eax);
	//	}
	//[3] Handle the incoming trap/interrupt
	if (tf->tf_trapno >= IRQ_OFFSET && tf->tf_trapno < IRQ_OFFSET + MAX_IRQS)
f010e5f0:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5f3:	8b 40 28             	mov    0x28(%eax),%eax
f010e5f6:	83 f8 1f             	cmp    $0x1f,%eax
f010e5f9:	76 1b                	jbe    f010e616 <trap+0x197>
f010e5fb:	8b 45 08             	mov    0x8(%ebp),%eax
f010e5fe:	8b 40 28             	mov    0x28(%eax),%eax
f010e601:	83 f8 2f             	cmp    $0x2f,%eax
f010e604:	77 10                	ja     f010e616 <trap+0x197>
	{
		irq_dispatch(tf);
f010e606:	83 ec 0c             	sub    $0xc,%esp
f010e609:	ff 75 08             	pushl  0x8(%ebp)
f010e60c:	e8 d6 fc ff ff       	call   f010e2e7 <irq_dispatch>
f010e611:	83 c4 10             	add    $0x10,%esp
f010e614:	eb 0e                	jmp    f010e624 <trap+0x1a5>
	}
	else
	{
		trap_dispatch(tf);
f010e616:	83 ec 0c             	sub    $0xc,%esp
f010e619:	ff 75 08             	pushl  0x8(%ebp)
f010e61c:	e8 0e fd ff ff       	call   f010e32f <trap_dispatch>
f010e621:	83 c4 10             	add    $0x10,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e624:	9c                   	pushf  
f010e625:	58                   	pop    %eax
f010e626:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        return eflags;
f010e629:	8b 45 d4             	mov    -0x2c(%ebp),%eax

	//cprintf("will be returned to the trapret() \n");
	/*2024: will be returned to the trapret() in trapentry.S which return to the caller*/

	//[4] Make sure that the interrupt is disabled before executing the trapret()
	uint32 IEN = read_eflags() & FL_IF;
f010e62c:	25 00 02 00 00       	and    $0x200,%eax
f010e631:	89 45 cc             	mov    %eax,-0x34(%ebp)
	assert(IEN == 0);
f010e634:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f010e638:	74 19                	je     f010e653 <trap+0x1d4>
f010e63a:	68 dc 11 13 f0       	push   $0xf01311dc
f010e63f:	68 12 11 13 f0       	push   $0xf0131112
f010e644:	68 73 01 00 00       	push   $0x173
f010e649:	68 56 10 13 f0       	push   $0xf0131056
f010e64e:	e8 5c 29 ff ff       	call   f0100faf <_panic>

	//cprintf("will resume the clock\n");

	//[5] Resume the clock
	kclock_resume();
f010e653:	e8 eb 76 ff ff       	call   f0105d43 <kclock_resume>
	//cprintf("\nclock is resumed with counter = %d.\n", kclock_read_cnt0_latch());
	//	cprintf("[tf] tf @%x - tf.cs = %x - tf.eip = %x - tf.eax = %d\n", tf, tf->tf_cs,tf->tf_eip, tf->tf_regs.reg_eax );
}
f010e658:	90                   	nop
f010e659:	8d 65 f4             	lea    -0xc(%ebp),%esp
f010e65c:	5b                   	pop    %ebx
f010e65d:	5e                   	pop    %esi
f010e65e:	5f                   	pop    %edi
f010e65f:	5d                   	pop    %ebp
f010e660:	c3                   	ret    
f010e661:	90                   	nop

f010e662 <DBL_FAULT>:
	jmp _alltraps

.text
/* Lab 3: Your code here for generating entry points for the different traps.
*/
TRAPHANDLER(DBL_FAULT, T_DBLFLT)					//8 double fault
f010e662:	6a 08                	push   $0x8
f010e664:	e9 ed 00 00 00       	jmp    f010e756 <_alltraps>
f010e669:	90                   	nop

f010e66a <PAGE_FAULT>:
TRAPHANDLER(PAGE_FAULT, T_PGFLT)					//14 page fault
f010e66a:	6a 0e                	push   $0xe
f010e66c:	e9 e5 00 00 00       	jmp    f010e756 <_alltraps>
f010e671:	90                   	nop

f010e672 <IRQ0_CLK_HANDLER>:
TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER, IRQ0_Clock)		//32 the first IRQ (clock iterrrupt)
f010e672:	6a 00                	push   $0x0
f010e674:	6a 20                	push   $0x20
f010e676:	e9 db 00 00 00       	jmp    f010e756 <_alltraps>
f010e67b:	90                   	nop

f010e67c <IRQ1_KBD_HANDLER>:
TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER, IRQ1_KB	)		//33 keyboard interrupt request
f010e67c:	6a 00                	push   $0x0
f010e67e:	6a 21                	push   $0x21
f010e680:	e9 d1 00 00 00       	jmp    f010e756 <_alltraps>
f010e685:	90                   	nop

f010e686 <SYSCALL_HANDLER>:
TRAPHANDLER_NOEC(SYSCALL_HANDLER, T_SYSCALL)		//48 SYSTEM CALLS
f010e686:	6a 00                	push   $0x0
f010e688:	6a 30                	push   $0x30
f010e68a:	e9 c7 00 00 00       	jmp    f010e756 <_alltraps>
f010e68f:	90                   	nop

f010e690 <ALL_FAULTS0>:

// FOS 2010
//TRAPHANDLER(GP_FAULT, T_GPFLT)

TRAPHANDLER_NOEC(ALL_FAULTS0, T_DIVIDE)		//0			// divide error
f010e690:	6a 00                	push   $0x0
f010e692:	6a 00                	push   $0x0
f010e694:	e9 bd 00 00 00       	jmp    f010e756 <_alltraps>
f010e699:	90                   	nop

f010e69a <ALL_FAULTS1>:
TRAPHANDLER_NOEC(ALL_FAULTS1, T_DEBUG   )	//1			// debug exception
f010e69a:	6a 00                	push   $0x0
f010e69c:	6a 01                	push   $0x1
f010e69e:	e9 b3 00 00 00       	jmp    f010e756 <_alltraps>
f010e6a3:	90                   	nop

f010e6a4 <ALL_FAULTS2>:
TRAPHANDLER_NOEC(ALL_FAULTS2,  T_NMI       )//2			// NMI: non-maskable interrupt
f010e6a4:	6a 00                	push   $0x0
f010e6a6:	6a 02                	push   $0x2
f010e6a8:	e9 a9 00 00 00       	jmp    f010e756 <_alltraps>
f010e6ad:	90                   	nop

f010e6ae <ALL_FAULTS3>:
TRAPHANDLER_NOEC(ALL_FAULTS3,  T_BRKPT     )//3			// breakpoint
f010e6ae:	6a 00                	push   $0x0
f010e6b0:	6a 03                	push   $0x3
f010e6b2:	e9 9f 00 00 00       	jmp    f010e756 <_alltraps>
f010e6b7:	90                   	nop

f010e6b8 <ALL_FAULTS4>:
TRAPHANDLER_NOEC(ALL_FAULTS4,  T_OFLOW     )//4			// overflow
f010e6b8:	6a 00                	push   $0x0
f010e6ba:	6a 04                	push   $0x4
f010e6bc:	e9 95 00 00 00       	jmp    f010e756 <_alltraps>
f010e6c1:	90                   	nop

f010e6c2 <ALL_FAULTS5>:
TRAPHANDLER_NOEC(ALL_FAULTS5,  T_BOUND     )//5			// bounds check
f010e6c2:	6a 00                	push   $0x0
f010e6c4:	6a 05                	push   $0x5
f010e6c6:	e9 8b 00 00 00       	jmp    f010e756 <_alltraps>
f010e6cb:	90                   	nop

f010e6cc <ALL_FAULTS6>:
TRAPHANDLER_NOEC(ALL_FAULTS6,  T_ILLOP     )//6			// illegal opcode
f010e6cc:	6a 00                	push   $0x0
f010e6ce:	6a 06                	push   $0x6
f010e6d0:	e9 81 00 00 00       	jmp    f010e756 <_alltraps>
f010e6d5:	90                   	nop

f010e6d6 <ALL_FAULTS7>:
TRAPHANDLER_NOEC(ALL_FAULTS7,  T_DEVICE    )//7			// device not available
f010e6d6:	6a 00                	push   $0x0
f010e6d8:	6a 07                	push   $0x7
f010e6da:	eb 7a                	jmp    f010e756 <_alltraps>

f010e6dc <ALL_FAULTS10>:
//TRAPHANDLER(ALL_FAULTS8,  T_DBLFLT)     	//8			// double fault
//TRAPHANDLER_NOEC(ALL_FAULTS9,  9   )		//9			// reserved (not generated by recent processors)
TRAPHANDLER(ALL_FAULTS10,  T_TSS       )	//10		// invalid task switch segment
f010e6dc:	6a 0a                	push   $0xa
f010e6de:	eb 76                	jmp    f010e756 <_alltraps>

f010e6e0 <ALL_FAULTS11>:
TRAPHANDLER(ALL_FAULTS11,  T_SEGNP     )	//11		// segment not present
f010e6e0:	6a 0b                	push   $0xb
f010e6e2:	eb 72                	jmp    f010e756 <_alltraps>

f010e6e4 <ALL_FAULTS12>:
TRAPHANDLER(ALL_FAULTS12,  T_STACK     )	//12		// stack exception
f010e6e4:	6a 0c                	push   $0xc
f010e6e6:	eb 6e                	jmp    f010e756 <_alltraps>

f010e6e8 <ALL_FAULTS13>:
TRAPHANDLER(ALL_FAULTS13,  T_GPFLT     )	//13		// General protection fault
f010e6e8:	6a 0d                	push   $0xd
f010e6ea:	eb 6a                	jmp    f010e756 <_alltraps>

f010e6ec <ALL_FAULTS16>:
//TRAPHANDLER(ALL_FAULTS14,  T_PGFLT)     	//14		// page fault
//TRAPHANDLER(ALL_FAULTS,  15    )			//15 		// reserved
TRAPHANDLER_NOEC(ALL_FAULTS16,  T_FPERR    )//16		// floating point error
f010e6ec:	6a 00                	push   $0x0
f010e6ee:	6a 10                	push   $0x10
f010e6f0:	eb 64                	jmp    f010e756 <_alltraps>

f010e6f2 <ALL_FAULTS17>:
TRAPHANDLER(ALL_FAULTS17,  T_ALIGN     )	//17		// Alignment check
f010e6f2:	6a 11                	push   $0x11
f010e6f4:	eb 60                	jmp    f010e756 <_alltraps>

f010e6f6 <ALL_FAULTS18>:
TRAPHANDLER_NOEC(ALL_FAULTS18,  T_MCHK     )//18		// machine check
f010e6f6:	6a 00                	push   $0x0
f010e6f8:	6a 12                	push   $0x12
f010e6fa:	eb 5a                	jmp    f010e756 <_alltraps>

f010e6fc <ALL_FAULTS19>:
TRAPHANDLER_NOEC(ALL_FAULTS19,  19      )	//19		// the last one
f010e6fc:	6a 00                	push   $0x0
f010e6fe:	6a 13                	push   $0x13
f010e700:	eb 54                	jmp    f010e756 <_alltraps>

f010e702 <ALL_FAULTS34>:

//TRAPHANDLER_NOEC(IRQ0_CLK_HANDLER,IRQ0_Clock)			//32 the first IRQ (clock iterrrupt)
//TRAPHANDLER_NOEC(IRQ1_KBD_HANDLER,IRQ1_KB	)			//33 keyboard interrupt request
TRAPHANDLER_NOEC(ALL_FAULTS34,      34		)//34
f010e702:	6a 00                	push   $0x0
f010e704:	6a 22                	push   $0x22
f010e706:	eb 4e                	jmp    f010e756 <_alltraps>

f010e708 <ALL_FAULTS35>:
TRAPHANDLER_NOEC(ALL_FAULTS35,		35		)//35
f010e708:	6a 00                	push   $0x0
f010e70a:	6a 23                	push   $0x23
f010e70c:	eb 48                	jmp    f010e756 <_alltraps>

f010e70e <ALL_FAULTS36>:
TRAPHANDLER_NOEC(ALL_FAULTS36,      36      )//36
f010e70e:	6a 00                	push   $0x0
f010e710:	6a 24                	push   $0x24
f010e712:	eb 42                	jmp    f010e756 <_alltraps>

f010e714 <ALL_FAULTS37>:
TRAPHANDLER_NOEC(ALL_FAULTS37,      37      )//37
f010e714:	6a 00                	push   $0x0
f010e716:	6a 25                	push   $0x25
f010e718:	eb 3c                	jmp    f010e756 <_alltraps>

f010e71a <ALL_FAULTS38>:
TRAPHANDLER_NOEC(ALL_FAULTS38,      38		)//38
f010e71a:	6a 00                	push   $0x0
f010e71c:	6a 26                	push   $0x26
f010e71e:	eb 36                	jmp    f010e756 <_alltraps>

f010e720 <ALL_FAULTS39>:
TRAPHANDLER_NOEC(ALL_FAULTS39,      39		)//39
f010e720:	6a 00                	push   $0x0
f010e722:	6a 27                	push   $0x27
f010e724:	eb 30                	jmp    f010e756 <_alltraps>

f010e726 <ALL_FAULTS40>:
TRAPHANDLER_NOEC(ALL_FAULTS40,      40		)//40
f010e726:	6a 00                	push   $0x0
f010e728:	6a 28                	push   $0x28
f010e72a:	eb 2a                	jmp    f010e756 <_alltraps>

f010e72c <ALL_FAULTS41>:
TRAPHANDLER_NOEC(ALL_FAULTS41,      41		)//41
f010e72c:	6a 00                	push   $0x0
f010e72e:	6a 29                	push   $0x29
f010e730:	eb 24                	jmp    f010e756 <_alltraps>

f010e732 <ALL_FAULTS42>:
TRAPHANDLER_NOEC(ALL_FAULTS42,      42		)//42
f010e732:	6a 00                	push   $0x0
f010e734:	6a 2a                	push   $0x2a
f010e736:	eb 1e                	jmp    f010e756 <_alltraps>

f010e738 <ALL_FAULTS43>:
TRAPHANDLER_NOEC(ALL_FAULTS43,      43		)//43
f010e738:	6a 00                	push   $0x0
f010e73a:	6a 2b                	push   $0x2b
f010e73c:	eb 18                	jmp    f010e756 <_alltraps>

f010e73e <ALL_FAULTS44>:
TRAPHANDLER_NOEC(ALL_FAULTS44,      44		)//44
f010e73e:	6a 00                	push   $0x0
f010e740:	6a 2c                	push   $0x2c
f010e742:	eb 12                	jmp    f010e756 <_alltraps>

f010e744 <ALL_FAULTS45>:
TRAPHANDLER_NOEC(ALL_FAULTS45,      45		)//45
f010e744:	6a 00                	push   $0x0
f010e746:	6a 2d                	push   $0x2d
f010e748:	eb 0c                	jmp    f010e756 <_alltraps>

f010e74a <ALL_FAULTS46>:
TRAPHANDLER_NOEC(ALL_FAULTS46,      46		)//46
f010e74a:	6a 00                	push   $0x0
f010e74c:	6a 2e                	push   $0x2e
f010e74e:	eb 06                	jmp    f010e756 <_alltraps>

f010e750 <ALL_FAULTS47>:
TRAPHANDLER_NOEC(ALL_FAULTS47,      47		)//47 		//the last IRQ
f010e750:	6a 00                	push   $0x0
f010e752:	6a 2f                	push   $0x2f
f010e754:	eb 00                	jmp    f010e756 <_alltraps>

f010e756 <_alltraps>:

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
push 	%ds
f010e756:	1e                   	push   %ds
push 	%es
f010e757:	06                   	push   %es
pushal
f010e758:	60                   	pusha  

mov 	$(GD_KD), %ax
f010e759:	66 b8 10 00          	mov    $0x10,%ax
mov 	%ax,%ds
f010e75d:	8e d8                	mov    %eax,%ds
mov 	%ax,%es
f010e75f:	8e c0                	mov    %eax,%es

push 	%esp /* push the pointer to the tf into the stack to be passed as a param to the trap()*/
f010e761:	54                   	push   %esp
call 	trap
f010e762:	e8 18 fd ff ff       	call   f010e47f <trap>

pop 	%ecx /* pop the pointer to the tf from the stack so that the stack top is at the beginning values of the registers pushed by pusha*/
f010e767:	59                   	pop    %ecx

f010e768 <trapret>:
.globl trapret
trapret:
popal
f010e768:	61                   	popa   
pop 	%es
f010e769:	07                   	pop    %es
pop 	%ds
f010e76a:	1f                   	pop    %ds
add 	$(8),%esp /*skipping the trap_no and the error code so that the stack top is at the old eip value*/
f010e76b:	83 c4 08             	add    $0x8,%esp
iret
f010e76e:	cf                   	iret   

f010e76f <sys_cputs>:

// Print a string to the system console.
// The string is exactly 'len' characters long.
// Destroys the environment on memory errors.
static void sys_cputs(const char *s, uint32 len, uint8 printProgName, int color)
{
f010e76f:	55                   	push   %ebp
f010e770:	89 e5                	mov    %esp,%ebp
f010e772:	83 ec 28             	sub    $0x28,%esp
f010e775:	8b 45 10             	mov    0x10(%ebp),%eax
f010e778:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f010e77b:	e8 98 d3 ff ff       	call   f010bb18 <get_cpu_proc>
f010e780:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e783:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e787:	75 16                	jne    f010e79f <sys_cputs+0x30>
f010e789:	68 90 13 13 f0       	push   $0xf0131390
f010e78e:	68 a0 13 13 f0       	push   $0xf01313a0
f010e793:	6a 22                	push   $0x22
f010e795:	68 b5 13 13 f0       	push   $0xf01313b5
f010e79a:	e8 10 28 ff ff       	call   f0100faf <_panic>

	pushcli();	//disable interrupts
f010e79f:	e8 8c 99 ff ff       	call   f0108130 <pushcli>
	{
		// Check that the user has permission to read memory [s, s+len).
		// Destroy the environment if not.
		current_text_color = color; // setting text color to be used in cga_putc()
f010e7a4:	8b 45 14             	mov    0x14(%ebp),%eax
f010e7a7:	a3 f0 6a 85 f0       	mov    %eax,0xf0856af0
		{
			// Print the string supplied by the user.
			if (printProgName)
f010e7ac:	80 7d e4 00          	cmpb   $0x0,-0x1c(%ebp)
f010e7b0:	74 1e                	je     f010e7d0 <sys_cputs+0x61>
				cprintf("[%s %d] ",cur_env->prog_name, cur_env->env_id);
f010e7b2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e7b5:	8b 40 10             	mov    0x10(%eax),%eax
f010e7b8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010e7bb:	83 c2 20             	add    $0x20,%edx
f010e7be:	83 ec 04             	sub    $0x4,%esp
f010e7c1:	50                   	push   %eax
f010e7c2:	52                   	push   %edx
f010e7c3:	68 c9 13 13 f0       	push   $0xf01313c9
f010e7c8:	e8 8f 34 ff ff       	call   f0101c5c <cprintf>
f010e7cd:	83 c4 10             	add    $0x10,%esp
			cprintf("%.*s",len, s);
f010e7d0:	83 ec 04             	sub    $0x4,%esp
f010e7d3:	ff 75 08             	pushl  0x8(%ebp)
f010e7d6:	ff 75 0c             	pushl  0xc(%ebp)
f010e7d9:	68 d2 13 13 f0       	push   $0xf01313d2
f010e7de:	e8 79 34 ff ff       	call   f0101c5c <cprintf>
f010e7e3:	83 c4 10             	add    $0x10,%esp
		}
		current_text_color = TEXT_DEFAULT_CLR; //restore default text color
f010e7e6:	c7 05 f0 6a 85 f0 00 	movl   $0x700,0xf0856af0
f010e7ed:	07 00 00 
	}
	popcli();	//enable interrupts
f010e7f0:	e8 8d 99 ff ff       	call   f0108182 <popcli>
}
f010e7f5:	90                   	nop
f010e7f6:	c9                   	leave  
f010e7f7:	c3                   	ret    

f010e7f8 <sys_cputc>:


// Print a char to the system console.
static void sys_cputc(const char c)
{
f010e7f8:	55                   	push   %ebp
f010e7f9:	89 e5                	mov    %esp,%ebp
f010e7fb:	83 ec 18             	sub    $0x18,%esp
f010e7fe:	8b 45 08             	mov    0x8(%ebp),%eax
f010e801:	88 45 f4             	mov    %al,-0xc(%ebp)
	// Print the char supplied by the user.
	cprintf("%c",c);
f010e804:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
f010e808:	83 ec 08             	sub    $0x8,%esp
f010e80b:	50                   	push   %eax
f010e80c:	68 d7 13 13 f0       	push   $0xf01313d7
f010e811:	e8 46 34 ff ff       	call   f0101c5c <cprintf>
f010e816:	83 c4 10             	add    $0x10,%esp
}
f010e819:	90                   	nop
f010e81a:	c9                   	leave  
f010e81b:	c3                   	ret    

f010e81c <sys_cgetc>:

// Read a character from the system console.
// Returns the character.
static int
sys_cgetc(void)
{
f010e81c:	55                   	push   %ebp
f010e81d:	89 e5                	mov    %esp,%ebp
f010e81f:	83 ec 18             	sub    $0x18,%esp

static __inline uint32
read_eflags(void)
{
        uint32 eflags;
        __asm __volatile("pushfl; popl %0" : "=r" (eflags));
f010e822:	9c                   	pushf  
f010e823:	58                   	pop    %eax
f010e824:	89 45 ec             	mov    %eax,-0x14(%ebp)
        return eflags;
f010e827:	8b 45 ec             	mov    -0x14(%ebp),%eax
	int c;
	int IEN = read_eflags() & FL_IF;
f010e82a:	25 00 02 00 00       	and    $0x200,%eax
f010e82f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (IEN) /*Interrupt-Enabled I/O*/
f010e832:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010e836:	74 10                	je     f010e848 <sys_cgetc+0x2c>
	{
		// The cons_getc2() primitive doesn't wait for a character
		while ((c = cons_getc2()) == 0)
f010e838:	e8 15 32 ff ff       	call   f0101a52 <cons_getc2>
f010e83d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e840:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e844:	74 f2                	je     f010e838 <sys_cgetc+0x1c>
f010e846:	eb 0e                	jmp    f010e856 <sys_cgetc+0x3a>
	else	/*Programmed I/O*/
	{
		//cprintf("\n(((((((Programmed I/O))))))\n");
		// The cons_getc() primitive doesn't wait for a character,
		// but the sys_cgetc() system call does.
		while ((c = cons_getc()) == 0)
f010e848:	e8 aa 31 ff ff       	call   f01019f7 <cons_getc>
f010e84d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010e850:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e854:	74 f2                	je     f010e848 <sys_cgetc+0x2c>
			/* do nothing */;
		}
	}
	//cprintf("\nCHAR %d is READ from KB, IEN = %d\n", c, read_eflags() & FL_IF);

	return c;
f010e856:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e859:	c9                   	leave  
f010e85a:	c3                   	ret    

f010e85b <sys_lock_cons>:

//Lock the console so that no other processes can read from KB or output to the monitor
void sys_lock_cons(void)
{
f010e85b:	55                   	push   %ebp
f010e85c:	89 e5                	mov    %esp,%ebp
f010e85e:	83 ec 08             	sub    $0x8,%esp
	cons_lock();
f010e861:	e8 1b 33 ff ff       	call   f0101b81 <cons_lock>
}
f010e866:	90                   	nop
f010e867:	c9                   	leave  
f010e868:	c3                   	ret    

f010e869 <sys_unlock_cons>:
//Unlock the console so that other processes can read from KB or output to the monitor
void sys_unlock_cons(void)
{
f010e869:	55                   	push   %ebp
f010e86a:	89 e5                	mov    %esp,%ebp
f010e86c:	83 ec 08             	sub    $0x8,%esp
	cons_unlock();
f010e86f:	e8 54 33 ff ff       	call   f0101bc8 <cons_unlock>
}
f010e874:	90                   	nop
f010e875:	c9                   	leave  
f010e876:	c3                   	ret    

f010e877 <__sys_allocate_page>:
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
//	E_INVAL if perm is inappropriate (see above).
//	E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_allocate_page(void *va, int perm)
{
f010e877:	55                   	push   %ebp
f010e878:	89 e5                	mov    %esp,%ebp
f010e87a:	83 ec 18             	sub    $0x18,%esp
	//   map_frame() from kern/mem/memory_manager.c.
	//   Most of the new code you write should be to check the
	//   parameters for correctness.
	//   If map_frame() fails, remember to free the page you allocated!

	struct Env* cur_env = get_cpu_proc();
f010e87d:	e8 96 d2 ff ff       	call   f010bb18 <get_cpu_proc>
f010e882:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f010e885:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e889:	75 07                	jne    f010e892 <__sys_allocate_page+0x1b>
		return E_BAD_ENV;
f010e88b:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010e890:	eb 5d                	jmp    f010e8ef <__sys_allocate_page+0x78>

	//check virtual address to be paged_aligned and < USER_TOP
	if ((uint32)va >= USER_TOP || (uint32)va % PAGE_SIZE != 0)
f010e892:	8b 45 08             	mov    0x8(%ebp),%eax
f010e895:	3d ff ff bf ee       	cmp    $0xeebfffff,%eax
f010e89a:	77 0c                	ja     f010e8a8 <__sys_allocate_page+0x31>
f010e89c:	8b 45 08             	mov    0x8(%ebp),%eax
f010e89f:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e8a4:	85 c0                	test   %eax,%eax
f010e8a6:	74 07                	je     f010e8af <__sys_allocate_page+0x38>
		return E_INVAL;
f010e8a8:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e8ad:	eb 40                	jmp    f010e8ef <__sys_allocate_page+0x78>

	//check permissions to be appropriate
	if ((perm & (~PERM_AVAILABLE & ~PERM_WRITEABLE)) != (PERM_USER))
f010e8af:	8b 45 0c             	mov    0xc(%ebp),%eax
f010e8b2:	25 fd f1 ff ff       	and    $0xfffff1fd,%eax
f010e8b7:	83 f8 04             	cmp    $0x4,%eax
f010e8ba:	74 07                	je     f010e8c3 <__sys_allocate_page+0x4c>
		return E_INVAL;
f010e8bc:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e8c1:	eb 2c                	jmp    f010e8ef <__sys_allocate_page+0x78>

	int ret = alloc_page(cur_env->env_page_directory, (uint32)va, perm, 1);
f010e8c3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
f010e8c6:	8b 55 08             	mov    0x8(%ebp),%edx
f010e8c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e8cc:	8b 40 64             	mov    0x64(%eax),%eax
f010e8cf:	6a 01                	push   $0x1
f010e8d1:	51                   	push   %ecx
f010e8d2:	52                   	push   %edx
f010e8d3:	50                   	push   %eax
f010e8d4:	e8 75 b5 ff ff       	call   f0109e4e <alloc_page>
f010e8d9:	83 c4 10             	add    $0x10,%esp
f010e8dc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret == E_NO_MEM)
f010e8df:	83 7d f0 fc          	cmpl   $0xfffffffc,-0x10(%ebp)
f010e8e3:	75 05                	jne    f010e8ea <__sys_allocate_page+0x73>
		return ret ;
f010e8e5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e8e8:	eb 05                	jmp    f010e8ef <__sys_allocate_page+0x78>

	return 0 ;
f010e8ea:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e8ef:	c9                   	leave  
f010e8f0:	c3                   	ret    

f010e8f1 <__sys_map_frame>:
//	-E_INVAL if (perm & PTE_W), but srcva is read-only in srcenvid's
//		address space.
//	-E_NO_MEM if there's no memory to allocate the new page,
//		or to allocate any necessary page tables.
static int __sys_map_frame(int32 srcenvid, void *srcva, int32 dstenvid, void *dstva, int perm)
{
f010e8f1:	55                   	push   %ebp
f010e8f2:	89 e5                	mov    %esp,%ebp
f010e8f4:	83 ec 08             	sub    $0x8,%esp
	//   parameters for correctness.
	//   Use the third argument to page_lookup() to
	//   check the current permissions on the page.

	// LAB 4: Your code here.
	panic("sys_map_frame not implemented");
f010e8f7:	83 ec 04             	sub    $0x4,%esp
f010e8fa:	68 da 13 13 f0       	push   $0xf01313da
f010e8ff:	68 bb 00 00 00       	push   $0xbb
f010e904:	68 b5 13 13 f0       	push   $0xf01313b5
f010e909:	e8 a1 26 ff ff       	call   f0100faf <_panic>

f010e90e <__sys_unmap_frame>:
//
// Return 0 on success, < 0 on error.  Errors are:
//	E_BAD_ENV if environment doesn't currently exist,
//	E_INVAL if va >= USER_TOP, or va is not page-aligned.
static int __sys_unmap_frame(uint32 va)
{
f010e90e:	55                   	push   %ebp
f010e90f:	89 e5                	mov    %esp,%ebp
f010e911:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e914:	e8 ff d1 ff ff       	call   f010bb18 <get_cpu_proc>
f010e919:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(cur_env == NULL)
f010e91c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e920:	75 07                	jne    f010e929 <__sys_unmap_frame+0x1b>
		return E_BAD_ENV;
f010e922:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
f010e927:	eb 36                	jmp    f010e95f <__sys_unmap_frame+0x51>

	if (va >= USER_TOP || va % PAGE_SIZE != 0)
f010e929:	81 7d 08 ff ff bf ee 	cmpl   $0xeebfffff,0x8(%ebp)
f010e930:	77 0c                	ja     f010e93e <__sys_unmap_frame+0x30>
f010e932:	8b 45 08             	mov    0x8(%ebp),%eax
f010e935:	25 ff 0f 00 00       	and    $0xfff,%eax
f010e93a:	85 c0                	test   %eax,%eax
f010e93c:	74 07                	je     f010e945 <__sys_unmap_frame+0x37>
		return E_INVAL;
f010e93e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
f010e943:	eb 1a                	jmp    f010e95f <__sys_unmap_frame+0x51>

	unmap_frame(cur_env->env_page_directory, va);
f010e945:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e948:	8b 40 64             	mov    0x64(%eax),%eax
f010e94b:	83 ec 08             	sub    $0x8,%esp
f010e94e:	ff 75 08             	pushl  0x8(%ebp)
f010e951:	50                   	push   %eax
f010e952:	e8 f8 ad ff ff       	call   f010974f <unmap_frame>
f010e957:	83 c4 10             	add    $0x10,%esp
	return 0;
f010e95a:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010e95f:	c9                   	leave  
f010e960:	c3                   	ret    

f010e961 <sys_calculate_required_frames>:

uint32 sys_calculate_required_frames(uint32 start_virtual_address, uint32 size)
{
f010e961:	55                   	push   %ebp
f010e962:	89 e5                	mov    %esp,%ebp
f010e964:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010e967:	e8 ac d1 ff ff       	call   f010bb18 <get_cpu_proc>
f010e96c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010e96f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010e973:	75 19                	jne    f010e98e <sys_calculate_required_frames+0x2d>
f010e975:	68 90 13 13 f0       	push   $0xf0131390
f010e97a:	68 a0 13 13 f0       	push   $0xf01313a0
f010e97f:	68 d6 00 00 00       	push   $0xd6
f010e984:	68 b5 13 13 f0       	push   $0xf01313b5
f010e989:	e8 21 26 ff ff       	call   f0100faf <_panic>

	return calculate_required_frames(cur_env->env_page_directory, start_virtual_address, size);
f010e98e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010e991:	8b 40 64             	mov    0x64(%eax),%eax
f010e994:	83 ec 04             	sub    $0x4,%esp
f010e997:	ff 75 0c             	pushl  0xc(%ebp)
f010e99a:	ff 75 08             	pushl  0x8(%ebp)
f010e99d:	50                   	push   %eax
f010e99e:	e8 78 c3 ff ff       	call   f010ad1b <calculate_required_frames>
f010e9a3:	83 c4 10             	add    $0x10,%esp
}
f010e9a6:	c9                   	leave  
f010e9a7:	c3                   	ret    

f010e9a8 <sys_calculate_free_frames>:

uint32 sys_calculate_free_frames()
{
f010e9a8:	55                   	push   %ebp
f010e9a9:	89 e5                	mov    %esp,%ebp
f010e9ab:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9ae:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9b1:	83 ec 0c             	sub    $0xc,%esp
f010e9b4:	50                   	push   %eax
f010e9b5:	e8 17 af ff ff       	call   f01098d1 <calculate_available_frames>
f010e9ba:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("Free Frames = %d : Buffered = %d, Not Buffered = %d\n", counters.freeBuffered + counters.freeNotBuffered, counters.freeBuffered ,counters.freeNotBuffered);
	return counters.freeBuffered + counters.freeNotBuffered;
f010e9bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010e9c0:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010e9c3:	01 d0                	add    %edx,%eax
}
f010e9c5:	c9                   	leave  
f010e9c6:	c3                   	ret    

f010e9c7 <sys_calculate_modified_frames>:
uint32 sys_calculate_modified_frames()
{
f010e9c7:	55                   	push   %ebp
f010e9c8:	89 e5                	mov    %esp,%ebp
f010e9ca:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9cd:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9d0:	83 ec 0c             	sub    $0xc,%esp
f010e9d3:	50                   	push   %eax
f010e9d4:	e8 f8 ae ff ff       	call   f01098d1 <calculate_available_frames>
f010e9d9:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Modified Frames = %d\n", counters.modified) ;
	return counters.modified;
f010e9dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f010e9df:	c9                   	leave  
f010e9e0:	c3                   	ret    

f010e9e1 <sys_calculate_notmod_frames>:

uint32 sys_calculate_notmod_frames()
{
f010e9e1:	55                   	push   %ebp
f010e9e2:	89 e5                	mov    %esp,%ebp
f010e9e4:	83 ec 18             	sub    $0x18,%esp
	struct freeFramesCounters counters = calculate_available_frames();
f010e9e7:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010e9ea:	83 ec 0c             	sub    $0xc,%esp
f010e9ed:	50                   	push   %eax
f010e9ee:	e8 de ae ff ff       	call   f01098d1 <calculate_available_frames>
f010e9f3:	83 c4 0c             	add    $0xc,%esp
	//	cprintf("================ Not Modified Frames = %d\n", counters.freeBuffered) ;
	return counters.freeBuffered;
f010e9f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
f010e9f9:	c9                   	leave  
f010e9fa:	c3                   	ret    

f010e9fb <sys_calculate_pages_tobe_removed_ready_exit>:

int sys_calculate_pages_tobe_removed_ready_exit(uint32 WS_or_MEMORY_flag)
{
f010e9fb:	55                   	push   %ebp
f010e9fc:	89 e5                	mov    %esp,%ebp
f010e9fe:	83 ec 08             	sub    $0x8,%esp
	return calc_no_pages_tobe_removed_from_ready_exit_queues(WS_or_MEMORY_flag);
f010ea01:	83 ec 0c             	sub    $0xc,%esp
f010ea04:	ff 75 08             	pushl  0x8(%ebp)
f010ea07:	e8 5e ae 00 00       	call   f011986a <calc_no_pages_tobe_removed_from_ready_exit_queues>
f010ea0c:	83 c4 10             	add    $0x10,%esp
}
f010ea0f:	c9                   	leave  
f010ea10:	c3                   	ret    

f010ea11 <sys_scarce_memory>:

void sys_scarce_memory(void)
{
f010ea11:	55                   	push   %ebp
f010ea12:	89 e5                	mov    %esp,%ebp
f010ea14:	83 ec 08             	sub    $0x8,%esp
	scarce_memory();
f010ea17:	e8 79 ad 00 00       	call   f0119795 <scarce_memory>
}
f010ea1c:	90                   	nop
f010ea1d:	c9                   	leave  
f010ea1e:	c3                   	ret    

f010ea1f <sys_clearFFL>:

void sys_clearFFL()
{
f010ea1f:	55                   	push   %ebp
f010ea20:	89 e5                	mov    %esp,%ebp
f010ea22:	83 ec 18             	sub    $0x18,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
f010ea25:	83 ec 0c             	sub    $0xc,%esp
f010ea28:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010ea2d:	e8 49 14 00 00       	call   f010fe7b <acquire_kspinlock>
f010ea32:	83 c4 10             	add    $0x10,%esp
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
f010ea35:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f010ea3a:	89 45 f0             	mov    %eax,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ea3d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f010ea44:	eb 12                	jmp    f010ea58 <sys_clearFFL+0x39>
		{
			allocate_frame(&ptr_tmp_FI) ;
f010ea46:	83 ec 0c             	sub    $0xc,%esp
f010ea49:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ea4c:	50                   	push   %eax
f010ea4d:	e8 f0 a6 ff ff       	call   f0109142 <allocate_frame>
f010ea52:	83 c4 10             	add    $0x10,%esp
	int size;
	acquire_kspinlock(&MemFrameLists.mfllock);
	{
		size = LIST_SIZE(&MemFrameLists.free_frame_list) ;
		struct FrameInfo* ptr_tmp_FI ;
		for (int i = 0; i < size ; i++)
f010ea55:	ff 45 f4             	incl   -0xc(%ebp)
f010ea58:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ea5b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010ea5e:	7c e6                	jl     f010ea46 <sys_clearFFL+0x27>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f010ea60:	83 ec 0c             	sub    $0xc,%esp
f010ea63:	68 e0 e7 83 f0       	push   $0xf083e7e0
f010ea68:	e8 b3 14 00 00       	call   f010ff20 <release_kspinlock>
f010ea6d:	83 c4 10             	add    $0x10,%esp
}
f010ea70:	90                   	nop
f010ea71:	c9                   	leave  
f010ea72:	c3                   	ret    

f010ea73 <sys_pf_calculate_allocated_pages>:

/*******************************/
/* PAGE FILE SYSTEM CALLS */
/*******************************/
int sys_pf_calculate_allocated_pages(void)
{
f010ea73:	55                   	push   %ebp
f010ea74:	89 e5                	mov    %esp,%ebp
f010ea76:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ea79:	e8 9a d0 ff ff       	call   f010bb18 <get_cpu_proc>
f010ea7e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ea81:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ea85:	75 19                	jne    f010eaa0 <sys_pf_calculate_allocated_pages+0x2d>
f010ea87:	68 90 13 13 f0       	push   $0xf0131390
f010ea8c:	68 a0 13 13 f0       	push   $0xf01313a0
f010ea91:	68 0e 01 00 00       	push   $0x10e
f010ea96:	68 b5 13 13 f0       	push   $0xf01313b5
f010ea9b:	e8 0f 25 ff ff       	call   f0100faf <_panic>

	return pf_calculate_allocated_pages(cur_env);
f010eaa0:	83 ec 0c             	sub    $0xc,%esp
f010eaa3:	ff 75 f4             	pushl  -0xc(%ebp)
f010eaa6:	e8 de 6d ff ff       	call   f0105889 <pf_calculate_allocated_pages>
f010eaab:	83 c4 10             	add    $0x10,%esp
}
f010eaae:	c9                   	leave  
f010eaaf:	c3                   	ret    

f010eab0 <sys_free_user_mem>:

/*******************************/
/* USER HEAP SYSTEM CALLS */
/*******************************/
void sys_free_user_mem(uint32 virtual_address, uint32 size)
{
f010eab0:	55                   	push   %ebp
f010eab1:	89 e5                	mov    %esp,%ebp
f010eab3:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010eab6:	e8 5d d0 ff ff       	call   f010bb18 <get_cpu_proc>
f010eabb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eabe:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eac2:	75 19                	jne    f010eadd <sys_free_user_mem+0x2d>
f010eac4:	68 90 13 13 f0       	push   $0xf0131390
f010eac9:	68 a0 13 13 f0       	push   $0xf01313a0
f010eace:	68 19 01 00 00       	push   $0x119
f010ead3:	68 b5 13 13 f0       	push   $0xf01313b5
f010ead8:	e8 d2 24 ff ff       	call   f0100faf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f010eadd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010eae1:	74 2b                	je     f010eb0e <sys_free_user_mem+0x5e>
f010eae3:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010eaea:	77 22                	ja     f010eb0e <sys_free_user_mem+0x5e>
f010eaec:	8b 45 08             	mov    0x8(%ebp),%eax
f010eaef:	85 c0                	test   %eax,%eax
f010eaf1:	79 1b                	jns    f010eb0e <sys_free_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f010eaf3:	8b 55 08             	mov    0x8(%ebp),%edx
f010eaf6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eaf9:	01 d0                	add    %edx,%eax
f010eafb:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f010eb00:	77 0c                	ja     f010eb0e <sys_free_user_mem+0x5e>
f010eb02:	8b 55 08             	mov    0x8(%ebp),%edx
f010eb05:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eb08:	01 d0                	add    %edx,%eax
f010eb0a:	85 c0                	test   %eax,%eax
f010eb0c:	78 15                	js     f010eb23 <sys_free_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f010eb0e:	83 ec 0c             	sub    $0xc,%esp
f010eb11:	68 f8 13 13 f0       	push   $0xf01313f8
f010eb16:	e8 41 31 ff ff       	call   f0101c5c <cprintf>
f010eb1b:	83 c4 10             	add    $0x10,%esp
		env_exit();
f010eb1e:	e8 b3 cf ff ff       	call   f010bad6 <env_exit>
	}

	if(isBufferingEnabled())
f010eb23:	e8 d9 0e 00 00       	call   f010fa01 <isBufferingEnabled>
f010eb28:	84 c0                	test   %al,%al
f010eb2a:	74 16                	je     f010eb42 <sys_free_user_mem+0x92>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
f010eb2c:	83 ec 04             	sub    $0x4,%esp
f010eb2f:	ff 75 0c             	pushl  0xc(%ebp)
f010eb32:	ff 75 08             	pushl  0x8(%ebp)
f010eb35:	ff 75 f4             	pushl  -0xc(%ebp)
f010eb38:	e8 4f c2 ff ff       	call   f010ad8c <__free_user_mem_with_buffering>
f010eb3d:	83 c4 10             	add    $0x10,%esp
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
	}
	return;
f010eb40:	eb 15                	jmp    f010eb57 <sys_free_user_mem+0xa7>
	{
		__free_user_mem_with_buffering(cur_env, virtual_address, size);
	}
	else
	{
		free_user_mem(cur_env, virtual_address, size);
f010eb42:	83 ec 04             	sub    $0x4,%esp
f010eb45:	ff 75 0c             	pushl  0xc(%ebp)
f010eb48:	ff 75 08             	pushl  0x8(%ebp)
f010eb4b:	ff 75 f4             	pushl  -0xc(%ebp)
f010eb4e:	e8 1c c2 ff ff       	call   f010ad6f <free_user_mem>
f010eb53:	83 c4 10             	add    $0x10,%esp
	}
	return;
f010eb56:	90                   	nop
}
f010eb57:	c9                   	leave  
f010eb58:	c3                   	ret    

f010eb59 <sys_allocate_user_mem>:

void sys_allocate_user_mem(uint32 virtual_address, uint32 size)
{
f010eb59:	55                   	push   %ebp
f010eb5a:	89 e5                	mov    %esp,%ebp
f010eb5c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010eb5f:	e8 b4 cf ff ff       	call   f010bb18 <get_cpu_proc>
f010eb64:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010eb67:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eb6b:	75 19                	jne    f010eb86 <sys_allocate_user_mem+0x2d>
f010eb6d:	68 90 13 13 f0       	push   $0xf0131390
f010eb72:	68 a0 13 13 f0       	push   $0xf01313a0
f010eb77:	68 30 01 00 00       	push   $0x130
f010eb7c:	68 b5 13 13 f0       	push   $0xf01313b5
f010eb81:	e8 29 24 ff ff       	call   f0100faf <_panic>

	if (virtual_address == 0 || (virtual_address >= USER_HEAP_MAX) || (virtual_address < USER_HEAP_START)
f010eb86:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010eb8a:	74 2b                	je     f010ebb7 <sys_allocate_user_mem+0x5e>
f010eb8c:	81 7d 08 ff ff ff 9f 	cmpl   $0x9fffffff,0x8(%ebp)
f010eb93:	77 22                	ja     f010ebb7 <sys_allocate_user_mem+0x5e>
f010eb95:	8b 45 08             	mov    0x8(%ebp),%eax
f010eb98:	85 c0                	test   %eax,%eax
f010eb9a:	79 1b                	jns    f010ebb7 <sys_allocate_user_mem+0x5e>
		|| (virtual_address + size >= USER_HEAP_MAX) || (virtual_address + size < USER_HEAP_START))
f010eb9c:	8b 55 08             	mov    0x8(%ebp),%edx
f010eb9f:	8b 45 0c             	mov    0xc(%ebp),%eax
f010eba2:	01 d0                	add    %edx,%eax
f010eba4:	3d ff ff ff 9f       	cmp    $0x9fffffff,%eax
f010eba9:	77 0c                	ja     f010ebb7 <sys_allocate_user_mem+0x5e>
f010ebab:	8b 55 08             	mov    0x8(%ebp),%edx
f010ebae:	8b 45 0c             	mov    0xc(%ebp),%eax
f010ebb1:	01 d0                	add    %edx,%eax
f010ebb3:	85 c0                	test   %eax,%eax
f010ebb5:	78 15                	js     f010ebcc <sys_allocate_user_mem+0x73>
	{
		cprintf("\nsys_free_user_mem(): ILLEGAL ADDRESS! Process will be terminated...\n");
f010ebb7:	83 ec 0c             	sub    $0xc,%esp
f010ebba:	68 f8 13 13 f0       	push   $0xf01313f8
f010ebbf:	e8 98 30 ff ff       	call   f0101c5c <cprintf>
f010ebc4:	83 c4 10             	add    $0x10,%esp
		env_exit();
f010ebc7:	e8 0a cf ff ff       	call   f010bad6 <env_exit>
	}
	allocate_user_mem(cur_env, virtual_address, size);
f010ebcc:	83 ec 04             	sub    $0x4,%esp
f010ebcf:	ff 75 0c             	pushl  0xc(%ebp)
f010ebd2:	ff 75 08             	pushl  0x8(%ebp)
f010ebd5:	ff 75 f4             	pushl  -0xc(%ebp)
f010ebd8:	e8 75 c1 ff ff       	call   f010ad52 <allocate_user_mem>
f010ebdd:	83 c4 10             	add    $0x10,%esp
	return;
f010ebe0:	90                   	nop
}
f010ebe1:	c9                   	leave  
f010ebe2:	c3                   	ret    

f010ebe3 <sys_allocate_chunk>:

void sys_allocate_chunk(uint32 virtual_address, uint32 size, uint32 perms)
{
f010ebe3:	55                   	push   %ebp
f010ebe4:	89 e5                	mov    %esp,%ebp
f010ebe6:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ebe9:	e8 2a cf ff ff       	call   f010bb18 <get_cpu_proc>
f010ebee:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ebf1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ebf5:	75 19                	jne    f010ec10 <sys_allocate_chunk+0x2d>
f010ebf7:	68 90 13 13 f0       	push   $0xf0131390
f010ebfc:	68 a0 13 13 f0       	push   $0xf01313a0
f010ec01:	68 3f 01 00 00       	push   $0x13f
f010ec06:	68 b5 13 13 f0       	push   $0xf01313b5
f010ec0b:	e8 9f 23 ff ff       	call   f0100faf <_panic>

	allocate_chunk(cur_env->env_page_directory, virtual_address, size, perms);
f010ec10:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ec13:	8b 40 64             	mov    0x64(%eax),%eax
f010ec16:	ff 75 10             	pushl  0x10(%ebp)
f010ec19:	ff 75 0c             	pushl  0xc(%ebp)
f010ec1c:	ff 75 08             	pushl  0x8(%ebp)
f010ec1f:	50                   	push   %eax
f010ec20:	e8 a8 c0 ff ff       	call   f010accd <allocate_chunk>
f010ec25:	83 c4 10             	add    $0x10,%esp
	return;
f010ec28:	90                   	nop
}
f010ec29:	c9                   	leave  
f010ec2a:	c3                   	ret    

f010ec2b <sys_move_user_mem>:

//2014
void sys_move_user_mem(uint32 src_virtual_address, uint32 dst_virtual_address, uint32 size)
{
f010ec2b:	55                   	push   %ebp
f010ec2c:	89 e5                	mov    %esp,%ebp
f010ec2e:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ec31:	e8 e2 ce ff ff       	call   f010bb18 <get_cpu_proc>
f010ec36:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ec39:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec3d:	75 19                	jne    f010ec58 <sys_move_user_mem+0x2d>
f010ec3f:	68 90 13 13 f0       	push   $0xf0131390
f010ec44:	68 a0 13 13 f0       	push   $0xf01313a0
f010ec49:	68 49 01 00 00       	push   $0x149
f010ec4e:	68 b5 13 13 f0       	push   $0xf01313b5
f010ec53:	e8 57 23 ff ff       	call   f0100faf <_panic>

	move_user_mem(cur_env, src_virtual_address, dst_virtual_address, size);
f010ec58:	ff 75 10             	pushl  0x10(%ebp)
f010ec5b:	ff 75 0c             	pushl  0xc(%ebp)
f010ec5e:	ff 75 08             	pushl  0x8(%ebp)
f010ec61:	ff 75 f4             	pushl  -0xc(%ebp)
f010ec64:	e8 40 c1 ff ff       	call   f010ada9 <move_user_mem>
f010ec69:	83 c4 10             	add    $0x10,%esp
	return;
f010ec6c:	90                   	nop
}
f010ec6d:	c9                   	leave  
f010ec6e:	c3                   	ret    

f010ec6f <sys_get_heap_strategy>:

//2015
uint32 sys_get_heap_strategy()
{
f010ec6f:	55                   	push   %ebp
f010ec70:	89 e5                	mov    %esp,%ebp
	return _UHeapPlacementStrategy ;
f010ec72:	a1 e8 6a 85 f0       	mov    0xf0856ae8,%eax
}
f010ec77:	5d                   	pop    %ebp
f010ec78:	c3                   	ret    

f010ec79 <sys_set_uheap_strategy>:
void sys_set_uheap_strategy(uint32 heapStrategy)
{
f010ec79:	55                   	push   %ebp
f010ec7a:	89 e5                	mov    %esp,%ebp
	_UHeapPlacementStrategy = heapStrategy;
f010ec7c:	8b 45 08             	mov    0x8(%ebp),%eax
f010ec7f:	a3 e8 6a 85 f0       	mov    %eax,0xf0856ae8
}
f010ec84:	90                   	nop
f010ec85:	5d                   	pop    %ebp
f010ec86:	c3                   	ret    

f010ec87 <sys_create_shared_object>:

/*******************************/
/* SHARED MEMORY SYSTEM CALLS */
/*******************************/
int sys_create_shared_object(char* shareName, uint32 size, uint8 isWritable, void* virtual_address)
{
f010ec87:	55                   	push   %ebp
f010ec88:	89 e5                	mov    %esp,%ebp
f010ec8a:	83 ec 28             	sub    $0x28,%esp
f010ec8d:	8b 45 10             	mov    0x10(%ebp),%eax
f010ec90:	88 45 e4             	mov    %al,-0x1c(%ebp)
	struct Env* cur_env = get_cpu_proc();
f010ec93:	e8 80 ce ff ff       	call   f010bb18 <get_cpu_proc>
f010ec98:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ec9b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ec9f:	75 19                	jne    f010ecba <sys_create_shared_object+0x33>
f010eca1:	68 90 13 13 f0       	push   $0xf0131390
f010eca6:	68 a0 13 13 f0       	push   $0xf01313a0
f010ecab:	68 64 01 00 00       	push   $0x164
f010ecb0:	68 b5 13 13 f0       	push   $0xf01313b5
f010ecb5:	e8 f5 22 ff ff       	call   f0100faf <_panic>

	return create_shared_object(cur_env->env_id, shareName, size, isWritable, virtual_address);
f010ecba:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
f010ecbe:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ecc1:	8b 40 10             	mov    0x10(%eax),%eax
f010ecc4:	83 ec 0c             	sub    $0xc,%esp
f010ecc7:	ff 75 14             	pushl  0x14(%ebp)
f010ecca:	52                   	push   %edx
f010eccb:	ff 75 0c             	pushl  0xc(%ebp)
f010ecce:	ff 75 08             	pushl  0x8(%ebp)
f010ecd1:	50                   	push   %eax
f010ecd2:	e8 1e ae ff ff       	call   f0109af5 <create_shared_object>
f010ecd7:	83 c4 20             	add    $0x20,%esp
}
f010ecda:	c9                   	leave  
f010ecdb:	c3                   	ret    

f010ecdc <sys_size_of_shared_object>:

int sys_size_of_shared_object(int32 ownerID, char* shareName)
{
f010ecdc:	55                   	push   %ebp
f010ecdd:	89 e5                	mov    %esp,%ebp
f010ecdf:	83 ec 08             	sub    $0x8,%esp
	return size_of_shared_object(ownerID, shareName);
f010ece2:	83 ec 08             	sub    $0x8,%esp
f010ece5:	ff 75 0c             	pushl  0xc(%ebp)
f010ece8:	ff 75 08             	pushl  0x8(%ebp)
f010eceb:	e8 b6 ad ff ff       	call   f0109aa6 <size_of_shared_object>
f010ecf0:	83 c4 10             	add    $0x10,%esp
}
f010ecf3:	c9                   	leave  
f010ecf4:	c3                   	ret    

f010ecf5 <sys_get_shared_object>:

int sys_get_shared_object(int32 ownerID, char* shareName, void* virtual_address)
{
f010ecf5:	55                   	push   %ebp
f010ecf6:	89 e5                	mov    %esp,%ebp
f010ecf8:	83 ec 08             	sub    $0x8,%esp
	return get_shared_object(ownerID, shareName, virtual_address);
f010ecfb:	83 ec 04             	sub    $0x4,%esp
f010ecfe:	ff 75 10             	pushl  0x10(%ebp)
f010ed01:	ff 75 0c             	pushl  0xc(%ebp)
f010ed04:	ff 75 08             	pushl  0x8(%ebp)
f010ed07:	e8 09 ae ff ff       	call   f0109b15 <get_shared_object>
f010ed0c:	83 c4 10             	add    $0x10,%esp
}
f010ed0f:	c9                   	leave  
f010ed10:	c3                   	ret    

f010ed11 <sys_delete_shared_object>:

int sys_delete_shared_object(int32 sharedObjectID, void *startVA)
{
f010ed11:	55                   	push   %ebp
f010ed12:	89 e5                	mov    %esp,%ebp
f010ed14:	83 ec 08             	sub    $0x8,%esp
	return delete_shared_object(sharedObjectID, startVA);
f010ed17:	83 ec 08             	sub    $0x8,%esp
f010ed1a:	ff 75 0c             	pushl  0xc(%ebp)
f010ed1d:	ff 75 08             	pushl  0x8(%ebp)
f010ed20:	e8 2a ae ff ff       	call   f0109b4f <delete_shared_object>
f010ed25:	83 c4 10             	add    $0x10,%esp
}
f010ed28:	c9                   	leave  
f010ed29:	c3                   	ret    

f010ed2a <sys_getenvid>:
/* USER ENVIRONMENT SYSTEM CALLS */
/*********************************/
// Returns the current environment's envid.
//2017
static int32 sys_getenvid(void)
{
f010ed2a:	55                   	push   %ebp
f010ed2b:	89 e5                	mov    %esp,%ebp
f010ed2d:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ed30:	e8 e3 cd ff ff       	call   f010bb18 <get_cpu_proc>
f010ed35:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ed38:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed3c:	75 19                	jne    f010ed57 <sys_getenvid+0x2d>
f010ed3e:	68 90 13 13 f0       	push   $0xf0131390
f010ed43:	68 a0 13 13 f0       	push   $0xf01313a0
f010ed48:	68 80 01 00 00       	push   $0x180
f010ed4d:	68 b5 13 13 f0       	push   $0xf01313b5
f010ed52:	e8 58 22 ff ff       	call   f0100faf <_panic>

	return cur_env->env_id;
f010ed57:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed5a:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ed5d:	c9                   	leave  
f010ed5e:	c3                   	ret    

f010ed5f <sys_getenvindex>:

//2017
static int32 sys_getenvindex(void)
{
f010ed5f:	55                   	push   %ebp
f010ed60:	89 e5                	mov    %esp,%ebp
f010ed62:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ed65:	e8 ae cd ff ff       	call   f010bb18 <get_cpu_proc>
f010ed6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ed6d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ed71:	75 19                	jne    f010ed8c <sys_getenvindex+0x2d>
f010ed73:	68 90 13 13 f0       	push   $0xf0131390
f010ed78:	68 a0 13 13 f0       	push   $0xf01313a0
f010ed7d:	68 89 01 00 00       	push   $0x189
f010ed82:	68 b5 13 13 f0       	push   $0xf01313b5
f010ed87:	e8 23 22 ff ff       	call   f0100faf <_panic>

	//return cur_env->env_id;
	return (cur_env - envs) ;
f010ed8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ed8f:	8b 15 90 5b 81 f0    	mov    0xf0815b90,%edx
f010ed95:	29 d0                	sub    %edx,%eax
f010ed97:	c1 f8 02             	sar    $0x2,%eax
f010ed9a:	89 c1                	mov    %eax,%ecx
f010ed9c:	89 ca                	mov    %ecx,%edx
f010ed9e:	c1 e2 02             	shl    $0x2,%edx
f010eda1:	01 ca                	add    %ecx,%edx
f010eda3:	c1 e2 02             	shl    $0x2,%edx
f010eda6:	01 ca                	add    %ecx,%edx
f010eda8:	c1 e2 03             	shl    $0x3,%edx
f010edab:	01 ca                	add    %ecx,%edx
f010edad:	89 d0                	mov    %edx,%eax
f010edaf:	c1 e0 05             	shl    $0x5,%eax
f010edb2:	29 d0                	sub    %edx,%eax
f010edb4:	c1 e0 02             	shl    $0x2,%eax
f010edb7:	01 c8                	add    %ecx,%eax
f010edb9:	c1 e0 02             	shl    $0x2,%eax
f010edbc:	01 c8                	add    %ecx,%eax
f010edbe:	c1 e0 02             	shl    $0x2,%eax
f010edc1:	01 c8                	add    %ecx,%eax
f010edc3:	c1 e0 06             	shl    $0x6,%eax
f010edc6:	29 c8                	sub    %ecx,%eax
f010edc8:	c1 e0 03             	shl    $0x3,%eax
f010edcb:	01 c8                	add    %ecx,%eax
f010edcd:	c1 e0 04             	shl    $0x4,%eax
f010edd0:	01 c8                	add    %ecx,%eax
}
f010edd2:	c9                   	leave  
f010edd3:	c3                   	ret    

f010edd4 <sys_getparentenvid>:

//2017
static int32 sys_getparentenvid(void)
{
f010edd4:	55                   	push   %ebp
f010edd5:	89 e5                	mov    %esp,%ebp
f010edd7:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010edda:	e8 39 cd ff ff       	call   f010bb18 <get_cpu_proc>
f010eddf:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ede2:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ede6:	75 19                	jne    f010ee01 <sys_getparentenvid+0x2d>
f010ede8:	68 90 13 13 f0       	push   $0xf0131390
f010eded:	68 a0 13 13 f0       	push   $0xf01313a0
f010edf2:	68 93 01 00 00       	push   $0x193
f010edf7:	68 b5 13 13 f0       	push   $0xf01313b5
f010edfc:	e8 ae 21 ff ff       	call   f0100faf <_panic>

	return cur_env->env_parent_id;
f010ee01:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee04:	8b 40 14             	mov    0x14(%eax),%eax
}
f010ee07:	c9                   	leave  
f010ee08:	c3                   	ret    

f010ee09 <sys_destroy_env>:
//
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_BAD_ENV if environment envid doesn't currently exist,
//		or the caller doesn't have permission to change envid.
static int sys_destroy_env(int32 envid)
{
f010ee09:	55                   	push   %ebp
f010ee0a:	89 e5                	mov    %esp,%ebp
f010ee0c:	83 ec 18             	sub    $0x18,%esp
	struct Env* cur_env = get_cpu_proc();
f010ee0f:	e8 04 cd ff ff       	call   f010bb18 <get_cpu_proc>
f010ee14:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010ee17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ee1b:	75 19                	jne    f010ee36 <sys_destroy_env+0x2d>
f010ee1d:	68 90 13 13 f0       	push   $0xf0131390
f010ee22:	68 a0 13 13 f0       	push   $0xf01313a0
f010ee27:	68 a1 01 00 00       	push   $0x1a1
f010ee2c:	68 b5 13 13 f0       	push   $0xf01313b5
f010ee31:	e8 79 21 ff ff       	call   f0100faf <_panic>

	int r;
	struct Env *e;
	if (envid == 0)
f010ee36:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f010ee3a:	75 08                	jne    f010ee44 <sys_destroy_env+0x3b>
	{
		e = cur_env ;
f010ee3c:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee3f:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010ee42:	eb 22                	jmp    f010ee66 <sys_destroy_env+0x5d>
	}
	else if ((r = envid2env(envid, &e, 0)) < 0)
f010ee44:	83 ec 04             	sub    $0x4,%esp
f010ee47:	6a 00                	push   $0x0
f010ee49:	8d 45 ec             	lea    -0x14(%ebp),%eax
f010ee4c:	50                   	push   %eax
f010ee4d:	ff 75 08             	pushl  0x8(%ebp)
f010ee50:	e8 13 cd ff ff       	call   f010bb68 <envid2env>
f010ee55:	83 c4 10             	add    $0x10,%esp
f010ee58:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010ee5b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ee5f:	79 05                	jns    f010ee66 <sys_destroy_env+0x5d>
	{
		return r;
f010ee61:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ee64:	eb 56                	jmp    f010eebc <sys_destroy_env+0xb3>
	}

	if (e == cur_env)
f010ee66:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee69:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ee6c:	75 19                	jne    f010ee87 <sys_destroy_env+0x7e>
	{
		cprintf("[%08x] exiting gracefully\n", cur_env->env_id);
f010ee6e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee71:	8b 40 10             	mov    0x10(%eax),%eax
f010ee74:	83 ec 08             	sub    $0x8,%esp
f010ee77:	50                   	push   %eax
f010ee78:	68 3e 14 13 f0       	push   $0xf013143e
f010ee7d:	e8 da 2d ff ff       	call   f0101c5c <cprintf>
f010ee82:	83 c4 10             	add    $0x10,%esp
f010ee85:	eb 1e                	jmp    f010eea5 <sys_destroy_env+0x9c>
	}
	else
	{
		cprintf("[%08x] destroying %08x\n", cur_env->env_id, e->env_id);
f010ee87:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ee8a:	8b 50 10             	mov    0x10(%eax),%edx
f010ee8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ee90:	8b 40 10             	mov    0x10(%eax),%eax
f010ee93:	83 ec 04             	sub    $0x4,%esp
f010ee96:	52                   	push   %edx
f010ee97:	50                   	push   %eax
f010ee98:	68 59 14 13 f0       	push   $0xf0131459
f010ee9d:	e8 ba 2d ff ff       	call   f0101c5c <cprintf>
f010eea2:	83 c4 10             	add    $0x10,%esp
	}
	//2015
	sched_kill_env(e->env_id);
f010eea5:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010eea8:	8b 40 10             	mov    0x10(%eax),%eax
f010eeab:	83 ec 0c             	sub    $0xc,%esp
f010eeae:	50                   	push   %eax
f010eeaf:	e8 71 7c ff ff       	call   f0106b25 <sched_kill_env>
f010eeb4:	83 c4 10             	add    $0x10,%esp

	return 0;
f010eeb7:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010eebc:	c9                   	leave  
f010eebd:	c3                   	ret    

f010eebe <sys_exit_env>:

//Just place the current env into the EXIT queue & schedule the next one
static void sys_exit_env()
{
f010eebe:	55                   	push   %ebp
f010eebf:	89 e5                	mov    %esp,%ebp
f010eec1:	83 ec 08             	sub    $0x8,%esp
	//2015
	env_exit();
f010eec4:	e8 0d cc ff ff       	call   f010bad6 <env_exit>

	//2024: if returned here, then it's not the current environment. So, just return
	//env_run_cmd_prmpt();
	//context_switch(&(cur_env->context), mycpu()->scheduler);

}
f010eec9:	90                   	nop
f010eeca:	c9                   	leave  
f010eecb:	c3                   	ret    

f010eecc <sys_create_env>:

//New update in 2020
//Create a new env & add it to the NEW queue
int sys_create_env(char* programName, unsigned int page_WS_size,unsigned int LRU_second_list_size, unsigned int percent_WS_pages_to_remove)
{
f010eecc:	55                   	push   %ebp
f010eecd:	89 e5                	mov    %esp,%ebp
f010eecf:	83 ec 18             	sub    $0x18,%esp
	//cprintf("\nAttempt to create a new env\n");

	struct Env* env =  env_create(programName, page_WS_size, LRU_second_list_size, percent_WS_pages_to_remove);
f010eed2:	ff 75 14             	pushl  0x14(%ebp)
f010eed5:	ff 75 10             	pushl  0x10(%ebp)
f010eed8:	ff 75 0c             	pushl  0xc(%ebp)
f010eedb:	ff 75 08             	pushl  0x8(%ebp)
f010eede:	e8 7e c0 ff ff       	call   f010af61 <env_create>
f010eee3:	83 c4 10             	add    $0x10,%esp
f010eee6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(env == NULL)
f010eee9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eeed:	75 07                	jne    f010eef6 <sys_create_env+0x2a>
	{
		return E_ENV_CREATION_ERROR;
f010eeef:	b8 ef ff ff ff       	mov    $0xffffffef,%eax
f010eef4:	eb 14                	jmp    f010ef0a <sys_create_env+0x3e>
	}
	//cprintf("\nENV %d is created\n", env->env_id);

	//2015
	sched_new_env(env);
f010eef6:	83 ec 0c             	sub    $0xc,%esp
f010eef9:	ff 75 f4             	pushl  -0xc(%ebp)
f010eefc:	e8 88 78 ff ff       	call   f0106789 <sched_new_env>
f010ef01:	83 c4 10             	add    $0x10,%esp

	//cprintf("\nENV %d is scheduled as NEW\n", env->env_id);

	return env->env_id;
f010ef04:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef07:	8b 40 10             	mov    0x10(%eax),%eax
}
f010ef0a:	c9                   	leave  
f010ef0b:	c3                   	ret    

f010ef0c <sys_run_env>:

//Place a new env into the READY queue
void sys_run_env(int32 envId)
{
f010ef0c:	55                   	push   %ebp
f010ef0d:	89 e5                	mov    %esp,%ebp
f010ef0f:	83 ec 08             	sub    $0x8,%esp
	sched_run_env(envId);
f010ef12:	8b 45 08             	mov    0x8(%ebp),%eax
f010ef15:	83 ec 0c             	sub    $0xc,%esp
f010ef18:	50                   	push   %eax
f010ef19:	e8 c1 78 ff ff       	call   f01067df <sched_run_env>
f010ef1e:	83 c4 10             	add    $0x10,%esp
}
f010ef21:	90                   	nop
f010ef22:	c9                   	leave  
f010ef23:	c3                   	ret    

f010ef24 <sys_get_optimal_num_faults>:

//Calculate the number of page faults for the OPTIMAL replacement
int sys_get_optimal_num_faults()
{
f010ef24:	55                   	push   %ebp
f010ef25:	89 e5                	mov    %esp,%ebp
f010ef27:	53                   	push   %ebx
f010ef28:	83 ec 24             	sub    $0x24,%esp
#if USE_KHEAP
	struct Env* cur_env = get_cpu_proc();
f010ef2b:	e8 e8 cb ff ff       	call   f010bb18 <get_cpu_proc>
f010ef30:	89 45 ec             	mov    %eax,-0x14(%ebp)
	assert(cur_env != NULL);
f010ef33:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f010ef37:	75 19                	jne    f010ef52 <sys_get_optimal_num_faults+0x2e>
f010ef39:	68 90 13 13 f0       	push   $0xf0131390
f010ef3e:	68 a0 13 13 f0       	push   $0xf01313a0
f010ef43:	68 e8 01 00 00       	push   $0x1e8
f010ef48:	68 b5 13 13 f0       	push   $0xf01313b5
f010ef4d:	e8 5d 20 ff ff       	call   f0100faf <_panic>

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
f010ef52:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f010ef59:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef5c:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f010ef62:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010ef65:	eb 5d                	jmp    f010efc4 <sys_get_optimal_num_faults+0xa0>
	{
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
f010ef67:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010ef6a:	8b 00                	mov    (%eax),%eax
f010ef6c:	89 45 e8             	mov    %eax,-0x18(%ebp)
f010ef6f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ef72:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ef77:	89 c3                	mov    %eax,%ebx
f010ef79:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010ef7c:	8b 88 ac 00 00 00    	mov    0xac(%eax),%ecx
f010ef82:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ef85:	8d 50 01             	lea    0x1(%eax),%edx
f010ef88:	89 55 f0             	mov    %edx,-0x10(%ebp)
f010ef8b:	c1 e0 02             	shl    $0x2,%eax
f010ef8e:	01 c8                	add    %ecx,%eax
f010ef90:	8b 00                	mov    (%eax),%eax
f010ef92:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f010ef95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010ef98:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f010ef9d:	39 c3                	cmp    %eax,%ebx
f010ef9f:	74 17                	je     f010efb8 <sys_get_optimal_num_faults+0x94>
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
f010efa1:	83 ec 04             	sub    $0x4,%esp
f010efa4:	68 74 14 13 f0       	push   $0xf0131474
f010efa9:	68 f0 01 00 00       	push   $0x1f0
f010efae:	68 b5 13 13 f0       	push   $0xf01313b5
f010efb3:	e8 f7 1f ff ff       	call   f0100faf <_panic>
	struct Env* cur_env = get_cpu_proc();
	assert(cur_env != NULL);

	struct WorkingSetElement *ptrWSE ;
	int w = 0;
	LIST_FOREACH(ptrWSE, &(cur_env->page_WS_list))
f010efb8:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010efbb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010efc1:	89 45 f4             	mov    %eax,-0xc(%ebp)
f010efc4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010efc8:	74 08                	je     f010efd2 <sys_get_optimal_num_faults+0xae>
f010efca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010efcd:	8b 40 10             	mov    0x10(%eax),%eax
f010efd0:	eb 05                	jmp    f010efd7 <sys_get_optimal_num_faults+0xb3>
f010efd2:	b8 00 00 00 00       	mov    $0x0,%eax
f010efd7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010efda:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f010efe0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010efe3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f010efe9:	85 c0                	test   %eax,%eax
f010efeb:	0f 85 76 ff ff ff    	jne    f010ef67 <sys_get_optimal_num_faults+0x43>
f010eff1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010eff5:	0f 85 6c ff ff ff    	jne    f010ef67 <sys_get_optimal_num_faults+0x43>
		if (ROUNDDOWN(ptrWSE->virtual_address, PAGE_SIZE) != ROUNDDOWN(cur_env->prepagedVAs[w++], PAGE_SIZE))
		{
			panic("sys_get_optimal_num_faults(): page working set is changed during the OPTIMAL replacement while it's not expected to");
		}
	}
	return get_optimal_num_faults(&(cur_env->page_WS_list), cur_env->page_WS_max_size, &(cur_env->referenceStreamList));
f010effb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010effe:	8d 88 9c 00 00 00    	lea    0x9c(%eax),%ecx
f010f004:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f007:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010f00d:	89 c2                	mov    %eax,%edx
f010f00f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f012:	05 88 00 00 00       	add    $0x88,%eax
f010f017:	83 ec 04             	sub    $0x4,%esp
f010f01a:	51                   	push   %ecx
f010f01b:	52                   	push   %edx
f010f01c:	50                   	push   %eax
f010f01d:	e8 25 0d 00 00       	call   f010fd47 <get_optimal_num_faults>
f010f022:	83 c4 10             	add    $0x10,%esp
#else
	panic("MUST ENABLE KHEAP");
#endif
	return 0;
}
f010f025:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010f028:	c9                   	leave  
f010f029:	c3                   	ret    

f010f02a <sys_get_virtual_time>:
/*******************************/
/* ETC... SYSTEM CALLS */
/*******************************/

struct uint64 sys_get_virtual_time()
{
f010f02a:	55                   	push   %ebp
f010f02b:	89 e5                	mov    %esp,%ebp
f010f02d:	83 ec 10             	sub    $0x10,%esp
	//	lcr4(0);


	struct uint64 result;

	__asm __volatile("rdtsc\n"
f010f030:	0f 31                	rdtsc  
f010f032:	89 45 f0             	mov    %eax,-0x10(%ebp)
f010f035:	89 55 f4             	mov    %edx,-0xc(%ebp)
	//ptr[3]=0;
	//cprintf("as str = %s\n", ptr);
	cprintf("ax = %x, bx = %x, cx = %x, dx = %x\n", eaxp,ebxp,ecxp,edxp);
	*/

	return result;
f010f038:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f03b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f010f03e:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f041:	89 55 fc             	mov    %edx,-0x4(%ebp)
	struct uint64 t = get_virtual_time();
	return t;
f010f044:	8b 4d 08             	mov    0x8(%ebp),%ecx
f010f047:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f04a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f04d:	89 01                	mov    %eax,(%ecx)
f010f04f:	89 51 04             	mov    %edx,0x4(%ecx)
}
f010f052:	8b 45 08             	mov    0x8(%ebp),%eax
f010f055:	c9                   	leave  
f010f056:	c2 04 00             	ret    $0x4

f010f059 <sys_rcr2>:

uint32 sys_rcr2()
{
f010f059:	55                   	push   %ebp
f010f05a:	89 e5                	mov    %esp,%ebp
f010f05c:	83 ec 10             	sub    $0x10,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010f05f:	0f 20 d0             	mov    %cr2,%eax
f010f062:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return val;
f010f065:	8b 45 fc             	mov    -0x4(%ebp),%eax
	return rcr2();
f010f068:	90                   	nop
}
f010f069:	c9                   	leave  
f010f06a:	c3                   	ret    

f010f06b <sys_bypassPageFault>:
void sys_bypassPageFault(uint8 instrLength)
{
f010f06b:	55                   	push   %ebp
f010f06c:	89 e5                	mov    %esp,%ebp
f010f06e:	83 ec 04             	sub    $0x4,%esp
f010f071:	8b 45 08             	mov    0x8(%ebp),%eax
f010f074:	88 45 fc             	mov    %al,-0x4(%ebp)
	bypassInstrLength = instrLength;
f010f077:	8a 45 fc             	mov    -0x4(%ebp),%al
f010f07a:	a2 00 64 81 f0       	mov    %al,0xf0816400
}
f010f07f:	90                   	nop
f010f080:	c9                   	leave  
f010f081:	c3                   	ret    

f010f082 <syscall>:
/**************************************************************************/
/************************* SYSTEM CALLS HANDLER ***************************/
/**************************************************************************/
// Dispatches to the correct kernel function, passing the arguments.
uint32 syscall(uint32 syscallno, uint32 a1, uint32 a2, uint32 a3, uint32 a4, uint32 a5)
{
f010f082:	55                   	push   %ebp
f010f083:	89 e5                	mov    %esp,%ebp
f010f085:	56                   	push   %esi
f010f086:	53                   	push   %ebx
f010f087:	83 ec 20             	sub    $0x20,%esp
	struct Env* cur_env = get_cpu_proc();
f010f08a:	e8 89 ca ff ff       	call   f010bb18 <get_cpu_proc>
f010f08f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(cur_env != NULL);
f010f092:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f096:	75 19                	jne    f010f0b1 <syscall+0x2f>
f010f098:	68 90 13 13 f0       	push   $0xf0131390
f010f09d:	68 a0 13 13 f0       	push   $0xf01313a0
f010f0a2:	68 16 02 00 00       	push   $0x216
f010f0a7:	68 b5 13 13 f0       	push   $0xf01313b5
f010f0ac:	e8 fe 1e ff ff       	call   f0100faf <_panic>

	//cprintf("syscallno = %d\n", syscallno);
	// Call the function corresponding to the 'syscallno' parameter.
	// Return any appropriate return value.
	switch(syscallno)
f010f0b1:	83 7d 08 2e          	cmpl   $0x2e,0x8(%ebp)
f010f0b5:	0f 87 b5 03 00 00    	ja     f010f470 <syscall+0x3ee>
f010f0bb:	8b 45 08             	mov    0x8(%ebp),%eax
f010f0be:	c1 e0 02             	shl    $0x2,%eax
f010f0c1:	05 e8 14 13 f0       	add    $0xf01314e8,%eax
f010f0c6:	8b 00                	mov    (%eax),%eax
f010f0c8:	ff e0                	jmp    *%eax
	//TODO: [PROJECT'25.IM#4] CPU SCHEDULING - #1 System Calls - Add suitable code here
	//Your code is here

	//=============================================
	case SYS_cputs:
		sys_cputs((const char*)a1,a2,(uint8)a3, a4);
f010f0ca:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f0cd:	8b 45 14             	mov    0x14(%ebp),%eax
f010f0d0:	0f b6 d0             	movzbl %al,%edx
f010f0d3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0d6:	51                   	push   %ecx
f010f0d7:	52                   	push   %edx
f010f0d8:	ff 75 10             	pushl  0x10(%ebp)
f010f0db:	50                   	push   %eax
f010f0dc:	e8 8e f6 ff ff       	call   f010e76f <sys_cputs>
f010f0e1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f0e4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f0e9:	e9 87 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_cgetc:
		return sys_cgetc();
f010f0ee:	e8 29 f7 ff ff       	call   f010e81c <sys_cgetc>
f010f0f3:	e9 7d 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_cputc:
		sys_cputc((const char)a1);
f010f0f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f0fb:	0f be c0             	movsbl %al,%eax
f010f0fe:	83 ec 0c             	sub    $0xc,%esp
f010f101:	50                   	push   %eax
f010f102:	e8 f1 f6 ff ff       	call   f010e7f8 <sys_cputc>
f010f107:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f10a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f10f:	e9 61 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_lock_cons:
		sys_lock_cons();
f010f114:	e8 42 f7 ff ff       	call   f010e85b <sys_lock_cons>
		return 0;
f010f119:	b8 00 00 00 00       	mov    $0x0,%eax
f010f11e:	e9 52 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_unlock_cons:
		sys_unlock_cons();
f010f123:	e8 41 f7 ff ff       	call   f010e869 <sys_unlock_cons>
		return 0;
f010f128:	b8 00 00 00 00       	mov    $0x0,%eax
f010f12d:	e9 43 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_calc_req_frames:
		return sys_calculate_required_frames(a1, a2);
f010f132:	83 ec 08             	sub    $0x8,%esp
f010f135:	ff 75 10             	pushl  0x10(%ebp)
f010f138:	ff 75 0c             	pushl  0xc(%ebp)
f010f13b:	e8 21 f8 ff ff       	call   f010e961 <sys_calculate_required_frames>
f010f140:	83 c4 10             	add    $0x10,%esp
f010f143:	e9 2d 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_calc_free_frames:
		return sys_calculate_free_frames();
f010f148:	e8 5b f8 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f010f14d:	e9 23 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_calc_modified_frames:
		return sys_calculate_modified_frames();
f010f152:	e8 70 f8 ff ff       	call   f010e9c7 <sys_calculate_modified_frames>
f010f157:	e9 19 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_calc_notmod_frames:
		return sys_calculate_notmod_frames();
f010f15c:	e8 80 f8 ff ff       	call   f010e9e1 <sys_calculate_notmod_frames>
f010f161:	e9 0f 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_pf_calc_allocated_pages:
		return sys_pf_calculate_allocated_pages();
f010f166:	e8 08 f9 ff ff       	call   f010ea73 <sys_pf_calculate_allocated_pages>
f010f16b:	e9 05 03 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_calculate_pages_tobe_removed_ready_exit:
		return sys_calculate_pages_tobe_removed_ready_exit(a1);
f010f170:	83 ec 0c             	sub    $0xc,%esp
f010f173:	ff 75 0c             	pushl  0xc(%ebp)
f010f176:	e8 80 f8 ff ff       	call   f010e9fb <sys_calculate_pages_tobe_removed_ready_exit>
f010f17b:	83 c4 10             	add    $0x10,%esp
f010f17e:	e9 f2 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_scarce_memory:
		sys_scarce_memory();
f010f183:	e8 89 f8 ff ff       	call   f010ea11 <sys_scarce_memory>
		return 0;
f010f188:	b8 00 00 00 00       	mov    $0x0,%eax
f010f18d:	e9 e3 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_allocate_chunk_in_mem:
		sys_allocate_chunk(a1, (uint32)a2, a3);
f010f192:	83 ec 04             	sub    $0x4,%esp
f010f195:	ff 75 14             	pushl  0x14(%ebp)
f010f198:	ff 75 10             	pushl  0x10(%ebp)
f010f19b:	ff 75 0c             	pushl  0xc(%ebp)
f010f19e:	e8 40 fa ff ff       	call   f010ebe3 <sys_allocate_chunk>
f010f1a3:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f1a6:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1ab:	e9 c5 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

		//======================
	case SYS_allocate_page:
		return __sys_allocate_page((void*)a1, a2);
f010f1b0:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1b6:	83 ec 08             	sub    $0x8,%esp
f010f1b9:	52                   	push   %edx
f010f1ba:	50                   	push   %eax
f010f1bb:	e8 b7 f6 ff ff       	call   f010e877 <__sys_allocate_page>
f010f1c0:	83 c4 10             	add    $0x10,%esp
f010f1c3:	e9 ad 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_map_frame:
		__sys_map_frame(a1, (void*)a2, a3, (void*)a4, a5);
f010f1c8:	8b 75 1c             	mov    0x1c(%ebp),%esi
f010f1cb:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f1ce:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f1d1:	8b 55 10             	mov    0x10(%ebp),%edx
f010f1d4:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f1d7:	83 ec 0c             	sub    $0xc,%esp
f010f1da:	56                   	push   %esi
f010f1db:	53                   	push   %ebx
f010f1dc:	51                   	push   %ecx
f010f1dd:	52                   	push   %edx
f010f1de:	50                   	push   %eax
f010f1df:	e8 0d f7 ff ff       	call   f010e8f1 <__sys_map_frame>
f010f1e4:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f1e7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f1ec:	e9 84 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_unmap_frame:
		return __sys_unmap_frame(a1);
f010f1f1:	83 ec 0c             	sub    $0xc,%esp
f010f1f4:	ff 75 0c             	pushl  0xc(%ebp)
f010f1f7:	e8 12 f7 ff ff       	call   f010e90e <__sys_unmap_frame>
f010f1fc:	83 c4 10             	add    $0x10,%esp
f010f1ff:	e9 71 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_clearFFL:
		sys_clearFFL((const char)a1);
f010f204:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f207:	0f be c0             	movsbl %al,%eax
f010f20a:	83 ec 0c             	sub    $0xc,%esp
f010f20d:	50                   	push   %eax
f010f20e:	e8 0c f8 ff ff       	call   f010ea1f <sys_clearFFL>
f010f213:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f216:	b8 00 00 00 00       	mov    $0x0,%eax
f010f21b:	e9 55 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_create_shared_object:
		return sys_create_shared_object((char*)a1, a2, a3, (void*)a4);
f010f220:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f223:	8b 45 14             	mov    0x14(%ebp),%eax
f010f226:	0f b6 d0             	movzbl %al,%edx
f010f229:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f22c:	51                   	push   %ecx
f010f22d:	52                   	push   %edx
f010f22e:	ff 75 10             	pushl  0x10(%ebp)
f010f231:	50                   	push   %eax
f010f232:	e8 50 fa ff ff       	call   f010ec87 <sys_create_shared_object>
f010f237:	83 c4 10             	add    $0x10,%esp
f010f23a:	e9 36 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_get_shared_object:
		return sys_get_shared_object((int32)a1, (char*)a2, (void*)a3);
f010f23f:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f242:	8b 55 10             	mov    0x10(%ebp),%edx
f010f245:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f248:	83 ec 04             	sub    $0x4,%esp
f010f24b:	51                   	push   %ecx
f010f24c:	52                   	push   %edx
f010f24d:	50                   	push   %eax
f010f24e:	e8 a2 fa ff ff       	call   f010ecf5 <sys_get_shared_object>
f010f253:	83 c4 10             	add    $0x10,%esp
f010f256:	e9 1a 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_free_shared_object:
		return sys_delete_shared_object((int32)a1, (void *)a2);
f010f25b:	8b 55 10             	mov    0x10(%ebp),%edx
f010f25e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f261:	83 ec 08             	sub    $0x8,%esp
f010f264:	52                   	push   %edx
f010f265:	50                   	push   %eax
f010f266:	e8 a6 fa ff ff       	call   f010ed11 <sys_delete_shared_object>
f010f26b:	83 c4 10             	add    $0x10,%esp
f010f26e:	e9 02 02 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_get_size_of_shared_object:
		return sys_size_of_shared_object((int32)a1, (char*)a2);
f010f273:	8b 55 10             	mov    0x10(%ebp),%edx
f010f276:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f279:	83 ec 08             	sub    $0x8,%esp
f010f27c:	52                   	push   %edx
f010f27d:	50                   	push   %eax
f010f27e:	e8 59 fa ff ff       	call   f010ecdc <sys_size_of_shared_object>
f010f283:	83 c4 10             	add    $0x10,%esp
f010f286:	e9 ea 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_create_env:
		return sys_create_env((char*)a1, (uint32)a2, (uint32)a3, (uint32)a4);
f010f28b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f28e:	ff 75 18             	pushl  0x18(%ebp)
f010f291:	ff 75 14             	pushl  0x14(%ebp)
f010f294:	ff 75 10             	pushl  0x10(%ebp)
f010f297:	50                   	push   %eax
f010f298:	e8 2f fc ff ff       	call   f010eecc <sys_create_env>
f010f29d:	83 c4 10             	add    $0x10,%esp
f010f2a0:	e9 d0 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;

	case SYS_run_env:
		sys_run_env((int32)a1);
f010f2a5:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2a8:	83 ec 0c             	sub    $0xc,%esp
f010f2ab:	50                   	push   %eax
f010f2ac:	e8 5b fc ff ff       	call   f010ef0c <sys_run_env>
f010f2b1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f2b4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2b9:	e9 b7 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_getenvindex:
		return sys_getenvindex();
f010f2be:	e8 9c fa ff ff       	call   f010ed5f <sys_getenvindex>
f010f2c3:	e9 ad 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_getenvid:
		return sys_getenvid();
f010f2c8:	e8 5d fa ff ff       	call   f010ed2a <sys_getenvid>
f010f2cd:	e9 a3 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_getparentenvid:
		return sys_getparentenvid();
f010f2d2:	e8 fd fa ff ff       	call   f010edd4 <sys_getparentenvid>
f010f2d7:	e9 99 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_destroy_env:
		return sys_destroy_env(a1);
f010f2dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f2df:	83 ec 0c             	sub    $0xc,%esp
f010f2e2:	50                   	push   %eax
f010f2e3:	e8 21 fb ff ff       	call   f010ee09 <sys_destroy_env>
f010f2e8:	83 c4 10             	add    $0x10,%esp
f010f2eb:	e9 85 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_exit_env:
		sys_exit_env();
f010f2f0:	e8 c9 fb ff ff       	call   f010eebe <sys_exit_env>
		return 0;
f010f2f5:	b8 00 00 00 00       	mov    $0x0,%eax
f010f2fa:	e9 76 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_get_virtual_time:
	{
		struct uint64 res = sys_get_virtual_time();
f010f2ff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
f010f302:	83 ec 0c             	sub    $0xc,%esp
f010f305:	50                   	push   %eax
f010f306:	e8 1f fd ff ff       	call   f010f02a <sys_get_virtual_time>
f010f30b:	83 c4 0c             	add    $0xc,%esp
		uint32* ptrlow = ((uint32*)a1);
f010f30e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f311:	89 45 f0             	mov    %eax,-0x10(%ebp)
		uint32* ptrhi = ((uint32*)a2);
f010f314:	8b 45 10             	mov    0x10(%ebp),%eax
f010f317:	89 45 ec             	mov    %eax,-0x14(%ebp)
		*ptrlow = res.low;
f010f31a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f31d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f320:	89 10                	mov    %edx,(%eax)
		*ptrhi = res.hi;
f010f322:	8b 55 e8             	mov    -0x18(%ebp),%edx
f010f325:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f328:	89 10                	mov    %edx,(%eax)
		return 0;
f010f32a:	b8 00 00 00 00       	mov    $0x0,%eax
f010f32f:	e9 41 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	}
	case SYS_move_user_mem:
		sys_move_user_mem(a1, a2, a3);
f010f334:	83 ec 04             	sub    $0x4,%esp
f010f337:	ff 75 14             	pushl  0x14(%ebp)
f010f33a:	ff 75 10             	pushl  0x10(%ebp)
f010f33d:	ff 75 0c             	pushl  0xc(%ebp)
f010f340:	e8 e6 f8 ff ff       	call   f010ec2b <sys_move_user_mem>
f010f345:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f348:	b8 00 00 00 00       	mov    $0x0,%eax
f010f34d:	e9 23 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_rcr2:
		return sys_rcr2();
f010f352:	e8 02 fd ff ff       	call   f010f059 <sys_rcr2>
f010f357:	e9 19 01 00 00       	jmp    f010f475 <syscall+0x3f3>
		break;
	case SYS_bypassPageFault:
		sys_bypassPageFault(a1);
f010f35c:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f35f:	0f b6 c0             	movzbl %al,%eax
f010f362:	83 ec 0c             	sub    $0xc,%esp
f010f365:	50                   	push   %eax
f010f366:	e8 00 fd ff ff       	call   f010f06b <sys_bypassPageFault>
f010f36b:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f36e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f373:	e9 fd 00 00 00       	jmp    f010f475 <syscall+0x3f3>

	case SYS_rsttst:
		rsttst();
f010f378:	e8 b6 96 00 00       	call   f0118a33 <rsttst>
		return 0;
f010f37d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f382:	e9 ee 00 00 00       	jmp    f010f475 <syscall+0x3f3>
	case SYS_inctst:
		inctst();
f010f387:	e8 ef 96 00 00       	call   f0118a7b <inctst>
		return 0;
f010f38c:	b8 00 00 00 00       	mov    $0x0,%eax
f010f391:	e9 df 00 00 00       	jmp    f010f475 <syscall+0x3f3>
	case SYS_chktst:
		chktst(a1);
f010f396:	83 ec 0c             	sub    $0xc,%esp
f010f399:	ff 75 0c             	pushl  0xc(%ebp)
f010f39c:	e8 1c 98 00 00       	call   f0118bbd <chktst>
f010f3a1:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3a4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3a9:	e9 c7 00 00 00       	jmp    f010f475 <syscall+0x3f3>
	case SYS_gettst:
		return gettst();
f010f3ae:	e8 fc 96 00 00       	call   f0118aaf <gettst>
f010f3b3:	e9 bd 00 00 00       	jmp    f010f475 <syscall+0x3f3>
	case SYS_testNum:
		tst(a1, a2, a3, (char)a4, a5);
f010f3b8:	8b 55 1c             	mov    0x1c(%ebp),%edx
f010f3bb:	8b 45 18             	mov    0x18(%ebp),%eax
f010f3be:	0f be c0             	movsbl %al,%eax
f010f3c1:	83 ec 0c             	sub    $0xc,%esp
f010f3c4:	52                   	push   %edx
f010f3c5:	50                   	push   %eax
f010f3c6:	ff 75 14             	pushl  0x14(%ebp)
f010f3c9:	ff 75 10             	pushl  0x10(%ebp)
f010f3cc:	ff 75 0c             	pushl  0xc(%ebp)
f010f3cf:	e8 e5 96 00 00       	call   f0118ab9 <tst>
f010f3d4:	83 c4 20             	add    $0x20,%esp
		return 0;
f010f3d7:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3dc:	e9 94 00 00 00       	jmp    f010f475 <syscall+0x3f3>

	case SYS_get_heap_strategy:
		return sys_get_heap_strategy();
f010f3e1:	e8 89 f8 ff ff       	call   f010ec6f <sys_get_heap_strategy>
f010f3e6:	e9 8a 00 00 00       	jmp    f010f475 <syscall+0x3f3>

	case SYS_set_heap_strategy:
		sys_set_uheap_strategy(a1);
f010f3eb:	83 ec 0c             	sub    $0xc,%esp
f010f3ee:	ff 75 0c             	pushl  0xc(%ebp)
f010f3f1:	e8 83 f8 ff ff       	call   f010ec79 <sys_set_uheap_strategy>
f010f3f6:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f3f9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f3fe:	eb 75                	jmp    f010f475 <syscall+0x3f3>

	case SYS_check_LRU_lists:
		return sys_check_LRU_lists((uint32*)a1, (uint32*)a2, (int)a3, (int)a4);
f010f400:	8b 5d 18             	mov    0x18(%ebp),%ebx
f010f403:	8b 4d 14             	mov    0x14(%ebp),%ecx
f010f406:	8b 55 10             	mov    0x10(%ebp),%edx
f010f409:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f40c:	53                   	push   %ebx
f010f40d:	51                   	push   %ecx
f010f40e:	52                   	push   %edx
f010f40f:	50                   	push   %eax
f010f410:	e8 62 1d 00 00       	call   f0111177 <sys_check_LRU_lists>
f010f415:	83 c4 10             	add    $0x10,%esp
f010f418:	eb 5b                	jmp    f010f475 <syscall+0x3f3>

	case SYS_check_LRU_lists_free:
		return sys_check_LRU_lists_free((uint32*)a1, (int)a2);
f010f41a:	8b 55 10             	mov    0x10(%ebp),%edx
f010f41d:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f420:	83 ec 08             	sub    $0x8,%esp
f010f423:	52                   	push   %edx
f010f424:	50                   	push   %eax
f010f425:	e8 0f 1f 00 00       	call   f0111339 <sys_check_LRU_lists_free>
f010f42a:	83 c4 10             	add    $0x10,%esp
f010f42d:	eb 46                	jmp    f010f475 <syscall+0x3f3>

	case SYS_check_WS_list:
		return sys_check_WS_list((uint32*)a1, (int)a2, (uint32)a3, (bool)a4);
f010f42f:	8b 4d 18             	mov    0x18(%ebp),%ecx
f010f432:	8b 55 10             	mov    0x10(%ebp),%edx
f010f435:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f438:	51                   	push   %ecx
f010f439:	ff 75 14             	pushl  0x14(%ebp)
f010f43c:	52                   	push   %edx
f010f43d:	50                   	push   %eax
f010f43e:	e8 83 20 00 00       	call   f01114c6 <sys_check_WS_list>
f010f443:	83 c4 10             	add    $0x10,%esp
f010f446:	eb 2d                	jmp    f010f475 <syscall+0x3f3>

	case SYS_utilities:
		sys_utilities((char*)a1, (int)a2);
f010f448:	8b 55 10             	mov    0x10(%ebp),%edx
f010f44b:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f44e:	83 ec 08             	sub    $0x8,%esp
f010f451:	52                   	push   %edx
f010f452:	50                   	push   %eax
f010f453:	e8 66 99 00 00       	call   f0118dbe <sys_utilities>
f010f458:	83 c4 10             	add    $0x10,%esp
		return 0;
f010f45b:	b8 00 00 00 00       	mov    $0x0,%eax
f010f460:	eb 13                	jmp    f010f475 <syscall+0x3f3>

	case SYS_get_optimal_num_faults:
		return sys_get_optimal_num_faults();
f010f462:	e8 bd fa ff ff       	call   f010ef24 <sys_get_optimal_num_faults>
f010f467:	eb 0c                	jmp    f010f475 <syscall+0x3f3>

	case NSYSCALLS:
		return 	-E_INVAL;
f010f469:	b8 03 00 00 00       	mov    $0x3,%eax
f010f46e:	eb 05                	jmp    f010f475 <syscall+0x3f3>
		break;
	}
	//panic("syscall not implemented");
	return -E_INVAL;
f010f470:	b8 03 00 00 00       	mov    $0x3,%eax
}
f010f475:	8d 65 f8             	lea    -0x8(%ebp),%esp
f010f478:	5b                   	pop    %ebx
f010f479:	5e                   	pop    %esi
f010f47a:	5d                   	pop    %ebp
f010f47b:	c3                   	ret    

f010f47c <stab_binsearch>:
//	will exit setting left = 118, right = 554.
//
static void
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
f010f47c:	55                   	push   %ebp
f010f47d:	89 e5                	mov    %esp,%ebp
f010f47f:	83 ec 20             	sub    $0x20,%esp
	int l = *region_left, r = *region_right, any_matches = 0;
f010f482:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f485:	8b 00                	mov    (%eax),%eax
f010f487:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f48a:	8b 45 10             	mov    0x10(%ebp),%eax
f010f48d:	8b 00                	mov    (%eax),%eax
f010f48f:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f492:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	while (l <= r) {
f010f499:	e9 ca 00 00 00       	jmp    f010f568 <stab_binsearch+0xec>
		int true_m = (l + r) / 2, m = true_m;
f010f49e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f4a1:	8b 45 f8             	mov    -0x8(%ebp),%eax
f010f4a4:	01 d0                	add    %edx,%eax
f010f4a6:	89 c2                	mov    %eax,%edx
f010f4a8:	c1 ea 1f             	shr    $0x1f,%edx
f010f4ab:	01 d0                	add    %edx,%eax
f010f4ad:	d1 f8                	sar    %eax
f010f4af:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010f4b2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f4b5:	89 45 f0             	mov    %eax,-0x10(%ebp)

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f4b8:	eb 03                	jmp    f010f4bd <stab_binsearch+0x41>
			m--;
f010f4ba:	ff 4d f0             	decl   -0x10(%ebp)

	while (l <= r) {
		int true_m = (l + r) / 2, m = true_m;

		// search for earliest stab with right type
		while (m >= l && stabs[m].n_type != type)
f010f4bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f4c0:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f4c3:	7c 1e                	jl     f010f4e3 <stab_binsearch+0x67>
f010f4c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f4c8:	89 d0                	mov    %edx,%eax
f010f4ca:	01 c0                	add    %eax,%eax
f010f4cc:	01 d0                	add    %edx,%eax
f010f4ce:	c1 e0 02             	shl    $0x2,%eax
f010f4d1:	89 c2                	mov    %eax,%edx
f010f4d3:	8b 45 08             	mov    0x8(%ebp),%eax
f010f4d6:	01 d0                	add    %edx,%eax
f010f4d8:	8a 40 04             	mov    0x4(%eax),%al
f010f4db:	0f b6 c0             	movzbl %al,%eax
f010f4de:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f4e1:	75 d7                	jne    f010f4ba <stab_binsearch+0x3e>
			m--;
		if (m < l) {	// no match in [l, m]
f010f4e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f4e6:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f4e9:	7d 09                	jge    f010f4f4 <stab_binsearch+0x78>
			l = true_m + 1;
f010f4eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f4ee:	40                   	inc    %eax
f010f4ef:	89 45 fc             	mov    %eax,-0x4(%ebp)
			continue;
f010f4f2:	eb 74                	jmp    f010f568 <stab_binsearch+0xec>
		}

		// actual binary search
		any_matches = 1;
f010f4f4:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		if (stabs[m].n_value < addr) {
f010f4fb:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f4fe:	89 d0                	mov    %edx,%eax
f010f500:	01 c0                	add    %eax,%eax
f010f502:	01 d0                	add    %edx,%eax
f010f504:	c1 e0 02             	shl    $0x2,%eax
f010f507:	89 c2                	mov    %eax,%edx
f010f509:	8b 45 08             	mov    0x8(%ebp),%eax
f010f50c:	01 d0                	add    %edx,%eax
f010f50e:	8b 40 08             	mov    0x8(%eax),%eax
f010f511:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f514:	73 11                	jae    f010f527 <stab_binsearch+0xab>
			*region_left = m;
f010f516:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f519:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f51c:	89 10                	mov    %edx,(%eax)
			l = true_m + 1;
f010f51e:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f521:	40                   	inc    %eax
f010f522:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f525:	eb 41                	jmp    f010f568 <stab_binsearch+0xec>
		} else if (stabs[m].n_value > addr) {
f010f527:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f52a:	89 d0                	mov    %edx,%eax
f010f52c:	01 c0                	add    %eax,%eax
f010f52e:	01 d0                	add    %edx,%eax
f010f530:	c1 e0 02             	shl    $0x2,%eax
f010f533:	89 c2                	mov    %eax,%edx
f010f535:	8b 45 08             	mov    0x8(%ebp),%eax
f010f538:	01 d0                	add    %edx,%eax
f010f53a:	8b 40 08             	mov    0x8(%eax),%eax
f010f53d:	3b 45 18             	cmp    0x18(%ebp),%eax
f010f540:	76 14                	jbe    f010f556 <stab_binsearch+0xda>
			*region_right = m - 1;
f010f542:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f545:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f548:	8b 45 10             	mov    0x10(%ebp),%eax
f010f54b:	89 10                	mov    %edx,(%eax)
			r = m - 1;
f010f54d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f550:	48                   	dec    %eax
f010f551:	89 45 f8             	mov    %eax,-0x8(%ebp)
f010f554:	eb 12                	jmp    f010f568 <stab_binsearch+0xec>
		} else {
			// exact match for 'addr', but continue loop to find
			// *region_right
			*region_left = m;
f010f556:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f559:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f55c:	89 10                	mov    %edx,(%eax)
			l = m;
f010f55e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010f561:	89 45 fc             	mov    %eax,-0x4(%ebp)
			addr++;
f010f564:	83 45 18 04          	addl   $0x4,0x18(%ebp)
stab_binsearch(const struct Stab *stabs, int *region_left, int *region_right,
	       int type, uint32*  addr)
{
	int l = *region_left, r = *region_right, any_matches = 0;

	while (l <= r) {
f010f568:	8b 45 fc             	mov    -0x4(%ebp),%eax
f010f56b:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f010f56e:	0f 8e 2a ff ff ff    	jle    f010f49e <stab_binsearch+0x22>
			l = m;
			addr++;
		}
	}

	if (!any_matches)
f010f574:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010f578:	75 0f                	jne    f010f589 <stab_binsearch+0x10d>
		*region_right = *region_left - 1;
f010f57a:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f57d:	8b 00                	mov    (%eax),%eax
f010f57f:	8d 50 ff             	lea    -0x1(%eax),%edx
f010f582:	8b 45 10             	mov    0x10(%ebp),%eax
f010f585:	89 10                	mov    %edx,(%eax)
		     l > *region_left && stabs[l].n_type != type;
		     l--)
			/* do nothing */;
		*region_left = l;
	}
}
f010f587:	eb 3d                	jmp    f010f5c6 <stab_binsearch+0x14a>

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f589:	8b 45 10             	mov    0x10(%ebp),%eax
f010f58c:	8b 00                	mov    (%eax),%eax
f010f58e:	89 45 fc             	mov    %eax,-0x4(%ebp)
f010f591:	eb 03                	jmp    f010f596 <stab_binsearch+0x11a>
		     l > *region_left && stabs[l].n_type != type;
		     l--)
f010f593:	ff 4d fc             	decl   -0x4(%ebp)
	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
		     l > *region_left && stabs[l].n_type != type;
f010f596:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f599:	8b 00                	mov    (%eax),%eax

	if (!any_matches)
		*region_right = *region_left - 1;
	else {
		// find rightmost region containing 'addr'
		for (l = *region_right;
f010f59b:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f010f59e:	7d 1e                	jge    f010f5be <stab_binsearch+0x142>
		     l > *region_left && stabs[l].n_type != type;
f010f5a0:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f5a3:	89 d0                	mov    %edx,%eax
f010f5a5:	01 c0                	add    %eax,%eax
f010f5a7:	01 d0                	add    %edx,%eax
f010f5a9:	c1 e0 02             	shl    $0x2,%eax
f010f5ac:	89 c2                	mov    %eax,%edx
f010f5ae:	8b 45 08             	mov    0x8(%ebp),%eax
f010f5b1:	01 d0                	add    %edx,%eax
f010f5b3:	8a 40 04             	mov    0x4(%eax),%al
f010f5b6:	0f b6 c0             	movzbl %al,%eax
f010f5b9:	3b 45 14             	cmp    0x14(%ebp),%eax
f010f5bc:	75 d5                	jne    f010f593 <stab_binsearch+0x117>
		     l--)
			/* do nothing */;
		*region_left = l;
f010f5be:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5c1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f010f5c4:	89 10                	mov    %edx,(%eax)
	}
}
f010f5c6:	90                   	nop
f010f5c7:	c9                   	leave  
f010f5c8:	c3                   	ret    

f010f5c9 <debuginfo_eip>:
//	negative if not.  But even if it returns negative it has stored some
//	information into '*info'.
//
int
debuginfo_eip(uint32*  addr, struct Eipdebuginfo *info)
{
f010f5c9:	55                   	push   %ebp
f010f5ca:	89 e5                	mov    %esp,%ebp
f010f5cc:	83 ec 38             	sub    $0x38,%esp
	const struct Stab *stabs, *stab_end;
	const char *stabstr, *stabstr_end;
	int lfile, rfile, lfun, rfun, lline, rline;

	// Initialize *info
	info->eip_file = "<unknown>";
f010f5cf:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5d2:	c7 00 a4 15 13 f0    	movl   $0xf01315a4,(%eax)
	info->eip_line = 0;
f010f5d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5db:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	info->eip_fn_name = "<unknown>";
f010f5e2:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5e5:	c7 40 08 a4 15 13 f0 	movl   $0xf01315a4,0x8(%eax)
	info->eip_fn_namelen = 9;
f010f5ec:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5ef:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
	info->eip_fn_addr = addr;
f010f5f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f5f9:	8b 55 08             	mov    0x8(%ebp),%edx
f010f5fc:	89 50 10             	mov    %edx,0x10(%eax)
	info->eip_fn_narg = 0;
f010f5ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f602:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)

	// Find the relevant set of stabs
	if ((uint32)addr >= USER_LIMIT) {
f010f609:	8b 45 08             	mov    0x8(%ebp),%eax
f010f60c:	3d ff ff 7f ef       	cmp    $0xef7fffff,%eax
f010f611:	76 1e                	jbe    f010f631 <debuginfo_eip+0x68>
		stabs = __STAB_BEGIN__;
f010f613:	c7 45 f4 b4 67 13 f0 	movl   $0xf01367b4,-0xc(%ebp)
		stab_end = __STAB_END__;
f010f61a:	c7 45 f0 b8 3c 16 f0 	movl   $0xf0163cb8,-0x10(%ebp)
		stabstr = __STABSTR_BEGIN__;
f010f621:	c7 45 ec b9 3c 16 f0 	movl   $0xf0163cb9,-0x14(%ebp)
		stabstr_end = __STABSTR_END__;
f010f628:	c7 45 e8 a1 6d 17 f0 	movl   $0xf0176da1,-0x18(%ebp)
f010f62f:	eb 2a                	jmp    f010f65b <debuginfo_eip+0x92>
		// The user-application linker script, user/user.ld,
		// puts information about the application's stabs (equivalent
		// to __STAB_BEGIN__, __STAB_END__, __STABSTR_BEGIN__, and
		// __STABSTR_END__) in a structure located at virtual address
		// USTABDATA.
		const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;
f010f631:	c7 45 e0 00 00 20 00 	movl   $0x200000,-0x20(%ebp)

		// Make sure this memory is valid.
		// Return -1 if it is not.  Hint: Call user_mem_check.
		// LAB 3: Your code here.

		stabs = usd->stabs;
f010f638:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f63b:	8b 00                	mov    (%eax),%eax
f010f63d:	89 45 f4             	mov    %eax,-0xc(%ebp)
		stab_end = usd->stab_end;
f010f640:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f643:	8b 40 04             	mov    0x4(%eax),%eax
f010f646:	89 45 f0             	mov    %eax,-0x10(%ebp)
		stabstr = usd->stabstr;
f010f649:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f64c:	8b 40 08             	mov    0x8(%eax),%eax
f010f64f:	89 45 ec             	mov    %eax,-0x14(%ebp)
		stabstr_end = usd->stabstr_end;
f010f652:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010f655:	8b 40 0c             	mov    0xc(%eax),%eax
f010f658:	89 45 e8             	mov    %eax,-0x18(%ebp)
		// Make sure the STABS and string table memory is valid.
		// LAB 3: Your code here.
	}

	// String table validity checks
	if (stabstr_end <= stabstr || stabstr_end[-1] != 0)
f010f65b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f65e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010f661:	76 0a                	jbe    f010f66d <debuginfo_eip+0xa4>
f010f663:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010f666:	48                   	dec    %eax
f010f667:	8a 00                	mov    (%eax),%al
f010f669:	84 c0                	test   %al,%al
f010f66b:	74 0a                	je     f010f677 <debuginfo_eip+0xae>
		return -1;
f010f66d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f672:	e9 01 02 00 00       	jmp    f010f878 <debuginfo_eip+0x2af>
	// 'eip'.  First, we find the basic source file containing 'eip'.
	// Then, we look in that source file for the function.  Then we look
	// for the line number.

	// Search the entire set of stabs for the source file (type N_SO).
	lfile = 0;
f010f677:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	rfile = (stab_end - stabs) - 1;
f010f67e:	8b 55 f0             	mov    -0x10(%ebp),%edx
f010f681:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f684:	29 c2                	sub    %eax,%edx
f010f686:	89 d0                	mov    %edx,%eax
f010f688:	c1 f8 02             	sar    $0x2,%eax
f010f68b:	89 c2                	mov    %eax,%edx
f010f68d:	89 d0                	mov    %edx,%eax
f010f68f:	c1 e0 02             	shl    $0x2,%eax
f010f692:	01 d0                	add    %edx,%eax
f010f694:	c1 e0 02             	shl    $0x2,%eax
f010f697:	01 d0                	add    %edx,%eax
f010f699:	c1 e0 02             	shl    $0x2,%eax
f010f69c:	01 d0                	add    %edx,%eax
f010f69e:	89 c1                	mov    %eax,%ecx
f010f6a0:	c1 e1 08             	shl    $0x8,%ecx
f010f6a3:	01 c8                	add    %ecx,%eax
f010f6a5:	89 c1                	mov    %eax,%ecx
f010f6a7:	c1 e1 10             	shl    $0x10,%ecx
f010f6aa:	01 c8                	add    %ecx,%eax
f010f6ac:	01 c0                	add    %eax,%eax
f010f6ae:	01 d0                	add    %edx,%eax
f010f6b0:	48                   	dec    %eax
f010f6b1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
f010f6b4:	ff 75 08             	pushl  0x8(%ebp)
f010f6b7:	6a 64                	push   $0x64
f010f6b9:	8d 45 d4             	lea    -0x2c(%ebp),%eax
f010f6bc:	50                   	push   %eax
f010f6bd:	8d 45 d8             	lea    -0x28(%ebp),%eax
f010f6c0:	50                   	push   %eax
f010f6c1:	ff 75 f4             	pushl  -0xc(%ebp)
f010f6c4:	e8 b3 fd ff ff       	call   f010f47c <stab_binsearch>
f010f6c9:	83 c4 14             	add    $0x14,%esp
	if (lfile == 0)
f010f6cc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f6cf:	85 c0                	test   %eax,%eax
f010f6d1:	75 0a                	jne    f010f6dd <debuginfo_eip+0x114>
		return -1;
f010f6d3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f010f6d8:	e9 9b 01 00 00       	jmp    f010f878 <debuginfo_eip+0x2af>

	// Search within that file's stabs for the function definition
	// (N_FUN).
	lfun = lfile;
f010f6dd:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f6e0:	89 45 d0             	mov    %eax,-0x30(%ebp)
	rfun = rfile;
f010f6e3:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f6e6:	89 45 cc             	mov    %eax,-0x34(%ebp)
	stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
f010f6e9:	ff 75 08             	pushl  0x8(%ebp)
f010f6ec:	6a 24                	push   $0x24
f010f6ee:	8d 45 cc             	lea    -0x34(%ebp),%eax
f010f6f1:	50                   	push   %eax
f010f6f2:	8d 45 d0             	lea    -0x30(%ebp),%eax
f010f6f5:	50                   	push   %eax
f010f6f6:	ff 75 f4             	pushl  -0xc(%ebp)
f010f6f9:	e8 7e fd ff ff       	call   f010f47c <stab_binsearch>
f010f6fe:	83 c4 14             	add    $0x14,%esp

	if (lfun <= rfun) {
f010f701:	8b 55 d0             	mov    -0x30(%ebp),%edx
f010f704:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f707:	39 c2                	cmp    %eax,%edx
f010f709:	0f 8f 86 00 00 00    	jg     f010f795 <debuginfo_eip+0x1cc>
		// stabs[lfun] points to the function name
		// in the string table, but check bounds just in case.
		if (stabs[lfun].n_strx < stabstr_end - stabstr)
f010f70f:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f712:	89 c2                	mov    %eax,%edx
f010f714:	89 d0                	mov    %edx,%eax
f010f716:	01 c0                	add    %eax,%eax
f010f718:	01 d0                	add    %edx,%eax
f010f71a:	c1 e0 02             	shl    $0x2,%eax
f010f71d:	89 c2                	mov    %eax,%edx
f010f71f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f722:	01 d0                	add    %edx,%eax
f010f724:	8b 00                	mov    (%eax),%eax
f010f726:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f729:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f72c:	29 d1                	sub    %edx,%ecx
f010f72e:	89 ca                	mov    %ecx,%edx
f010f730:	39 d0                	cmp    %edx,%eax
f010f732:	73 22                	jae    f010f756 <debuginfo_eip+0x18d>
			info->eip_fn_name = stabstr + stabs[lfun].n_strx;
f010f734:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f737:	89 c2                	mov    %eax,%edx
f010f739:	89 d0                	mov    %edx,%eax
f010f73b:	01 c0                	add    %eax,%eax
f010f73d:	01 d0                	add    %edx,%eax
f010f73f:	c1 e0 02             	shl    $0x2,%eax
f010f742:	89 c2                	mov    %eax,%edx
f010f744:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f747:	01 d0                	add    %edx,%eax
f010f749:	8b 10                	mov    (%eax),%edx
f010f74b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f74e:	01 c2                	add    %eax,%edx
f010f750:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f753:	89 50 08             	mov    %edx,0x8(%eax)
		info->eip_fn_addr = (uint32*) stabs[lfun].n_value;
f010f756:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f759:	89 c2                	mov    %eax,%edx
f010f75b:	89 d0                	mov    %edx,%eax
f010f75d:	01 c0                	add    %eax,%eax
f010f75f:	01 d0                	add    %edx,%eax
f010f761:	c1 e0 02             	shl    $0x2,%eax
f010f764:	89 c2                	mov    %eax,%edx
f010f766:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f769:	01 d0                	add    %edx,%eax
f010f76b:	8b 50 08             	mov    0x8(%eax),%edx
f010f76e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f771:	89 50 10             	mov    %edx,0x10(%eax)
		addr = (uint32*)(addr - (info->eip_fn_addr));
f010f774:	8b 55 08             	mov    0x8(%ebp),%edx
f010f777:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f77a:	8b 40 10             	mov    0x10(%eax),%eax
f010f77d:	29 c2                	sub    %eax,%edx
f010f77f:	89 d0                	mov    %edx,%eax
f010f781:	c1 f8 02             	sar    $0x2,%eax
f010f784:	89 45 08             	mov    %eax,0x8(%ebp)
		// Search within the function definition for the line number.
		lline = lfun;
f010f787:	8b 45 d0             	mov    -0x30(%ebp),%eax
f010f78a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfun;
f010f78d:	8b 45 cc             	mov    -0x34(%ebp),%eax
f010f790:	89 45 dc             	mov    %eax,-0x24(%ebp)
f010f793:	eb 15                	jmp    f010f7aa <debuginfo_eip+0x1e1>
	} else {
		// Couldn't find function stab!  Maybe we're in an assembly
		// file.  Search the whole file for the line number.
		info->eip_fn_addr = addr;
f010f795:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f798:	8b 55 08             	mov    0x8(%ebp),%edx
f010f79b:	89 50 10             	mov    %edx,0x10(%eax)
		lline = lfile;
f010f79e:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f7a1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		rline = rfile;
f010f7a4:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f010f7a7:	89 45 dc             	mov    %eax,-0x24(%ebp)
	}
	// Ignore stuff after the colon.
	info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
f010f7aa:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7ad:	8b 40 08             	mov    0x8(%eax),%eax
f010f7b0:	83 ec 08             	sub    $0x8,%esp
f010f7b3:	6a 3a                	push   $0x3a
f010f7b5:	50                   	push   %eax
f010f7b6:	e8 82 b5 00 00       	call   f011ad3d <strfind>
f010f7bb:	83 c4 10             	add    $0x10,%esp
f010f7be:	89 c2                	mov    %eax,%edx
f010f7c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7c3:	8b 40 08             	mov    0x8(%eax),%eax
f010f7c6:	29 c2                	sub    %eax,%edx
f010f7c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f7cb:	89 50 0c             	mov    %edx,0xc(%eax)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f7ce:	eb 03                	jmp    f010f7d3 <debuginfo_eip+0x20a>
	       && stabs[lline].n_type != N_SOL
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
		lline--;
f010f7d0:	ff 4d e4             	decl   -0x1c(%ebp)
	// Search backwards from the line number for the relevant filename
	// stab.
	// We can't just use the "lfile" stab because inlined functions
	// can interpolate code from a different file!
	// Such included source files use the N_SOL stab type.
	while (lline >= lfile
f010f7d3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f7d6:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f7d9:	7c 4e                	jl     f010f829 <debuginfo_eip+0x260>
	       && stabs[lline].n_type != N_SOL
f010f7db:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f7de:	89 d0                	mov    %edx,%eax
f010f7e0:	01 c0                	add    %eax,%eax
f010f7e2:	01 d0                	add    %edx,%eax
f010f7e4:	c1 e0 02             	shl    $0x2,%eax
f010f7e7:	89 c2                	mov    %eax,%edx
f010f7e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f7ec:	01 d0                	add    %edx,%eax
f010f7ee:	8a 40 04             	mov    0x4(%eax),%al
f010f7f1:	3c 84                	cmp    $0x84,%al
f010f7f3:	74 34                	je     f010f829 <debuginfo_eip+0x260>
	       && (stabs[lline].n_type != N_SO || !stabs[lline].n_value))
f010f7f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f7f8:	89 d0                	mov    %edx,%eax
f010f7fa:	01 c0                	add    %eax,%eax
f010f7fc:	01 d0                	add    %edx,%eax
f010f7fe:	c1 e0 02             	shl    $0x2,%eax
f010f801:	89 c2                	mov    %eax,%edx
f010f803:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f806:	01 d0                	add    %edx,%eax
f010f808:	8a 40 04             	mov    0x4(%eax),%al
f010f80b:	3c 64                	cmp    $0x64,%al
f010f80d:	75 c1                	jne    f010f7d0 <debuginfo_eip+0x207>
f010f80f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f812:	89 d0                	mov    %edx,%eax
f010f814:	01 c0                	add    %eax,%eax
f010f816:	01 d0                	add    %edx,%eax
f010f818:	c1 e0 02             	shl    $0x2,%eax
f010f81b:	89 c2                	mov    %eax,%edx
f010f81d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f820:	01 d0                	add    %edx,%eax
f010f822:	8b 40 08             	mov    0x8(%eax),%eax
f010f825:	85 c0                	test   %eax,%eax
f010f827:	74 a7                	je     f010f7d0 <debuginfo_eip+0x207>
		lline--;
	if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr)
f010f829:	8b 45 d8             	mov    -0x28(%ebp),%eax
f010f82c:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
f010f82f:	7c 42                	jl     f010f873 <debuginfo_eip+0x2aa>
f010f831:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f834:	89 d0                	mov    %edx,%eax
f010f836:	01 c0                	add    %eax,%eax
f010f838:	01 d0                	add    %edx,%eax
f010f83a:	c1 e0 02             	shl    $0x2,%eax
f010f83d:	89 c2                	mov    %eax,%edx
f010f83f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f842:	01 d0                	add    %edx,%eax
f010f844:	8b 00                	mov    (%eax),%eax
f010f846:	8b 4d e8             	mov    -0x18(%ebp),%ecx
f010f849:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010f84c:	29 d1                	sub    %edx,%ecx
f010f84e:	89 ca                	mov    %ecx,%edx
f010f850:	39 d0                	cmp    %edx,%eax
f010f852:	73 1f                	jae    f010f873 <debuginfo_eip+0x2aa>
		info->eip_file = stabstr + stabs[lline].n_strx;
f010f854:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f010f857:	89 d0                	mov    %edx,%eax
f010f859:	01 c0                	add    %eax,%eax
f010f85b:	01 d0                	add    %edx,%eax
f010f85d:	c1 e0 02             	shl    $0x2,%eax
f010f860:	89 c2                	mov    %eax,%edx
f010f862:	8b 45 f4             	mov    -0xc(%ebp),%eax
f010f865:	01 d0                	add    %edx,%eax
f010f867:	8b 10                	mov    (%eax),%edx
f010f869:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010f86c:	01 c2                	add    %eax,%edx
f010f86e:	8b 45 0c             	mov    0xc(%ebp),%eax
f010f871:	89 10                	mov    %edx,(%eax)
	// Set eip_fn_narg to the number of arguments taken by the function,
	// or 0 if there was no containing function.
	// Your code here.


	return 0;
f010f873:	b8 00 00 00 00       	mov    $0x0,%eax
}
f010f878:	c9                   	leave  
f010f879:	c3                   	ret    

f010f87a <setPageReplacmentAlgorithmLRU>:
//===============================
// REPLACEMENT STRATEGIES
//===============================
//2020
void setPageReplacmentAlgorithmLRU(int LRU_TYPE)
{
f010f87a:	55                   	push   %ebp
f010f87b:	89 e5                	mov    %esp,%ebp
f010f87d:	83 ec 08             	sub    $0x8,%esp
	assert(LRU_TYPE == PG_REP_LRU_TIME_APPROX || LRU_TYPE == PG_REP_LRU_LISTS_APPROX);
f010f880:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f010f884:	74 1c                	je     f010f8a2 <setPageReplacmentAlgorithmLRU+0x28>
f010f886:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f010f88a:	74 16                	je     f010f8a2 <setPageReplacmentAlgorithmLRU+0x28>
f010f88c:	68 b0 15 13 f0       	push   $0xf01315b0
f010f891:	68 fa 15 13 f0       	push   $0xf01315fa
f010f896:	6a 1a                	push   $0x1a
f010f898:	68 0f 16 13 f0       	push   $0xf013160f
f010f89d:	e8 0d 17 ff ff       	call   f0100faf <_panic>
	_PageRepAlgoType = LRU_TYPE ;
f010f8a2:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8a5:	a3 68 6d 85 f0       	mov    %eax,0xf0856d68
}
f010f8aa:	90                   	nop
f010f8ab:	c9                   	leave  
f010f8ac:	c3                   	ret    

f010f8ad <setPageReplacmentAlgorithmCLOCK>:
void setPageReplacmentAlgorithmCLOCK(){_PageRepAlgoType = PG_REP_CLOCK;}
f010f8ad:	55                   	push   %ebp
f010f8ae:	89 e5                	mov    %esp,%ebp
f010f8b0:	c7 05 68 6d 85 f0 03 	movl   $0x3,0xf0856d68
f010f8b7:	00 00 00 
f010f8ba:	90                   	nop
f010f8bb:	5d                   	pop    %ebp
f010f8bc:	c3                   	ret    

f010f8bd <setPageReplacmentAlgorithmFIFO>:
void setPageReplacmentAlgorithmFIFO(){_PageRepAlgoType = PG_REP_FIFO;}
f010f8bd:	55                   	push   %ebp
f010f8be:	89 e5                	mov    %esp,%ebp
f010f8c0:	c7 05 68 6d 85 f0 04 	movl   $0x4,0xf0856d68
f010f8c7:	00 00 00 
f010f8ca:	90                   	nop
f010f8cb:	5d                   	pop    %ebp
f010f8cc:	c3                   	ret    

f010f8cd <setPageReplacmentAlgorithmModifiedCLOCK>:
void setPageReplacmentAlgorithmModifiedCLOCK(){_PageRepAlgoType = PG_REP_MODIFIEDCLOCK;}
f010f8cd:	55                   	push   %ebp
f010f8ce:	89 e5                	mov    %esp,%ebp
f010f8d0:	c7 05 68 6d 85 f0 05 	movl   $0x5,0xf0856d68
f010f8d7:	00 00 00 
f010f8da:	90                   	nop
f010f8db:	5d                   	pop    %ebp
f010f8dc:	c3                   	ret    

f010f8dd <setPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ void setPageReplacmentAlgorithmDynamicLocal(){_PageRepAlgoType = PG_REP_DYNAMIC_LOCAL;}
f010f8dd:	55                   	push   %ebp
f010f8de:	89 e5                	mov    %esp,%ebp
f010f8e0:	c7 05 68 6d 85 f0 07 	movl   $0x7,0xf0856d68
f010f8e7:	00 00 00 
f010f8ea:	90                   	nop
f010f8eb:	5d                   	pop    %ebp
f010f8ec:	c3                   	ret    

f010f8ed <setPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ void setPageReplacmentAlgorithmNchanceCLOCK(int PageWSMaxSweeps){_PageRepAlgoType = PG_REP_NchanceCLOCK;  page_WS_max_sweeps = PageWSMaxSweeps;}
f010f8ed:	55                   	push   %ebp
f010f8ee:	89 e5                	mov    %esp,%ebp
f010f8f0:	c7 05 68 6d 85 f0 06 	movl   $0x6,0xf0856d68
f010f8f7:	00 00 00 
f010f8fa:	8b 45 08             	mov    0x8(%ebp),%eax
f010f8fd:	a3 b4 e7 83 f0       	mov    %eax,0xf083e7b4
f010f902:	90                   	nop
f010f903:	5d                   	pop    %ebp
f010f904:	c3                   	ret    

f010f905 <setFASTNchanceCLOCK>:
/*2024*/ void setFASTNchanceCLOCK(bool fast){ FASTNchanceCLOCK = fast; };
f010f905:	55                   	push   %ebp
f010f906:	89 e5                	mov    %esp,%ebp
f010f908:	8b 45 08             	mov    0x8(%ebp),%eax
f010f90b:	a3 14 6b 85 f0       	mov    %eax,0xf0856b14
f010f910:	90                   	nop
f010f911:	5d                   	pop    %ebp
f010f912:	c3                   	ret    

f010f913 <setPageReplacmentAlgorithmOPTIMAL>:
/*2025*/ void setPageReplacmentAlgorithmOPTIMAL(){ _PageRepAlgoType = PG_REP_OPTIMAL; };
f010f913:	55                   	push   %ebp
f010f914:	89 e5                	mov    %esp,%ebp
f010f916:	c7 05 68 6d 85 f0 08 	movl   $0x8,0xf0856d68
f010f91d:	00 00 00 
f010f920:	90                   	nop
f010f921:	5d                   	pop    %ebp
f010f922:	c3                   	ret    

f010f923 <isPageReplacmentAlgorithmLRU>:

//2020
uint32 isPageReplacmentAlgorithmLRU(int LRU_TYPE){return _PageRepAlgoType == LRU_TYPE ? 1 : 0;}
f010f923:	55                   	push   %ebp
f010f924:	89 e5                	mov    %esp,%ebp
f010f926:	8b 15 68 6d 85 f0    	mov    0xf0856d68,%edx
f010f92c:	8b 45 08             	mov    0x8(%ebp),%eax
f010f92f:	39 c2                	cmp    %eax,%edx
f010f931:	0f 94 c0             	sete   %al
f010f934:	0f b6 c0             	movzbl %al,%eax
f010f937:	5d                   	pop    %ebp
f010f938:	c3                   	ret    

f010f939 <isPageReplacmentAlgorithmCLOCK>:
uint32 isPageReplacmentAlgorithmCLOCK(){if(_PageRepAlgoType == PG_REP_CLOCK) return 1; return 0;}
f010f939:	55                   	push   %ebp
f010f93a:	89 e5                	mov    %esp,%ebp
f010f93c:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f941:	83 f8 03             	cmp    $0x3,%eax
f010f944:	75 07                	jne    f010f94d <isPageReplacmentAlgorithmCLOCK+0x14>
f010f946:	b8 01 00 00 00       	mov    $0x1,%eax
f010f94b:	eb 05                	jmp    f010f952 <isPageReplacmentAlgorithmCLOCK+0x19>
f010f94d:	b8 00 00 00 00       	mov    $0x0,%eax
f010f952:	5d                   	pop    %ebp
f010f953:	c3                   	ret    

f010f954 <isPageReplacmentAlgorithmFIFO>:
uint32 isPageReplacmentAlgorithmFIFO(){if(_PageRepAlgoType == PG_REP_FIFO) return 1; return 0;}
f010f954:	55                   	push   %ebp
f010f955:	89 e5                	mov    %esp,%ebp
f010f957:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f95c:	83 f8 04             	cmp    $0x4,%eax
f010f95f:	75 07                	jne    f010f968 <isPageReplacmentAlgorithmFIFO+0x14>
f010f961:	b8 01 00 00 00       	mov    $0x1,%eax
f010f966:	eb 05                	jmp    f010f96d <isPageReplacmentAlgorithmFIFO+0x19>
f010f968:	b8 00 00 00 00       	mov    $0x0,%eax
f010f96d:	5d                   	pop    %ebp
f010f96e:	c3                   	ret    

f010f96f <isPageReplacmentAlgorithmModifiedCLOCK>:
uint32 isPageReplacmentAlgorithmModifiedCLOCK(){if(_PageRepAlgoType == PG_REP_MODIFIEDCLOCK) return 1; return 0;}
f010f96f:	55                   	push   %ebp
f010f970:	89 e5                	mov    %esp,%ebp
f010f972:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f977:	83 f8 05             	cmp    $0x5,%eax
f010f97a:	75 07                	jne    f010f983 <isPageReplacmentAlgorithmModifiedCLOCK+0x14>
f010f97c:	b8 01 00 00 00       	mov    $0x1,%eax
f010f981:	eb 05                	jmp    f010f988 <isPageReplacmentAlgorithmModifiedCLOCK+0x19>
f010f983:	b8 00 00 00 00       	mov    $0x0,%eax
f010f988:	5d                   	pop    %ebp
f010f989:	c3                   	ret    

f010f98a <isPageReplacmentAlgorithmDynamicLocal>:
/*2018*/ uint32 isPageReplacmentAlgorithmDynamicLocal(){if(_PageRepAlgoType == PG_REP_DYNAMIC_LOCAL) return 1; return 0;}
f010f98a:	55                   	push   %ebp
f010f98b:	89 e5                	mov    %esp,%ebp
f010f98d:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f992:	83 f8 07             	cmp    $0x7,%eax
f010f995:	75 07                	jne    f010f99e <isPageReplacmentAlgorithmDynamicLocal+0x14>
f010f997:	b8 01 00 00 00       	mov    $0x1,%eax
f010f99c:	eb 05                	jmp    f010f9a3 <isPageReplacmentAlgorithmDynamicLocal+0x19>
f010f99e:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9a3:	5d                   	pop    %ebp
f010f9a4:	c3                   	ret    

f010f9a5 <isPageReplacmentAlgorithmNchanceCLOCK>:
/*2021*/ uint32 isPageReplacmentAlgorithmNchanceCLOCK(){if(_PageRepAlgoType == PG_REP_NchanceCLOCK) return 1; return 0;}
f010f9a5:	55                   	push   %ebp
f010f9a6:	89 e5                	mov    %esp,%ebp
f010f9a8:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f9ad:	83 f8 06             	cmp    $0x6,%eax
f010f9b0:	75 07                	jne    f010f9b9 <isPageReplacmentAlgorithmNchanceCLOCK+0x14>
f010f9b2:	b8 01 00 00 00       	mov    $0x1,%eax
f010f9b7:	eb 05                	jmp    f010f9be <isPageReplacmentAlgorithmNchanceCLOCK+0x19>
f010f9b9:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9be:	5d                   	pop    %ebp
f010f9bf:	c3                   	ret    

f010f9c0 <isPageReplacmentAlgorithmOPTIMAL>:
/*2021*/ uint32 isPageReplacmentAlgorithmOPTIMAL(){if(_PageRepAlgoType == PG_REP_OPTIMAL) return 1; return 0;}
f010f9c0:	55                   	push   %ebp
f010f9c1:	89 e5                	mov    %esp,%ebp
f010f9c3:	a1 68 6d 85 f0       	mov    0xf0856d68,%eax
f010f9c8:	83 f8 08             	cmp    $0x8,%eax
f010f9cb:	75 07                	jne    f010f9d4 <isPageReplacmentAlgorithmOPTIMAL+0x14>
f010f9cd:	b8 01 00 00 00       	mov    $0x1,%eax
f010f9d2:	eb 05                	jmp    f010f9d9 <isPageReplacmentAlgorithmOPTIMAL+0x19>
f010f9d4:	b8 00 00 00 00       	mov    $0x0,%eax
f010f9d9:	5d                   	pop    %ebp
f010f9da:	c3                   	ret    

f010f9db <enableModifiedBuffer>:

//===============================
// PAGE BUFFERING
//===============================
void enableModifiedBuffer(uint32 enableIt){_EnableModifiedBuffer = enableIt;}
f010f9db:	55                   	push   %ebp
f010f9dc:	89 e5                	mov    %esp,%ebp
f010f9de:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9e1:	a3 00 6b 85 f0       	mov    %eax,0xf0856b00
f010f9e6:	90                   	nop
f010f9e7:	5d                   	pop    %ebp
f010f9e8:	c3                   	ret    

f010f9e9 <isModifiedBufferEnabled>:
uint8 isModifiedBufferEnabled(){  return _EnableModifiedBuffer ; }
f010f9e9:	55                   	push   %ebp
f010f9ea:	89 e5                	mov    %esp,%ebp
f010f9ec:	a1 00 6b 85 f0       	mov    0xf0856b00,%eax
f010f9f1:	5d                   	pop    %ebp
f010f9f2:	c3                   	ret    

f010f9f3 <enableBuffering>:

void enableBuffering(uint32 enableIt){_EnableBuffering = enableIt;}
f010f9f3:	55                   	push   %ebp
f010f9f4:	89 e5                	mov    %esp,%ebp
f010f9f6:	8b 45 08             	mov    0x8(%ebp),%eax
f010f9f9:	a3 d4 6d 85 f0       	mov    %eax,0xf0856dd4
f010f9fe:	90                   	nop
f010f9ff:	5d                   	pop    %ebp
f010fa00:	c3                   	ret    

f010fa01 <isBufferingEnabled>:
uint8 isBufferingEnabled(){  return _EnableBuffering ; }
f010fa01:	55                   	push   %ebp
f010fa02:	89 e5                	mov    %esp,%ebp
f010fa04:	a1 d4 6d 85 f0       	mov    0xf0856dd4,%eax
f010fa09:	5d                   	pop    %ebp
f010fa0a:	c3                   	ret    

f010fa0b <setModifiedBufferLength>:

void setModifiedBufferLength(uint32 length) { _ModifiedBufferLength = length;}
f010fa0b:	55                   	push   %ebp
f010fa0c:	89 e5                	mov    %esp,%ebp
f010fa0e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fa11:	a3 70 6e 85 f0       	mov    %eax,0xf0856e70
f010fa16:	90                   	nop
f010fa17:	5d                   	pop    %ebp
f010fa18:	c3                   	ret    

f010fa19 <getModifiedBufferLength>:
uint32 getModifiedBufferLength() { return _ModifiedBufferLength;}
f010fa19:	55                   	push   %ebp
f010fa1a:	89 e5                	mov    %esp,%ebp
f010fa1c:	a1 70 6e 85 f0       	mov    0xf0856e70,%eax
f010fa21:	5d                   	pop    %ebp
f010fa22:	c3                   	ret    

f010fa23 <fault_handler_init>:

//==================
// [0] INIT HANDLER:
//==================
void fault_handler_init()
{
f010fa23:	55                   	push   %ebp
f010fa24:	89 e5                	mov    %esp,%ebp
	//setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
	//setPageReplacmentAlgorithmOPTIMAL();
	setPageReplacmentAlgorithmCLOCK();
f010fa26:	e8 82 fe ff ff       	call   f010f8ad <setPageReplacmentAlgorithmCLOCK>
	//setPageReplacmentAlgorithmModifiedCLOCK();
	enableBuffering(0);
f010fa2b:	6a 00                	push   $0x0
f010fa2d:	e8 c1 ff ff ff       	call   f010f9f3 <enableBuffering>
f010fa32:	83 c4 04             	add    $0x4,%esp
	enableModifiedBuffer(0) ;
f010fa35:	6a 00                	push   $0x0
f010fa37:	e8 9f ff ff ff       	call   f010f9db <enableModifiedBuffer>
f010fa3c:	83 c4 04             	add    $0x4,%esp
	setModifiedBufferLength(1000);
f010fa3f:	68 e8 03 00 00       	push   $0x3e8
f010fa44:	e8 c2 ff ff ff       	call   f010fa0b <setModifiedBufferLength>
f010fa49:	83 c4 04             	add    $0x4,%esp
}
f010fa4c:	90                   	nop
f010fa4d:	c9                   	leave  
f010fa4e:	c3                   	ret    

f010fa4f <fault_handler>:
int8 num_repeated_fault  = 0;
extern uint32 sys_calculate_free_frames() ;

struct Env* last_faulted_env = NULL;
void fault_handler(struct Trapframe *tf)
{
f010fa4f:	55                   	push   %ebp
f010fa50:	89 e5                	mov    %esp,%ebp
f010fa52:	83 ec 28             	sub    $0x28,%esp

static __inline uint32
rcr2(void)
{
	uint32 val;
	__asm __volatile("movl %%cr2,%0" : "=r" (val));
f010fa55:	0f 20 d0             	mov    %cr2,%eax
f010fa58:	89 45 d8             	mov    %eax,-0x28(%ebp)
	return val;
f010fa5b:	8b 45 d8             	mov    -0x28(%ebp),%eax
	/******************************************************/
	// Read processor's CR2 register to find the faulting address
	uint32 fault_va = rcr2();
f010fa5e:	89 45 ec             	mov    %eax,-0x14(%ebp)
	//	print_trapframe(tf);
	/******************************************************/

	//If same fault va for 3 times, then panic
	//UPDATE: 3 FAULTS MUST come from the same environment (or the kernel)
	struct Env* cur_env = get_cpu_proc();
f010fa61:	e8 b2 c0 ff ff       	call   f010bb18 <get_cpu_proc>
f010fa66:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (last_fault_va == fault_va && last_faulted_env == cur_env)
f010fa69:	a1 0c 64 81 f0       	mov    0xf081640c,%eax
f010fa6e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fa71:	75 50                	jne    f010fac3 <fault_handler+0x74>
f010fa73:	a1 18 64 81 f0       	mov    0xf0816418,%eax
f010fa78:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f010fa7b:	75 46                	jne    f010fac3 <fault_handler+0x74>
	{
		num_repeated_fault++ ;
f010fa7d:	a0 14 64 81 f0       	mov    0xf0816414,%al
f010fa82:	40                   	inc    %eax
f010fa83:	a2 14 64 81 f0       	mov    %al,0xf0816414
		if (num_repeated_fault == 3)
f010fa88:	a0 14 64 81 f0       	mov    0xf0816414,%al
f010fa8d:	3c 03                	cmp    $0x3,%al
f010fa8f:	75 4d                	jne    f010fade <fault_handler+0x8f>
		{
			print_trapframe(tf);
f010fa91:	83 ec 0c             	sub    $0xc,%esp
f010fa94:	ff 75 08             	pushl  0x8(%ebp)
f010fa97:	e8 41 e6 ff ff       	call   f010e0dd <print_trapframe>
f010fa9c:	83 c4 10             	add    $0x10,%esp
			panic("Failed to handle fault! fault @ at va = %x from eip = %x causes va (%x) to be faulted for 3 successive times\n", before_last_fault_va, before_last_eip, fault_va);
f010fa9f:	8b 15 08 64 81 f0    	mov    0xf0816408,%edx
f010faa5:	a1 10 64 81 f0       	mov    0xf0816410,%eax
f010faaa:	83 ec 08             	sub    $0x8,%esp
f010faad:	ff 75 ec             	pushl  -0x14(%ebp)
f010fab0:	52                   	push   %edx
f010fab1:	50                   	push   %eax
f010fab2:	68 2c 16 13 f0       	push   $0xf013162c
f010fab7:	6a 69                	push   $0x69
f010fab9:	68 0f 16 13 f0       	push   $0xf013160f
f010fabe:	e8 ec 14 ff ff       	call   f0100faf <_panic>
		}
	}
	else
	{
		before_last_fault_va = last_fault_va;
f010fac3:	a1 0c 64 81 f0       	mov    0xf081640c,%eax
f010fac8:	a3 10 64 81 f0       	mov    %eax,0xf0816410
		before_last_eip = last_eip;
f010facd:	a1 04 64 81 f0       	mov    0xf0816404,%eax
f010fad2:	a3 08 64 81 f0       	mov    %eax,0xf0816408
		num_repeated_fault = 0;
f010fad7:	c6 05 14 64 81 f0 00 	movb   $0x0,0xf0816414
	}
	last_eip = (uint32)tf->tf_eip;
f010fade:	8b 45 08             	mov    0x8(%ebp),%eax
f010fae1:	8b 40 30             	mov    0x30(%eax),%eax
f010fae4:	a3 04 64 81 f0       	mov    %eax,0xf0816404
	last_fault_va = fault_va ;
f010fae9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f010faec:	a3 0c 64 81 f0       	mov    %eax,0xf081640c
	last_faulted_env = cur_env;
f010faf1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010faf4:	a3 18 64 81 f0       	mov    %eax,0xf0816418
	/******************************************************/
	//2017: Check stack overflow for Kernel
	int userTrap = 0;
f010faf9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if ((tf->tf_cs & 3) == 3) {
f010fb00:	8b 45 08             	mov    0x8(%ebp),%eax
f010fb03:	8b 40 34             	mov    0x34(%eax),%eax
f010fb06:	0f b7 c0             	movzwl %ax,%eax
f010fb09:	83 e0 03             	and    $0x3,%eax
f010fb0c:	83 f8 03             	cmp    $0x3,%eax
f010fb0f:	75 07                	jne    f010fb18 <fault_handler+0xc9>
		userTrap = 1;
f010fb11:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	}
	if (!userTrap)
f010fb18:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010fb1c:	0f 85 cb 00 00 00    	jne    f010fbed <fault_handler+0x19e>
	{
		struct cpu* c = mycpu();
f010fb22:	e8 49 85 ff ff       	call   f0108070 <mycpu>
f010fb27:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//cprintf("trap from KERNEL\n");
		if (cur_env && fault_va >= (uint32)cur_env->kstack && fault_va < (uint32)cur_env->kstack + PAGE_SIZE)
f010fb2a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f010fb2e:	74 32                	je     f010fb62 <fault_handler+0x113>
f010fb30:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb33:	8b 40 70             	mov    0x70(%eax),%eax
f010fb36:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb39:	77 27                	ja     f010fb62 <fault_handler+0x113>
f010fb3b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fb3e:	8b 40 70             	mov    0x70(%eax),%eax
f010fb41:	05 00 10 00 00       	add    $0x1000,%eax
f010fb46:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb49:	76 17                	jbe    f010fb62 <fault_handler+0x113>
			panic("User Kernel Stack: overflow exception!");
f010fb4b:	83 ec 04             	sub    $0x4,%esp
f010fb4e:	68 9c 16 13 f0       	push   $0xf013169c
f010fb53:	68 80 00 00 00       	push   $0x80
f010fb58:	68 0f 16 13 f0       	push   $0xf013160f
f010fb5d:	e8 4d 14 ff ff       	call   f0100faf <_panic>
		else if (fault_va >= (uint32)c->stack && fault_va < (uint32)c->stack + PAGE_SIZE)
f010fb62:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb65:	8b 40 08             	mov    0x8(%eax),%eax
f010fb68:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb6b:	77 60                	ja     f010fbcd <fault_handler+0x17e>
f010fb6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb70:	8b 40 08             	mov    0x8(%eax),%eax
f010fb73:	05 00 10 00 00       	add    $0x1000,%eax
f010fb78:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f010fb7b:	76 50                	jbe    f010fbcd <fault_handler+0x17e>
			panic("Sched Kernel Stack of CPU #%d: overflow exception!", c - CPUS);
f010fb7d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fb80:	ba 00 e9 83 f0       	mov    $0xf083e900,%edx
f010fb85:	29 d0                	sub    %edx,%eax
f010fb87:	c1 f8 03             	sar    $0x3,%eax
f010fb8a:	89 c2                	mov    %eax,%edx
f010fb8c:	89 d0                	mov    %edx,%eax
f010fb8e:	c1 e0 02             	shl    $0x2,%eax
f010fb91:	01 d0                	add    %edx,%eax
f010fb93:	01 c0                	add    %eax,%eax
f010fb95:	01 d0                	add    %edx,%eax
f010fb97:	c1 e0 03             	shl    $0x3,%eax
f010fb9a:	01 d0                	add    %edx,%eax
f010fb9c:	89 c1                	mov    %eax,%ecx
f010fb9e:	c1 e1 0b             	shl    $0xb,%ecx
f010fba1:	01 c8                	add    %ecx,%eax
f010fba3:	c1 e0 05             	shl    $0x5,%eax
f010fba6:	01 d0                	add    %edx,%eax
f010fba8:	c1 e0 02             	shl    $0x2,%eax
f010fbab:	01 d0                	add    %edx,%eax
f010fbad:	01 c0                	add    %eax,%eax
f010fbaf:	01 d0                	add    %edx,%eax
f010fbb1:	c1 e0 03             	shl    $0x3,%eax
f010fbb4:	01 d0                	add    %edx,%eax
f010fbb6:	f7 d8                	neg    %eax
f010fbb8:	50                   	push   %eax
f010fbb9:	68 c4 16 13 f0       	push   $0xf01316c4
f010fbbe:	68 82 00 00 00       	push   $0x82
f010fbc3:	68 0f 16 13 f0       	push   $0xf013160f
f010fbc8:	e8 e2 13 ff ff       	call   f0100faf <_panic>
#if USE_KHEAP
		if (fault_va >= KERNEL_HEAP_MAX)
f010fbcd:	81 7d ec ff ef ff ff 	cmpl   $0xffffefff,-0x14(%ebp)
f010fbd4:	76 40                	jbe    f010fc16 <fault_handler+0x1c7>
			panic("Kernel: heap overflow exception!");
f010fbd6:	83 ec 04             	sub    $0x4,%esp
f010fbd9:	68 f8 16 13 f0       	push   $0xf01316f8
f010fbde:	68 85 00 00 00       	push   $0x85
f010fbe3:	68 0f 16 13 f0       	push   $0xf013160f
f010fbe8:	e8 c2 13 ff ff       	call   f0100faf <_panic>
	}
	//2017: Check stack underflow for User
	else
	{
		//cprintf("trap from USER\n");
		if (fault_va >= USTACKTOP && fault_va < USER_TOP)
f010fbed:	81 7d ec ff df bf ee 	cmpl   $0xeebfdfff,-0x14(%ebp)
f010fbf4:	76 20                	jbe    f010fc16 <fault_handler+0x1c7>
f010fbf6:	81 7d ec ff ff bf ee 	cmpl   $0xeebfffff,-0x14(%ebp)
f010fbfd:	77 17                	ja     f010fc16 <fault_handler+0x1c7>
			panic("User: stack underflow exception!");
f010fbff:	83 ec 04             	sub    $0x4,%esp
f010fc02:	68 1c 17 13 f0       	push   $0xf013171c
f010fc07:	68 8d 00 00 00       	push   $0x8d
f010fc0c:	68 0f 16 13 f0       	push   $0xf013160f
f010fc11:	e8 99 13 ff ff       	call   f0100faf <_panic>
	}

	//get a pointer to the environment that caused the fault at runtime
	//cprintf("curenv = %x\n", curenv);
	struct Env* faulted_env = cur_env;
f010fc16:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fc19:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (faulted_env == NULL)
f010fc1c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f010fc20:	75 38                	jne    f010fc5a <fault_handler+0x20b>
	{
		cprintf("\nFaulted VA = %x\n", fault_va);
f010fc22:	83 ec 08             	sub    $0x8,%esp
f010fc25:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc28:	68 3d 17 13 f0       	push   $0xf013173d
f010fc2d:	e8 2a 20 ff ff       	call   f0101c5c <cprintf>
f010fc32:	83 c4 10             	add    $0x10,%esp
		print_trapframe(tf);
f010fc35:	83 ec 0c             	sub    $0xc,%esp
f010fc38:	ff 75 08             	pushl  0x8(%ebp)
f010fc3b:	e8 9d e4 ff ff       	call   f010e0dd <print_trapframe>
f010fc40:	83 c4 10             	add    $0x10,%esp
		panic("faulted env == NULL!");
f010fc43:	83 ec 04             	sub    $0x4,%esp
f010fc46:	68 4f 17 13 f0       	push   $0xf013174f
f010fc4b:	68 97 00 00 00       	push   $0x97
f010fc50:	68 0f 16 13 f0       	push   $0xf013160f
f010fc55:	e8 55 13 ff ff       	call   f0100faf <_panic>
	}
	//check the faulted address, is it a table or not ?
	//If the directory entry of the faulted address is NOT PRESENT then
	if ( (faulted_env->env_page_directory[PDX(fault_va)] & PERM_PRESENT) != PERM_PRESENT)
f010fc5a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc5d:	8b 40 64             	mov    0x64(%eax),%eax
f010fc60:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fc63:	c1 ea 16             	shr    $0x16,%edx
f010fc66:	c1 e2 02             	shl    $0x2,%edx
f010fc69:	01 d0                	add    %edx,%eax
f010fc6b:	8b 00                	mov    (%eax),%eax
f010fc6d:	83 e0 01             	and    $0x1,%eax
f010fc70:	85 c0                	test   %eax,%eax
f010fc72:	75 28                	jne    f010fc9c <fault_handler+0x24d>
	{
		faulted_env->tableFaultsCounter ++ ;
f010fc74:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc77:	8b 80 9c 05 00 00    	mov    0x59c(%eax),%eax
f010fc7d:	8d 50 01             	lea    0x1(%eax),%edx
f010fc80:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc83:	89 90 9c 05 00 00    	mov    %edx,0x59c(%eax)
		table_fault_handler(faulted_env, fault_va);
f010fc89:	83 ec 08             	sub    $0x8,%esp
f010fc8c:	ff 75 ec             	pushl  -0x14(%ebp)
f010fc8f:	ff 75 e0             	pushl  -0x20(%ebp)
f010fc92:	e8 8f 00 00 00       	call   f010fd26 <table_fault_handler>
f010fc97:	83 c4 10             	add    $0x10,%esp
f010fc9a:	eb 7b                	jmp    f010fd17 <fault_handler+0x2c8>

			/*============================================================================================*/
		}

		/*2022: Check if fault due to Access Rights */
		int perms = pt_get_page_permissions(faulted_env->env_page_directory, fault_va);
f010fc9c:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fc9f:	8b 40 64             	mov    0x64(%eax),%eax
f010fca2:	83 ec 08             	sub    $0x8,%esp
f010fca5:	ff 75 ec             	pushl  -0x14(%ebp)
f010fca8:	50                   	push   %eax
f010fca9:	e8 16 a1 ff ff       	call   f0109dc4 <pt_get_page_permissions>
f010fcae:	83 c4 10             	add    $0x10,%esp
f010fcb1:	89 45 dc             	mov    %eax,-0x24(%ebp)
		if (perms & PERM_PRESENT)
f010fcb4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f010fcb7:	83 e0 01             	and    $0x1,%eax
f010fcba:	85 c0                	test   %eax,%eax
f010fcbc:	74 17                	je     f010fcd5 <fault_handler+0x286>
			panic("Page @va=%x is exist! page fault due to violation of ACCESS RIGHTS\n", fault_va) ;
f010fcbe:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcc1:	68 64 17 13 f0       	push   $0xf0131764
f010fcc6:	68 af 00 00 00       	push   $0xaf
f010fccb:	68 0f 16 13 f0       	push   $0xf013160f
f010fcd0:	e8 da 12 ff ff       	call   f0100faf <_panic>
		/*============================================================================================*/


		// we have normal page fault =============================================================
		faulted_env->pageFaultsCounter ++ ;
f010fcd5:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fcd8:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f010fcde:	8d 50 01             	lea    0x1(%eax),%edx
f010fce1:	8b 45 e0             	mov    -0x20(%ebp),%eax
f010fce4:	89 90 98 05 00 00    	mov    %edx,0x598(%eax)
//				cprintf("[%08s] user PAGE fault va %08x\n", faulted_env->prog_name, fault_va);
//				cprintf("\nPage working set BEFORE fault handler...\n");
//				env_page_ws_print(faulted_env);
		//int ffb = sys_calculate_free_frames();

		if(isBufferingEnabled())
f010fcea:	e8 12 fd ff ff       	call   f010fa01 <isBufferingEnabled>
f010fcef:	84 c0                	test   %al,%al
f010fcf1:	74 13                	je     f010fd06 <fault_handler+0x2b7>
		{
			__page_fault_handler_with_buffering(faulted_env, fault_va);
f010fcf3:	83 ec 08             	sub    $0x8,%esp
f010fcf6:	ff 75 ec             	pushl  -0x14(%ebp)
f010fcf9:	ff 75 e0             	pushl  -0x20(%ebp)
f010fcfc:	e8 2c 01 00 00       	call   f010fe2d <__page_fault_handler_with_buffering>
f010fd01:	83 c4 10             	add    $0x10,%esp
f010fd04:	eb 11                	jmp    f010fd17 <fault_handler+0x2c8>
		}
		else
		{
			page_fault_handler(faulted_env, fault_va);
f010fd06:	83 ec 08             	sub    $0x8,%esp
f010fd09:	ff 75 ec             	pushl  -0x14(%ebp)
f010fd0c:	ff 75 e0             	pushl  -0x20(%ebp)
f010fd0f:	e8 50 00 00 00       	call   f010fd64 <page_fault_handler>
f010fd14:	83 c4 10             	add    $0x10,%esp

static __inline void
tlbflush(void)
{
	uint32 cr3;
	__asm __volatile("movl %%cr3,%0" : "=r" (cr3));
f010fd17:	0f 20 d8             	mov    %cr3,%eax
f010fd1a:	89 45 f0             	mov    %eax,-0x10(%ebp)
	__asm __volatile("movl %0,%%cr3" : : "r" (cr3));
f010fd1d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010fd20:	0f 22 d8             	mov    %eax,%cr3

	/*************************************************************/
	//Refresh the TLB cache
	tlbflush();
	/*************************************************************/
}
f010fd23:	90                   	nop
f010fd24:	c9                   	leave  
f010fd25:	c3                   	ret    

f010fd26 <table_fault_handler>:

//=========================
// [2] TABLE FAULT HANDLER:
//=========================
void table_fault_handler(struct Env * curenv, uint32 fault_va)
{
f010fd26:	55                   	push   %ebp
f010fd27:	89 e5                	mov    %esp,%ebp
f010fd29:	83 ec 18             	sub    $0x18,%esp
	//panic("table_fault_handler() is not implemented yet...!!");
	//Check if it's a stack page
	uint32* ptr_table;
#if USE_KHEAP
	{
		ptr_table = create_page_table(curenv->env_page_directory, (uint32)fault_va);
f010fd2c:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd2f:	8b 40 64             	mov    0x64(%eax),%eax
f010fd32:	83 ec 08             	sub    $0x8,%esp
f010fd35:	ff 75 0c             	pushl  0xc(%ebp)
f010fd38:	50                   	push   %eax
f010fd39:	e8 6b 97 ff ff       	call   f01094a9 <create_page_table>
f010fd3e:	83 c4 10             	add    $0x10,%esp
f010fd41:	89 45 f4             	mov    %eax,-0xc(%ebp)
#else
	{
		__static_cpt(curenv->env_page_directory, (uint32)fault_va, &ptr_table);
	}
#endif
}
f010fd44:	90                   	nop
f010fd45:	c9                   	leave  
f010fd46:	c3                   	ret    

f010fd47 <get_optimal_num_faults>:
 * 	3. Page References List (contains the stream of referenced VAs till the process finished)
 *
 * 	IMPORTANT: This function SHOULD NOT change any of the given lists
 */
int get_optimal_num_faults(struct WS_List *initWorkingSet, int maxWSSize, struct PageRef_List *pageReferences)
{
f010fd47:	55                   	push   %ebp
f010fd48:	89 e5                	mov    %esp,%ebp
f010fd4a:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #2 get_optimal_num_faults
	//Your code is here
	//Comment the following line
	panic("get_optimal_num_faults() is not implemented yet...!!");
f010fd4d:	83 ec 04             	sub    $0x4,%esp
f010fd50:	68 a8 17 13 f0       	push   $0xf01317a8
f010fd55:	68 f4 00 00 00       	push   $0xf4
f010fd5a:	68 0f 16 13 f0       	push   $0xf013160f
f010fd5f:	e8 4b 12 ff ff       	call   f0100faf <_panic>

f010fd64 <page_fault_handler>:
}

void page_fault_handler(struct Env * faulted_env, uint32 fault_va)
{
f010fd64:	55                   	push   %ebp
f010fd65:	89 e5                	mov    %esp,%ebp
f010fd67:	83 ec 18             	sub    $0x18,%esp
#if USE_KHEAP
	struct WorkingSetElement *victimWSElement = NULL;
f010fd6a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 wsSize = LIST_SIZE(&(faulted_env->page_WS_list));
f010fd71:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd74:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f010fd7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
#else
	int iWS =faulted_env->page_last_WS_index;
	uint32 wsSize = env_page_ws_get_size(faulted_env);
#endif
	if(wsSize < (faulted_env->page_WS_max_size))
f010fd7d:	8b 45 08             	mov    0x8(%ebp),%eax
f010fd80:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f010fd86:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f010fd89:	76 17                	jbe    f010fda2 <page_fault_handler+0x3e>
	{
		//TODO: [PROJECT'25.GM#3] FAULT HANDLER I - #3 placement
		//Your code is here
		//Comment the following line
		panic("page_fault_handler().PLACEMENT is not implemented yet...!!");
f010fd8b:	83 ec 04             	sub    $0x4,%esp
f010fd8e:	68 e0 17 13 f0       	push   $0xf01317e0
f010fd93:	68 05 01 00 00       	push   $0x105
f010fd98:	68 0f 16 13 f0       	push   $0xf013160f
f010fd9d:	e8 0d 12 ff ff       	call   f0100faf <_panic>
	}
	else
	{
		if (isPageReplacmentAlgorithmOPTIMAL())
f010fda2:	e8 19 fc ff ff       	call   f010f9c0 <isPageReplacmentAlgorithmOPTIMAL>
f010fda7:	85 c0                	test   %eax,%eax
f010fda9:	74 17                	je     f010fdc2 <page_fault_handler+0x5e>
		{
			//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #1 Optimal Reference Stream
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fdab:	83 ec 04             	sub    $0x4,%esp
f010fdae:	68 1c 18 13 f0       	push   $0xf013181c
f010fdb3:	68 0e 01 00 00       	push   $0x10e
f010fdb8:	68 0f 16 13 f0       	push   $0xf013160f
f010fdbd:	e8 ed 11 ff ff       	call   f0100faf <_panic>
		}
		else if (isPageReplacmentAlgorithmOPTIMAL())
f010fdc2:	e8 f9 fb ff ff       	call   f010f9c0 <isPageReplacmentAlgorithmOPTIMAL>
f010fdc7:	85 c0                	test   %eax,%eax
f010fdc9:	74 17                	je     f010fde2 <page_fault_handler+0x7e>
		{
			//TODO: [PROJECT'25.IM#1] FAULT HANDLER II - #3 Clock Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fdcb:	83 ec 04             	sub    $0x4,%esp
f010fdce:	68 1c 18 13 f0       	push   $0xf013181c
f010fdd3:	68 15 01 00 00       	push   $0x115
f010fdd8:	68 0f 16 13 f0       	push   $0xf013160f
f010fddd:	e8 cd 11 ff ff       	call   f0100faf <_panic>
		}
		else if (isPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX))
f010fde2:	83 ec 0c             	sub    $0xc,%esp
f010fde5:	6a 01                	push   $0x1
f010fde7:	e8 37 fb ff ff       	call   f010f923 <isPageReplacmentAlgorithmLRU>
f010fdec:	83 c4 10             	add    $0x10,%esp
f010fdef:	85 c0                	test   %eax,%eax
f010fdf1:	74 17                	je     f010fe0a <page_fault_handler+0xa6>
		{
			//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #2 LRU Aging Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fdf3:	83 ec 04             	sub    $0x4,%esp
f010fdf6:	68 1c 18 13 f0       	push   $0xf013181c
f010fdfb:	68 1c 01 00 00       	push   $0x11c
f010fe00:	68 0f 16 13 f0       	push   $0xf013160f
f010fe05:	e8 a5 11 ff ff       	call   f0100faf <_panic>
		}
		else if (isPageReplacmentAlgorithmModifiedCLOCK())
f010fe0a:	e8 60 fb ff ff       	call   f010f96f <isPageReplacmentAlgorithmModifiedCLOCK>
f010fe0f:	85 c0                	test   %eax,%eax
f010fe11:	74 17                	je     f010fe2a <page_fault_handler+0xc6>
		{
			//TODO: [PROJECT'25.IM#6] FAULT HANDLER II - #3 Modified Clock Replacement
			//Your code is here
			//Comment the following line
			panic("page_fault_handler().REPLACEMENT is not implemented yet...!!");
f010fe13:	83 ec 04             	sub    $0x4,%esp
f010fe16:	68 1c 18 13 f0       	push   $0xf013181c
f010fe1b:	68 23 01 00 00       	push   $0x123
f010fe20:	68 0f 16 13 f0       	push   $0xf013160f
f010fe25:	e8 85 11 ff ff       	call   f0100faf <_panic>
		}
	}
}
f010fe2a:	90                   	nop
f010fe2b:	c9                   	leave  
f010fe2c:	c3                   	ret    

f010fe2d <__page_fault_handler_with_buffering>:

void __page_fault_handler_with_buffering(struct Env * curenv, uint32 fault_va)
{
f010fe2d:	55                   	push   %ebp
f010fe2e:	89 e5                	mov    %esp,%ebp
f010fe30:	83 ec 08             	sub    $0x8,%esp
	panic("this function is not required...!!");
f010fe33:	83 ec 04             	sub    $0x4,%esp
f010fe36:	68 5c 18 13 f0       	push   $0xf013185c
f010fe3b:	68 2a 01 00 00       	push   $0x12a
f010fe40:	68 0f 16 13 f0       	push   $0xf013160f
f010fe45:	e8 65 11 ff ff       	call   f0100faf <_panic>

f010fe4a <init_kspinlock>:
#include "inc/assert.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_kspinlock(struct kspinlock *lk, char *name)
{
f010fe4a:	55                   	push   %ebp
f010fe4b:	89 e5                	mov    %esp,%ebp
f010fe4d:	83 ec 08             	sub    $0x8,%esp
	strcpy(lk->name, name);
f010fe50:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe53:	83 c0 04             	add    $0x4,%eax
f010fe56:	83 ec 08             	sub    $0x8,%esp
f010fe59:	ff 75 0c             	pushl  0xc(%ebp)
f010fe5c:	50                   	push   %eax
f010fe5d:	e8 68 ad 00 00       	call   f011abca <strcpy>
f010fe62:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f010fe65:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe68:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->cpu = 0;
f010fe6e:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe71:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
}
f010fe78:	90                   	nop
f010fe79:	c9                   	leave  
f010fe7a:	c3                   	ret    

f010fe7b <acquire_kspinlock>:
// Acquire the lock.
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void acquire_kspinlock(struct kspinlock *lk)
{
f010fe7b:	55                   	push   %ebp
f010fe7c:	89 e5                	mov    %esp,%ebp
f010fe7e:	53                   	push   %ebx
f010fe7f:	83 ec 24             	sub    $0x24,%esp
	if(holding_kspinlock(lk))
f010fe82:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe85:	83 ec 0c             	sub    $0xc,%esp
f010fe88:	50                   	push   %eax
f010fe89:	e8 42 02 00 00       	call   f01100d0 <holding_kspinlock>
f010fe8e:	83 c4 10             	add    $0x10,%esp
f010fe91:	85 c0                	test   %eax,%eax
f010fe93:	74 18                	je     f010fead <acquire_kspinlock+0x32>
		panic("acquire_spinlock: lock \"%s\" is already held by the same CPU.", lk->name);
f010fe95:	8b 45 08             	mov    0x8(%ebp),%eax
f010fe98:	83 c0 04             	add    $0x4,%eax
f010fe9b:	50                   	push   %eax
f010fe9c:	68 80 18 13 f0       	push   $0xf0131880
f010fea1:	6a 1f                	push   $0x1f
f010fea3:	68 bd 18 13 f0       	push   $0xf01318bd
f010fea8:	e8 02 11 ff ff       	call   f0100faf <_panic>

	/*disable interrupts to avoid deadlock (in case if interrupted from a higher priority (or event handler)
	 * just after holding the lock => the handler will stuck in busy-waiting and prevent the other from resuming)
	 */
	pushcli();
f010fead:	e8 7e 82 ff ff       	call   f0108130 <pushcli>

	int envID = 0;
f010feb2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f010feb9:	e8 5a bc ff ff       	call   f010bb18 <get_cpu_proc>
f010febe:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f010fec1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010fec5:	74 09                	je     f010fed0 <acquire_kspinlock+0x55>
f010fec7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010feca:	8b 40 10             	mov    0x10(%eax),%eax
f010fecd:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] try to acquire spinlock [%s]\n", envID, lk->name);

	// The xchg is atomic.
	while(xchg(&lk->locked, 1) != 0) ;
f010fed0:	90                   	nop
f010fed1:	8b 45 08             	mov    0x8(%ebp),%eax
f010fed4:	89 45 ec             	mov    %eax,-0x14(%ebp)
f010fed7:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)
xchg(volatile uint32 *addr, uint32 newval)
{
  uint32 result;

  // The + in "+m" denotes a read-modify-write operand.
  __asm __volatile("lock; xchgl %0, %1" :
f010fede:	8b 55 ec             	mov    -0x14(%ebp),%edx
f010fee1:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fee4:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f010fee7:	f0 87 02             	lock xchg %eax,(%edx)
f010feea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
               "+m" (*addr), "=a" (result) :
               "1" (newval) :
               "cc");
  return result;
f010feed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f010fef0:	85 c0                	test   %eax,%eax
f010fef2:	75 dd                	jne    f010fed1 <acquire_kspinlock+0x56>
	//cprintf("SPIN lock [%s] is ACQUIRED  by [%d]\n", lk->name, envID);

	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that the critical section's memory
	// references happen after the lock is acquired.
	__sync_synchronize();
f010fef4:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Record info about lock acquisition for debugging.
	lk->cpu = mycpu();
f010fef9:	8b 5d 08             	mov    0x8(%ebp),%ebx
f010fefc:	e8 6f 81 ff ff       	call   f0108070 <mycpu>
f010ff01:	89 43 44             	mov    %eax,0x44(%ebx)
	getcallerpcs(&lk, lk->pcs);
f010ff04:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff07:	83 c0 48             	add    $0x48,%eax
f010ff0a:	83 ec 08             	sub    $0x8,%esp
f010ff0d:	50                   	push   %eax
f010ff0e:	8d 45 08             	lea    0x8(%ebp),%eax
f010ff11:	50                   	push   %eax
f010ff12:	e8 92 00 00 00       	call   f010ffa9 <getcallerpcs>
f010ff17:	83 c4 10             	add    $0x10,%esp

}
f010ff1a:	90                   	nop
f010ff1b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f010ff1e:	c9                   	leave  
f010ff1f:	c3                   	ret    

f010ff20 <release_kspinlock>:

// Release the lock.
void release_kspinlock(struct kspinlock *lk)
{
f010ff20:	55                   	push   %ebp
f010ff21:	89 e5                	mov    %esp,%ebp
f010ff23:	83 ec 18             	sub    $0x18,%esp
	if(!holding_kspinlock(lk))
f010ff26:	83 ec 0c             	sub    $0xc,%esp
f010ff29:	ff 75 08             	pushl  0x8(%ebp)
f010ff2c:	e8 9f 01 00 00       	call   f01100d0 <holding_kspinlock>
f010ff31:	83 c4 10             	add    $0x10,%esp
f010ff34:	85 c0                	test   %eax,%eax
f010ff36:	75 26                	jne    f010ff5e <release_kspinlock+0x3e>
	{
		printcallstack(lk);
f010ff38:	83 ec 0c             	sub    $0xc,%esp
f010ff3b:	ff 75 08             	pushl  0x8(%ebp)
f010ff3e:	e8 26 01 00 00       	call   f0110069 <printcallstack>
f010ff43:	83 c4 10             	add    $0x10,%esp
		panic("release: lock \"%s\" is either not held or held by another CPU!", lk->name);
f010ff46:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff49:	83 c0 04             	add    $0x4,%eax
f010ff4c:	50                   	push   %eax
f010ff4d:	68 d4 18 13 f0       	push   $0xf01318d4
f010ff52:	6a 41                	push   $0x41
f010ff54:	68 bd 18 13 f0       	push   $0xf01318bd
f010ff59:	e8 51 10 ff ff       	call   f0100faf <_panic>
	}
	lk->pcs[0] = 0;
f010ff5e:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff61:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	lk->cpu = 0;
f010ff68:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff6b:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)
	// Tell the C compiler and the processor to not move loads or stores
	// past this point, to ensure that all the stores in the critical
	// section are visible to other cores before the lock is released.
	// Both the C compiler and the hardware may re-order loads and
	// stores; __sync_synchronize() tells them both not to.
	__sync_synchronize();
f010ff72:	f0 83 0c 24 00       	lock orl $0x0,(%esp)

	// Release the lock, equivalent to lk->locked = 0.
	// This code can't use a C assignment, since it might
	// not be atomic. A real OS would use C atomics here.
	asm volatile("movl $0, %0" : "+m" (lk->locked) : );
f010ff77:	8b 45 08             	mov    0x8(%ebp),%eax
f010ff7a:	8b 55 08             	mov    0x8(%ebp),%edx
f010ff7d:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	int envID = 0;
f010ff83:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct Env *e = get_cpu_proc() ;
f010ff8a:	e8 89 bb ff ff       	call   f010bb18 <get_cpu_proc>
f010ff8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (e) envID = e->env_id;
f010ff92:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f010ff96:	74 09                	je     f010ffa1 <release_kspinlock+0x81>
f010ff98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f010ff9b:	8b 40 10             	mov    0x10(%eax),%eax
f010ff9e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//cprintf("[%d] release spinlock [%s]\n", envID, lk->name);

	popcli();
f010ffa1:	e8 dc 81 ff ff       	call   f0108182 <popcli>

}
f010ffa6:	90                   	nop
f010ffa7:	c9                   	leave  
f010ffa8:	c3                   	ret    

f010ffa9 <getcallerpcs>:

// Record the current call stack in pcs[] by following the %ebp chain.
int getcallerpcs(void *v, uint32 pcs[])
{
f010ffa9:	55                   	push   %ebp
f010ffaa:	89 e5                	mov    %esp,%ebp
f010ffac:	83 ec 28             	sub    $0x28,%esp
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
f010ffaf:	e8 64 bb ff ff       	call   f010bb18 <get_cpu_proc>
f010ffb4:	89 45 ec             	mov    %eax,-0x14(%ebp)
	struct cpu* c = mycpu();
f010ffb7:	e8 b4 80 ff ff       	call   f0108070 <mycpu>
f010ffbc:	89 45 e8             	mov    %eax,-0x18(%ebp)
	ebp = (uint32*)v - 2;
f010ffbf:	8b 45 08             	mov    0x8(%ebp),%eax
f010ffc2:	83 e8 08             	sub    $0x8,%eax
f010ffc5:	89 45 f4             	mov    %eax,-0xc(%ebp)
	for(i = 0; i < 10; i++)
f010ffc8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f010ffcf:	eb 67                	jmp    f0110038 <getcallerpcs+0x8f>
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ffd1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f010ffd5:	74 67                	je     f011003e <getcallerpcs+0x95>
f010ffd7:	81 7d f4 ff ff 7f ef 	cmpl   $0xef7fffff,-0xc(%ebp)
f010ffde:	76 5e                	jbe    f011003e <getcallerpcs+0x95>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010ffe0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010ffe3:	8b 40 08             	mov    0x8(%eax),%eax
f010ffe6:	05 00 80 00 00       	add    $0x8000,%eax
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
	{
		//cprintf("old ebp = %x\n", ebp);
		if	(	ebp == 0 || (ebp < (uint32*) USER_LIMIT) ||
f010ffeb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010ffee:	77 10                	ja     f0110000 <getcallerpcs+0x57>
				(ebp >= (uint32*)(c->stack + KERNEL_STACK_SIZE) && ebp < (uint32*)(c->stack + KERNEL_STACK_SIZE + PAGE_SIZE)) ||
f010fff0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f010fff3:	8b 40 08             	mov    0x8(%eax),%eax
f010fff6:	05 00 90 00 00       	add    $0x9000,%eax
f010fffb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f010fffe:	77 3e                	ja     f011003e <getcallerpcs+0x95>
f0110000:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0110004:	74 10                	je     f0110016 <getcallerpcs+0x6d>
				(p && ebp >= (uint32*) (p->kstack + KERNEL_STACK_SIZE)))
f0110006:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110009:	8b 40 70             	mov    0x70(%eax),%eax
f011000c:	05 00 80 00 00       	add    $0x8000,%eax
f0110011:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0110014:	76 28                	jbe    f011003e <getcallerpcs+0x95>
			break;
		pcs[i] = ebp[1];     // saved %eip
f0110016:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110019:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110020:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110023:	01 c2                	add    %eax,%edx
f0110025:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110028:	8b 40 04             	mov    0x4(%eax),%eax
f011002b:	89 02                	mov    %eax,(%edx)
		ebp = (uint32*)ebp[0]; // saved %ebp
f011002d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110030:	8b 00                	mov    (%eax),%eax
f0110032:	89 45 f4             	mov    %eax,-0xc(%ebp)
	uint32 *ebp;
	int i;
	struct Env* p = get_cpu_proc();
	struct cpu* c = mycpu();
	ebp = (uint32*)v - 2;
	for(i = 0; i < 10; i++)
f0110035:	ff 45 f0             	incl   -0x10(%ebp)
f0110038:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f011003c:	7e 93                	jle    f010ffd1 <getcallerpcs+0x28>
		pcs[i] = ebp[1];     // saved %eip
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
f011003e:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110041:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for(; i < 10; i++)
f0110044:	eb 18                	jmp    f011005e <getcallerpcs+0xb5>
		pcs[i] = 0;
f0110046:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110049:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0110050:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110053:	01 d0                	add    %edx,%eax
f0110055:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		ebp = (uint32*)ebp[0]; // saved %ebp
		//		cprintf("new ebp = %x\n", ebp);
		//		cprintf("pc[%d] = %x\n", i, pcs[i]);
	}
	int length = i ;
	for(; i < 10; i++)
f011005b:	ff 45 f0             	incl   -0x10(%ebp)
f011005e:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0110062:	7e e2                	jle    f0110046 <getcallerpcs+0x9d>
		pcs[i] = 0;
	return length ;
f0110064:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f0110067:	c9                   	leave  
f0110068:	c3                   	ret    

f0110069 <printcallstack>:

void printcallstack(struct kspinlock *lk)
{
f0110069:	55                   	push   %ebp
f011006a:	89 e5                	mov    %esp,%ebp
f011006c:	83 ec 18             	sub    $0x18,%esp
	cprintf("\nCaller Stack:\n");
f011006f:	83 ec 0c             	sub    $0xc,%esp
f0110072:	68 12 19 13 f0       	push   $0xf0131912
f0110077:	e8 e0 1b ff ff       	call   f0101c5c <cprintf>
f011007c:	83 c4 10             	add    $0x10,%esp
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
f011007f:	8b 45 08             	mov    0x8(%ebp),%eax
f0110082:	83 c0 48             	add    $0x48,%eax
f0110085:	83 ec 08             	sub    $0x8,%esp
f0110088:	50                   	push   %eax
f0110089:	8d 45 08             	lea    0x8(%ebp),%eax
f011008c:	50                   	push   %eax
f011008d:	e8 17 ff ff ff       	call   f010ffa9 <getcallerpcs>
f0110092:	83 c4 10             	add    $0x10,%esp
f0110095:	89 45 f0             	mov    %eax,-0x10(%ebp)
	for (int i = 0; i < stacklen; ++i) {
f0110098:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011009f:	eb 24                	jmp    f01100c5 <printcallstack+0x5c>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
f01100a1:	8b 45 08             	mov    0x8(%ebp),%eax
f01100a4:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01100a7:	83 c2 10             	add    $0x10,%edx
f01100aa:	8b 44 90 08          	mov    0x8(%eax,%edx,4),%eax
f01100ae:	83 ec 04             	sub    $0x4,%esp
f01100b1:	50                   	push   %eax
f01100b2:	ff 75 f4             	pushl  -0xc(%ebp)
f01100b5:	68 22 19 13 f0       	push   $0xf0131922
f01100ba:	e8 9d 1b ff ff       	call   f0101c5c <cprintf>
f01100bf:	83 c4 10             	add    $0x10,%esp

void printcallstack(struct kspinlock *lk)
{
	cprintf("\nCaller Stack:\n");
	int stacklen = 	getcallerpcs(&lk, lk->pcs);
	for (int i = 0; i < stacklen; ++i) {
f01100c2:	ff 45 f4             	incl   -0xc(%ebp)
f01100c5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01100c8:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f01100cb:	7c d4                	jl     f01100a1 <printcallstack+0x38>
		cprintf("  PC[%d] = %x\n", i, lk->pcs[i]);
	}
}
f01100cd:	90                   	nop
f01100ce:	c9                   	leave  
f01100cf:	c3                   	ret    

f01100d0 <holding_kspinlock>:
// Check whether this cpu is holding the lock.
int holding_kspinlock(struct kspinlock *lock)
{
f01100d0:	55                   	push   %ebp
f01100d1:	89 e5                	mov    %esp,%ebp
f01100d3:	53                   	push   %ebx
f01100d4:	83 ec 14             	sub    $0x14,%esp
	int r;
	pushcli();
f01100d7:	e8 54 80 ff ff       	call   f0108130 <pushcli>
	r = lock->locked && lock->cpu == mycpu();
f01100dc:	8b 45 08             	mov    0x8(%ebp),%eax
f01100df:	8b 00                	mov    (%eax),%eax
f01100e1:	85 c0                	test   %eax,%eax
f01100e3:	74 16                	je     f01100fb <holding_kspinlock+0x2b>
f01100e5:	8b 45 08             	mov    0x8(%ebp),%eax
f01100e8:	8b 58 44             	mov    0x44(%eax),%ebx
f01100eb:	e8 80 7f ff ff       	call   f0108070 <mycpu>
f01100f0:	39 c3                	cmp    %eax,%ebx
f01100f2:	75 07                	jne    f01100fb <holding_kspinlock+0x2b>
f01100f4:	b8 01 00 00 00       	mov    $0x1,%eax
f01100f9:	eb 05                	jmp    f0110100 <holding_kspinlock+0x30>
f01100fb:	b8 00 00 00 00       	mov    $0x0,%eax
f0110100:	89 45 f4             	mov    %eax,-0xc(%ebp)
	popcli();
f0110103:	e8 7a 80 ff ff       	call   f0108182 <popcli>
	return r;
f0110108:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011010b:	83 c4 14             	add    $0x14,%esp
f011010e:	5b                   	pop    %ebx
f011010f:	5d                   	pop    %ebp
f0110110:	c3                   	ret    

f0110111 <init_sleeplock>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_sleeplock(struct sleeplock *lk, char *name)
{
f0110111:	55                   	push   %ebp
f0110112:	89 e5                	mov    %esp,%ebp
f0110114:	57                   	push   %edi
f0110115:	56                   	push   %esi
f0110116:	53                   	push   %ebx
f0110117:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	init_channel(&(lk->chan), "sleep lock channel");
f011011d:	8b 45 08             	mov    0x8(%ebp),%eax
f0110120:	83 c0 74             	add    $0x74,%eax
f0110123:	83 ec 08             	sub    $0x8,%esp
f0110126:	68 34 19 13 f0       	push   $0xf0131934
f011012b:	50                   	push   %eax
f011012c:	e8 22 01 00 00       	call   f0110253 <init_channel>
f0110131:	83 c4 10             	add    $0x10,%esp
	char prefix[30] = "lock of sleeplock - ";
f0110134:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0110137:	bb 47 19 13 f0       	mov    $0xf0131947,%ebx
f011013c:	ba 15 00 00 00       	mov    $0x15,%edx
f0110141:	89 c7                	mov    %eax,%edi
f0110143:	89 de                	mov    %ebx,%esi
f0110145:	89 d1                	mov    %edx,%ecx
f0110147:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0110149:	8d 55 df             	lea    -0x21(%ebp),%edx
f011014c:	b9 09 00 00 00       	mov    $0x9,%ecx
f0110151:	b0 00                	mov    $0x0,%al
f0110153:	89 d7                	mov    %edx,%edi
f0110155:	f3 aa                	rep stos %al,%es:(%edi)
	char guardName[30+NAMELEN];
	strcconcat(prefix, name, guardName);
f0110157:	83 ec 04             	sub    $0x4,%esp
f011015a:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0110160:	50                   	push   %eax
f0110161:	ff 75 0c             	pushl  0xc(%ebp)
f0110164:	8d 45 ca             	lea    -0x36(%ebp),%eax
f0110167:	50                   	push   %eax
f0110168:	e8 3c b0 00 00       	call   f011b1a9 <strcconcat>
f011016d:	83 c4 10             	add    $0x10,%esp
	init_kspinlock(&(lk->lk), guardName);
f0110170:	8b 45 08             	mov    0x8(%ebp),%eax
f0110173:	8d 50 04             	lea    0x4(%eax),%edx
f0110176:	83 ec 08             	sub    $0x8,%esp
f0110179:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f011017f:	50                   	push   %eax
f0110180:	52                   	push   %edx
f0110181:	e8 c4 fc ff ff       	call   f010fe4a <init_kspinlock>
f0110186:	83 c4 10             	add    $0x10,%esp
	strcpy(lk->name, name);
f0110189:	8b 45 08             	mov    0x8(%ebp),%eax
f011018c:	05 c4 00 00 00       	add    $0xc4,%eax
f0110191:	83 ec 08             	sub    $0x8,%esp
f0110194:	ff 75 0c             	pushl  0xc(%ebp)
f0110197:	50                   	push   %eax
f0110198:	e8 2d aa 00 00       	call   f011abca <strcpy>
f011019d:	83 c4 10             	add    $0x10,%esp
	lk->locked = 0;
f01101a0:	8b 45 08             	mov    0x8(%ebp),%eax
f01101a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	lk->pid = 0;
f01101a9:	8b 45 08             	mov    0x8(%ebp),%eax
f01101ac:	c7 80 04 01 00 00 00 	movl   $0x0,0x104(%eax)
f01101b3:	00 00 00 
}
f01101b6:	90                   	nop
f01101b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01101ba:	5b                   	pop    %ebx
f01101bb:	5e                   	pop    %esi
f01101bc:	5f                   	pop    %edi
f01101bd:	5d                   	pop    %ebp
f01101be:	c3                   	ret    

f01101bf <acquire_sleeplock>:

void acquire_sleeplock(struct sleeplock *lk)
{
f01101bf:	55                   	push   %ebp
f01101c0:	89 e5                	mov    %esp,%ebp
f01101c2:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #4 SLEEP LOCK - acquire_sleeplock
	//Your code is here
	//Comment the following line
	panic("acquire_sleeplock() is not implemented yet...!!");
f01101c5:	83 ec 04             	sub    $0x4,%esp
f01101c8:	68 68 19 13 f0       	push   $0xf0131968
f01101cd:	6a 20                	push   $0x20
f01101cf:	68 98 19 13 f0       	push   $0xf0131998
f01101d4:	e8 d6 0d ff ff       	call   f0100faf <_panic>

f01101d9 <release_sleeplock>:
}

void release_sleeplock(struct sleeplock *lk)
{
f01101d9:	55                   	push   %ebp
f01101da:	89 e5                	mov    %esp,%ebp
f01101dc:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #5 SLEEP LOCK - release_sleeplock
	//Your code is here
	//Comment the following line
	panic("release_sleeplock() is not implemented yet...!!");
f01101df:	83 ec 04             	sub    $0x4,%esp
f01101e2:	68 b0 19 13 f0       	push   $0xf01319b0
f01101e7:	6a 28                	push   $0x28
f01101e9:	68 98 19 13 f0       	push   $0xf0131998
f01101ee:	e8 bc 0d ff ff       	call   f0100faf <_panic>

f01101f3 <holding_sleeplock>:
}

int holding_sleeplock(struct sleeplock *lk)
{
f01101f3:	55                   	push   %ebp
f01101f4:	89 e5                	mov    %esp,%ebp
f01101f6:	53                   	push   %ebx
f01101f7:	83 ec 14             	sub    $0x14,%esp
	int r;
	acquire_kspinlock(&(lk->lk));
f01101fa:	8b 45 08             	mov    0x8(%ebp),%eax
f01101fd:	83 c0 04             	add    $0x4,%eax
f0110200:	83 ec 0c             	sub    $0xc,%esp
f0110203:	50                   	push   %eax
f0110204:	e8 72 fc ff ff       	call   f010fe7b <acquire_kspinlock>
f0110209:	83 c4 10             	add    $0x10,%esp
	r = lk->locked && (lk->pid == get_cpu_proc()->env_id);
f011020c:	8b 45 08             	mov    0x8(%ebp),%eax
f011020f:	8b 00                	mov    (%eax),%eax
f0110211:	85 c0                	test   %eax,%eax
f0110213:	74 1c                	je     f0110231 <holding_sleeplock+0x3e>
f0110215:	8b 45 08             	mov    0x8(%ebp),%eax
f0110218:	8b 98 04 01 00 00    	mov    0x104(%eax),%ebx
f011021e:	e8 f5 b8 ff ff       	call   f010bb18 <get_cpu_proc>
f0110223:	8b 40 10             	mov    0x10(%eax),%eax
f0110226:	39 c3                	cmp    %eax,%ebx
f0110228:	75 07                	jne    f0110231 <holding_sleeplock+0x3e>
f011022a:	b8 01 00 00 00       	mov    $0x1,%eax
f011022f:	eb 05                	jmp    f0110236 <holding_sleeplock+0x43>
f0110231:	b8 00 00 00 00       	mov    $0x0,%eax
f0110236:	89 45 f4             	mov    %eax,-0xc(%ebp)
	release_kspinlock(&(lk->lk));
f0110239:	8b 45 08             	mov    0x8(%ebp),%eax
f011023c:	83 c0 04             	add    $0x4,%eax
f011023f:	83 ec 0c             	sub    $0xc,%esp
f0110242:	50                   	push   %eax
f0110243:	e8 d8 fc ff ff       	call   f010ff20 <release_kspinlock>
f0110248:	83 c4 10             	add    $0x10,%esp
	return r;
f011024b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011024e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0110251:	c9                   	leave  
f0110252:	c3                   	ret    

f0110253 <init_channel>:
//===============================
// 1) INITIALIZE THE CHANNEL:
//===============================
// initialize its lock & queue
void init_channel(struct Channel *chan, char *name)
{
f0110253:	55                   	push   %ebp
f0110254:	89 e5                	mov    %esp,%ebp
f0110256:	83 ec 08             	sub    $0x8,%esp
	strcpy(chan->name, name);
f0110259:	8b 45 08             	mov    0x8(%ebp),%eax
f011025c:	83 c0 10             	add    $0x10,%eax
f011025f:	83 ec 08             	sub    $0x8,%esp
f0110262:	ff 75 0c             	pushl  0xc(%ebp)
f0110265:	50                   	push   %eax
f0110266:	e8 5f a9 00 00       	call   f011abca <strcpy>
f011026b:	83 c4 10             	add    $0x10,%esp
	init_queue(&(chan->queue));
f011026e:	8b 45 08             	mov    0x8(%ebp),%eax
f0110271:	83 ec 0c             	sub    $0xc,%esp
f0110274:	50                   	push   %eax
f0110275:	e8 50 5d ff ff       	call   f0105fca <init_queue>
f011027a:	83 c4 10             	add    $0x10,%esp
}
f011027d:	90                   	nop
f011027e:	c9                   	leave  
f011027f:	c3                   	ret    

f0110280 <sleep>:
//===============================
// Atomically release lock and sleep on chan.
// Reacquires lock when awakened.
// Ref: xv6-x86 OS code
void sleep(struct Channel *chan, struct kspinlock* lk)
{
f0110280:	55                   	push   %ebp
f0110281:	89 e5                	mov    %esp,%ebp
f0110283:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #1 CHANNEL - sleep
	//Your code is here
	//Comment the following line
	panic("sleep() is not implemented yet...!!");
f0110286:	83 ec 04             	sub    $0x4,%esp
f0110289:	68 e0 19 13 f0       	push   $0xf01319e0
f011028e:	6a 22                	push   $0x22
f0110290:	68 04 1a 13 f0       	push   $0xf0131a04
f0110295:	e8 15 0d ff ff       	call   f0100faf <_panic>

f011029a <wakeup_one>:
// Wake up ONE process sleeping on chan.
// The qlock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes
void wakeup_one(struct Channel *chan)
{
f011029a:	55                   	push   %ebp
f011029b:	89 e5                	mov    %esp,%ebp
f011029d:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #2 CHANNEL - wakeup_one
	//Your code is here
	//Comment the following line
	panic("wakeup_one() is not implemented yet...!!");
f01102a0:	83 ec 04             	sub    $0x4,%esp
f01102a3:	68 18 1a 13 f0       	push   $0xf0131a18
f01102a8:	6a 31                	push   $0x31
f01102aa:	68 04 1a 13 f0       	push   $0xf0131a04
f01102af:	e8 fb 0c ff ff       	call   f0100faf <_panic>

f01102b4 <wakeup_all>:
// The queues lock must be held.
// Ref: xv6-x86 OS code
// chan MUST be of type "struct Env_Queue" to hold the blocked processes

void wakeup_all(struct Channel *chan)
{
f01102b4:	55                   	push   %ebp
f01102b5:	89 e5                	mov    %esp,%ebp
f01102b7:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #3 CHANNEL - wakeup_all
	//Your code is here
	//Comment the following line
	panic("wakeup_all() is not implemented yet...!!");
f01102ba:	83 ec 04             	sub    $0x4,%esp
f01102bd:	68 44 1a 13 f0       	push   $0xf0131a44
f01102c2:	6a 41                	push   $0x41
f01102c4:	68 04 1a 13 f0       	push   $0xf0131a04
f01102c9:	e8 e1 0c ff ff       	call   f0100faf <_panic>

f01102ce <init_ksemaphore>:
#include "channel.h"
#include "../cpu/cpu.h"
#include "../proc/user_environment.h"

void init_ksemaphore(struct ksemaphore *ksem, int value, char *name)
{
f01102ce:	55                   	push   %ebp
f01102cf:	89 e5                	mov    %esp,%ebp
f01102d1:	83 ec 08             	sub    $0x8,%esp
	init_channel(&(ksem->chan), "ksemaphore channel");
f01102d4:	8b 45 08             	mov    0x8(%ebp),%eax
f01102d7:	83 c0 74             	add    $0x74,%eax
f01102da:	83 ec 08             	sub    $0x8,%esp
f01102dd:	68 70 1a 13 f0       	push   $0xf0131a70
f01102e2:	50                   	push   %eax
f01102e3:	e8 6b ff ff ff       	call   f0110253 <init_channel>
f01102e8:	83 c4 10             	add    $0x10,%esp
	init_kspinlock(&(ksem->lk), "lock of ksemaphore");
f01102eb:	8b 45 08             	mov    0x8(%ebp),%eax
f01102ee:	83 c0 04             	add    $0x4,%eax
f01102f1:	83 ec 08             	sub    $0x8,%esp
f01102f4:	68 83 1a 13 f0       	push   $0xf0131a83
f01102f9:	50                   	push   %eax
f01102fa:	e8 4b fb ff ff       	call   f010fe4a <init_kspinlock>
f01102ff:	83 c4 10             	add    $0x10,%esp
	strcpy(ksem->name, name);
f0110302:	8b 45 08             	mov    0x8(%ebp),%eax
f0110305:	05 c4 00 00 00       	add    $0xc4,%eax
f011030a:	83 ec 08             	sub    $0x8,%esp
f011030d:	ff 75 10             	pushl  0x10(%ebp)
f0110310:	50                   	push   %eax
f0110311:	e8 b4 a8 00 00       	call   f011abca <strcpy>
f0110316:	83 c4 10             	add    $0x10,%esp
	ksem->count = value;
f0110319:	8b 45 08             	mov    0x8(%ebp),%eax
f011031c:	8b 55 0c             	mov    0xc(%ebp),%edx
f011031f:	89 10                	mov    %edx,(%eax)
}
f0110321:	90                   	nop
f0110322:	c9                   	leave  
f0110323:	c3                   	ret    

f0110324 <wait_ksemaphore>:

void wait_ksemaphore(struct ksemaphore *ksem)
{
f0110324:	55                   	push   %ebp
f0110325:	89 e5                	mov    %esp,%ebp
f0110327:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #6 SEMAPHORE - wait_ksemaphore
	//Your code is here
	//Comment the following line
	panic("wait_ksemaphore() is not implemented yet...!!");
f011032a:	83 ec 04             	sub    $0x4,%esp
f011032d:	68 98 1a 13 f0       	push   $0xf0131a98
f0110332:	6a 1c                	push   $0x1c
f0110334:	68 c6 1a 13 f0       	push   $0xf0131ac6
f0110339:	e8 71 0c ff ff       	call   f0100faf <_panic>

f011033e <signal_ksemaphore>:

}

void signal_ksemaphore(struct ksemaphore *ksem)
{
f011033e:	55                   	push   %ebp
f011033f:	89 e5                	mov    %esp,%ebp
f0110341:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.IM#5] KERNEL PROTECTION: #7 SEMAPHORE - signal_ksemaphore
	//Your code is here
	//Comment the following line
	panic("signal_ksemaphore() is not implemented yet...!!");
f0110344:	83 ec 04             	sub    $0x4,%esp
f0110347:	68 e0 1a 13 f0       	push   $0xf0131ae0
f011034c:	6a 25                	push   $0x25
f011034e:	68 c6 1a 13 f0       	push   $0xf0131ac6
f0110353:	e8 57 0c ff ff       	call   f0100faf <_panic>

f0110358 <set_kheap_strategy>:
uint32 kheapPageAllocStart ;
uint32 kheapPageAllocBreak ;
uint32 kheapPlacementStrategy;

/*2025*/ //Replaced by setter & getter function
static inline void set_kheap_strategy(uint32 strategy){kheapPlacementStrategy = strategy;}
f0110358:	55                   	push   %ebp
f0110359:	89 e5                	mov    %esp,%ebp
f011035b:	8b 45 08             	mov    0x8(%ebp),%eax
f011035e:	a3 c4 69 85 f0       	mov    %eax,0xf08569c4
f0110363:	90                   	nop
f0110364:	5d                   	pop    %ebp
f0110365:	c3                   	ret    

f0110366 <tst_handler>:

//=================//
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
f0110366:	55                   	push   %ebp
f0110367:	89 e5                	mov    %esp,%ebp
f0110369:	83 ec 18             	sub    $0x18,%esp
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f011036c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0110373:	eb 26                	jmp    f011039b <tst_handler+0x35>
	{
		arguments[a] = arguments[a+1] ;
f0110375:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110378:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011037f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110382:	01 c2                	add    %eax,%edx
f0110384:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110387:	40                   	inc    %eax
f0110388:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011038f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110392:	01 c8                	add    %ecx,%eax
f0110394:	8b 00                	mov    (%eax),%eax
f0110396:	89 02                	mov    %eax,(%edx)
/*Test MAIN Handler*/
//=================//
int tst_handler(int number_of_arguments, char **arguments)
{
	//Remove "tst" from arguments
	for (int a = 0; a < number_of_arguments - 1; ++a)
f0110398:	ff 45 f4             	incl   -0xc(%ebp)
f011039b:	8b 45 08             	mov    0x8(%ebp),%eax
f011039e:	48                   	dec    %eax
f011039f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f01103a2:	7f d1                	jg     f0110375 <tst_handler+0xf>
	{
		arguments[a] = arguments[a+1] ;
	}
	number_of_arguments--;
f01103a4:	ff 4d 08             	decl   0x8(%ebp)

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
f01103a7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01103ae:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f01103b5:	eb 35                	jmp    f01103ec <tst_handler+0x86>
	{
		if (strcmp(arguments[0], tests[i].name) == 0)
f01103b7:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01103ba:	89 d0                	mov    %edx,%eax
f01103bc:	01 c0                	add    %eax,%eax
f01103be:	01 d0                	add    %edx,%eax
f01103c0:	c1 e0 02             	shl    $0x2,%eax
f01103c3:	05 c0 00 18 f0       	add    $0xf01800c0,%eax
f01103c8:	8b 10                	mov    (%eax),%edx
f01103ca:	8b 45 0c             	mov    0xc(%ebp),%eax
f01103cd:	8b 00                	mov    (%eax),%eax
f01103cf:	83 ec 08             	sub    $0x8,%esp
f01103d2:	52                   	push   %edx
f01103d3:	50                   	push   %eax
f01103d4:	e8 ae a8 00 00       	call   f011ac87 <strcmp>
f01103d9:	83 c4 10             	add    $0x10,%esp
f01103dc:	85 c0                	test   %eax,%eax
f01103de:	75 09                	jne    f01103e9 <tst_handler+0x83>
		{
			test_found = 1;
f01103e0:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
			break;
f01103e7:	eb 0f                	jmp    f01103f8 <tst_handler+0x92>
	number_of_arguments--;

	//Check name of the given test and execute its corresponding function
	int test_found = 0;
	int i ;
	for (i = 0; i < NUM_OF_TESTS; i++)
f01103e9:	ff 45 ec             	incl   -0x14(%ebp)
f01103ec:	8b 55 ec             	mov    -0x14(%ebp),%edx
f01103ef:	a1 80 01 18 f0       	mov    0xf0180180,%eax
f01103f4:	39 c2                	cmp    %eax,%edx
f01103f6:	72 bf                	jb     f01103b7 <tst_handler+0x51>
			test_found = 1;
			break;
		}
	}

	if(test_found)
f01103f8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01103fc:	74 29                	je     f0110427 <tst_handler+0xc1>
	{
		int return_value;
		return_value = tests[i].function_to_execute(number_of_arguments, arguments);
f01103fe:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0110401:	89 d0                	mov    %edx,%eax
f0110403:	01 c0                	add    %eax,%eax
f0110405:	01 d0                	add    %edx,%eax
f0110407:	c1 e0 02             	shl    $0x2,%eax
f011040a:	05 c8 00 18 f0       	add    $0xf01800c8,%eax
f011040f:	8b 00                	mov    (%eax),%eax
f0110411:	83 ec 08             	sub    $0x8,%esp
f0110414:	ff 75 0c             	pushl  0xc(%ebp)
f0110417:	ff 75 08             	pushl  0x8(%ebp)
f011041a:	ff d0                	call   *%eax
f011041c:	83 c4 10             	add    $0x10,%esp
f011041f:	89 45 e8             	mov    %eax,-0x18(%ebp)
		return return_value;
f0110422:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110425:	eb 1b                	jmp    f0110442 <tst_handler+0xdc>
	}
	else
	{
		cprintf("Unknown test '%s'\n", arguments[0]);
f0110427:	8b 45 0c             	mov    0xc(%ebp),%eax
f011042a:	8b 00                	mov    (%eax),%eax
f011042c:	83 ec 08             	sub    $0x8,%esp
f011042f:	50                   	push   %eax
f0110430:	68 a0 1e 13 f0       	push   $0xf0131ea0
f0110435:	e8 22 18 ff ff       	call   f0101c5c <cprintf>
f011043a:	83 c4 10             	add    $0x10,%esp
		return 0;
f011043d:	b8 00 00 00 00       	mov    $0x0,%eax
	}
}
f0110442:	c9                   	leave  
f0110443:	c3                   	ret    

f0110444 <tst_three_creation_functions>:

//=================//
/*TESTING Functions*/
//=================//
int tst_three_creation_functions(int number_of_arguments, char **arguments)
{
f0110444:	55                   	push   %ebp
f0110445:	89 e5                	mov    %esp,%ebp
f0110447:	83 ec 08             	sub    $0x8,%esp
	test_three_creation_functions();
f011044a:	e8 25 78 00 00       	call   f0117c74 <test_three_creation_functions>
	return 0;
f011044f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110454:	c9                   	leave  
f0110455:	c3                   	ret    

f0110456 <tst_priority1>:

int tst_priority1(int number_of_arguments, char **arguments)
{
f0110456:	55                   	push   %ebp
f0110457:	89 e5                	mov    %esp,%ebp
f0110459:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_higher();
f011045c:	e8 3a 6e 00 00       	call   f011729b <test_priority_normal_and_higher>
	return 0;
f0110461:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110466:	c9                   	leave  
f0110467:	c3                   	ret    

f0110468 <tst_priority2>:

int tst_priority2(int number_of_arguments, char **arguments)
{
f0110468:	55                   	push   %ebp
f0110469:	89 e5                	mov    %esp,%ebp
f011046b:	83 ec 08             	sub    $0x8,%esp
	test_priority_normal_and_lower();
f011046e:	e8 42 6e 00 00       	call   f01172b5 <test_priority_normal_and_lower>
	return 0;
f0110473:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110478:	c9                   	leave  
f0110479:	c3                   	ret    

f011047a <tst_kfreeall>:

int tst_kfreeall(int number_of_arguments, char **arguments)
{
f011047a:	55                   	push   %ebp
f011047b:	89 e5                	mov    %esp,%ebp
f011047d:	83 ec 08             	sub    $0x8,%esp
	test_kfreeall();
f0110480:	e8 a2 79 00 00       	call   f0117e27 <test_kfreeall>
	return 0;
f0110485:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011048a:	c9                   	leave  
f011048b:	c3                   	ret    

f011048c <tst_kexpand>:

int tst_kexpand(int number_of_arguments, char **arguments)
{
f011048c:	55                   	push   %ebp
f011048d:	89 e5                	mov    %esp,%ebp
f011048f:	83 ec 08             	sub    $0x8,%esp
	test_kexpand();
f0110492:	e8 ad 79 00 00       	call   f0117e44 <test_kexpand>
	return 0;
f0110497:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011049c:	c9                   	leave  
f011049d:	c3                   	ret    

f011049e <tst_kshrink>:

int tst_kshrink(int number_of_arguments, char **arguments)
{
f011049e:	55                   	push   %ebp
f011049f:	89 e5                	mov    %esp,%ebp
f01104a1:	83 ec 08             	sub    $0x8,%esp
	test_kshrink();
f01104a4:	e8 b8 79 00 00       	call   f0117e61 <test_kshrink>
	return 0;
f01104a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104ae:	c9                   	leave  
f01104af:	c3                   	ret    

f01104b0 <tst_kfreelast>:

int tst_kfreelast(int number_of_arguments, char **arguments)
{
f01104b0:	55                   	push   %ebp
f01104b1:	89 e5                	mov    %esp,%ebp
f01104b3:	83 ec 08             	sub    $0x8,%esp
	test_kfreelast();
f01104b6:	e8 c3 79 00 00       	call   f0117e7e <test_kfreelast>
	return 0;
f01104bb:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01104c0:	c9                   	leave  
f01104c1:	c3                   	ret    

f01104c2 <tst_sc_MLFQ>:

int tst_sc_MLFQ(int number_of_arguments, char **arguments)
{
f01104c2:	55                   	push   %ebp
f01104c3:	89 e5                	mov    %esp,%ebp
f01104c5:	83 ec 18             	sub    $0x18,%esp
	int numOfSlave2 = strtol(arguments[1], NULL, 10);
f01104c8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01104cb:	83 c0 04             	add    $0x4,%eax
f01104ce:	8b 00                	mov    (%eax),%eax
f01104d0:	83 ec 04             	sub    $0x4,%esp
f01104d3:	6a 0a                	push   $0xa
f01104d5:	6a 00                	push   $0x0
f01104d7:	50                   	push   %eax
f01104d8:	e8 ad aa 00 00       	call   f011af8a <strtol>
f01104dd:	83 c4 10             	add    $0x10,%esp
f01104e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int cnt = 0 ;
f01104e3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int firstTime = 1;
f01104ea:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
f01104f1:	83 ec 0c             	sub    $0xc,%esp
f01104f4:	68 20 e7 83 f0       	push   $0xf083e720
f01104f9:	e8 7d f9 ff ff       	call   f010fe7b <acquire_kspinlock>
f01104fe:	83 c4 10             	add    $0x10,%esp
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f0110501:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0110506:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110509:	eb 3b                	jmp    f0110546 <tst_sc_MLFQ+0x84>
									{
			if (strcmp(e->prog_name, "tmlfq_2") == 0)
f011050b:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011050e:	83 c0 20             	add    $0x20,%eax
f0110511:	83 ec 08             	sub    $0x8,%esp
f0110514:	68 b3 1e 13 f0       	push   $0xf0131eb3
f0110519:	50                   	push   %eax
f011051a:	e8 68 a7 00 00       	call   f011ac87 <strcmp>
f011051f:	83 c4 10             	add    $0x10,%esp
f0110522:	85 c0                	test   %eax,%eax
f0110524:	75 12                	jne    f0110538 <tst_sc_MLFQ+0x76>
			{
				if (firstTime)
f0110526:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011052a:	74 07                	je     f0110533 <tst_sc_MLFQ+0x71>
					firstTime = 0;
f011052c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				cnt++ ;
f0110533:	ff 45 f4             	incl   -0xc(%ebp)
f0110536:	eb 06                	jmp    f011053e <tst_sc_MLFQ+0x7c>
			}
			else if (!firstTime)
f0110538:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011053c:	74 31                	je     f011056f <tst_sc_MLFQ+0xad>
	int cnt = 0 ;
	int firstTime = 1;
	struct Env *e ;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		LIST_FOREACH(e, &ProcessQueues.env_exit_queue)
f011053e:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0110543:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0110546:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011054a:	74 08                	je     f0110554 <tst_sc_MLFQ+0x92>
f011054c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011054f:	8b 40 08             	mov    0x8(%eax),%eax
f0110552:	eb 05                	jmp    f0110559 <tst_sc_MLFQ+0x97>
f0110554:	b8 00 00 00 00       	mov    $0x0,%eax
f0110559:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f011055e:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0110563:	85 c0                	test   %eax,%eax
f0110565:	75 a4                	jne    f011050b <tst_sc_MLFQ+0x49>
f0110567:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011056b:	75 9e                	jne    f011050b <tst_sc_MLFQ+0x49>
f011056d:	eb 01                	jmp    f0110570 <tst_sc_MLFQ+0xae>
				if (firstTime)
					firstTime = 0;
				cnt++ ;
			}
			else if (!firstTime)
				break;
f011056f:	90                   	nop
									}
		if(cnt == numOfSlave2)
f0110570:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110573:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0110576:	75 12                	jne    f011058a <tst_sc_MLFQ+0xc8>
		{
			cprintf("Congratulations... MLFQScenario# completed successfully\n");
f0110578:	83 ec 0c             	sub    $0xc,%esp
f011057b:	68 bc 1e 13 f0       	push   $0xf0131ebc
f0110580:	e8 d7 16 ff ff       	call   f0101c5c <cprintf>
f0110585:	83 c4 10             	add    $0x10,%esp
f0110588:	eb 17                	jmp    f01105a1 <tst_sc_MLFQ+0xdf>
		}
		else
		{
			panic("MLFQScenario# failed\n");
f011058a:	83 ec 04             	sub    $0x4,%esp
f011058d:	68 f5 1e 13 f0       	push   $0xf0131ef5
f0110592:	68 9c 00 00 00       	push   $0x9c
f0110597:	68 0b 1f 13 f0       	push   $0xf0131f0b
f011059c:	e8 0e 0a ff ff       	call   f0100faf <_panic>
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f01105a1:	83 ec 0c             	sub    $0xc,%esp
f01105a4:	68 20 e7 83 f0       	push   $0xf083e720
f01105a9:	e8 72 f9 ff ff       	call   f010ff20 <release_kspinlock>
f01105ae:	83 c4 10             	add    $0x10,%esp
	return 0;
f01105b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01105b6:	c9                   	leave  
f01105b7:	c3                   	ret    

f01105b8 <tst_bsd_nice>:


/*2023*/
int tst_bsd_nice(int number_of_arguments, char **arguments)
{
f01105b8:	55                   	push   %ebp
f01105b9:	89 e5                	mov    %esp,%ebp
f01105bb:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f01105be:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01105c2:	74 17                	je     f01105db <tst_bsd_nice+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst bsd_nice <testnumber>\n");
f01105c4:	83 ec 0c             	sub    $0xc,%esp
f01105c7:	68 24 1f 13 f0       	push   $0xf0131f24
f01105cc:	e8 8b 16 ff ff       	call   f0101c5c <cprintf>
f01105d1:	83 c4 10             	add    $0x10,%esp
		return 0;
f01105d4:	b8 00 00 00 00       	mov    $0x0,%eax
f01105d9:	eb 45                	jmp    f0110620 <tst_bsd_nice+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f01105db:	8b 45 0c             	mov    0xc(%ebp),%eax
f01105de:	83 c0 04             	add    $0x4,%eax
f01105e1:	8b 00                	mov    (%eax),%eax
f01105e3:	83 ec 04             	sub    $0x4,%esp
f01105e6:	6a 0a                	push   $0xa
f01105e8:	6a 00                	push   $0x0
f01105ea:	50                   	push   %eax
f01105eb:	e8 9a a9 00 00       	call   f011af8a <strtol>
f01105f0:	83 c4 10             	add    $0x10,%esp
f01105f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f01105f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01105f9:	83 f8 01             	cmp    $0x1,%eax
f01105fc:	74 10                	je     f011060e <tst_bsd_nice+0x56>
f01105fe:	83 f8 02             	cmp    $0x2,%eax
f0110601:	74 12                	je     f0110615 <tst_bsd_nice+0x5d>
f0110603:	85 c0                	test   %eax,%eax
f0110605:	75 14                	jne    f011061b <tst_bsd_nice+0x63>
	{
	case 0:
		test_bsd_nice_0();
f0110607:	e8 e4 79 00 00       	call   f0117ff0 <test_bsd_nice_0>
		break;
f011060c:	eb 0d                	jmp    f011061b <tst_bsd_nice+0x63>
	case 1:
		test_bsd_nice_1();
f011060e:	e8 f7 79 00 00       	call   f011800a <test_bsd_nice_1>
		break;
f0110613:	eb 06                	jmp    f011061b <tst_bsd_nice+0x63>
	case 2:
		test_bsd_nice_2();
f0110615:	e8 0a 7a 00 00       	call   f0118024 <test_bsd_nice_2>
		break;
f011061a:	90                   	nop
	}
	return 0;
f011061b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110620:	c9                   	leave  
f0110621:	c3                   	ret    

f0110622 <tst_priorityRR>:

/*2024*/
int tst_priorityRR(int number_of_arguments, char **arguments)
{
f0110622:	55                   	push   %ebp
f0110623:	89 e5                	mov    %esp,%ebp
f0110625:	83 ec 18             	sub    $0x18,%esp
	if (number_of_arguments != 2)
f0110628:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011062c:	74 17                	je     f0110645 <tst_priorityRR+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst priorityRR <testnumber>\n");
f011062e:	83 ec 0c             	sub    $0xc,%esp
f0110631:	68 64 1f 13 f0       	push   $0xf0131f64
f0110636:	e8 21 16 ff ff       	call   f0101c5c <cprintf>
f011063b:	83 c4 10             	add    $0x10,%esp
		return 0;
f011063e:	b8 00 00 00 00       	mov    $0x0,%eax
f0110643:	eb 45                	jmp    f011068a <tst_priorityRR+0x68>
	}
	int testNumber = strtol(arguments[1], NULL, 10);
f0110645:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110648:	83 c0 04             	add    $0x4,%eax
f011064b:	8b 00                	mov    (%eax),%eax
f011064d:	83 ec 04             	sub    $0x4,%esp
f0110650:	6a 0a                	push   $0xa
f0110652:	6a 00                	push   $0x0
f0110654:	50                   	push   %eax
f0110655:	e8 30 a9 00 00       	call   f011af8a <strtol>
f011065a:	83 c4 10             	add    $0x10,%esp
f011065d:	89 45 f4             	mov    %eax,-0xc(%ebp)
	switch (testNumber)
f0110660:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110663:	83 f8 01             	cmp    $0x1,%eax
f0110666:	74 10                	je     f0110678 <tst_priorityRR+0x56>
f0110668:	83 f8 02             	cmp    $0x2,%eax
f011066b:	74 12                	je     f011067f <tst_priorityRR+0x5d>
f011066d:	85 c0                	test   %eax,%eax
f011066f:	75 14                	jne    f0110685 <tst_priorityRR+0x63>
	{
	case 0:
		test_priorityRR_0();
f0110671:	e8 c8 79 00 00       	call   f011803e <test_priorityRR_0>
		break;
f0110676:	eb 0d                	jmp    f0110685 <tst_priorityRR+0x63>
	case 1:
		test_priorityRR_1();
f0110678:	e8 70 7c 00 00       	call   f01182ed <test_priorityRR_1>
		break;
f011067d:	eb 06                	jmp    f0110685 <tst_priorityRR+0x63>
	case 2:
		test_priorityRR_2();
f011067f:	e8 fc 7e 00 00       	call   f0118580 <test_priorityRR_2>
		break;
f0110684:	90                   	nop
	}
	return 0;
f0110685:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011068a:	c9                   	leave  
f011068b:	c3                   	ret    

f011068c <tst_str2lower>:
int tst_str2lower(int number_of_arguments, char **arguments)
{
f011068c:	55                   	push   %ebp
f011068d:	89 e5                	mov    %esp,%ebp
f011068f:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 1)
f0110692:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0110696:	74 17                	je     f01106af <tst_str2lower+0x23>
	{
		cprintf("Invalid number of arguments! USAGE: tst str2lower\n");
f0110698:	83 ec 0c             	sub    $0xc,%esp
f011069b:	68 a8 1f 13 f0       	push   $0xf0131fa8
f01106a0:	e8 b7 15 ff ff       	call   f0101c5c <cprintf>
f01106a5:	83 c4 10             	add    $0x10,%esp
		return 0;
f01106a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01106ad:	eb 0a                	jmp    f01106b9 <tst_str2lower+0x2d>
	}

	test_str2lower_function();
f01106af:	e8 7e 16 00 00       	call   f0111d32 <test_str2lower_function>
	return 0;
f01106b4:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106b9:	c9                   	leave  
f01106ba:	c3                   	ret    

f01106bb <tst_autocomplete>:

int tst_autocomplete(int number_of_arguments, char **arguments)
{
f01106bb:	55                   	push   %ebp
f01106bc:	89 e5                	mov    %esp,%ebp
f01106be:	83 ec 18             	sub    $0x18,%esp
	int x = TestAutoCompleteCommand();
f01106c1:	e8 51 12 00 00       	call   f0111917 <TestAutoCompleteCommand>
f01106c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
	return 0;
f01106c9:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01106ce:	c9                   	leave  
f01106cf:	c3                   	ret    

f01106d0 <tst_dyn_alloc>:
int tst_dyn_alloc(int number_of_arguments, char **arguments)
{
f01106d0:	55                   	push   %ebp
f01106d1:	89 e5                	mov    %esp,%ebp
f01106d3:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f01106d6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01106da:	74 1a                	je     f01106f6 <tst_dyn_alloc+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst dynalloc <testname>\n") ;
f01106dc:	83 ec 0c             	sub    $0xc,%esp
f01106df:	68 dc 1f 13 f0       	push   $0xf0131fdc
f01106e4:	e8 73 15 ff ff       	call   f0101c5c <cprintf>
f01106e9:	83 c4 10             	add    $0x10,%esp
		return 0;
f01106ec:	b8 00 00 00 00       	mov    $0x0,%eax
f01106f1:	e9 93 00 00 00       	jmp    f0110789 <tst_dyn_alloc+0xb9>
	}
	//str2lower(arguments[1]);
	// Test 1 Example for initialize_MemBlocksList: tstdynalloc init
	if(strcmp(arguments[1], "init") == 0)
f01106f6:	8b 45 0c             	mov    0xc(%ebp),%eax
f01106f9:	83 c0 04             	add    $0x4,%eax
f01106fc:	8b 00                	mov    (%eax),%eax
f01106fe:	83 ec 08             	sub    $0x8,%esp
f0110701:	68 19 20 13 f0       	push   $0xf0132019
f0110706:	50                   	push   %eax
f0110707:	e8 7b a5 00 00       	call   f011ac87 <strcmp>
f011070c:	83 c4 10             	add    $0x10,%esp
f011070f:	85 c0                	test   %eax,%eax
f0110711:	75 07                	jne    f011071a <tst_dyn_alloc+0x4a>
	{
		test_initialize_dynamic_allocator();
f0110713:	e8 d1 09 00 00       	call   f01110e9 <test_initialize_dynamic_allocator>
f0110718:	eb 6a                	jmp    f0110784 <tst_dyn_alloc+0xb4>
	}
	// Test 2 Example for alloc_block: tst dynalloc alloc
	else if(strcmp(arguments[1], "alloc") == 0)
f011071a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011071d:	83 c0 04             	add    $0x4,%eax
f0110720:	8b 00                	mov    (%eax),%eax
f0110722:	83 ec 08             	sub    $0x8,%esp
f0110725:	68 1e 20 13 f0       	push   $0xf013201e
f011072a:	50                   	push   %eax
f011072b:	e8 57 a5 00 00       	call   f011ac87 <strcmp>
f0110730:	83 c4 10             	add    $0x10,%esp
f0110733:	85 c0                	test   %eax,%eax
f0110735:	75 07                	jne    f011073e <tst_dyn_alloc+0x6e>
	{
		test_alloc_block();
f0110737:	e8 e4 09 00 00       	call   f0111120 <test_alloc_block>
f011073c:	eb 46                	jmp    f0110784 <tst_dyn_alloc+0xb4>
	{
		test_alloc_block_NF();
	}
	 */
	// Test 5 Example for free_block: tst dynalloc free
	else if(strcmp(arguments[1], "free") == 0)
f011073e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110741:	83 c0 04             	add    $0x4,%eax
f0110744:	8b 00                	mov    (%eax),%eax
f0110746:	83 ec 08             	sub    $0x8,%esp
f0110749:	68 24 20 13 f0       	push   $0xf0132024
f011074e:	50                   	push   %eax
f011074f:	e8 33 a5 00 00       	call   f011ac87 <strcmp>
f0110754:	83 c4 10             	add    $0x10,%esp
f0110757:	85 c0                	test   %eax,%eax
f0110759:	75 07                	jne    f0110762 <tst_dyn_alloc+0x92>
	{
		test_free_block();
f011075b:	e8 dd 09 00 00       	call   f011113d <test_free_block>
f0110760:	eb 22                	jmp    f0110784 <tst_dyn_alloc+0xb4>
	else if(strcmp(arguments[1], "freenf") == 0)
	{
		test_free_block_NF();
	}*/
	// Test 8 Example for realloc_block: tst dynalloc realloc
	else if(strcmp(arguments[1], "realloc") == 0)
f0110762:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110765:	83 c0 04             	add    $0x4,%eax
f0110768:	8b 00                	mov    (%eax),%eax
f011076a:	83 ec 08             	sub    $0x8,%esp
f011076d:	68 29 20 13 f0       	push   $0xf0132029
f0110772:	50                   	push   %eax
f0110773:	e8 0f a5 00 00       	call   f011ac87 <strcmp>
f0110778:	83 c4 10             	add    $0x10,%esp
f011077b:	85 c0                	test   %eax,%eax
f011077d:	75 05                	jne    f0110784 <tst_dyn_alloc+0xb4>
	{
		test_realloc_block();
f011077f:	e8 d6 09 00 00       	call   f011115a <test_realloc_block>
	}
	return 0;
f0110784:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110789:	c9                   	leave  
f011078a:	c3                   	ret    

f011078b <tst_chunks>:

int tst_chunks(int number_of_arguments, char **arguments)
{
f011078b:	55                   	push   %ebp
f011078c:	89 e5                	mov    %esp,%ebp
f011078e:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f0110791:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110795:	74 1a                	je     f01107b1 <tst_chunks+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst chunks <testname>\n") ;
f0110797:	83 ec 0c             	sub    $0xc,%esp
f011079a:	68 34 20 13 f0       	push   $0xf0132034
f011079f:	e8 b8 14 ff ff       	call   f0101c5c <cprintf>
f01107a4:	83 c4 10             	add    $0x10,%esp
		return 0;
f01107a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01107ac:	e9 e1 00 00 00       	jmp    f0110892 <tst_chunks+0x107>
	}
	// CUT-PASTE Test
	if(strcmp(arguments[1], "cutpaste") == 0)
f01107b1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107b4:	83 c0 04             	add    $0x4,%eax
f01107b7:	8b 00                	mov    (%eax),%eax
f01107b9:	83 ec 08             	sub    $0x8,%esp
f01107bc:	68 6f 20 13 f0       	push   $0xf013206f
f01107c1:	50                   	push   %eax
f01107c2:	e8 c0 a4 00 00       	call   f011ac87 <strcmp>
f01107c7:	83 c4 10             	add    $0x10,%esp
f01107ca:	85 c0                	test   %eax,%eax
f01107cc:	75 0a                	jne    f01107d8 <tst_chunks+0x4d>
	{
		test_cut_paste_pages();
f01107ce:	e8 00 22 00 00       	call   f01129d3 <test_cut_paste_pages>
f01107d3:	e9 b5 00 00 00       	jmp    f011088d <tst_chunks+0x102>
	}
	// COPY-PASTE Test
	else if(strcmp(arguments[1], "copypaste") == 0)
f01107d8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01107db:	83 c0 04             	add    $0x4,%eax
f01107de:	8b 00                	mov    (%eax),%eax
f01107e0:	83 ec 08             	sub    $0x8,%esp
f01107e3:	68 78 20 13 f0       	push   $0xf0132078
f01107e8:	50                   	push   %eax
f01107e9:	e8 99 a4 00 00       	call   f011ac87 <strcmp>
f01107ee:	83 c4 10             	add    $0x10,%esp
f01107f1:	85 c0                	test   %eax,%eax
f01107f3:	75 0a                	jne    f01107ff <tst_chunks+0x74>
	{
		test_copy_paste_chunk();
f01107f5:	e8 24 2c 00 00       	call   f011341e <test_copy_paste_chunk>
f01107fa:	e9 8e 00 00 00       	jmp    f011088d <tst_chunks+0x102>
	}
	// SHARE Test
	else if(strcmp(arguments[1], "share") == 0)
f01107ff:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110802:	83 c0 04             	add    $0x4,%eax
f0110805:	8b 00                	mov    (%eax),%eax
f0110807:	83 ec 08             	sub    $0x8,%esp
f011080a:	68 82 20 13 f0       	push   $0xf0132082
f011080f:	50                   	push   %eax
f0110810:	e8 72 a4 00 00       	call   f011ac87 <strcmp>
f0110815:	83 c4 10             	add    $0x10,%esp
f0110818:	85 c0                	test   %eax,%eax
f011081a:	75 07                	jne    f0110823 <tst_chunks+0x98>
	{
		test_share_chunk();
f011081c:	e8 fb 3c 00 00       	call   f011451c <test_share_chunk>
f0110821:	eb 6a                	jmp    f011088d <tst_chunks+0x102>
	}
	// ALLOCATE Test
	else if(strcmp(arguments[1], "allocate") == 0)
f0110823:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110826:	83 c0 04             	add    $0x4,%eax
f0110829:	8b 00                	mov    (%eax),%eax
f011082b:	83 ec 08             	sub    $0x8,%esp
f011082e:	68 88 20 13 f0       	push   $0xf0132088
f0110833:	50                   	push   %eax
f0110834:	e8 4e a4 00 00       	call   f011ac87 <strcmp>
f0110839:	83 c4 10             	add    $0x10,%esp
f011083c:	85 c0                	test   %eax,%eax
f011083e:	75 07                	jne    f0110847 <tst_chunks+0xbc>
	{
		test_allocate_chunk();
f0110840:	e8 ff 46 00 00       	call   f0114f44 <test_allocate_chunk>
f0110845:	eb 46                	jmp    f011088d <tst_chunks+0x102>
	}
	// REQUIRED SPACE Test
	else if(strcmp(arguments[1], "required_space") == 0)
f0110847:	8b 45 0c             	mov    0xc(%ebp),%eax
f011084a:	83 c0 04             	add    $0x4,%eax
f011084d:	8b 00                	mov    (%eax),%eax
f011084f:	83 ec 08             	sub    $0x8,%esp
f0110852:	68 91 20 13 f0       	push   $0xf0132091
f0110857:	50                   	push   %eax
f0110858:	e8 2a a4 00 00       	call   f011ac87 <strcmp>
f011085d:	83 c4 10             	add    $0x10,%esp
f0110860:	85 c0                	test   %eax,%eax
f0110862:	75 07                	jne    f011086b <tst_chunks+0xe0>
	{
		test_calculate_required_frames();
f0110864:	e8 e2 4f 00 00       	call   f011584b <test_calculate_required_frames>
f0110869:	eb 22                	jmp    f011088d <tst_chunks+0x102>
	}
	// ALLOCATED SPACE Test
	else if(strcmp(arguments[1], "allocated_space") == 0)
f011086b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011086e:	83 c0 04             	add    $0x4,%eax
f0110871:	8b 00                	mov    (%eax),%eax
f0110873:	83 ec 08             	sub    $0x8,%esp
f0110876:	68 a0 20 13 f0       	push   $0xf01320a0
f011087b:	50                   	push   %eax
f011087c:	e8 06 a4 00 00       	call   f011ac87 <strcmp>
f0110881:	83 c4 10             	add    $0x10,%esp
f0110884:	85 c0                	test   %eax,%eax
f0110886:	75 05                	jne    f011088d <tst_chunks+0x102>
	{
		test_calculate_allocated_space();
f0110888:	e8 32 58 00 00       	call   f01160bf <test_calculate_allocated_space>
	}
	return 0;
f011088d:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110892:	c9                   	leave  
f0110893:	c3                   	ret    

f0110894 <tst_paging_manipulation>:

int tst_paging_manipulation(int number_of_arguments, char **arguments)
{
f0110894:	55                   	push   %ebp
f0110895:	89 e5                	mov    %esp,%ebp
f0110897:	83 ec 08             	sub    $0x8,%esp
	if (number_of_arguments != 2)
f011089a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011089e:	74 1a                	je     f01108ba <tst_paging_manipulation+0x26>
	{
		cprintf("Invalid number of arguments! USAGE: tst pg <testname>\n") ;
f01108a0:	83 ec 0c             	sub    $0xc,%esp
f01108a3:	68 b0 20 13 f0       	push   $0xf01320b0
f01108a8:	e8 af 13 ff ff       	call   f0101c5c <cprintf>
f01108ad:	83 c4 10             	add    $0x10,%esp
		return 0;
f01108b0:	b8 00 00 00 00       	mov    $0x0,%eax
f01108b5:	e9 e1 00 00 00       	jmp    f011099b <tst_paging_manipulation+0x107>
	}
	// Test 1.1-Set/Clear permissions: tst pg scperm1
	if(strcmp(arguments[1], "scperm1") == 0)
f01108ba:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108bd:	83 c0 04             	add    $0x4,%eax
f01108c0:	8b 00                	mov    (%eax),%eax
f01108c2:	83 ec 08             	sub    $0x8,%esp
f01108c5:	68 e7 20 13 f0       	push   $0xf01320e7
f01108ca:	50                   	push   %eax
f01108cb:	e8 b7 a3 00 00       	call   f011ac87 <strcmp>
f01108d0:	83 c4 10             	add    $0x10,%esp
f01108d3:	85 c0                	test   %eax,%eax
f01108d5:	75 0a                	jne    f01108e1 <tst_paging_manipulation+0x4d>
	{
		test_pt_set_page_permissions();
f01108d7:	e8 dc 17 00 00       	call   f01120b8 <test_pt_set_page_permissions>
f01108dc:	e9 b5 00 00 00       	jmp    f0110996 <tst_paging_manipulation+0x102>
	}
	// Test 1.2-Set/Clear permissions: tst pg scperm2
	else if(strcmp(arguments[1], "scperm2") == 0)
f01108e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01108e4:	83 c0 04             	add    $0x4,%eax
f01108e7:	8b 00                	mov    (%eax),%eax
f01108e9:	83 ec 08             	sub    $0x8,%esp
f01108ec:	68 ef 20 13 f0       	push   $0xf01320ef
f01108f1:	50                   	push   %eax
f01108f2:	e8 90 a3 00 00       	call   f011ac87 <strcmp>
f01108f7:	83 c4 10             	add    $0x10,%esp
f01108fa:	85 c0                	test   %eax,%eax
f01108fc:	75 0a                	jne    f0110908 <tst_paging_manipulation+0x74>
	{
		test_pt_set_page_permissions_invalid_va();
f01108fe:	e8 24 1a 00 00       	call   f0112327 <test_pt_set_page_permissions_invalid_va>
f0110903:	e9 8e 00 00 00       	jmp    f0110996 <tst_paging_manipulation+0x102>
	}
	// Test 2-Get permissions: tst pg getperm
	else if(strcmp(arguments[1], "getperm") == 0)
f0110908:	8b 45 0c             	mov    0xc(%ebp),%eax
f011090b:	83 c0 04             	add    $0x4,%eax
f011090e:	8b 00                	mov    (%eax),%eax
f0110910:	83 ec 08             	sub    $0x8,%esp
f0110913:	68 f7 20 13 f0       	push   $0xf01320f7
f0110918:	50                   	push   %eax
f0110919:	e8 69 a3 00 00       	call   f011ac87 <strcmp>
f011091e:	83 c4 10             	add    $0x10,%esp
f0110921:	85 c0                	test   %eax,%eax
f0110923:	75 07                	jne    f011092c <tst_paging_manipulation+0x98>
	{
		test_pt_get_page_permissions();
f0110925:	e8 46 1a 00 00       	call   f0112370 <test_pt_get_page_permissions>
f011092a:	eb 6a                	jmp    f0110996 <tst_paging_manipulation+0x102>
	}
	// Test 3.1-Clear entry: tst pg clear1
	else if(strcmp(arguments[1], "clear1") == 0)
f011092c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011092f:	83 c0 04             	add    $0x4,%eax
f0110932:	8b 00                	mov    (%eax),%eax
f0110934:	83 ec 08             	sub    $0x8,%esp
f0110937:	68 ff 20 13 f0       	push   $0xf01320ff
f011093c:	50                   	push   %eax
f011093d:	e8 45 a3 00 00       	call   f011ac87 <strcmp>
f0110942:	83 c4 10             	add    $0x10,%esp
f0110945:	85 c0                	test   %eax,%eax
f0110947:	75 07                	jne    f0110950 <tst_paging_manipulation+0xbc>
	{
		test_pt_clear_page_table_entry();
f0110949:	e8 66 1b 00 00       	call   f01124b4 <test_pt_clear_page_table_entry>
f011094e:	eb 46                	jmp    f0110996 <tst_paging_manipulation+0x102>
	}
	// Test 3.2-Clear entry: tst pg clear2
	else if(strcmp(arguments[1], "clear2") == 0)
f0110950:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110953:	83 c0 04             	add    $0x4,%eax
f0110956:	8b 00                	mov    (%eax),%eax
f0110958:	83 ec 08             	sub    $0x8,%esp
f011095b:	68 06 21 13 f0       	push   $0xf0132106
f0110960:	50                   	push   %eax
f0110961:	e8 21 a3 00 00       	call   f011ac87 <strcmp>
f0110966:	83 c4 10             	add    $0x10,%esp
f0110969:	85 c0                	test   %eax,%eax
f011096b:	75 07                	jne    f0110974 <tst_paging_manipulation+0xe0>
	{
		test_pt_clear_page_table_entry_invalid_va();
f011096d:	e8 9b 1c 00 00       	call   f011260d <test_pt_clear_page_table_entry_invalid_va>
f0110972:	eb 22                	jmp    f0110996 <tst_paging_manipulation+0x102>
	}
	// Test 4-Convert virtual to physical: tst pg v2p
	else if(strcmp(arguments[1], "v2p") == 0)
f0110974:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110977:	83 c0 04             	add    $0x4,%eax
f011097a:	8b 00                	mov    (%eax),%eax
f011097c:	83 ec 08             	sub    $0x8,%esp
f011097f:	68 0d 21 13 f0       	push   $0xf013210d
f0110984:	50                   	push   %eax
f0110985:	e8 fd a2 00 00       	call   f011ac87 <strcmp>
f011098a:	83 c4 10             	add    $0x10,%esp
f011098d:	85 c0                	test   %eax,%eax
f011098f:	75 05                	jne    f0110996 <tst_paging_manipulation+0x102>
	{
		test_virtual_to_physical();
f0110991:	e8 af 1c 00 00       	call   f0112645 <test_virtual_to_physical>
	}
	return 0;
f0110996:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011099b:	c9                   	leave  
f011099c:	c3                   	ret    

f011099d <tst_kheap>:

int tst_kheap(int number_of_arguments, char **arguments)
{
f011099d:	55                   	push   %ebp
f011099e:	89 e5                	mov    %esp,%ebp
f01109a0:	83 ec 18             	sub    $0x18,%esp
#if !USE_KHEAP
	panic("MUST ENABLE KHEAP");
	return 0;
#endif
	// Parameters Validation Checking
	if (strcmp(arguments[2], "kmalloc") == 0 && number_of_arguments != 4)
f01109a3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109a6:	83 c0 08             	add    $0x8,%eax
f01109a9:	8b 00                	mov    (%eax),%eax
f01109ab:	83 ec 08             	sub    $0x8,%esp
f01109ae:	68 11 21 13 f0       	push   $0xf0132111
f01109b3:	50                   	push   %eax
f01109b4:	e8 ce a2 00 00       	call   f011ac87 <strcmp>
f01109b9:	83 c4 10             	add    $0x10,%esp
f01109bc:	85 c0                	test   %eax,%eax
f01109be:	75 20                	jne    f01109e0 <tst_kheap+0x43>
f01109c0:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f01109c4:	74 1a                	je     f01109e0 <tst_kheap+0x43>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kmalloc <both or blk or page>\n") ;
f01109c6:	83 ec 0c             	sub    $0xc,%esp
f01109c9:	68 1c 21 13 f0       	push   $0xf013211c
f01109ce:	e8 89 12 ff ff       	call   f0101c5c <cprintf>
f01109d3:	83 c4 10             	add    $0x10,%esp
		return 0;
f01109d6:	b8 00 00 00 00       	mov    $0x0,%eax
f01109db:	e9 b1 04 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "fast") == 0 && number_of_arguments != 3)
f01109e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01109e3:	83 c0 08             	add    $0x8,%eax
f01109e6:	8b 00                	mov    (%eax),%eax
f01109e8:	83 ec 08             	sub    $0x8,%esp
f01109eb:	68 74 21 13 f0       	push   $0xf0132174
f01109f0:	50                   	push   %eax
f01109f1:	e8 91 a2 00 00       	call   f011ac87 <strcmp>
f01109f6:	83 c4 10             	add    $0x10,%esp
f01109f9:	85 c0                	test   %eax,%eax
f01109fb:	75 20                	jne    f0110a1d <tst_kheap+0x80>
f01109fd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0110a01:	74 1a                	je     f0110a1d <tst_kheap+0x80>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> fast\n") ;
f0110a03:	83 ec 0c             	sub    $0xc,%esp
f0110a06:	68 7c 21 13 f0       	push   $0xf013217c
f0110a0b:	e8 4c 12 ff ff       	call   f0101c5c <cprintf>
f0110a10:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a13:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a18:	e9 74 04 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kfree") == 0 && number_of_arguments != 4)
f0110a1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a20:	83 c0 08             	add    $0x8,%eax
f0110a23:	8b 00                	mov    (%eax),%eax
f0110a25:	83 ec 08             	sub    $0x8,%esp
f0110a28:	68 bb 21 13 f0       	push   $0xf01321bb
f0110a2d:	50                   	push   %eax
f0110a2e:	e8 54 a2 00 00       	call   f011ac87 <strcmp>
f0110a33:	83 c4 10             	add    $0x10,%esp
f0110a36:	85 c0                	test   %eax,%eax
f0110a38:	75 20                	jne    f0110a5a <tst_kheap+0xbd>
f0110a3a:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110a3e:	74 1a                	je     f0110a5a <tst_kheap+0xbd>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> kfree <both or blk or page>\n") ;
f0110a40:	83 ec 0c             	sub    $0xc,%esp
f0110a43:	68 c4 21 13 f0       	push   $0xf01321c4
f0110a48:	e8 0f 12 ff ff       	call   f0101c5c <cprintf>
f0110a4d:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a50:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a55:	e9 37 04 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kvirtaddr") == 0 && number_of_arguments != 2)
f0110a5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a5d:	83 c0 08             	add    $0x8,%eax
f0110a60:	8b 00                	mov    (%eax),%eax
f0110a62:	83 ec 08             	sub    $0x8,%esp
f0110a65:	68 1a 22 13 f0       	push   $0xf013221a
f0110a6a:	50                   	push   %eax
f0110a6b:	e8 17 a2 00 00       	call   f011ac87 <strcmp>
f0110a70:	83 c4 10             	add    $0x10,%esp
f0110a73:	85 c0                	test   %eax,%eax
f0110a75:	75 20                	jne    f0110a97 <tst_kheap+0xfa>
f0110a77:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110a7b:	74 1a                	je     f0110a97 <tst_kheap+0xfa>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap kvirtaddr\n") ;
f0110a7d:	83 ec 0c             	sub    $0xc,%esp
f0110a80:	68 24 22 13 f0       	push   $0xf0132224
f0110a85:	e8 d2 11 ff ff       	call   f0101c5c <cprintf>
f0110a8a:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110a8d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110a92:	e9 fa 03 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "kphysaddr") == 0 && number_of_arguments != 2)
f0110a97:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110a9a:	83 c0 08             	add    $0x8,%eax
f0110a9d:	8b 00                	mov    (%eax),%eax
f0110a9f:	83 ec 08             	sub    $0x8,%esp
f0110aa2:	68 5d 22 13 f0       	push   $0xf013225d
f0110aa7:	50                   	push   %eax
f0110aa8:	e8 da a1 00 00       	call   f011ac87 <strcmp>
f0110aad:	83 c4 10             	add    $0x10,%esp
f0110ab0:	85 c0                	test   %eax,%eax
f0110ab2:	75 20                	jne    f0110ad4 <tst_kheap+0x137>
f0110ab4:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0110ab8:	74 1a                	je     f0110ad4 <tst_kheap+0x137>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap kphysaddr\n") ;
f0110aba:	83 ec 0c             	sub    $0xc,%esp
f0110abd:	68 68 22 13 f0       	push   $0xf0132268
f0110ac2:	e8 95 11 ff ff       	call   f0101c5c <cprintf>
f0110ac7:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110aca:	b8 00 00 00 00       	mov    $0x0,%eax
f0110acf:	e9 bd 03 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	else if (strcmp(arguments[2], "krealloc") == 0 && number_of_arguments != 4)
f0110ad4:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ad7:	83 c0 08             	add    $0x8,%eax
f0110ada:	8b 00                	mov    (%eax),%eax
f0110adc:	83 ec 08             	sub    $0x8,%esp
f0110adf:	68 a1 22 13 f0       	push   $0xf01322a1
f0110ae4:	50                   	push   %eax
f0110ae5:	e8 9d a1 00 00       	call   f011ac87 <strcmp>
f0110aea:	83 c4 10             	add    $0x10,%esp
f0110aed:	85 c0                	test   %eax,%eax
f0110aef:	75 20                	jne    f0110b11 <tst_kheap+0x174>
f0110af1:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110af5:	74 1a                	je     f0110b11 <tst_kheap+0x174>
	{
		cprintf("Invalid number of arguments! USAGE: tst kheap <Strategy> krealloc <both or blk or page>\n") ;
f0110af7:	83 ec 0c             	sub    $0xc,%esp
f0110afa:	68 ac 22 13 f0       	push   $0xf01322ac
f0110aff:	e8 58 11 ff ff       	call   f0101c5c <cprintf>
f0110b04:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110b07:	b8 00 00 00 00       	mov    $0x0,%eax
f0110b0c:	e9 80 03 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}

	// Specify Test Type [ig any]
	uint32 testType = 0;
f0110b11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (number_of_arguments == 4)
f0110b18:	83 7d 08 04          	cmpl   $0x4,0x8(%ebp)
f0110b1c:	0f 85 8c 00 00 00    	jne    f0110bae <tst_kheap+0x211>
	{
		if (strcmp(arguments[3], "page") == 0)
f0110b22:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b25:	83 c0 0c             	add    $0xc,%eax
f0110b28:	8b 00                	mov    (%eax),%eax
f0110b2a:	83 ec 08             	sub    $0x8,%esp
f0110b2d:	68 05 23 13 f0       	push   $0xf0132305
f0110b32:	50                   	push   %eax
f0110b33:	e8 4f a1 00 00       	call   f011ac87 <strcmp>
f0110b38:	83 c4 10             	add    $0x10,%esp
f0110b3b:	85 c0                	test   %eax,%eax
f0110b3d:	75 09                	jne    f0110b48 <tst_kheap+0x1ab>
		{
			testType = TST_PAGE_ALLOC;
f0110b3f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
f0110b46:	eb 66                	jmp    f0110bae <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "blk") == 0)
f0110b48:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b4b:	83 c0 0c             	add    $0xc,%eax
f0110b4e:	8b 00                	mov    (%eax),%eax
f0110b50:	83 ec 08             	sub    $0x8,%esp
f0110b53:	68 0a 23 13 f0       	push   $0xf013230a
f0110b58:	50                   	push   %eax
f0110b59:	e8 29 a1 00 00       	call   f011ac87 <strcmp>
f0110b5e:	83 c4 10             	add    $0x10,%esp
f0110b61:	85 c0                	test   %eax,%eax
f0110b63:	75 09                	jne    f0110b6e <tst_kheap+0x1d1>
		{
			testType = TST_BLOCK_ALLOC;
f0110b65:	c7 45 f4 02 00 00 00 	movl   $0x2,-0xc(%ebp)
f0110b6c:	eb 40                	jmp    f0110bae <tst_kheap+0x211>
		}
		else if (strcmp(arguments[3], "both") == 0)
f0110b6e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110b71:	83 c0 0c             	add    $0xc,%eax
f0110b74:	8b 00                	mov    (%eax),%eax
f0110b76:	83 ec 08             	sub    $0x8,%esp
f0110b79:	68 0e 23 13 f0       	push   $0xf013230e
f0110b7e:	50                   	push   %eax
f0110b7f:	e8 03 a1 00 00       	call   f011ac87 <strcmp>
f0110b84:	83 c4 10             	add    $0x10,%esp
f0110b87:	85 c0                	test   %eax,%eax
f0110b89:	75 09                	jne    f0110b94 <tst_kheap+0x1f7>
		{
			testType = TST_BOTH_ALLOC;
f0110b8b:	c7 45 f4 03 00 00 00 	movl   $0x3,-0xc(%ebp)
f0110b92:	eb 1a                	jmp    f0110bae <tst_kheap+0x211>
		}
		else
		{
			cprintf("Invalid Allocator Type! <both or blk or page>\n") ;
f0110b94:	83 ec 0c             	sub    $0xc,%esp
f0110b97:	68 14 23 13 f0       	push   $0xf0132314
f0110b9c:	e8 bb 10 ff ff       	call   f0101c5c <cprintf>
f0110ba1:	83 c4 10             	add    $0x10,%esp
			return 0;
f0110ba4:	b8 00 00 00 00       	mov    $0x0,%eax
f0110ba9:	e9 e3 02 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
		}
	}

	// Setting Strategy
	if(strcmp(arguments[1], "FF") == 0 || strcmp(arguments[1], "ff") == 0)
f0110bae:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bb1:	83 c0 04             	add    $0x4,%eax
f0110bb4:	8b 00                	mov    (%eax),%eax
f0110bb6:	83 ec 08             	sub    $0x8,%esp
f0110bb9:	68 43 23 13 f0       	push   $0xf0132343
f0110bbe:	50                   	push   %eax
f0110bbf:	e8 c3 a0 00 00       	call   f011ac87 <strcmp>
f0110bc4:	83 c4 10             	add    $0x10,%esp
f0110bc7:	85 c0                	test   %eax,%eax
f0110bc9:	74 1d                	je     f0110be8 <tst_kheap+0x24b>
f0110bcb:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110bce:	83 c0 04             	add    $0x4,%eax
f0110bd1:	8b 00                	mov    (%eax),%eax
f0110bd3:	83 ec 08             	sub    $0x8,%esp
f0110bd6:	68 46 23 13 f0       	push   $0xf0132346
f0110bdb:	50                   	push   %eax
f0110bdc:	e8 a6 a0 00 00       	call   f011ac87 <strcmp>
f0110be1:	83 c4 10             	add    $0x10,%esp
f0110be4:	85 c0                	test   %eax,%eax
f0110be6:	75 22                	jne    f0110c0a <tst_kheap+0x26d>
	{
		set_kheap_strategy(KHP_PLACE_FIRSTFIT);
f0110be8:	83 ec 0c             	sub    $0xc,%esp
f0110beb:	6a 01                	push   $0x1
f0110bed:	e8 66 f7 ff ff       	call   f0110358 <set_kheap_strategy>
f0110bf2:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is FIRST FIT\n");
f0110bf5:	83 ec 0c             	sub    $0xc,%esp
f0110bf8:	68 4c 23 13 f0       	push   $0xf013234c
f0110bfd:	e8 5a 10 ff ff       	call   f0101c5c <cprintf>
f0110c02:	83 c4 10             	add    $0x10,%esp
f0110c05:	e9 68 01 00 00       	jmp    f0110d72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "BF") == 0 || strcmp(arguments[1], "bf") == 0)
f0110c0a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c0d:	83 c0 04             	add    $0x4,%eax
f0110c10:	8b 00                	mov    (%eax),%eax
f0110c12:	83 ec 08             	sub    $0x8,%esp
f0110c15:	68 79 23 13 f0       	push   $0xf0132379
f0110c1a:	50                   	push   %eax
f0110c1b:	e8 67 a0 00 00       	call   f011ac87 <strcmp>
f0110c20:	83 c4 10             	add    $0x10,%esp
f0110c23:	85 c0                	test   %eax,%eax
f0110c25:	74 1d                	je     f0110c44 <tst_kheap+0x2a7>
f0110c27:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c2a:	83 c0 04             	add    $0x4,%eax
f0110c2d:	8b 00                	mov    (%eax),%eax
f0110c2f:	83 ec 08             	sub    $0x8,%esp
f0110c32:	68 7c 23 13 f0       	push   $0xf013237c
f0110c37:	50                   	push   %eax
f0110c38:	e8 4a a0 00 00       	call   f011ac87 <strcmp>
f0110c3d:	83 c4 10             	add    $0x10,%esp
f0110c40:	85 c0                	test   %eax,%eax
f0110c42:	75 22                	jne    f0110c66 <tst_kheap+0x2c9>
	{
		set_kheap_strategy(KHP_PLACE_BESTFIT);
f0110c44:	83 ec 0c             	sub    $0xc,%esp
f0110c47:	6a 02                	push   $0x2
f0110c49:	e8 0a f7 ff ff       	call   f0110358 <set_kheap_strategy>
f0110c4e:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is BEST FIT\n");
f0110c51:	83 ec 0c             	sub    $0xc,%esp
f0110c54:	68 80 23 13 f0       	push   $0xf0132380
f0110c59:	e8 fe 0f ff ff       	call   f0101c5c <cprintf>
f0110c5e:	83 c4 10             	add    $0x10,%esp
f0110c61:	e9 0c 01 00 00       	jmp    f0110d72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "NF") == 0 || strcmp(arguments[1], "nf") == 0)
f0110c66:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c69:	83 c0 04             	add    $0x4,%eax
f0110c6c:	8b 00                	mov    (%eax),%eax
f0110c6e:	83 ec 08             	sub    $0x8,%esp
f0110c71:	68 ac 23 13 f0       	push   $0xf01323ac
f0110c76:	50                   	push   %eax
f0110c77:	e8 0b a0 00 00       	call   f011ac87 <strcmp>
f0110c7c:	83 c4 10             	add    $0x10,%esp
f0110c7f:	85 c0                	test   %eax,%eax
f0110c81:	74 1d                	je     f0110ca0 <tst_kheap+0x303>
f0110c83:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110c86:	83 c0 04             	add    $0x4,%eax
f0110c89:	8b 00                	mov    (%eax),%eax
f0110c8b:	83 ec 08             	sub    $0x8,%esp
f0110c8e:	68 af 23 13 f0       	push   $0xf01323af
f0110c93:	50                   	push   %eax
f0110c94:	e8 ee 9f 00 00       	call   f011ac87 <strcmp>
f0110c99:	83 c4 10             	add    $0x10,%esp
f0110c9c:	85 c0                	test   %eax,%eax
f0110c9e:	75 22                	jne    f0110cc2 <tst_kheap+0x325>
	{
		set_kheap_strategy(KHP_PLACE_NEXTFIT);
f0110ca0:	83 ec 0c             	sub    $0xc,%esp
f0110ca3:	6a 03                	push   $0x3
f0110ca5:	e8 ae f6 ff ff       	call   f0110358 <set_kheap_strategy>
f0110caa:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is NEXT FIT\n");
f0110cad:	83 ec 0c             	sub    $0xc,%esp
f0110cb0:	68 b4 23 13 f0       	push   $0xf01323b4
f0110cb5:	e8 a2 0f ff ff       	call   f0101c5c <cprintf>
f0110cba:	83 c4 10             	add    $0x10,%esp
f0110cbd:	e9 b0 00 00 00       	jmp    f0110d72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "WF") == 0 || strcmp(arguments[1], "wf") == 0)
f0110cc2:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110cc5:	83 c0 04             	add    $0x4,%eax
f0110cc8:	8b 00                	mov    (%eax),%eax
f0110cca:	83 ec 08             	sub    $0x8,%esp
f0110ccd:	68 e0 23 13 f0       	push   $0xf01323e0
f0110cd2:	50                   	push   %eax
f0110cd3:	e8 af 9f 00 00       	call   f011ac87 <strcmp>
f0110cd8:	83 c4 10             	add    $0x10,%esp
f0110cdb:	85 c0                	test   %eax,%eax
f0110cdd:	74 1d                	je     f0110cfc <tst_kheap+0x35f>
f0110cdf:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ce2:	83 c0 04             	add    $0x4,%eax
f0110ce5:	8b 00                	mov    (%eax),%eax
f0110ce7:	83 ec 08             	sub    $0x8,%esp
f0110cea:	68 e3 23 13 f0       	push   $0xf01323e3
f0110cef:	50                   	push   %eax
f0110cf0:	e8 92 9f 00 00       	call   f011ac87 <strcmp>
f0110cf5:	83 c4 10             	add    $0x10,%esp
f0110cf8:	85 c0                	test   %eax,%eax
f0110cfa:	75 1f                	jne    f0110d1b <tst_kheap+0x37e>
	{
		set_kheap_strategy(KHP_PLACE_WORSTFIT);
f0110cfc:	83 ec 0c             	sub    $0xc,%esp
f0110cff:	6a 04                	push   $0x4
f0110d01:	e8 52 f6 ff ff       	call   f0110358 <set_kheap_strategy>
f0110d06:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is WORST FIT\n");
f0110d09:	83 ec 0c             	sub    $0xc,%esp
f0110d0c:	68 e8 23 13 f0       	push   $0xf01323e8
f0110d11:	e8 46 0f ff ff       	call   f0101c5c <cprintf>
f0110d16:	83 c4 10             	add    $0x10,%esp
f0110d19:	eb 57                	jmp    f0110d72 <tst_kheap+0x3d5>
	}
	else if(strcmp(arguments[1], "CF") == 0 || strcmp(arguments[1], "cf") == 0)
f0110d1b:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d1e:	83 c0 04             	add    $0x4,%eax
f0110d21:	8b 00                	mov    (%eax),%eax
f0110d23:	83 ec 08             	sub    $0x8,%esp
f0110d26:	68 15 24 13 f0       	push   $0xf0132415
f0110d2b:	50                   	push   %eax
f0110d2c:	e8 56 9f 00 00       	call   f011ac87 <strcmp>
f0110d31:	83 c4 10             	add    $0x10,%esp
f0110d34:	85 c0                	test   %eax,%eax
f0110d36:	74 1d                	je     f0110d55 <tst_kheap+0x3b8>
f0110d38:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d3b:	83 c0 04             	add    $0x4,%eax
f0110d3e:	8b 00                	mov    (%eax),%eax
f0110d40:	83 ec 08             	sub    $0x8,%esp
f0110d43:	68 18 24 13 f0       	push   $0xf0132418
f0110d48:	50                   	push   %eax
f0110d49:	e8 39 9f 00 00       	call   f011ac87 <strcmp>
f0110d4e:	83 c4 10             	add    $0x10,%esp
f0110d51:	85 c0                	test   %eax,%eax
f0110d53:	75 1d                	jne    f0110d72 <tst_kheap+0x3d5>
	{
		set_kheap_strategy(KHP_PLACE_CUSTOMFIT);
f0110d55:	83 ec 0c             	sub    $0xc,%esp
f0110d58:	6a 05                	push   $0x5
f0110d5a:	e8 f9 f5 ff ff       	call   f0110358 <set_kheap_strategy>
f0110d5f:	83 c4 10             	add    $0x10,%esp
		cprintf("Kernel Heap placement strategy is CUSTOM FIT\n");
f0110d62:	83 ec 0c             	sub    $0xc,%esp
f0110d65:	68 1c 24 13 f0       	push   $0xf013241c
f0110d6a:	e8 ed 0e ff ff       	call   f0101c5c <cprintf>
f0110d6f:	83 c4 10             	add    $0x10,%esp
	}
	// Test 1-kmalloc: tst kheap <Strategy> kmalloc <allocator>
	if(strcmp(arguments[2], "kmalloc") == 0)
f0110d72:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110d75:	83 c0 08             	add    $0x8,%eax
f0110d78:	8b 00                	mov    (%eax),%eax
f0110d7a:	83 ec 08             	sub    $0x8,%esp
f0110d7d:	68 11 21 13 f0       	push   $0xf0132111
f0110d82:	50                   	push   %eax
f0110d83:	e8 ff 9e 00 00       	call   f011ac87 <strcmp>
f0110d88:	83 c4 10             	add    $0x10,%esp
f0110d8b:	85 c0                	test   %eax,%eax
f0110d8d:	75 18                	jne    f0110da7 <tst_kheap+0x40a>
	{
		test_kmalloc(testType);
f0110d8f:	83 ec 0c             	sub    $0xc,%esp
f0110d92:	ff 75 f4             	pushl  -0xc(%ebp)
f0110d95:	e8 42 65 00 00       	call   f01172dc <test_kmalloc>
f0110d9a:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110d9d:	b8 00 00 00 00       	mov    $0x0,%eax
f0110da2:	e9 ea 00 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	// Test Fast Implementation of kmalloc/kfree: tst kheap <Startegy> fast
	else if(strcmp(arguments[2], "fast") == 0)
f0110da7:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110daa:	83 c0 08             	add    $0x8,%eax
f0110dad:	8b 00                	mov    (%eax),%eax
f0110daf:	83 ec 08             	sub    $0x8,%esp
f0110db2:	68 74 21 13 f0       	push   $0xf0132174
f0110db7:	50                   	push   %eax
f0110db8:	e8 ca 9e 00 00       	call   f011ac87 <strcmp>
f0110dbd:	83 c4 10             	add    $0x10,%esp
f0110dc0:	85 c0                	test   %eax,%eax
f0110dc2:	75 0f                	jne    f0110dd3 <tst_kheap+0x436>
	{
		test_fast_page_alloc();
f0110dc4:	e8 61 68 00 00       	call   f011762a <test_fast_page_alloc>
		return 0;
f0110dc9:	b8 00 00 00 00       	mov    $0x0,%eax
f0110dce:	e9 be 00 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	// Test 2-kfree: tst kheap <Strategy> kfree <allocator>
	else if(strcmp(arguments[2], "kfree") == 0)
f0110dd3:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110dd6:	83 c0 08             	add    $0x8,%eax
f0110dd9:	8b 00                	mov    (%eax),%eax
f0110ddb:	83 ec 08             	sub    $0x8,%esp
f0110dde:	68 bb 21 13 f0       	push   $0xf01321bb
f0110de3:	50                   	push   %eax
f0110de4:	e8 9e 9e 00 00       	call   f011ac87 <strcmp>
f0110de9:	83 c4 10             	add    $0x10,%esp
f0110dec:	85 c0                	test   %eax,%eax
f0110dee:	75 18                	jne    f0110e08 <tst_kheap+0x46b>
	{
		test_kfree(testType);
f0110df0:	83 ec 0c             	sub    $0xc,%esp
f0110df3:	ff 75 f4             	pushl  -0xc(%ebp)
f0110df6:	e8 fb 65 00 00       	call   f01173f6 <test_kfree>
f0110dfb:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110dfe:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e03:	e9 89 00 00 00       	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	// Test 3-kphysaddr: tst kheap kphysaddr
	else if(strcmp(arguments[2], "kphysaddr") == 0)
f0110e08:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e0b:	83 c0 08             	add    $0x8,%eax
f0110e0e:	8b 00                	mov    (%eax),%eax
f0110e10:	83 ec 08             	sub    $0x8,%esp
f0110e13:	68 5d 22 13 f0       	push   $0xf013225d
f0110e18:	50                   	push   %eax
f0110e19:	e8 69 9e 00 00       	call   f011ac87 <strcmp>
f0110e1e:	83 c4 10             	add    $0x10,%esp
f0110e21:	85 c0                	test   %eax,%eax
f0110e23:	75 0c                	jne    f0110e31 <tst_kheap+0x494>
	{
		test_kheap_phys_addr();
f0110e25:	e8 60 68 00 00       	call   f011768a <test_kheap_phys_addr>
		return 0;
f0110e2a:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e2f:	eb 60                	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	// Test 4-kvirtaddr: tst kheap kvirtaddr
	else if(strcmp(arguments[2], "kvirtaddr") == 0)
f0110e31:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e34:	83 c0 08             	add    $0x8,%eax
f0110e37:	8b 00                	mov    (%eax),%eax
f0110e39:	83 ec 08             	sub    $0x8,%esp
f0110e3c:	68 1a 22 13 f0       	push   $0xf013221a
f0110e41:	50                   	push   %eax
f0110e42:	e8 40 9e 00 00       	call   f011ac87 <strcmp>
f0110e47:	83 c4 10             	add    $0x10,%esp
f0110e4a:	85 c0                	test   %eax,%eax
f0110e4c:	75 0c                	jne    f0110e5a <tst_kheap+0x4bd>
	{
		test_kheap_virt_addr();
f0110e4e:	e8 57 68 00 00       	call   f01176aa <test_kheap_virt_addr>
		return 0;
f0110e53:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e58:	eb 37                	jmp    f0110e91 <tst_kheap+0x4f4>
	}
	// Test 5-krealloc: tst kheap <Strategy> krealloc <allocator>
	else if(strcmp(arguments[2], "krealloc") == 0)
f0110e5a:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110e5d:	83 c0 08             	add    $0x8,%eax
f0110e60:	8b 00                	mov    (%eax),%eax
f0110e62:	83 ec 08             	sub    $0x8,%esp
f0110e65:	68 a1 22 13 f0       	push   $0xf01322a1
f0110e6a:	50                   	push   %eax
f0110e6b:	e8 17 9e 00 00       	call   f011ac87 <strcmp>
f0110e70:	83 c4 10             	add    $0x10,%esp
f0110e73:	85 c0                	test   %eax,%eax
f0110e75:	75 15                	jne    f0110e8c <tst_kheap+0x4ef>
	{
		test_krealloc(testType);
f0110e77:	83 ec 0c             	sub    $0xc,%esp
f0110e7a:	ff 75 f4             	pushl  -0xc(%ebp)
f0110e7d:	e8 8e 66 00 00       	call   f0117510 <test_krealloc>
f0110e82:	83 c4 10             	add    $0x10,%esp
		return 0;
f0110e85:	b8 00 00 00 00       	mov    $0x0,%eax
f0110e8a:	eb 05                	jmp    f0110e91 <tst_kheap+0x4f4>
	/*	// Test 6-sbr: tst kheap FF sbrk
	else if (strcmp(arguments[2], "sbrk") == 0)
	{
		test_ksbrk();
	}*/
	return 0;
f0110e8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0110e91:	c9                   	leave  
f0110e92:	c3                   	ret    

f0110e93 <IDX>:

short* startVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;
short* endVAsInit[DYN_ALLOC_MAX_BLOCK_SIZE + 1] ;

__inline__ uint8 IDX(uint32 size)
{
f0110e93:	55                   	push   %ebp
f0110e94:	89 e5                	mov    %esp,%ebp
f0110e96:	83 ec 10             	sub    $0x10,%esp
	size>>= LOG2_MIN_SIZE;
f0110e99:	c1 6d 08 03          	shrl   $0x3,0x8(%ebp)
	int index = 0;
f0110e9d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	while ((size>>=1) != 0)
f0110ea4:	eb 03                	jmp    f0110ea9 <IDX+0x16>
	{
		index++;
f0110ea6:	ff 45 fc             	incl   -0x4(%ebp)

__inline__ uint8 IDX(uint32 size)
{
	size>>= LOG2_MIN_SIZE;
	int index = 0;
	while ((size>>=1) != 0)
f0110ea9:	d1 6d 08             	shrl   0x8(%ebp)
f0110eac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0110eb0:	75 f4                	jne    f0110ea6 <IDX+0x13>
	{
		index++;
	}
	return index;
f0110eb2:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0110eb5:	c9                   	leave  
f0110eb6:	c3                   	ret    

f0110eb7 <check_dynalloc_datastruct>:

int check_dynalloc_datastruct(uint32 curSize, uint32 numOfBlksAtCurSize)
{
f0110eb7:	55                   	push   %ebp
f0110eb8:	89 e5                	mov    %esp,%ebp
f0110eba:	53                   	push   %ebx
f0110ebb:	83 ec 44             	sub    $0x44,%esp
	int maxNumOfBlksPerPage = PAGE_SIZE / curSize;
f0110ebe:	b8 00 10 00 00       	mov    $0x1000,%eax
f0110ec3:	ba 00 00 00 00       	mov    $0x0,%edx
f0110ec8:	f7 75 08             	divl   0x8(%ebp)
f0110ecb:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int expectedNumOfCompletePages = numOfBlksAtCurSize / maxNumOfBlksPerPage;
f0110ece:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f0110ed1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ed4:	ba 00 00 00 00       	mov    $0x0,%edx
f0110ed9:	f7 f3                	div    %ebx
f0110edb:	89 45 d8             	mov    %eax,-0x28(%ebp)
	int expectedNumOfInCompletePages = numOfBlksAtCurSize % maxNumOfBlksPerPage != 0? 1 : 0;
f0110ede:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0110ee1:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110ee4:	ba 00 00 00 00       	mov    $0x0,%edx
f0110ee9:	f7 f1                	div    %ecx
f0110eeb:	89 d0                	mov    %edx,%eax
f0110eed:	85 c0                	test   %eax,%eax
f0110eef:	0f 95 c0             	setne  %al
f0110ef2:	0f b6 c0             	movzbl %al,%eax
f0110ef5:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	int expectedNumOfFreeBlks = expectedNumOfInCompletePages * (maxNumOfBlksPerPage - numOfBlksAtCurSize % maxNumOfBlksPerPage);
f0110ef8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
f0110efb:	8b 5d dc             	mov    -0x24(%ebp),%ebx
f0110efe:	8b 45 0c             	mov    0xc(%ebp),%eax
f0110f01:	ba 00 00 00 00       	mov    $0x0,%edx
f0110f06:	f7 f3                	div    %ebx
f0110f08:	89 d0                	mov    %edx,%eax
f0110f0a:	29 c1                	sub    %eax,%ecx
f0110f0c:	89 ca                	mov    %ecx,%edx
f0110f0e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0110f11:	0f af c2             	imul   %edx,%eax
f0110f14:	89 45 d0             	mov    %eax,-0x30(%ebp)

	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
f0110f17:	c7 45 cc 00 20 00 00 	movl   $0x2000,-0x34(%ebp)
	int actualNumOfCompletePages = 0;
f0110f1e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int actualNumOfInCompletePages = 0;
f0110f25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int actualNumOfFreeBlks = 0;
f0110f2c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	for (int i = 0; i < numOfPages; ++i)
f0110f33:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0110f3a:	eb 59                	jmp    f0110f95 <check_dynalloc_datastruct+0xde>
	{
		if (pageBlockInfoArr[i].block_size == curSize)
f0110f3c:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110f3f:	89 d0                	mov    %edx,%eax
f0110f41:	01 c0                	add    %eax,%eax
f0110f43:	01 d0                	add    %edx,%eax
f0110f45:	c1 e0 02             	shl    $0x2,%eax
f0110f48:	05 c8 e9 83 f0       	add    $0xf083e9c8,%eax
f0110f4d:	8b 00                	mov    (%eax),%eax
f0110f4f:	0f b7 c0             	movzwl %ax,%eax
f0110f52:	3b 45 08             	cmp    0x8(%ebp),%eax
f0110f55:	75 3b                	jne    f0110f92 <check_dynalloc_datastruct+0xdb>
		{
			if (pageBlockInfoArr[i].num_of_free_blocks == 0)
f0110f57:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110f5a:	89 d0                	mov    %edx,%eax
f0110f5c:	01 c0                	add    %eax,%eax
f0110f5e:	01 d0                	add    %edx,%eax
f0110f60:	c1 e0 02             	shl    $0x2,%eax
f0110f63:	05 ca e9 83 f0       	add    $0xf083e9ca,%eax
f0110f68:	66 8b 00             	mov    (%eax),%ax
f0110f6b:	66 85 c0             	test   %ax,%ax
f0110f6e:	75 05                	jne    f0110f75 <check_dynalloc_datastruct+0xbe>
			{
				actualNumOfCompletePages++;
f0110f70:	ff 45 f4             	incl   -0xc(%ebp)
f0110f73:	eb 1d                	jmp    f0110f92 <check_dynalloc_datastruct+0xdb>
			}
			else
			{
				actualNumOfInCompletePages++;
f0110f75:	ff 45 f0             	incl   -0x10(%ebp)
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
f0110f78:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0110f7b:	89 d0                	mov    %edx,%eax
f0110f7d:	01 c0                	add    %eax,%eax
f0110f7f:	01 d0                	add    %edx,%eax
f0110f81:	c1 e0 02             	shl    $0x2,%eax
f0110f84:	05 ca e9 83 f0       	add    $0xf083e9ca,%eax
f0110f89:	66 8b 00             	mov    (%eax),%ax
f0110f8c:	0f b7 c0             	movzwl %ax,%eax
f0110f8f:	01 45 ec             	add    %eax,-0x14(%ebp)
	//[1] Check PageBlkInfoArr
	int numOfPages = DYN_ALLOC_MAX_SIZE / PAGE_SIZE;
	int actualNumOfCompletePages = 0;
	int actualNumOfInCompletePages = 0;
	int actualNumOfFreeBlks = 0;
	for (int i = 0; i < numOfPages; ++i)
f0110f92:	ff 45 e8             	incl   -0x18(%ebp)
f0110f95:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0110f98:	3b 45 cc             	cmp    -0x34(%ebp),%eax
f0110f9b:	7c 9f                	jl     f0110f3c <check_dynalloc_datastruct+0x85>
				actualNumOfInCompletePages++;
				actualNumOfFreeBlks += pageBlockInfoArr[i].num_of_free_blocks;
			}
		}
	}
	if (actualNumOfCompletePages != expectedNumOfCompletePages ||
f0110f9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0110fa0:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0110fa3:	75 10                	jne    f0110fb5 <check_dynalloc_datastruct+0xfe>
f0110fa5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0110fa8:	3b 45 d4             	cmp    -0x2c(%ebp),%eax
f0110fab:	75 08                	jne    f0110fb5 <check_dynalloc_datastruct+0xfe>
			actualNumOfInCompletePages != expectedNumOfInCompletePages ||
f0110fad:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0110fb0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f0110fb3:	74 1c                	je     f0110fd1 <check_dynalloc_datastruct+0x11a>
			actualNumOfFreeBlks != expectedNumOfFreeBlks)
	{
		cprintf_colored(TEXT_TESTERR_CLR, "PageBlkInfoArr is not set/updated correctly!\n");
f0110fb5:	83 ec 08             	sub    $0x8,%esp
f0110fb8:	68 4c 24 13 f0       	push   $0xf013244c
f0110fbd:	6a 0c                	push   $0xc
f0110fbf:	e8 c8 0c ff ff       	call   f0101c8c <cprintf_colored>
f0110fc4:	83 c4 10             	add    $0x10,%esp
		//		cprintf("actualNumOfCompletePages = %d, expectedNumOfCompletePages = %d\n", actualNumOfCompletePages, expectedNumOfCompletePages);
		//		cprintf("actualNumOfInCompletePages = %d, expectedNumOfInCompletePages = %d\n", actualNumOfInCompletePages, expectedNumOfInCompletePages);
		//		cprintf("actualNumOfFreeBlks = %d, expectedNumOfFreeBlks = %d\n", actualNumOfFreeBlks, expectedNumOfFreeBlks);
		return 0;
f0110fc7:	b8 00 00 00 00       	mov    $0x0,%eax
f0110fcc:	e9 9d 00 00 00       	jmp    f011106e <check_dynalloc_datastruct+0x1b7>
	}

	//[2] Check freeBlkLists
	int index = IDX(curSize);
f0110fd1:	83 ec 0c             	sub    $0xc,%esp
f0110fd4:	ff 75 08             	pushl  0x8(%ebp)
f0110fd7:	e8 b7 fe ff ff       	call   f0110e93 <IDX>
f0110fdc:	83 c4 10             	add    $0x10,%esp
f0110fdf:	0f b6 c0             	movzbl %al,%eax
f0110fe2:	89 45 c8             	mov    %eax,-0x38(%ebp)
	struct BlockElement_List *ptrList = &freeBlockLists[index];
f0110fe5:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0110fe8:	c1 e0 04             	shl    $0x4,%eax
f0110feb:	05 40 6c 85 f0       	add    $0xf0856c40,%eax
f0110ff0:	89 45 c4             	mov    %eax,-0x3c(%ebp)
	int n = 0;
f0110ff3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f0110ffa:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0110ffd:	8b 00                	mov    (%eax),%eax
f0110fff:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0111002:	eb 0c                	jmp    f0111010 <check_dynalloc_datastruct+0x159>
	{
		n++;
f0111004:	ff 45 e4             	incl   -0x1c(%ebp)
	//[2] Check freeBlkLists
	int index = IDX(curSize);
	struct BlockElement_List *ptrList = &freeBlockLists[index];
	int n = 0;
	struct BlockElement *ptrBlk;
	LIST_FOREACH(ptrBlk, ptrList)
f0111007:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011100a:	8b 40 08             	mov    0x8(%eax),%eax
f011100d:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0111010:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111014:	74 07                	je     f011101d <check_dynalloc_datastruct+0x166>
f0111016:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111019:	8b 00                	mov    (%eax),%eax
f011101b:	eb 05                	jmp    f0111022 <check_dynalloc_datastruct+0x16b>
f011101d:	b8 00 00 00 00       	mov    $0x0,%eax
f0111022:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0111025:	89 42 08             	mov    %eax,0x8(%edx)
f0111028:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011102b:	8b 40 08             	mov    0x8(%eax),%eax
f011102e:	85 c0                	test   %eax,%eax
f0111030:	75 d2                	jne    f0111004 <check_dynalloc_datastruct+0x14d>
f0111032:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111036:	75 cc                	jne    f0111004 <check_dynalloc_datastruct+0x14d>
	{
		n++;
	}
	if (LIST_SIZE(ptrList) != expectedNumOfFreeBlks || n != expectedNumOfFreeBlks)
f0111038:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011103b:	8b 50 0c             	mov    0xc(%eax),%edx
f011103e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0111041:	39 c2                	cmp    %eax,%edx
f0111043:	75 08                	jne    f011104d <check_dynalloc_datastruct+0x196>
f0111045:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111048:	3b 45 d0             	cmp    -0x30(%ebp),%eax
f011104b:	74 1c                	je     f0111069 <check_dynalloc_datastruct+0x1b2>
	{
		cprintf_colored(TEXT_TESTERR_CLR,"freeBlockLists[%d] is not updated correctly!", index);
f011104d:	83 ec 04             	sub    $0x4,%esp
f0111050:	ff 75 c8             	pushl  -0x38(%ebp)
f0111053:	68 7c 24 13 f0       	push   $0xf013247c
f0111058:	6a 0c                	push   $0xc
f011105a:	e8 2d 0c ff ff       	call   f0101c8c <cprintf_colored>
f011105f:	83 c4 10             	add    $0x10,%esp
		return 0;
f0111062:	b8 00 00 00 00       	mov    $0x0,%eax
f0111067:	eb 05                	jmp    f011106e <check_dynalloc_datastruct+0x1b7>
	}
	return 1;
f0111069:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011106e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f0111071:	c9                   	leave  
f0111072:	c3                   	ret    

f0111073 <check_list_size>:
int check_list_size(uint32 expectedListSize)
{
f0111073:	55                   	push   %ebp
f0111074:	89 e5                	mov    %esp,%ebp
f0111076:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111079:	83 ec 04             	sub    $0x4,%esp
f011107c:	68 a9 24 13 f0       	push   $0xf01324a9
f0111081:	6a 64                	push   $0x64
f0111083:	68 c0 24 13 f0       	push   $0xf01324c0
f0111088:	e8 22 ff fe ff       	call   f0100faf <_panic>

f011108d <remove_current_mappings>:
extern uint32* ptr_page_directory;
extern void unmap_frame(uint32 *ptr_page_directory, uint32 virtual_address);
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
f011108d:	55                   	push   %ebp
f011108e:	89 e5                	mov    %esp,%ebp
f0111090:	83 ec 18             	sub    $0x18,%esp
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
f0111093:	81 7d 08 ff ff ff f5 	cmpl   $0xf5ffffff,0x8(%ebp)
f011109a:	76 09                	jbe    f01110a5 <remove_current_mappings+0x18>
f011109c:	81 7d 0c ff ff ff f5 	cmpl   $0xf5ffffff,0xc(%ebp)
f01110a3:	77 16                	ja     f01110bb <remove_current_mappings+0x2e>
f01110a5:	68 e4 24 13 f0       	push   $0xf01324e4
f01110aa:	68 1f 25 13 f0       	push   $0xf013251f
f01110af:	6a 73                	push   $0x73
f01110b1:	68 c0 24 13 f0       	push   $0xf01324c0
f01110b6:	e8 f4 fe fe ff       	call   f0100faf <_panic>
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f01110bb:	8b 45 08             	mov    0x8(%ebp),%eax
f01110be:	89 45 f4             	mov    %eax,-0xc(%ebp)
f01110c1:	eb 1b                	jmp    f01110de <remove_current_mappings+0x51>
	{
		unmap_frame(ptr_page_directory, va);
f01110c3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01110c8:	83 ec 08             	sub    $0x8,%esp
f01110cb:	ff 75 f4             	pushl  -0xc(%ebp)
f01110ce:	50                   	push   %eax
f01110cf:	e8 7b 86 ff ff       	call   f010974f <unmap_frame>
f01110d4:	83 c4 10             	add    $0x10,%esp
extern uint32 sys_calculate_free_frames() ;

void remove_current_mappings(uint32 startVA, uint32 endVA)
{
	assert(startVA >= KERNEL_HEAP_START && endVA >= KERNEL_HEAP_START);
	for (uint32 va = startVA; va < endVA; va+=PAGE_SIZE)
f01110d7:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f01110de:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01110e1:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01110e4:	72 dd                	jb     f01110c3 <remove_current_mappings+0x36>
	{
		unmap_frame(ptr_page_directory, va);
	}
}
f01110e6:	90                   	nop
f01110e7:	c9                   	leave  
f01110e8:	c3                   	ret    

f01110e9 <test_initialize_dynamic_allocator>:
/***********************************************************************************************************************/

void test_initialize_dynamic_allocator()
{
f01110e9:	55                   	push   %ebp
f01110ea:	89 e5                	mov    %esp,%ebp
f01110ec:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_initialize_dynamic_allocator: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f01110ef:	83 ec 04             	sub    $0x4,%esp
f01110f2:	68 34 25 13 f0       	push   $0xf0132534
f01110f7:	6a 7e                	push   $0x7e
f01110f9:	68 c0 24 13 f0       	push   $0xf01324c0
f01110fe:	e8 ac fe fe ff       	call   f0100faf <_panic>

f0111103 <test_initial_alloc>:
			"\nCongratulations!! test initialize_dynamic_allocator completed successfully.\n"
			"=============================================================================\n");
}

int test_initial_alloc()
{
f0111103:	55                   	push   %ebp
f0111104:	89 e5                	mov    %esp,%ebp
f0111106:	83 ec 58             	sub    $0x58,%esp
#if USE_KHEAP
	panic("test_initial_alloc: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111109:	83 ec 04             	sub    $0x4,%esp
f011110c:	68 94 25 13 f0       	push   $0xf0132594
f0111111:	68 b8 00 00 00       	push   $0xb8
f0111116:	68 c0 24 13 f0       	push   $0xf01324c0
f011111b:	e8 8f fe fe ff       	call   f0100faf <_panic>

f0111120 <test_alloc_block>:

	return eval;
}

void test_alloc_block()
{
f0111120:	55                   	push   %ebp
f0111121:	89 e5                	mov    %esp,%ebp
f0111123:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("test_alloc_block: the kernel heap should be disabled. make sure USE_KHEAP = 0");
f0111126:	83 ec 04             	sub    $0x4,%esp
f0111129:	68 e4 25 13 f0       	push   $0xf01325e4
f011112e:	68 6f 01 00 00       	push   $0x16f
f0111133:	68 c0 24 13 f0       	push   $0xf01324c0
f0111138:	e8 72 fe fe ff       	call   f0100faf <_panic>

f011113d <test_free_block>:
	cprintf("test alloc_block Evaluation = %d%\n", eval);
	return ;
}

void test_free_block()
{
f011113d:	55                   	push   %ebp
f011113e:	89 e5                	mov    %esp,%ebp
f0111140:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111143:	83 ec 04             	sub    $0x4,%esp
f0111146:	68 a9 24 13 f0       	push   $0xf01324a9
f011114b:	68 84 01 00 00       	push   $0x184
f0111150:	68 c0 24 13 f0       	push   $0xf01324c0
f0111155:	e8 55 fe fe ff       	call   f0100faf <_panic>

f011115a <test_realloc_block>:
	cprintf("===========================================================\n") ;
	void*expected_va ;
}

void test_realloc_block()
{
f011115a:	55                   	push   %ebp
f011115b:	89 e5                	mov    %esp,%ebp
f011115d:	83 ec 08             	sub    $0x8,%esp
	panic("update is required!!");
f0111160:	83 ec 04             	sub    $0x4,%esp
f0111163:	68 a9 24 13 f0       	push   $0xf01324a9
f0111168:	68 93 01 00 00       	push   $0x193
f011116d:	68 c0 24 13 f0       	push   $0xf01324c0
f0111172:	e8 38 fe fe ff       	call   f0100faf <_panic>

f0111177 <sys_check_LRU_lists>:
#include <kern/proc/user_environment.h>
#include <kern/mem/working_set_manager.h>

//2020
int sys_check_LRU_lists(uint32* active_list_content, uint32* second_list_content, int actual_active_list_size, int actual_second_list_size)
{
f0111177:	55                   	push   %ebp
f0111178:	89 e5                	mov    %esp,%ebp
f011117a:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011117d:	e8 96 a9 ff ff       	call   f010bb18 <get_cpu_proc>
f0111182:	89 45 e0             	mov    %eax,-0x20(%ebp)
	assert(cur_env != NULL);
f0111185:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0111189:	75 16                	jne    f01111a1 <sys_check_LRU_lists+0x2a>
f011118b:	68 34 26 13 f0       	push   $0xf0132634
f0111190:	68 44 26 13 f0       	push   $0xf0132644
f0111195:	6a 10                	push   $0x10
f0111197:	68 59 26 13 f0       	push   $0xf0132659
f011119c:	e8 0e fe fe ff       	call   f0100faf <_panic>
	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
f01111a1:	83 ec 0c             	sub    $0xc,%esp
f01111a4:	68 78 26 13 f0       	push   $0xf0132678
f01111a9:	e8 ae 0a ff ff       	call   f0101c5c <cprintf>
f01111ae:	83 c4 10             	add    $0x10,%esp
	env_page_ws_print(cur_env);
f01111b1:	83 ec 0c             	sub    $0xc,%esp
f01111b4:	ff 75 e0             	pushl  -0x20(%ebp)
f01111b7:	e8 23 94 ff ff       	call   f010a5df <env_page_ws_print>
f01111bc:	83 c4 10             	add    $0x10,%esp

	struct Env* env = cur_env;
f01111bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01111c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
	int active_list_validation = 1;
f01111c5:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	int second_list_validation = 1;
f01111cc:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	//1- Check active list content if not null
	if(active_list_content != NULL)
f01111d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f01111d7:	0f 84 a5 00 00 00    	je     f0111282 <sys_check_LRU_lists+0x10b>
	{
		int idx_active_list = 0;
f01111dd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01111e4:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01111e7:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f01111ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01111f0:	eb 4a                	jmp    f011123c <sys_check_LRU_lists+0xc5>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(active_list_content[idx_active_list], PAGE_SIZE))
f01111f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01111f5:	8b 00                	mov    (%eax),%eax
f01111f7:	89 45 d8             	mov    %eax,-0x28(%ebp)
f01111fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01111fd:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111202:	89 c2                	mov    %eax,%edx
f0111204:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111207:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011120e:	8b 45 08             	mov    0x8(%ebp),%eax
f0111211:	01 c8                	add    %ecx,%eax
f0111213:	8b 00                	mov    (%eax),%eax
f0111215:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0111218:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011121b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111220:	39 c2                	cmp    %eax,%edx
f0111222:	74 09                	je     f011122d <sys_check_LRU_lists+0xb6>
			{
				active_list_validation = 0;
f0111224:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f011122b:	eb 3e                	jmp    f011126b <sys_check_LRU_lists+0xf4>
			}
			idx_active_list++;
f011122d:	ff 45 e8             	incl   -0x18(%ebp)

	//1- Check active list content if not null
	if(active_list_content != NULL)
	{
		int idx_active_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111230:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111233:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111239:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011123c:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111240:	74 08                	je     f011124a <sys_check_LRU_lists+0xd3>
f0111242:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0111245:	8b 40 10             	mov    0x10(%eax),%eax
f0111248:	eb 05                	jmp    f011124f <sys_check_LRU_lists+0xd8>
f011124a:	b8 00 00 00 00       	mov    $0x0,%eax
f011124f:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111252:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f0111258:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011125b:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111261:	85 c0                	test   %eax,%eax
f0111263:	75 8d                	jne    f01111f2 <sys_check_LRU_lists+0x7b>
f0111265:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111269:	75 87                	jne    f01111f2 <sys_check_LRU_lists+0x7b>
				active_list_validation = 0;
				break;
			}
			idx_active_list++;
		}
		if(LIST_SIZE(&env->ActiveList) != actual_active_list_size)
f011126b:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011126e:	8b 90 74 05 00 00    	mov    0x574(%eax),%edx
f0111274:	8b 45 10             	mov    0x10(%ebp),%eax
f0111277:	39 c2                	cmp    %eax,%edx
f0111279:	74 07                	je     f0111282 <sys_check_LRU_lists+0x10b>
		{
			active_list_validation = 0;
f011127b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

		}
	}

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
f0111282:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0111286:	0f 84 a5 00 00 00    	je     f0111331 <sys_check_LRU_lists+0x1ba>
	{
		int idx_second_list = 0;
f011128c:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f0111293:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0111296:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f011129c:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011129f:	eb 4a                	jmp    f01112eb <sys_check_LRU_lists+0x174>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(second_list_content[idx_second_list], PAGE_SIZE))
f01112a1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112a4:	8b 00                	mov    (%eax),%eax
f01112a6:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01112a9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01112ac:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112b1:	89 c2                	mov    %eax,%edx
f01112b3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01112b6:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01112bd:	8b 45 0c             	mov    0xc(%ebp),%eax
f01112c0:	01 c8                	add    %ecx,%eax
f01112c2:	8b 00                	mov    (%eax),%eax
f01112c4:	89 45 cc             	mov    %eax,-0x34(%ebp)
f01112c7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01112ca:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01112cf:	39 c2                	cmp    %eax,%edx
f01112d1:	74 09                	je     f01112dc <sys_check_LRU_lists+0x165>
			{
				second_list_validation = 0;
f01112d3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
				break;
f01112da:	eb 3e                	jmp    f011131a <sys_check_LRU_lists+0x1a3>
			}
			idx_second_list++;
f01112dc:	ff 45 e4             	incl   -0x1c(%ebp)

	//2- Check second chance list content if not null
	if(second_list_content != NULL)
	{
		int idx_second_list = 0;
		LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f01112df:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01112e2:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f01112e8:	89 45 ec             	mov    %eax,-0x14(%ebp)
f01112eb:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01112ef:	74 08                	je     f01112f9 <sys_check_LRU_lists+0x182>
f01112f1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01112f4:	8b 40 10             	mov    0x10(%eax),%eax
f01112f7:	eb 05                	jmp    f01112fe <sys_check_LRU_lists+0x187>
f01112f9:	b8 00 00 00 00       	mov    $0x0,%eax
f01112fe:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0111301:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f0111307:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011130a:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f0111310:	85 c0                	test   %eax,%eax
f0111312:	75 8d                	jne    f01112a1 <sys_check_LRU_lists+0x12a>
f0111314:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0111318:	75 87                	jne    f01112a1 <sys_check_LRU_lists+0x12a>
				second_list_validation = 0;
				break;
			}
			idx_second_list++;
		}
		if(LIST_SIZE(&env->SecondList) != actual_second_list_size)
f011131a:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011131d:	8b 90 84 05 00 00    	mov    0x584(%eax),%edx
f0111323:	8b 45 14             	mov    0x14(%ebp),%eax
f0111326:	39 c2                	cmp    %eax,%edx
f0111328:	74 07                	je     f0111331 <sys_check_LRU_lists+0x1ba>
			second_list_validation = 0;
f011132a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	}
	return active_list_validation&second_list_validation;
f0111331:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111334:	23 45 f0             	and    -0x10(%ebp),%eax
}
f0111337:	c9                   	leave  
f0111338:	c3                   	ret    

f0111339 <sys_check_LRU_lists_free>:


//2020
int sys_check_LRU_lists_free(uint32* list_content, int list_size)
{
f0111339:	55                   	push   %ebp
f011133a:	89 e5                	mov    %esp,%ebp
f011133c:	83 ec 38             	sub    $0x38,%esp
	struct Env* cur_env = get_cpu_proc();
f011133f:	e8 d4 a7 ff ff       	call   f010bb18 <get_cpu_proc>
f0111344:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	assert(cur_env != NULL);
f0111347:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011134b:	75 16                	jne    f0111363 <sys_check_LRU_lists_free+0x2a>
f011134d:	68 34 26 13 f0       	push   $0xf0132634
f0111352:	68 44 26 13 f0       	push   $0xf0132644
f0111357:	6a 45                	push   $0x45
f0111359:	68 59 26 13 f0       	push   $0xf0132659
f011135e:	e8 4c fc fe ff       	call   f0100faf <_panic>
	struct Env* env = cur_env;
f0111363:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111366:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int list_validation_count = 0;
f0111369:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f0111370:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111373:	8b 80 68 05 00 00    	mov    0x568(%eax),%eax
f0111379:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011137c:	eb 65                	jmp    f01113e3 <sys_check_LRU_lists_free+0xaa>
	{
		for(int var = 0; var < list_size; var++)
f011137e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0111385:	eb 3a                	jmp    f01113c1 <sys_check_LRU_lists_free+0x88>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111387:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011138a:	8b 00                	mov    (%eax),%eax
f011138c:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f011138f:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0111392:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111397:	89 c2                	mov    %eax,%edx
f0111399:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011139c:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01113a3:	8b 45 08             	mov    0x8(%ebp),%eax
f01113a6:	01 c8                	add    %ecx,%eax
f01113a8:	8b 00                	mov    (%eax),%eax
f01113aa:	89 45 d0             	mov    %eax,-0x30(%ebp)
f01113ad:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01113b0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01113b5:	39 c2                	cmp    %eax,%edx
f01113b7:	75 05                	jne    f01113be <sys_check_LRU_lists_free+0x85>
			{
				list_validation_count++;
f01113b9:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f01113bc:	eb 0b                	jmp    f01113c9 <sys_check_LRU_lists_free+0x90>
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
	{
		for(int var = 0; var < list_size; var++)
f01113be:	ff 45 ec             	incl   -0x14(%ebp)
f01113c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01113c4:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01113c7:	7c be                	jl     f0111387 <sys_check_LRU_lists_free+0x4e>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f01113c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01113cd:	7e 08                	jle    f01113d7 <sys_check_LRU_lists_free+0x9e>
			return list_validation_count;
f01113cf:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01113d2:	e9 ed 00 00 00       	jmp    f01114c4 <sys_check_LRU_lists_free+0x18b>
	assert(cur_env != NULL);
	struct Env* env = cur_env;
	int list_validation_count = 0;
	struct WorkingSetElement* ptr_WS_element;

	LIST_FOREACH(ptr_WS_element, &(env->ActiveList))
f01113d7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01113da:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f01113e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01113e3:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01113e7:	74 08                	je     f01113f1 <sys_check_LRU_lists_free+0xb8>
f01113e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01113ec:	8b 40 10             	mov    0x10(%eax),%eax
f01113ef:	eb 05                	jmp    f01113f6 <sys_check_LRU_lists_free+0xbd>
f01113f1:	b8 00 00 00 00       	mov    $0x0,%eax
f01113f6:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01113f9:	89 82 70 05 00 00    	mov    %eax,0x570(%edx)
f01113ff:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111402:	8b 80 70 05 00 00    	mov    0x570(%eax),%eax
f0111408:	85 c0                	test   %eax,%eax
f011140a:	0f 85 6e ff ff ff    	jne    f011137e <sys_check_LRU_lists_free+0x45>
f0111410:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111414:	0f 85 64 ff ff ff    	jne    f011137e <sys_check_LRU_lists_free+0x45>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011141a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011141d:	8b 80 78 05 00 00    	mov    0x578(%eax),%eax
f0111423:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0111426:	eb 62                	jmp    f011148a <sys_check_LRU_lists_free+0x151>
	{
		for(int var = 0; var < list_size; var++)
f0111428:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f011142f:	eb 3a                	jmp    f011146b <sys_check_LRU_lists_free+0x132>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(list_content[var], PAGE_SIZE))
f0111431:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111434:	8b 00                	mov    (%eax),%eax
f0111436:	89 45 dc             	mov    %eax,-0x24(%ebp)
f0111439:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011143c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111441:	89 c2                	mov    %eax,%edx
f0111443:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0111446:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f011144d:	8b 45 08             	mov    0x8(%ebp),%eax
f0111450:	01 c8                	add    %ecx,%eax
f0111452:	8b 00                	mov    (%eax),%eax
f0111454:	89 45 d8             	mov    %eax,-0x28(%ebp)
f0111457:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011145a:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011145f:	39 c2                	cmp    %eax,%edx
f0111461:	75 05                	jne    f0111468 <sys_check_LRU_lists_free+0x12f>
			{
				list_validation_count++;
f0111463:	ff 45 f4             	incl   -0xc(%ebp)
				break;
f0111466:	eb 0b                	jmp    f0111473 <sys_check_LRU_lists_free+0x13a>
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
	{
		for(int var = 0; var < list_size; var++)
f0111468:	ff 45 e8             	incl   -0x18(%ebp)
f011146b:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011146e:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111471:	7c be                	jl     f0111431 <sys_check_LRU_lists_free+0xf8>
			{
				list_validation_count++;
				break;
			}
		}
		if(list_validation_count > 0)
f0111473:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0111477:	7e 05                	jle    f011147e <sys_check_LRU_lists_free+0x145>
			return list_validation_count;
f0111479:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011147c:	eb 46                	jmp    f01114c4 <sys_check_LRU_lists_free+0x18b>
		if(list_validation_count > 0)
			return list_validation_count;
	}


	LIST_FOREACH(ptr_WS_element, &(env->SecondList))
f011147e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111481:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f0111487:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011148a:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011148e:	74 08                	je     f0111498 <sys_check_LRU_lists_free+0x15f>
f0111490:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111493:	8b 40 10             	mov    0x10(%eax),%eax
f0111496:	eb 05                	jmp    f011149d <sys_check_LRU_lists_free+0x164>
f0111498:	b8 00 00 00 00       	mov    $0x0,%eax
f011149d:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01114a0:	89 82 80 05 00 00    	mov    %eax,0x580(%edx)
f01114a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01114a9:	8b 80 80 05 00 00    	mov    0x580(%eax),%eax
f01114af:	85 c0                	test   %eax,%eax
f01114b1:	0f 85 71 ff ff ff    	jne    f0111428 <sys_check_LRU_lists_free+0xef>
f01114b7:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01114bb:	0f 85 67 ff ff ff    	jne    f0111428 <sys_check_LRU_lists_free+0xef>
			return list_validation_count;

	}


	return list_validation_count;
f01114c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f01114c4:	c9                   	leave  
f01114c5:	c3                   	ret    

f01114c6 <sys_check_WS_list>:
 * = 1: check entire list (order is important)
 * = 2: check only the existence of the given set of elements
 * = 3: check only the NOT existence of the given set of elements
 */
int sys_check_WS_list(uint32* WS_list_content, int actual_WS_list_size, uint32 last_WS_element_content, bool chk_status)
{
f01114c6:	55                   	push   %ebp
f01114c7:	89 e5                	mov    %esp,%ebp
f01114c9:	83 ec 68             	sub    $0x68,%esp
#if USE_KHEAP
//	cprintf("CURRENT WS CONTENT BEFORE CHECKING:\n");
//	env_page_ws_print(get_cpu_proc());
	struct Env* cur_env = get_cpu_proc();
f01114cc:	e8 47 a6 ff ff       	call   f010bb18 <get_cpu_proc>
f01114d1:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f01114d4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f01114d8:	75 16                	jne    f01114f0 <sys_check_WS_list+0x2a>
f01114da:	68 34 26 13 f0       	push   $0xf0132634
f01114df:	68 44 26 13 f0       	push   $0xf0132644
f01114e4:	6a 79                	push   $0x79
f01114e6:	68 59 26 13 f0       	push   $0xf0132659
f01114eb:	e8 bf fa fe ff       	call   f0100faf <_panic>
	struct Env* env = cur_env;
f01114f0:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01114f3:	89 45 cc             	mov    %eax,-0x34(%ebp)
	int WS_list_validation = 1;
f01114f6:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	struct WorkingSetElement* ptr_WS_element;

	if (chk_status == 0 || chk_status == 1)
f01114fd:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111501:	74 06                	je     f0111509 <sys_check_WS_list+0x43>
f0111503:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f0111507:	75 1f                	jne    f0111528 <sys_check_WS_list+0x62>
	{
		if(LIST_SIZE(&(env->page_WS_list)) != actual_WS_list_size)
f0111509:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011150c:	8b 90 94 00 00 00    	mov    0x94(%eax),%edx
f0111512:	8b 45 0c             	mov    0xc(%ebp),%eax
f0111515:	39 c2                	cmp    %eax,%edx
f0111517:	74 0f                	je     f0111528 <sys_check_WS_list+0x62>
		{
			return WS_list_validation = 0;
f0111519:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0111520:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111523:	e9 ec 02 00 00       	jmp    f0111814 <sys_check_WS_list+0x34e>
		}
	}
	//if it's required to check the last_WS_element
	if (last_WS_element_content != 0)
f0111528:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011152c:	74 39                	je     f0111567 <sys_check_WS_list+0xa1>
	{
		if (ROUNDDOWN(env->page_last_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f011152e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111531:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f0111537:	8b 00                	mov    (%eax),%eax
f0111539:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011153c:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011153f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111544:	89 c2                	mov    %eax,%edx
f0111546:	8b 45 10             	mov    0x10(%ebp),%eax
f0111549:	89 45 c4             	mov    %eax,-0x3c(%ebp)
f011154c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011154f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111554:	39 c2                	cmp    %eax,%edx
f0111556:	74 0f                	je     f0111567 <sys_check_WS_list+0xa1>
		{
			return WS_list_validation = 0;
f0111558:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011155f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111562:	e9 ad 02 00 00       	jmp    f0111814 <sys_check_WS_list+0x34e>
		}
	}
	//if the order of the content is important to check
	if (chk_status == 1)
f0111567:	83 7d 14 01          	cmpl   $0x1,0x14(%ebp)
f011156b:	0f 85 13 01 00 00    	jne    f0111684 <sys_check_WS_list+0x1be>
		//				WS_list_validation = 0;
		//				break;
		//			}
		//			idx_WS_list++;
		//		}
		int idx_WS_list = 0;
f0111571:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
f0111578:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011157c:	74 4c                	je     f01115ca <sys_check_WS_list+0x104>
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f011157e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f0111585:	eb 3b                	jmp    f01115c2 <sys_check_WS_list+0xfc>
			{
				if (ROUNDDOWN(WS_list_content[i], PAGE_SIZE) == ROUNDDOWN(last_WS_element_content, PAGE_SIZE))
f0111587:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011158a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111591:	8b 45 08             	mov    0x8(%ebp),%eax
f0111594:	01 d0                	add    %edx,%eax
f0111596:	8b 00                	mov    (%eax),%eax
f0111598:	89 45 c0             	mov    %eax,-0x40(%ebp)
f011159b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011159e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115a3:	89 c2                	mov    %eax,%edx
f01115a5:	8b 45 10             	mov    0x10(%ebp),%eax
f01115a8:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01115ab:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01115ae:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01115b3:	39 c2                	cmp    %eax,%edx
f01115b5:	75 08                	jne    f01115bf <sys_check_WS_list+0xf9>
				{
					idx_WS_list = i ;
f01115b7:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01115ba:	89 45 ec             	mov    %eax,-0x14(%ebp)
					break;
f01115bd:	eb 0b                	jmp    f01115ca <sys_check_WS_list+0x104>
		int idx_WS_list = 0;

		//Search for the correct index of the current WS element (if any)
		if (last_WS_element_content)
		{
			for (int i = 0; i < actual_WS_list_size; ++i)
f01115bf:	ff 45 e8             	incl   -0x18(%ebp)
f01115c2:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01115c5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f01115c8:	7c bd                	jl     f0111587 <sys_check_WS_list+0xc1>
				}
			}
		}
		//cprintf("index of last WS element = %d\n",idx_WS_list);
		//Check the expected content starting from last WS element (if any)
		if (env->page_last_WS_element)
f01115ca:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115cd:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01115d3:	85 c0                	test   %eax,%eax
f01115d5:	74 0e                	je     f01115e5 <sys_check_WS_list+0x11f>
			ptr_WS_element = env->page_last_WS_element;
f01115d7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115da:	8b 80 98 00 00 00    	mov    0x98(%eax),%eax
f01115e0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01115e3:	eb 0c                	jmp    f01115f1 <sys_check_WS_list+0x12b>
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f01115e5:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01115e8:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01115ee:	89 45 f0             	mov    %eax,-0x10(%ebp)

		//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f01115f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01115f8:	eb 79                	jmp    f0111673 <sys_check_WS_list+0x1ad>
		{
			if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) != ROUNDDOWN(WS_list_content[idx_WS_list], PAGE_SIZE))
f01115fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01115fd:	8b 00                	mov    (%eax),%eax
f01115ff:	89 45 b8             	mov    %eax,-0x48(%ebp)
f0111602:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0111605:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011160a:	89 c2                	mov    %eax,%edx
f011160c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011160f:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111616:	8b 45 08             	mov    0x8(%ebp),%eax
f0111619:	01 c8                	add    %ecx,%eax
f011161b:	8b 00                	mov    (%eax),%eax
f011161d:	89 45 b4             	mov    %eax,-0x4c(%ebp)
f0111620:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0111623:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0111628:	39 c2                	cmp    %eax,%edx
f011162a:	74 0c                	je     f0111638 <sys_check_WS_list+0x172>
			{
				WS_list_validation = 0;
f011162c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111633:	e9 d9 01 00 00       	jmp    f0111811 <sys_check_WS_list+0x34b>
			}
			idx_WS_list = (idx_WS_list + 1) % env->page_WS_max_size;
f0111638:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011163b:	40                   	inc    %eax
f011163c:	89 c2                	mov    %eax,%edx
f011163e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111641:	8b 88 84 00 00 00    	mov    0x84(%eax),%ecx
f0111647:	89 d0                	mov    %edx,%eax
f0111649:	ba 00 00 00 00       	mov    $0x0,%edx
f011164e:	f7 f1                	div    %ecx
f0111650:	89 d0                	mov    %edx,%eax
f0111652:	89 45 ec             	mov    %eax,-0x14(%ebp)
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
f0111655:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111658:	8b 40 10             	mov    0x10(%eax),%eax
f011165b:	89 45 f0             	mov    %eax,-0x10(%ebp)
			if (ptr_WS_element == NULL)
f011165e:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111662:	75 0c                	jne    f0111670 <sys_check_WS_list+0x1aa>
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
f0111664:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111667:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f011166d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		else
			ptr_WS_element = LIST_FIRST(&(env->page_WS_list));

		//cprintf("comparison start from va = %x\n",ptr_WS_element->virtual_address);

		for (int i = 0; i < actual_WS_list_size; ++i)
f0111670:	ff 45 e4             	incl   -0x1c(%ebp)
f0111673:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0111676:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111679:	0f 8c 7b ff ff ff    	jl     f01115fa <sys_check_WS_list+0x134>
f011167f:	e9 8d 01 00 00       	jmp    f0111811 <sys_check_WS_list+0x34b>
			ptr_WS_element = LIST_NEXT(ptr_WS_element);
			if (ptr_WS_element == NULL)
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
f0111684:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
f0111688:	74 0a                	je     f0111694 <sys_check_WS_list+0x1ce>
f011168a:	83 7d 14 02          	cmpl   $0x2,0x14(%ebp)
f011168e:	0f 85 be 00 00 00    	jne    f0111752 <sys_check_WS_list+0x28c>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111694:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f011169b:	e9 a1 00 00 00       	jmp    f0111741 <sys_check_WS_list+0x27b>
		{
			bool found = 0;
f01116a0:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01116a7:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116aa:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f01116b0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01116b3:	eb 47                	jmp    f01116fc <sys_check_WS_list+0x236>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f01116b5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01116b8:	8b 00                	mov    (%eax),%eax
f01116ba:	89 45 a8             	mov    %eax,-0x58(%ebp)
f01116bd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01116c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116c5:	89 c2                	mov    %eax,%edx
f01116c7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01116ca:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f01116d1:	8b 45 08             	mov    0x8(%ebp),%eax
f01116d4:	01 c8                	add    %ecx,%eax
f01116d6:	8b 00                	mov    (%eax),%eax
f01116d8:	89 45 a4             	mov    %eax,-0x5c(%ebp)
f01116db:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f01116de:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01116e3:	39 c2                	cmp    %eax,%edx
f01116e5:	75 09                	jne    f01116f0 <sys_check_WS_list+0x22a>
				{
					found = 1;
f01116e7:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
					break;
f01116ee:	eb 3b                	jmp    f011172b <sys_check_WS_list+0x265>
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01116f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01116f3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01116f9:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01116fc:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111700:	74 08                	je     f011170a <sys_check_WS_list+0x244>
f0111702:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111705:	8b 40 10             	mov    0x10(%eax),%eax
f0111708:	eb 05                	jmp    f011170f <sys_check_WS_list+0x249>
f011170a:	b8 00 00 00 00       	mov    $0x0,%eax
f011170f:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0111712:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f0111718:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011171b:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f0111721:	85 c0                	test   %eax,%eax
f0111723:	75 90                	jne    f01116b5 <sys_check_WS_list+0x1ef>
f0111725:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0111729:	75 8a                	jne    f01116b5 <sys_check_WS_list+0x1ef>
				{
					found = 1;
					break;
				}
			}
			if (!found)
f011172b:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011172f:	75 0d                	jne    f011173e <sys_check_WS_list+0x278>
			{
				WS_list_validation = 0;
f0111731:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111738:	90                   	nop
				ptr_WS_element = LIST_FIRST(&(env->page_WS_list));
		}
	}
	else if (chk_status == 0 || chk_status == 2)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111739:	e9 d3 00 00 00       	jmp    f0111811 <sys_check_WS_list+0x34b>
f011173e:	ff 45 e0             	incl   -0x20(%ebp)
f0111741:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0111744:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111747:	0f 8c 53 ff ff ff    	jl     f01116a0 <sys_check_WS_list+0x1da>
f011174d:	e9 bf 00 00 00       	jmp    f0111811 <sys_check_WS_list+0x34b>
				break;
			}
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
f0111752:	83 7d 14 03          	cmpl   $0x3,0x14(%ebp)
f0111756:	0f 85 b5 00 00 00    	jne    f0111811 <sys_check_WS_list+0x34b>
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f011175c:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0111763:	e9 9d 00 00 00       	jmp    f0111805 <sys_check_WS_list+0x33f>
		{
			bool found = 0;
f0111768:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f011176f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0111772:	8b 80 88 00 00 00    	mov    0x88(%eax),%eax
f0111778:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011177b:	eb 47                	jmp    f01117c4 <sys_check_WS_list+0x2fe>
			{
				if (ROUNDDOWN(ptr_WS_element->virtual_address, PAGE_SIZE) == ROUNDDOWN(WS_list_content[idx_expected_list], PAGE_SIZE))
f011177d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111780:	8b 00                	mov    (%eax),%eax
f0111782:	89 45 b0             	mov    %eax,-0x50(%ebp)
f0111785:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0111788:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011178d:	89 c2                	mov    %eax,%edx
f011178f:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111792:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0111799:	8b 45 08             	mov    0x8(%ebp),%eax
f011179c:	01 c8                	add    %ecx,%eax
f011179e:	8b 00                	mov    (%eax),%eax
f01117a0:	89 45 ac             	mov    %eax,-0x54(%ebp)
f01117a3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01117a6:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f01117ab:	39 c2                	cmp    %eax,%edx
f01117ad:	75 09                	jne    f01117b8 <sys_check_WS_list+0x2f2>
				{
					found = 1;
f01117af:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
					break;
f01117b6:	eb 3b                	jmp    f01117f3 <sys_check_WS_list+0x32d>
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
		{
			bool found = 0;
			LIST_FOREACH(ptr_WS_element, &(env->page_WS_list))
f01117b8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117bb:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01117c1:	89 45 f0             	mov    %eax,-0x10(%ebp)
f01117c4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117c8:	74 08                	je     f01117d2 <sys_check_WS_list+0x30c>
f01117ca:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01117cd:	8b 40 10             	mov    0x10(%eax),%eax
f01117d0:	eb 05                	jmp    f01117d7 <sys_check_WS_list+0x311>
f01117d2:	b8 00 00 00 00       	mov    $0x0,%eax
f01117d7:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01117da:	89 82 90 00 00 00    	mov    %eax,0x90(%edx)
f01117e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01117e3:	8b 80 90 00 00 00    	mov    0x90(%eax),%eax
f01117e9:	85 c0                	test   %eax,%eax
f01117eb:	75 90                	jne    f011177d <sys_check_WS_list+0x2b7>
f01117ed:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01117f1:	75 8a                	jne    f011177d <sys_check_WS_list+0x2b7>
				{
					found = 1;
					break;
				}
			}
			if (found)
f01117f3:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f01117f7:	74 09                	je     f0111802 <sys_check_WS_list+0x33c>
			{
				WS_list_validation = 0;
f01117f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				break;
f0111800:	eb 0f                	jmp    f0111811 <sys_check_WS_list+0x34b>
		}
	}
	//Check NON-EXITENCE of the Given Addresses
	else if (chk_status == 3)
	{
		for (int idx_expected_list = 0; idx_expected_list < actual_WS_list_size; ++idx_expected_list)
f0111802:	ff 45 d8             	incl   -0x28(%ebp)
f0111805:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0111808:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011180b:	0f 8c 57 ff ff ff    	jl     f0111768 <sys_check_WS_list+0x2a2>
				break;
			}
		}
	}

	return WS_list_validation;
f0111811:	8b 45 f4             	mov    -0xc(%ebp),%eax
#else
	panic("sys_check_WS_list: this function is intended to be used when USE_KHEAP = 1");
	return 0;
#endif
}
f0111814:	c9                   	leave  
f0111815:	c3                   	ret    

f0111816 <hasExpectedCommands>:
	cprintf("=================\n\n");
	return 0;
}*/

int hasExpectedCommands(char **expectedCommands, int commandsCount)
{
f0111816:	55                   	push   %ebp
f0111817:	89 e5                	mov    %esp,%ebp
f0111819:	83 ec 18             	sub    $0x18,%esp
	struct Command *cmd = NULL;
f011181c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	if (LIST_SIZE(&foundCommands) != commandsCount)
f0111823:	8b 15 78 6d 85 f0    	mov    0xf0856d78,%edx
f0111829:	8b 45 0c             	mov    0xc(%ebp),%eax
f011182c:	39 c2                	cmp    %eax,%edx
f011182e:	74 0a                	je     f011183a <hasExpectedCommands+0x24>
		return 0;
f0111830:	b8 00 00 00 00       	mov    $0x0,%eax
f0111835:	e9 8b 00 00 00       	jmp    f01118c5 <hasExpectedCommands+0xaf>

	LIST_FOREACH(cmd, &foundCommands)
f011183a:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f011183f:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111842:	eb 55                	jmp    f0111899 <hasExpectedCommands+0x83>
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111844:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f011184b:	eb 2a                	jmp    f0111877 <hasExpectedCommands+0x61>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
f011184d:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111850:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0111857:	8b 45 08             	mov    0x8(%ebp),%eax
f011185a:	01 d0                	add    %edx,%eax
f011185c:	8b 10                	mov    (%eax),%edx
f011185e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0111861:	8b 00                	mov    (%eax),%eax
f0111863:	83 ec 08             	sub    $0x8,%esp
f0111866:	52                   	push   %edx
f0111867:	50                   	push   %eax
f0111868:	e8 1a 94 00 00       	call   f011ac87 <strcmp>
f011186d:	83 c4 10             	add    $0x10,%esp
f0111870:	85 c0                	test   %eax,%eax
f0111872:	74 0d                	je     f0111881 <hasExpectedCommands+0x6b>
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
	{
		int i;
		for (i = 0; i < commandsCount; i++)
f0111874:	ff 45 f0             	incl   -0x10(%ebp)
f0111877:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011187a:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011187d:	7c ce                	jl     f011184d <hasExpectedCommands+0x37>
f011187f:	eb 01                	jmp    f0111882 <hasExpectedCommands+0x6c>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
f0111881:	90                   	nop
		if (i == commandsCount)
f0111882:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0111885:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0111888:	75 07                	jne    f0111891 <hasExpectedCommands+0x7b>
			return 0;
f011188a:	b8 00 00 00 00       	mov    $0x0,%eax
f011188f:	eb 34                	jmp    f01118c5 <hasExpectedCommands+0xaf>
{
	struct Command *cmd = NULL;
	if (LIST_SIZE(&foundCommands) != commandsCount)
		return 0;

	LIST_FOREACH(cmd, &foundCommands)
f0111891:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f0111896:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0111899:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011189d:	74 08                	je     f01118a7 <hasExpectedCommands+0x91>
f011189f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01118a2:	8b 40 10             	mov    0x10(%eax),%eax
f01118a5:	eb 05                	jmp    f01118ac <hasExpectedCommands+0x96>
f01118a7:	b8 00 00 00 00       	mov    $0x0,%eax
f01118ac:	a3 74 6d 85 f0       	mov    %eax,0xf0856d74
f01118b1:	a1 74 6d 85 f0       	mov    0xf0856d74,%eax
f01118b6:	85 c0                	test   %eax,%eax
f01118b8:	75 8a                	jne    f0111844 <hasExpectedCommands+0x2e>
f01118ba:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f01118be:	75 84                	jne    f0111844 <hasExpectedCommands+0x2e>
			if (strcmp(cmd->name, expectedCommands[i]) == 0)
				break;
		if (i == commandsCount)
			return 0;
	}
	return 1;
f01118c0:	b8 01 00 00 00       	mov    $0x1,%eax
}
f01118c5:	c9                   	leave  
f01118c6:	c3                   	ret    

f01118c7 <getIndexOfCommand>:

int getIndexOfCommand(const char *commandName)
{
f01118c7:	55                   	push   %ebp
f01118c8:	89 e5                	mov    %esp,%ebp
f01118ca:	83 ec 18             	sub    $0x18,%esp
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f01118cd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f01118d4:	eb 2e                	jmp    f0111904 <getIndexOfCommand+0x3d>
		if (strcmp(commands[i].name, commandName) == 0)
f01118d6:	8b 55 f4             	mov    -0xc(%ebp),%edx
f01118d9:	89 d0                	mov    %edx,%eax
f01118db:	01 c0                	add    %eax,%eax
f01118dd:	01 d0                	add    %edx,%eax
f01118df:	c1 e0 03             	shl    $0x3,%eax
f01118e2:	05 60 f5 17 f0       	add    $0xf017f560,%eax
f01118e7:	8b 00                	mov    (%eax),%eax
f01118e9:	83 ec 08             	sub    $0x8,%esp
f01118ec:	ff 75 08             	pushl  0x8(%ebp)
f01118ef:	50                   	push   %eax
f01118f0:	e8 92 93 00 00       	call   f011ac87 <strcmp>
f01118f5:	83 c4 10             	add    $0x10,%esp
f01118f8:	85 c0                	test   %eax,%eax
f01118fa:	75 05                	jne    f0111901 <getIndexOfCommand+0x3a>
			return i;
f01118fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01118ff:	eb 14                	jmp    f0111915 <getIndexOfCommand+0x4e>
}

int getIndexOfCommand(const char *commandName)
{
	int i;
	for (i = 0; i < NUM_OF_COMMANDS; i++)
f0111901:	ff 45 f4             	incl   -0xc(%ebp)
f0111904:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0111907:	a1 a8 fb 17 f0       	mov    0xf017fba8,%eax
f011190c:	39 c2                	cmp    %eax,%edx
f011190e:	72 c6                	jb     f01118d6 <getIndexOfCommand+0xf>
		if (strcmp(commands[i].name, commandName) == 0)
			return i;
	return -404;
f0111910:	b8 6c fe ff ff       	mov    $0xfffffe6c,%eax
}
f0111915:	c9                   	leave  
f0111916:	c3                   	ret    

f0111917 <TestAutoCompleteCommand>:

int TestAutoCompleteCommand()
{
f0111917:	55                   	push   %ebp
f0111918:	89 e5                	mov    %esp,%ebp
f011191a:	57                   	push   %edi
f011191b:	56                   	push   %esi
f011191c:	53                   	push   %ebx
f011191d:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	cprintf("Automatic Testing of Autocomplete:\n");
f0111923:	83 ec 0c             	sub    $0xc,%esp
f0111926:	68 a0 26 13 f0       	push   $0xf01326a0
f011192b:	e8 2c 03 ff ff       	call   f0101c5c <cprintf>
f0111930:	83 c4 10             	add    $0x10,%esp
	cprintf("\n========================\n");
f0111933:	83 ec 0c             	sub    $0xc,%esp
f0111936:	68 c4 26 13 f0       	push   $0xf01326c4
f011193b:	e8 1c 03 ff ff       	call   f0101c5c <cprintf>
f0111940:	83 c4 10             	add    $0x10,%esp

	// CASE1: command is found with correct number of arguments
	int eval = 0;
f0111943:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)

	char *args1[] = {"kernel_info"};
f011194a:	c7 45 8c df 26 13 f0 	movl   $0xf01326df,-0x74(%ebp)
	int ret = process_command(ARRAY_LENGTH(args1), args1);
f0111951:	83 ec 08             	sub    $0x8,%esp
f0111954:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0111957:	50                   	push   %eax
f0111958:	6a 01                	push   $0x1
f011195a:	e8 91 08 ff ff       	call   f01021f0 <process_command>
f011195f:	83 c4 10             	add    $0x10,%esp
f0111962:	89 45 e0             	mov    %eax,-0x20(%ebp)
	cprintf("==>Testing now AUTOCOMPLETE for: kernel_info\n");
f0111965:	83 ec 0c             	sub    $0xc,%esp
f0111968:	68 ec 26 13 f0       	push   $0xf01326ec
f011196d:	e8 ea 02 ff ff       	call   f0101c5c <cprintf>
f0111972:	83 c4 10             	add    $0x10,%esp
	if (ret == getIndexOfCommand(args1[0]) && LIST_EMPTY(&foundCommands))
f0111975:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0111978:	83 ec 0c             	sub    $0xc,%esp
f011197b:	50                   	push   %eax
f011197c:	e8 46 ff ff ff       	call   f01118c7 <getIndexOfCommand>
f0111981:	83 c4 10             	add    $0x10,%esp
f0111984:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111987:	75 0f                	jne    f0111998 <TestAutoCompleteCommand+0x81>
f0111989:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f011198e:	85 c0                	test   %eax,%eax
f0111990:	75 06                	jne    f0111998 <TestAutoCompleteCommand+0x81>
		eval += 5;
f0111992:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0111996:	eb 10                	jmp    f01119a8 <TestAutoCompleteCommand+0x91>
	else
		cprintf("#1: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111998:	83 ec 0c             	sub    $0xc,%esp
f011199b:	68 1c 27 13 f0       	push   $0xf013271c
f01119a0:	e8 b7 02 ff ff       	call   f0101c5c <cprintf>
f01119a5:	83 c4 10             	add    $0x10,%esp

	// CASE2: command is not found BUT its chars are subsequence-matched with one or more commands
	// should print the commands that contains "clk" as subsequence
	cprintf("==>Testing now AUTOCOMPLETE for: clk\n");
f01119a8:	83 ec 0c             	sub    $0xc,%esp
f01119ab:	68 6c 27 13 f0       	push   $0xf013276c
f01119b0:	e8 a7 02 ff ff       	call   f0101c5c <cprintf>
f01119b5:	83 c4 10             	add    $0x10,%esp
	char *args2[] = {"clk"};
f01119b8:	c7 45 88 92 27 13 f0 	movl   $0xf0132792,-0x78(%ebp)
	ret = process_command(ARRAY_LENGTH(args2), args2);
f01119bf:	83 ec 08             	sub    $0x8,%esp
f01119c2:	8d 45 88             	lea    -0x78(%ebp),%eax
f01119c5:	50                   	push   %eax
f01119c6:	6a 01                	push   $0x1
f01119c8:	e8 23 08 ff ff       	call   f01021f0 <process_command>
f01119cd:	83 c4 10             	add    $0x10,%esp
f01119d0:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"clock", "modifiedclock", "nclock"}, 3))
f01119d3:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f01119d7:	75 30                	jne    f0111a09 <TestAutoCompleteCommand+0xf2>
f01119d9:	8d 45 90             	lea    -0x70(%ebp),%eax
f01119dc:	bb ac 2b 13 f0       	mov    $0xf0132bac,%ebx
f01119e1:	ba 03 00 00 00       	mov    $0x3,%edx
f01119e6:	89 c7                	mov    %eax,%edi
f01119e8:	89 de                	mov    %ebx,%esi
f01119ea:	89 d1                	mov    %edx,%ecx
f01119ec:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f01119ee:	83 ec 08             	sub    $0x8,%esp
f01119f1:	6a 03                	push   $0x3
f01119f3:	8d 45 90             	lea    -0x70(%ebp),%eax
f01119f6:	50                   	push   %eax
f01119f7:	e8 1a fe ff ff       	call   f0111816 <hasExpectedCommands>
f01119fc:	83 c4 10             	add    $0x10,%esp
f01119ff:	85 c0                	test   %eax,%eax
f0111a01:	74 06                	je     f0111a09 <TestAutoCompleteCommand+0xf2>
		eval += 15;
f0111a03:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111a07:	eb 10                	jmp    f0111a19 <TestAutoCompleteCommand+0x102>
	else
		cprintf("#2: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111a09:	83 ec 0c             	sub    $0xc,%esp
f0111a0c:	68 98 27 13 f0       	push   $0xf0132798
f0111a11:	e8 46 02 ff ff       	call   f0101c5c <cprintf>
f0111a16:	83 c4 10             	add    $0x10,%esp

	// CASE3.1: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: wm\n");
f0111a19:	83 ec 0c             	sub    $0xc,%esp
f0111a1c:	68 e8 27 13 f0       	push   $0xf01327e8
f0111a21:	e8 36 02 ff ff       	call   f0101c5c <cprintf>
f0111a26:	83 c4 10             	add    $0x10,%esp
	char *args3_1[] = {"wm"};
f0111a29:	c7 45 84 0d 28 13 f0 	movl   $0xf013280d,-0x7c(%ebp)
	ret = process_command(ARRAY_LENGTH(args3_1), args3_1);
f0111a30:	83 ec 08             	sub    $0x8,%esp
f0111a33:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111a36:	50                   	push   %eax
f0111a37:	6a 01                	push   $0x1
f0111a39:	e8 b2 07 ff ff       	call   f01021f0 <process_command>
f0111a3e:	83 c4 10             	add    $0x10,%esp
f0111a41:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_1, 1))
f0111a44:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0111a48:	75 1b                	jne    f0111a65 <TestAutoCompleteCommand+0x14e>
f0111a4a:	83 ec 08             	sub    $0x8,%esp
f0111a4d:	6a 01                	push   $0x1
f0111a4f:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0111a52:	50                   	push   %eax
f0111a53:	e8 be fd ff ff       	call   f0111816 <hasExpectedCommands>
f0111a58:	83 c4 10             	add    $0x10,%esp
f0111a5b:	85 c0                	test   %eax,%eax
f0111a5d:	74 06                	je     f0111a65 <TestAutoCompleteCommand+0x14e>
		eval += 15;
f0111a5f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111a63:	eb 10                	jmp    f0111a75 <TestAutoCompleteCommand+0x15e>
	else
		cprintf("#3.1: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111a65:	83 ec 0c             	sub    $0xc,%esp
f0111a68:	68 10 28 13 f0       	push   $0xf0132810
f0111a6d:	e8 ea 01 ff ff       	call   f0101c5c <cprintf>
f0111a72:	83 c4 10             	add    $0x10,%esp

	// CASE3.2: should print invalid number of args
	cprintf("==>Testing now AUTOCOMPLETE for: lru\n");
f0111a75:	83 ec 0c             	sub    $0xc,%esp
f0111a78:	68 6c 28 13 f0       	push   $0xf013286c
f0111a7d:	e8 da 01 ff ff       	call   f0101c5c <cprintf>
f0111a82:	83 c4 10             	add    $0x10,%esp
	char *args3_2[] = {"lru", "2", "1"};
f0111a85:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111a8b:	bb c0 2b 13 f0       	mov    $0xf0132bc0,%ebx
f0111a90:	ba 03 00 00 00       	mov    $0x3,%edx
f0111a95:	89 c7                	mov    %eax,%edi
f0111a97:	89 de                	mov    %ebx,%esi
f0111a99:	89 d1                	mov    %edx,%ecx
f0111a9b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args3_2), args3_2);
f0111a9d:	83 ec 08             	sub    $0x8,%esp
f0111aa0:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111aa6:	50                   	push   %eax
f0111aa7:	6a 03                	push   $0x3
f0111aa9:	e8 42 07 ff ff       	call   f01021f0 <process_command>
f0111aae:	83 c4 10             	add    $0x10,%esp
f0111ab1:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INV_NUM_ARGS && hasExpectedCommands(args3_2, 1))
f0111ab4:	83 7d e0 fe          	cmpl   $0xfffffffe,-0x20(%ebp)
f0111ab8:	75 1e                	jne    f0111ad8 <TestAutoCompleteCommand+0x1c1>
f0111aba:	83 ec 08             	sub    $0x8,%esp
f0111abd:	6a 01                	push   $0x1
f0111abf:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0111ac5:	50                   	push   %eax
f0111ac6:	e8 4b fd ff ff       	call   f0111816 <hasExpectedCommands>
f0111acb:	83 c4 10             	add    $0x10,%esp
f0111ace:	85 c0                	test   %eax,%eax
f0111ad0:	74 06                	je     f0111ad8 <TestAutoCompleteCommand+0x1c1>
		eval += 15;
f0111ad2:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111ad6:	eb 10                	jmp    f0111ae8 <TestAutoCompleteCommand+0x1d1>
	else
		cprintf("#3.2: WRONG - process_command return wrong value or foundCommands contains wrong values.\n");
f0111ad8:	83 ec 0c             	sub    $0xc,%esp
f0111adb:	68 94 28 13 f0       	push   $0xf0132894
f0111ae0:	e8 77 01 ff ff       	call   f0101c5c <cprintf>
f0111ae5:	83 c4 10             	add    $0x10,%esp

	// CASE4: should print invalid command
	cprintf("==>Testing now AUTOCOMPLETE for: smm\n");
f0111ae8:	83 ec 0c             	sub    $0xc,%esp
f0111aeb:	68 f0 28 13 f0       	push   $0xf01328f0
f0111af0:	e8 67 01 ff ff       	call   f0101c5c <cprintf>
f0111af5:	83 c4 10             	add    $0x10,%esp
	char *args4[] = {"smm"};
f0111af8:	c7 85 74 ff ff ff 16 	movl   $0xf0132916,-0x8c(%ebp)
f0111aff:	29 13 f0 
	ret = process_command(ARRAY_LENGTH(args4), args4);
f0111b02:	83 ec 08             	sub    $0x8,%esp
f0111b05:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0111b0b:	50                   	push   %eax
f0111b0c:	6a 01                	push   $0x1
f0111b0e:	e8 dd 06 ff ff       	call   f01021f0 <process_command>
f0111b13:	83 c4 10             	add    $0x10,%esp
f0111b16:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_INVALID && LIST_SIZE(&foundCommands) == 0)
f0111b19:	83 7d e0 fd          	cmpl   $0xfffffffd,-0x20(%ebp)
f0111b1d:	75 0f                	jne    f0111b2e <TestAutoCompleteCommand+0x217>
f0111b1f:	a1 78 6d 85 f0       	mov    0xf0856d78,%eax
f0111b24:	85 c0                	test   %eax,%eax
f0111b26:	75 06                	jne    f0111b2e <TestAutoCompleteCommand+0x217>
		eval += 10;
f0111b28:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111b2c:	eb 10                	jmp    f0111b3e <TestAutoCompleteCommand+0x227>
	else
		cprintf("#4: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111b2e:	83 ec 0c             	sub    $0xc,%esp
f0111b31:	68 1c 29 13 f0       	push   $0xf013291c
f0111b36:	e8 21 01 ff ff       	call   f0101c5c <cprintf>
f0111b3b:	83 c4 10             	add    $0x10,%esp

	// CASE5: should print the commands that contains he
	cprintf("==>Testing now AUTOCOMPLETE for: he\n");
f0111b3e:	83 ec 0c             	sub    $0xc,%esp
f0111b41:	68 6c 29 13 f0       	push   $0xf013296c
f0111b46:	e8 11 01 ff ff       	call   f0101c5c <cprintf>
f0111b4b:	83 c4 10             	add    $0x10,%esp
	char *args5[] = {"he"};
f0111b4e:	c7 85 70 ff ff ff 91 	movl   $0xf0132991,-0x90(%ebp)
f0111b55:	29 13 f0 
	ret = process_command(ARRAY_LENGTH(args5), args5);
f0111b58:	83 ec 08             	sub    $0x8,%esp
f0111b5b:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
f0111b61:	50                   	push   %eax
f0111b62:	6a 01                	push   $0x1
f0111b64:	e8 87 06 ff ff       	call   f01021f0 <process_command>
f0111b69:	83 c4 10             	add    $0x10,%esp
f0111b6c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"help", "sched?", "uhbestfit", "uhnextfit", "uheap?", "khbestfit", "khnextfit", "kheap?", "schedRR", "schedTest", "schedBSD", "schedMLFQ"}, 12))
f0111b6f:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111b73:	75 30                	jne    f0111ba5 <TestAutoCompleteCommand+0x28e>
f0111b75:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111b78:	bb 40 2c 13 f0       	mov    $0xf0132c40,%ebx
f0111b7d:	ba 0c 00 00 00       	mov    $0xc,%edx
f0111b82:	89 c7                	mov    %eax,%edi
f0111b84:	89 de                	mov    %ebx,%esi
f0111b86:	89 d1                	mov    %edx,%ecx
f0111b88:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111b8a:	83 ec 08             	sub    $0x8,%esp
f0111b8d:	6a 0c                	push   $0xc
f0111b8f:	8d 45 9c             	lea    -0x64(%ebp),%eax
f0111b92:	50                   	push   %eax
f0111b93:	e8 7e fc ff ff       	call   f0111816 <hasExpectedCommands>
f0111b98:	83 c4 10             	add    $0x10,%esp
f0111b9b:	85 c0                	test   %eax,%eax
f0111b9d:	74 06                	je     f0111ba5 <TestAutoCompleteCommand+0x28e>
		eval += 15;
f0111b9f:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
f0111ba3:	eb 10                	jmp    f0111bb5 <TestAutoCompleteCommand+0x29e>
	else
		cprintf("#5: WRONG - process_command return wrong value or foundCommands is has wrong values.\n");
f0111ba5:	83 ec 0c             	sub    $0xc,%esp
f0111ba8:	68 94 29 13 f0       	push   $0xf0132994
f0111bad:	e8 aa 00 ff ff       	call   f0101c5c <cprintf>
f0111bb2:	83 c4 10             	add    $0x10,%esp

	// CASE6: should print the commands that contains ru ---> Shall print (rum, rub, rut, run, runall) .. Each in a separate line
	cprintf("==>Testing now AUTOCOMPLETE for: ru\n");
f0111bb5:	83 ec 0c             	sub    $0xc,%esp
f0111bb8:	68 ec 29 13 f0       	push   $0xf01329ec
f0111bbd:	e8 9a 00 ff ff       	call   f0101c5c <cprintf>
f0111bc2:	83 c4 10             	add    $0x10,%esp
	char *args6[] = {"ru"};
f0111bc5:	c7 85 6c ff ff ff 11 	movl   $0xf0132a11,-0x94(%ebp)
f0111bcc:	2a 13 f0 
	ret = process_command(ARRAY_LENGTH(args6), args6);
f0111bcf:	83 ec 08             	sub    $0x8,%esp
f0111bd2:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0111bd8:	50                   	push   %eax
f0111bd9:	6a 01                	push   $0x1
f0111bdb:	e8 10 06 ff ff       	call   f01021f0 <process_command>
f0111be0:	83 c4 10             	add    $0x10,%esp
f0111be3:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == CMD_MATCHED && hasExpectedCommands((char *[]){"runall", "lru", "rub", "run", "rum"}, 5))
f0111be6:	83 7d e0 ff          	cmpl   $0xffffffff,-0x20(%ebp)
f0111bea:	75 30                	jne    f0111c1c <TestAutoCompleteCommand+0x305>
f0111bec:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111bef:	bb 84 2c 13 f0       	mov    $0xf0132c84,%ebx
f0111bf4:	ba 05 00 00 00       	mov    $0x5,%edx
f0111bf9:	89 c7                	mov    %eax,%edi
f0111bfb:	89 de                	mov    %ebx,%esi
f0111bfd:	89 d1                	mov    %edx,%ecx
f0111bff:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
f0111c01:	83 ec 08             	sub    $0x8,%esp
f0111c04:	6a 05                	push   $0x5
f0111c06:	8d 45 cc             	lea    -0x34(%ebp),%eax
f0111c09:	50                   	push   %eax
f0111c0a:	e8 07 fc ff ff       	call   f0111816 <hasExpectedCommands>
f0111c0f:	83 c4 10             	add    $0x10,%esp
f0111c12:	85 c0                	test   %eax,%eax
f0111c14:	74 06                	je     f0111c1c <TestAutoCompleteCommand+0x305>
		eval += 10;
f0111c16:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111c1a:	eb 10                	jmp    f0111c2c <TestAutoCompleteCommand+0x315>
	else
		cprintf("#6: WRONG - process_command return wrong value. or foundCommands is has wrong values.\n");
f0111c1c:	83 ec 0c             	sub    $0xc,%esp
f0111c1f:	68 14 2a 13 f0       	push   $0xf0132a14
f0111c24:	e8 33 00 ff ff       	call   f0101c5c <cprintf>
f0111c29:	83 c4 10             	add    $0x10,%esp

	// CASE7: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: load game\n");
f0111c2c:	83 ec 0c             	sub    $0xc,%esp
f0111c2f:	68 6c 2a 13 f0       	push   $0xf0132a6c
f0111c34:	e8 23 00 ff ff       	call   f0101c5c <cprintf>
f0111c39:	83 c4 10             	add    $0x10,%esp
	char *args7[] = {"load", "game"};
f0111c3c:	c7 85 64 ff ff ff 98 	movl   $0xf0132a98,-0x9c(%ebp)
f0111c43:	2a 13 f0 
f0111c46:	c7 85 68 ff ff ff 9d 	movl   $0xf0132a9d,-0x98(%ebp)
f0111c4d:	2a 13 f0 
	ret = process_command(ARRAY_LENGTH(args7), args7);
f0111c50:	83 ec 08             	sub    $0x8,%esp
f0111c53:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
f0111c59:	50                   	push   %eax
f0111c5a:	6a 02                	push   $0x2
f0111c5c:	e8 8f 05 ff ff       	call   f01021f0 <process_command>
f0111c61:	83 c4 10             	add    $0x10,%esp
f0111c64:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args7[0]) && LIST_EMPTY(&foundCommands))
f0111c67:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
f0111c6d:	83 ec 0c             	sub    $0xc,%esp
f0111c70:	50                   	push   %eax
f0111c71:	e8 51 fc ff ff       	call   f01118c7 <getIndexOfCommand>
f0111c76:	83 c4 10             	add    $0x10,%esp
f0111c79:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111c7c:	75 0f                	jne    f0111c8d <TestAutoCompleteCommand+0x376>
f0111c7e:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0111c83:	85 c0                	test   %eax,%eax
f0111c85:	75 06                	jne    f0111c8d <TestAutoCompleteCommand+0x376>
		eval += 5;
f0111c87:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
f0111c8b:	eb 10                	jmp    f0111c9d <TestAutoCompleteCommand+0x386>
	else
		cprintf("#7: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111c8d:	83 ec 0c             	sub    $0xc,%esp
f0111c90:	68 a4 2a 13 f0       	push   $0xf0132aa4
f0111c95:	e8 c2 ff fe ff       	call   f0101c5c <cprintf>
f0111c9a:	83 c4 10             	add    $0x10,%esp

	// CASE8: command is found with correct number of arguments
	cprintf("==>Testing now AUTOCOMPLETE for: wum 0xF0000000 M\n");
f0111c9d:	83 ec 0c             	sub    $0xc,%esp
f0111ca0:	68 f4 2a 13 f0       	push   $0xf0132af4
f0111ca5:	e8 b2 ff fe ff       	call   f0101c5c <cprintf>
f0111caa:	83 c4 10             	add    $0x10,%esp
	char *args8[] = {"wum", "0xF0000000", "M"};
f0111cad:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0111cb3:	bb ac 2c 13 f0       	mov    $0xf0132cac,%ebx
f0111cb8:	ba 03 00 00 00       	mov    $0x3,%edx
f0111cbd:	89 c7                	mov    %eax,%edi
f0111cbf:	89 de                	mov    %ebx,%esi
f0111cc1:	89 d1                	mov    %edx,%ecx
f0111cc3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	ret = process_command(ARRAY_LENGTH(args8), args8);
f0111cc5:	83 ec 08             	sub    $0x8,%esp
f0111cc8:	8d 85 58 ff ff ff    	lea    -0xa8(%ebp),%eax
f0111cce:	50                   	push   %eax
f0111ccf:	6a 03                	push   $0x3
f0111cd1:	e8 1a 05 ff ff       	call   f01021f0 <process_command>
f0111cd6:	83 c4 10             	add    $0x10,%esp
f0111cd9:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (ret == getIndexOfCommand(args8[0]) && LIST_EMPTY(&foundCommands))
f0111cdc:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
f0111ce2:	83 ec 0c             	sub    $0xc,%esp
f0111ce5:	50                   	push   %eax
f0111ce6:	e8 dc fb ff ff       	call   f01118c7 <getIndexOfCommand>
f0111ceb:	83 c4 10             	add    $0x10,%esp
f0111cee:	3b 45 e0             	cmp    -0x20(%ebp),%eax
f0111cf1:	75 0f                	jne    f0111d02 <TestAutoCompleteCommand+0x3eb>
f0111cf3:	a1 6c 6d 85 f0       	mov    0xf0856d6c,%eax
f0111cf8:	85 c0                	test   %eax,%eax
f0111cfa:	75 06                	jne    f0111d02 <TestAutoCompleteCommand+0x3eb>
		eval += 10;
f0111cfc:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
f0111d00:	eb 10                	jmp    f0111d12 <TestAutoCompleteCommand+0x3fb>
	else
		cprintf("#8: WRONG - process_command return wrong value or foundCommands is not empty.\n");
f0111d02:	83 ec 0c             	sub    $0xc,%esp
f0111d05:	68 28 2b 13 f0       	push   $0xf0132b28
f0111d0a:	e8 4d ff fe ff       	call   f0101c5c <cprintf>
f0111d0f:	83 c4 10             	add    $0x10,%esp

//	cprintf("test autocomplete completed. Evaluation = %d%%\n", eval);
//	cprintf("=================\n\n");
	cprintf("[AUTO_GR@DING_PARTIAL]%d\n", eval);
f0111d12:	83 ec 08             	sub    $0x8,%esp
f0111d15:	ff 75 e4             	pushl  -0x1c(%ebp)
f0111d18:	68 77 2b 13 f0       	push   $0xf0132b77
f0111d1d:	e8 3a ff fe ff       	call   f0101c5c <cprintf>
f0111d22:	83 c4 10             	add    $0x10,%esp

	return 0;
f0111d25:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0111d2a:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0111d2d:	5b                   	pop    %ebx
f0111d2e:	5e                   	pop    %esi
f0111d2f:	5f                   	pop    %edi
f0111d30:	5d                   	pop    %ebp
f0111d31:	c3                   	ret    

f0111d32 <test_str2lower_function>:

int test_str2lower_function()
{
f0111d32:	55                   	push   %ebp
f0111d33:	89 e5                	mov    %esp,%ebp
f0111d35:	81 ec f8 02 00 00    	sub    $0x2f8,%esp
	cprintf("Automatic Testing of str2lower:\n");
f0111d3b:	83 ec 0c             	sub    $0xc,%esp
f0111d3e:	68 b8 2c 13 f0       	push   $0xf0132cb8
f0111d43:	e8 14 ff fe ff       	call   f0101c5c <cprintf>
f0111d48:	83 c4 10             	add    $0x10,%esp
	cprintf("========================\n");
f0111d4b:	83 ec 0c             	sub    $0xc,%esp
f0111d4e:	68 d9 2c 13 f0       	push   $0xf0132cd9
f0111d53:	e8 04 ff fe ff       	call   f0101c5c <cprintf>
f0111d58:	83 c4 10             	add    $0x10,%esp
	int i = 0;
f0111d5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	int eval = 0;
f0111d62:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	// CASE1: input string in lower case
	const char *src1 = "HelloWorld";
f0111d69:	c7 45 ec f3 2c 13 f0 	movl   $0xf0132cf3,-0x14(%ebp)
	char dst1[100];
	char *result = str2lower(dst1, src1);
f0111d70:	83 ec 08             	sub    $0x8,%esp
f0111d73:	ff 75 ec             	pushl  -0x14(%ebp)
f0111d76:	8d 85 68 ff ff ff    	lea    -0x98(%ebp),%eax
f0111d7c:	50                   	push   %eax
f0111d7d:	e8 91 95 00 00       	call   f011b313 <str2lower>
f0111d82:	83 c4 10             	add    $0x10,%esp
f0111d85:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int resultLength = strlen(result);
f0111d88:	83 ec 0c             	sub    $0xc,%esp
f0111d8b:	ff 75 e8             	pushl  -0x18(%ebp)
f0111d8e:	e8 e8 8d 00 00       	call   f011ab7b <strlen>
f0111d93:	83 c4 10             	add    $0x10,%esp
f0111d96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "helloworld") != 0 || resultLength != strlen(src1))
f0111d99:	83 ec 08             	sub    $0x8,%esp
f0111d9c:	68 fe 2c 13 f0       	push   $0xf0132cfe
f0111da1:	ff 75 e8             	pushl  -0x18(%ebp)
f0111da4:	e8 de 8e 00 00       	call   f011ac87 <strcmp>
f0111da9:	83 c4 10             	add    $0x10,%esp
f0111dac:	85 c0                	test   %eax,%eax
f0111dae:	75 13                	jne    f0111dc3 <test_str2lower_function+0x91>
f0111db0:	83 ec 0c             	sub    $0xc,%esp
f0111db3:	ff 75 ec             	pushl  -0x14(%ebp)
f0111db6:	e8 c0 8d 00 00       	call   f011ab7b <strlen>
f0111dbb:	83 c4 10             	add    $0x10,%esp
f0111dbe:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111dc1:	74 15                	je     f0111dd8 <test_str2lower_function+0xa6>
		cprintf("str2lower #1: WRONG - str2lower return wrong value or length. Expected \"helloworld\", Actual \"%s\"\n", result);
f0111dc3:	83 ec 08             	sub    $0x8,%esp
f0111dc6:	ff 75 e8             	pushl  -0x18(%ebp)
f0111dc9:	68 0c 2d 13 f0       	push   $0xf0132d0c
f0111dce:	e8 89 fe fe ff       	call   f0101c5c <cprintf>
f0111dd3:	83 c4 10             	add    $0x10,%esp
f0111dd6:	eb 04                	jmp    f0111ddc <test_str2lower_function+0xaa>
	else
		eval += 10;
f0111dd8:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE2: input string is empty
	const char *src2 = "";
f0111ddc:	c7 45 e0 6e 2d 13 f0 	movl   $0xf0132d6e,-0x20(%ebp)
	char dst2[100];
	result = str2lower(dst2, src2);
f0111de3:	83 ec 08             	sub    $0x8,%esp
f0111de6:	ff 75 e0             	pushl  -0x20(%ebp)
f0111de9:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0111def:	50                   	push   %eax
f0111df0:	e8 1e 95 00 00       	call   f011b313 <str2lower>
f0111df5:	83 c4 10             	add    $0x10,%esp
f0111df8:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111dfb:	83 ec 0c             	sub    $0xc,%esp
f0111dfe:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e01:	e8 75 8d 00 00       	call   f011ab7b <strlen>
f0111e06:	83 c4 10             	add    $0x10,%esp
f0111e09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "") != 0 || resultLength != strlen(src2))
f0111e0c:	83 ec 08             	sub    $0x8,%esp
f0111e0f:	68 6e 2d 13 f0       	push   $0xf0132d6e
f0111e14:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e17:	e8 6b 8e 00 00       	call   f011ac87 <strcmp>
f0111e1c:	83 c4 10             	add    $0x10,%esp
f0111e1f:	85 c0                	test   %eax,%eax
f0111e21:	75 13                	jne    f0111e36 <test_str2lower_function+0x104>
f0111e23:	83 ec 0c             	sub    $0xc,%esp
f0111e26:	ff 75 e0             	pushl  -0x20(%ebp)
f0111e29:	e8 4d 8d 00 00       	call   f011ab7b <strlen>
f0111e2e:	83 c4 10             	add    $0x10,%esp
f0111e31:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111e34:	74 15                	je     f0111e4b <test_str2lower_function+0x119>
		cprintf("str2lower #2: WRONG - str2lower return wrong value or length. Expected \"\", Actual \"%s\"\n", result);
f0111e36:	83 ec 08             	sub    $0x8,%esp
f0111e39:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e3c:	68 70 2d 13 f0       	push   $0xf0132d70
f0111e41:	e8 16 fe fe ff       	call   f0101c5c <cprintf>
f0111e46:	83 c4 10             	add    $0x10,%esp
f0111e49:	eb 04                	jmp    f0111e4f <test_str2lower_function+0x11d>
	else
		eval += 10;
f0111e4b:	83 45 f4 0a          	addl   $0xa,-0xc(%ebp)

	// CASE3: input string is Only special characters
	const char *src3 = "!@#$%%^&*()";
f0111e4f:	c7 45 dc c8 2d 13 f0 	movl   $0xf0132dc8,-0x24(%ebp)
	char dst3[100];
	result = str2lower(dst3, src3);
f0111e56:	83 ec 08             	sub    $0x8,%esp
f0111e59:	ff 75 dc             	pushl  -0x24(%ebp)
f0111e5c:	8d 85 a0 fe ff ff    	lea    -0x160(%ebp),%eax
f0111e62:	50                   	push   %eax
f0111e63:	e8 ab 94 00 00       	call   f011b313 <str2lower>
f0111e68:	83 c4 10             	add    $0x10,%esp
f0111e6b:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111e6e:	83 ec 0c             	sub    $0xc,%esp
f0111e71:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e74:	e8 02 8d 00 00       	call   f011ab7b <strlen>
f0111e79:	83 c4 10             	add    $0x10,%esp
f0111e7c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "!@#$%%^&*()") != 0 || resultLength != strlen(src3))
f0111e7f:	83 ec 08             	sub    $0x8,%esp
f0111e82:	68 c8 2d 13 f0       	push   $0xf0132dc8
f0111e87:	ff 75 e8             	pushl  -0x18(%ebp)
f0111e8a:	e8 f8 8d 00 00       	call   f011ac87 <strcmp>
f0111e8f:	83 c4 10             	add    $0x10,%esp
f0111e92:	85 c0                	test   %eax,%eax
f0111e94:	75 13                	jne    f0111ea9 <test_str2lower_function+0x177>
f0111e96:	83 ec 0c             	sub    $0xc,%esp
f0111e99:	ff 75 dc             	pushl  -0x24(%ebp)
f0111e9c:	e8 da 8c 00 00       	call   f011ab7b <strlen>
f0111ea1:	83 c4 10             	add    $0x10,%esp
f0111ea4:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111ea7:	74 15                	je     f0111ebe <test_str2lower_function+0x18c>
		cprintf("str2lower #3: WRONG - str2lower return wrong value or length. Expected \"!@#$%%^&*()\", Actual \"%s\"\n", result);
f0111ea9:	83 ec 08             	sub    $0x8,%esp
f0111eac:	ff 75 e8             	pushl  -0x18(%ebp)
f0111eaf:	68 d4 2d 13 f0       	push   $0xf0132dd4
f0111eb4:	e8 a3 fd fe ff       	call   f0101c5c <cprintf>
f0111eb9:	83 c4 10             	add    $0x10,%esp
f0111ebc:	eb 04                	jmp    f0111ec2 <test_str2lower_function+0x190>
	else
		eval += 15;
f0111ebe:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE4: input string is only numbers
	const char *src4 = "1234567890";
f0111ec2:	c7 45 d8 37 2e 13 f0 	movl   $0xf0132e37,-0x28(%ebp)
	char dst4[100];
	result = str2lower(dst4, src4);
f0111ec9:	83 ec 08             	sub    $0x8,%esp
f0111ecc:	ff 75 d8             	pushl  -0x28(%ebp)
f0111ecf:	8d 85 3c fe ff ff    	lea    -0x1c4(%ebp),%eax
f0111ed5:	50                   	push   %eax
f0111ed6:	e8 38 94 00 00       	call   f011b313 <str2lower>
f0111edb:	83 c4 10             	add    $0x10,%esp
f0111ede:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111ee1:	83 ec 0c             	sub    $0xc,%esp
f0111ee4:	ff 75 e8             	pushl  -0x18(%ebp)
f0111ee7:	e8 8f 8c 00 00       	call   f011ab7b <strlen>
f0111eec:	83 c4 10             	add    $0x10,%esp
f0111eef:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "1234567890") != 0 || resultLength != strlen(src4))
f0111ef2:	83 ec 08             	sub    $0x8,%esp
f0111ef5:	68 37 2e 13 f0       	push   $0xf0132e37
f0111efa:	ff 75 e8             	pushl  -0x18(%ebp)
f0111efd:	e8 85 8d 00 00       	call   f011ac87 <strcmp>
f0111f02:	83 c4 10             	add    $0x10,%esp
f0111f05:	85 c0                	test   %eax,%eax
f0111f07:	75 13                	jne    f0111f1c <test_str2lower_function+0x1ea>
f0111f09:	83 ec 0c             	sub    $0xc,%esp
f0111f0c:	ff 75 d8             	pushl  -0x28(%ebp)
f0111f0f:	e8 67 8c 00 00       	call   f011ab7b <strlen>
f0111f14:	83 c4 10             	add    $0x10,%esp
f0111f17:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f1a:	74 15                	je     f0111f31 <test_str2lower_function+0x1ff>
		cprintf("str2lower #4: WRONG - str2lower return wrong value or length. Expected \"1234567890\", Actual \"%s\"\n", result);
f0111f1c:	83 ec 08             	sub    $0x8,%esp
f0111f1f:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f22:	68 44 2e 13 f0       	push   $0xf0132e44
f0111f27:	e8 30 fd fe ff       	call   f0101c5c <cprintf>
f0111f2c:	83 c4 10             	add    $0x10,%esp
f0111f2f:	eb 04                	jmp    f0111f35 <test_str2lower_function+0x203>
	else
		eval += 15;
f0111f31:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE5: input string contains invalid characters
	const char *src5 = "Hello!@#$%%^&*()World";
f0111f35:	c7 45 d4 a6 2e 13 f0 	movl   $0xf0132ea6,-0x2c(%ebp)
	char dst5[100];
	result = str2lower(dst5, src5);
f0111f3c:	83 ec 08             	sub    $0x8,%esp
f0111f3f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f42:	8d 85 d8 fd ff ff    	lea    -0x228(%ebp),%eax
f0111f48:	50                   	push   %eax
f0111f49:	e8 c5 93 00 00       	call   f011b313 <str2lower>
f0111f4e:	83 c4 10             	add    $0x10,%esp
f0111f51:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111f54:	83 ec 0c             	sub    $0xc,%esp
f0111f57:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f5a:	e8 1c 8c 00 00       	call   f011ab7b <strlen>
f0111f5f:	83 c4 10             	add    $0x10,%esp
f0111f62:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello!@#$%%^&*()world") != 0 || resultLength != strlen(src5))
f0111f65:	83 ec 08             	sub    $0x8,%esp
f0111f68:	68 bc 2e 13 f0       	push   $0xf0132ebc
f0111f6d:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f70:	e8 12 8d 00 00       	call   f011ac87 <strcmp>
f0111f75:	83 c4 10             	add    $0x10,%esp
f0111f78:	85 c0                	test   %eax,%eax
f0111f7a:	75 13                	jne    f0111f8f <test_str2lower_function+0x25d>
f0111f7c:	83 ec 0c             	sub    $0xc,%esp
f0111f7f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0111f82:	e8 f4 8b 00 00       	call   f011ab7b <strlen>
f0111f87:	83 c4 10             	add    $0x10,%esp
f0111f8a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0111f8d:	74 15                	je     f0111fa4 <test_str2lower_function+0x272>
		cprintf("str2lower #5: WRONG - str2lower return wrong value or length. Expected \"hello!@#$%%^&*()world\", Actual \"%s\"\n", result);
f0111f8f:	83 ec 08             	sub    $0x8,%esp
f0111f92:	ff 75 e8             	pushl  -0x18(%ebp)
f0111f95:	68 d4 2e 13 f0       	push   $0xf0132ed4
f0111f9a:	e8 bd fc fe ff       	call   f0101c5c <cprintf>
f0111f9f:	83 c4 10             	add    $0x10,%esp
f0111fa2:	eb 04                	jmp    f0111fa8 <test_str2lower_function+0x276>
	else
		eval += 15;
f0111fa4:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE6: input string contains characters with white-space characters
	const char *src6 = "Hello World";
f0111fa8:	c7 45 d0 41 2f 13 f0 	movl   $0xf0132f41,-0x30(%ebp)
	char dst6[100];
	result = str2lower(dst6, src6);
f0111faf:	83 ec 08             	sub    $0x8,%esp
f0111fb2:	ff 75 d0             	pushl  -0x30(%ebp)
f0111fb5:	8d 85 74 fd ff ff    	lea    -0x28c(%ebp),%eax
f0111fbb:	50                   	push   %eax
f0111fbc:	e8 52 93 00 00       	call   f011b313 <str2lower>
f0111fc1:	83 c4 10             	add    $0x10,%esp
f0111fc4:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f0111fc7:	83 ec 0c             	sub    $0xc,%esp
f0111fca:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fcd:	e8 a9 8b 00 00       	call   f011ab7b <strlen>
f0111fd2:	83 c4 10             	add    $0x10,%esp
f0111fd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world") != 0 || resultLength != strlen(src6))
f0111fd8:	83 ec 08             	sub    $0x8,%esp
f0111fdb:	68 4d 2f 13 f0       	push   $0xf0132f4d
f0111fe0:	ff 75 e8             	pushl  -0x18(%ebp)
f0111fe3:	e8 9f 8c 00 00       	call   f011ac87 <strcmp>
f0111fe8:	83 c4 10             	add    $0x10,%esp
f0111feb:	85 c0                	test   %eax,%eax
f0111fed:	75 13                	jne    f0112002 <test_str2lower_function+0x2d0>
f0111fef:	83 ec 0c             	sub    $0xc,%esp
f0111ff2:	ff 75 d0             	pushl  -0x30(%ebp)
f0111ff5:	e8 81 8b 00 00       	call   f011ab7b <strlen>
f0111ffa:	83 c4 10             	add    $0x10,%esp
f0111ffd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112000:	74 15                	je     f0112017 <test_str2lower_function+0x2e5>
		cprintf("str2lower #6: WRONG - str2lower return wrong value or length. Expected \"hello world\", Actual \"%s\"\n", result);
f0112002:	83 ec 08             	sub    $0x8,%esp
f0112005:	ff 75 e8             	pushl  -0x18(%ebp)
f0112008:	68 5c 2f 13 f0       	push   $0xf0132f5c
f011200d:	e8 4a fc fe ff       	call   f0101c5c <cprintf>
f0112012:	83 c4 10             	add    $0x10,%esp
f0112015:	eb 04                	jmp    f011201b <test_str2lower_function+0x2e9>
	else
		eval += 15;
f0112017:	83 45 f4 0f          	addl   $0xf,-0xc(%ebp)

	// CASE7: input string contains valid characters separated by _
	const char *src7 = "Hello WORLD String_2_LOWeR";
f011201b:	c7 45 cc bf 2f 13 f0 	movl   $0xf0132fbf,-0x34(%ebp)
	char dst7[100];
	result = str2lower(dst7, src7);
f0112022:	83 ec 08             	sub    $0x8,%esp
f0112025:	ff 75 cc             	pushl  -0x34(%ebp)
f0112028:	8d 85 10 fd ff ff    	lea    -0x2f0(%ebp),%eax
f011202e:	50                   	push   %eax
f011202f:	e8 df 92 00 00       	call   f011b313 <str2lower>
f0112034:	83 c4 10             	add    $0x10,%esp
f0112037:	89 45 e8             	mov    %eax,-0x18(%ebp)
	resultLength = strlen(result);
f011203a:	83 ec 0c             	sub    $0xc,%esp
f011203d:	ff 75 e8             	pushl  -0x18(%ebp)
f0112040:	e8 36 8b 00 00       	call   f011ab7b <strlen>
f0112045:	83 c4 10             	add    $0x10,%esp
f0112048:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if (strcmp(result, "hello world string_2_lower") != 0 || resultLength != strlen(src7))
f011204b:	83 ec 08             	sub    $0x8,%esp
f011204e:	68 da 2f 13 f0       	push   $0xf0132fda
f0112053:	ff 75 e8             	pushl  -0x18(%ebp)
f0112056:	e8 2c 8c 00 00       	call   f011ac87 <strcmp>
f011205b:	83 c4 10             	add    $0x10,%esp
f011205e:	85 c0                	test   %eax,%eax
f0112060:	75 13                	jne    f0112075 <test_str2lower_function+0x343>
f0112062:	83 ec 0c             	sub    $0xc,%esp
f0112065:	ff 75 cc             	pushl  -0x34(%ebp)
f0112068:	e8 0e 8b 00 00       	call   f011ab7b <strlen>
f011206d:	83 c4 10             	add    $0x10,%esp
f0112070:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0112073:	74 15                	je     f011208a <test_str2lower_function+0x358>
		cprintf("str2lower #7: WRONG - str2lower return wrong value or length. Expected \"hello world string_2_lower\", Actual \"%s\"\n", result);
f0112075:	83 ec 08             	sub    $0x8,%esp
f0112078:	ff 75 e8             	pushl  -0x18(%ebp)
f011207b:	68 f8 2f 13 f0       	push   $0xf0132ff8
f0112080:	e8 d7 fb fe ff       	call   f0101c5c <cprintf>
f0112085:	83 c4 10             	add    $0x10,%esp
f0112088:	eb 04                	jmp    f011208e <test_str2lower_function+0x35c>
	else
		eval += 20;
f011208a:	83 45 f4 14          	addl   $0x14,-0xc(%ebp)

	cprintf("Test str2lower completed. Evaluation = %d%%\n", eval);
f011208e:	83 ec 08             	sub    $0x8,%esp
f0112091:	ff 75 f4             	pushl  -0xc(%ebp)
f0112094:	68 6c 30 13 f0       	push   $0xf013306c
f0112099:	e8 be fb fe ff       	call   f0101c5c <cprintf>
f011209e:	83 c4 10             	add    $0x10,%esp
	cprintf("=================\n\n");
f01120a1:	83 ec 0c             	sub    $0xc,%esp
f01120a4:	68 99 30 13 f0       	push   $0xf0133099
f01120a9:	e8 ae fb fe ff       	call   f0101c5c <cprintf>
f01120ae:	83 c4 10             	add    $0x10,%esp
	return 0;
f01120b1:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01120b6:	c9                   	leave  
f01120b7:	c3                   	ret    

f01120b8 <test_pt_set_page_permissions>:

//=====================================
// 1) TEST SET/CLEAR PAGE PERMISSIONS:
//=====================================
int test_pt_set_page_permissions()
{
f01120b8:	55                   	push   %ebp
f01120b9:	89 e5                	mov    %esp,%ebp
f01120bb:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check setting a permission
	uint32 va = 0xEF800000;
f01120be:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f01120c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f01120cc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120d3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01120d8:	ff 75 ec             	pushl  -0x14(%ebp)
f01120db:	ff 75 f0             	pushl  -0x10(%ebp)
f01120de:	ff 75 f4             	pushl  -0xc(%ebp)
f01120e1:	50                   	push   %eax
f01120e2:	e8 18 7c ff ff       	call   f0109cff <pt_set_page_permissions>
f01120e7:	83 c4 10             	add    $0x10,%esp
	int ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01120ea:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01120ef:	ff 75 ec             	pushl  -0x14(%ebp)
f01120f2:	ff 75 f0             	pushl  -0x10(%ebp)
f01120f5:	ff 75 f4             	pushl  -0xc(%ebp)
f01120f8:	50                   	push   %eax
f01120f9:	e8 02 4f 00 00       	call   f0117000 <CP>
f01120fe:	83 c4 10             	add    $0x10,%esp
f0112101:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112104:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112108:	74 17                	je     f0112121 <test_pt_set_page_permissions+0x69>
	{
		panic("[EVAL] #1 Set Permission Failed.\n");
f011210a:	83 ec 04             	sub    $0x4,%esp
f011210d:	68 b0 30 13 f0       	push   $0xf01330b0
f0112112:	68 2c 01 00 00       	push   $0x12c
f0112117:	68 d2 30 13 f0       	push   $0xf01330d2
f011211c:	e8 8e ee fe ff       	call   f0100faf <_panic>
	}

	//Case 2: Check setting MORE THAN ONE permission
	va = 0xEF801000;
f0112121:	c7 45 f4 00 10 80 ef 	movl   $0xef801000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER;
f0112128:	c7 45 f0 44 00 00 00 	movl   $0x44,-0x10(%ebp)
	permissions_to_clear = 0;
f011212f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112136:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011213b:	ff 75 ec             	pushl  -0x14(%ebp)
f011213e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112141:	ff 75 f4             	pushl  -0xc(%ebp)
f0112144:	50                   	push   %eax
f0112145:	e8 b5 7b ff ff       	call   f0109cff <pt_set_page_permissions>
f011214a:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011214d:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112152:	ff 75 ec             	pushl  -0x14(%ebp)
f0112155:	ff 75 f0             	pushl  -0x10(%ebp)
f0112158:	ff 75 f4             	pushl  -0xc(%ebp)
f011215b:	50                   	push   %eax
f011215c:	e8 9f 4e 00 00       	call   f0117000 <CP>
f0112161:	83 c4 10             	add    $0x10,%esp
f0112164:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112167:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f011216b:	74 17                	je     f0112184 <test_pt_set_page_permissions+0xcc>
	{
		panic("[EVAL] #2 Set Permission Failed.\n");
f011216d:	83 ec 04             	sub    $0x4,%esp
f0112170:	68 f0 30 13 f0       	push   $0xf01330f0
f0112175:	68 38 01 00 00       	push   $0x138
f011217a:	68 d2 30 13 f0       	push   $0xf01330d2
f011217f:	e8 2b ee fe ff       	call   f0100faf <_panic>
	}

	va = 0xEF800000;
f0112184:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = PERM_MODIFIED|PERM_USER|PERM_USED|PERM_PRESENT;
f011218b:	c7 45 f0 65 00 00 00 	movl   $0x65,-0x10(%ebp)
	permissions_to_clear = 0;
f0112192:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112199:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011219e:	ff 75 ec             	pushl  -0x14(%ebp)
f01121a1:	ff 75 f0             	pushl  -0x10(%ebp)
f01121a4:	ff 75 f4             	pushl  -0xc(%ebp)
f01121a7:	50                   	push   %eax
f01121a8:	e8 52 7b ff ff       	call   f0109cff <pt_set_page_permissions>
f01121ad:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121b0:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01121b5:	ff 75 ec             	pushl  -0x14(%ebp)
f01121b8:	ff 75 f0             	pushl  -0x10(%ebp)
f01121bb:	ff 75 f4             	pushl  -0xc(%ebp)
f01121be:	50                   	push   %eax
f01121bf:	e8 3c 4e 00 00       	call   f0117000 <CP>
f01121c4:	83 c4 10             	add    $0x10,%esp
f01121c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01121ca:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01121ce:	74 17                	je     f01121e7 <test_pt_set_page_permissions+0x12f>
	{
		panic("[EVAL] #3 Set Permission Failed.\n");
f01121d0:	83 ec 04             	sub    $0x4,%esp
f01121d3:	68 14 31 13 f0       	push   $0xf0133114
f01121d8:	68 43 01 00 00       	push   $0x143
f01121dd:	68 d2 30 13 f0       	push   $0xf01330d2
f01121e2:	e8 c8 ed fe ff       	call   f0100faf <_panic>
	}

	//Case 3: Check clearing a permission
	va = 0xF0000000;
f01121e7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	permissions_to_set = 0;
f01121ee:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_PRESENT;
f01121f5:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01121fc:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112201:	ff 75 ec             	pushl  -0x14(%ebp)
f0112204:	ff 75 f0             	pushl  -0x10(%ebp)
f0112207:	ff 75 f4             	pushl  -0xc(%ebp)
f011220a:	50                   	push   %eax
f011220b:	e8 ef 7a ff ff       	call   f0109cff <pt_set_page_permissions>
f0112210:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112213:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112218:	ff 75 ec             	pushl  -0x14(%ebp)
f011221b:	ff 75 f0             	pushl  -0x10(%ebp)
f011221e:	ff 75 f4             	pushl  -0xc(%ebp)
f0112221:	50                   	push   %eax
f0112222:	e8 d9 4d 00 00       	call   f0117000 <CP>
f0112227:	83 c4 10             	add    $0x10,%esp
f011222a:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f011222d:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112231:	74 17                	je     f011224a <test_pt_set_page_permissions+0x192>
	{
		panic("[EVAL] #4 Clear Permission Failed.\n");
f0112233:	83 ec 04             	sub    $0x4,%esp
f0112236:	68 38 31 13 f0       	push   $0xf0133138
f011223b:	68 4f 01 00 00       	push   $0x14f
f0112240:	68 d2 30 13 f0       	push   $0xf01330d2
f0112245:	e8 65 ed fe ff       	call   f0100faf <_panic>
	}

	//Case 4: Check clearing MORE THAN ONE permission
	va = 0xEF800000;
f011224a:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	permissions_to_set = 0;
f0112251:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	permissions_to_clear = PERM_MODIFIED|PERM_USER;
f0112258:	c7 45 ec 44 00 00 00 	movl   $0x44,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f011225f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112264:	ff 75 ec             	pushl  -0x14(%ebp)
f0112267:	ff 75 f0             	pushl  -0x10(%ebp)
f011226a:	ff 75 f4             	pushl  -0xc(%ebp)
f011226d:	50                   	push   %eax
f011226e:	e8 8c 7a ff ff       	call   f0109cff <pt_set_page_permissions>
f0112273:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112276:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011227b:	ff 75 ec             	pushl  -0x14(%ebp)
f011227e:	ff 75 f0             	pushl  -0x10(%ebp)
f0112281:	ff 75 f4             	pushl  -0xc(%ebp)
f0112284:	50                   	push   %eax
f0112285:	e8 76 4d 00 00       	call   f0117000 <CP>
f011228a:	83 c4 10             	add    $0x10,%esp
f011228d:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f0112290:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f0112294:	74 17                	je     f01122ad <test_pt_set_page_permissions+0x1f5>
	{
		panic("[EVAL] #5 Clear Permission Failed.\n");
f0112296:	83 ec 04             	sub    $0x4,%esp
f0112299:	68 5c 31 13 f0       	push   $0xf013315c
f011229e:	68 5b 01 00 00       	push   $0x15b
f01122a3:	68 d2 30 13 f0       	push   $0xf01330d2
f01122a8:	e8 02 ed fe ff       	call   f0100faf <_panic>
	}

	//Case 5: Check settiing & clearing MORE THAN ONE permission together
	va = 0xF0001000;
f01122ad:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	permissions_to_set = PERM_USER|PERM_BUFFERED;
f01122b4:	c7 45 f0 04 02 00 00 	movl   $0x204,-0x10(%ebp)
	permissions_to_clear = PERM_WRITEABLE|PERM_USED|PERM_MODIFIED;
f01122bb:	c7 45 ec 62 00 00 00 	movl   $0x62,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01122c2:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01122c7:	ff 75 ec             	pushl  -0x14(%ebp)
f01122ca:	ff 75 f0             	pushl  -0x10(%ebp)
f01122cd:	ff 75 f4             	pushl  -0xc(%ebp)
f01122d0:	50                   	push   %eax
f01122d1:	e8 29 7a ff ff       	call   f0109cff <pt_set_page_permissions>
f01122d6:	83 c4 10             	add    $0x10,%esp

	ret = CP(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f01122d9:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01122de:	ff 75 ec             	pushl  -0x14(%ebp)
f01122e1:	ff 75 f0             	pushl  -0x10(%ebp)
f01122e4:	ff 75 f4             	pushl  -0xc(%ebp)
f01122e7:	50                   	push   %eax
f01122e8:	e8 13 4d 00 00       	call   f0117000 <CP>
f01122ed:	83 c4 10             	add    $0x10,%esp
f01122f0:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if (ret != 1)
f01122f3:	83 7d e8 01          	cmpl   $0x1,-0x18(%ebp)
f01122f7:	74 17                	je     f0112310 <test_pt_set_page_permissions+0x258>
	{
		panic("[EVAL] #6 Set & Clear Permission Failed.\n");
f01122f9:	83 ec 04             	sub    $0x4,%esp
f01122fc:	68 80 31 13 f0       	push   $0xf0133180
f0112301:	68 67 01 00 00       	push   $0x167
f0112306:	68 d2 30 13 f0       	push   $0xf01330d2
f011230b:	e8 9f ec fe ff       	call   f0100faf <_panic>
	}

	cprintf("Congratulations!! test pt_set&clear_page_permissions completed successfully.\n");
f0112310:	83 ec 0c             	sub    $0xc,%esp
f0112313:	68 ac 31 13 f0       	push   $0xf01331ac
f0112318:	e8 3f f9 fe ff       	call   f0101c5c <cprintf>
f011231d:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112320:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0112325:	c9                   	leave  
f0112326:	c3                   	ret    

f0112327 <test_pt_set_page_permissions_invalid_va>:

int test_pt_set_page_permissions_invalid_va()
{
f0112327:	55                   	push   %ebp
f0112328:	89 e5                	mov    %esp,%ebp
f011232a:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x0;
f011232d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 permissions_to_set = PERM_PRESENT;
f0112334:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
	uint32 permissions_to_clear = 0;
f011233b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	pt_set_page_permissions(ptr_page_directory, va, permissions_to_set, permissions_to_clear);
f0112342:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112347:	ff 75 ec             	pushl  -0x14(%ebp)
f011234a:	ff 75 f0             	pushl  -0x10(%ebp)
f011234d:	ff 75 f4             	pushl  -0xc(%ebp)
f0112350:	50                   	push   %eax
f0112351:	e8 a9 79 ff ff       	call   f0109cff <pt_set_page_permissions>
f0112356:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling setting permissions of an invalid virtual address with non existing page table.");
f0112359:	83 ec 04             	sub    $0x4,%esp
f011235c:	68 fc 31 13 f0       	push   $0xf01331fc
f0112361:	68 74 01 00 00       	push   $0x174
f0112366:	68 d2 30 13 f0       	push   $0xf01330d2
f011236b:	e8 3f ec fe ff       	call   f0100faf <_panic>

f0112370 <test_pt_get_page_permissions>:

//=====================================
// 2) TEST GET PAGE PERMISSIONS:
//=====================================
int test_pt_get_page_permissions()
{
f0112370:	55                   	push   %ebp
f0112371:	89 e5                	mov    %esp,%ebp
f0112373:	83 ec 18             	sub    $0x18,%esp
	//Case 1: Check getting a permission of a non existing VA with NO table
	uint32 va = 0xeebfe000;
f0112376:	c7 45 f4 00 e0 bf ee 	movl   $0xeebfe000,-0xc(%ebp)
	int ret = pt_get_page_permissions(ptr_page_directory, va);
f011237d:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112382:	83 ec 08             	sub    $0x8,%esp
f0112385:	ff 75 f4             	pushl  -0xc(%ebp)
f0112388:	50                   	push   %eax
f0112389:	e8 36 7a ff ff       	call   f0109dc4 <pt_get_page_permissions>
f011238e:	83 c4 10             	add    $0x10,%esp
f0112391:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != -1)
f0112394:	83 7d f0 ff          	cmpl   $0xffffffff,-0x10(%ebp)
f0112398:	74 17                	je     f01123b1 <test_pt_get_page_permissions+0x41>
	{
		panic("[EVAL] #1 Get Permission Failed.\n");
f011239a:	83 ec 04             	sub    $0x4,%esp
f011239d:	68 98 32 13 f0       	push   $0xf0133298
f01123a2:	68 82 01 00 00       	push   $0x182
f01123a7:	68 d2 30 13 f0       	push   $0xf01330d2
f01123ac:	e8 fe eb fe ff       	call   f0100faf <_panic>
	}

	//Case 2: Check getting a permission of a non existing VA with an existing table
	va = 0xEF800000;
f01123b1:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01123b8:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01123bd:	83 ec 08             	sub    $0x8,%esp
f01123c0:	ff 75 f4             	pushl  -0xc(%ebp)
f01123c3:	50                   	push   %eax
f01123c4:	e8 fb 79 ff ff       	call   f0109dc4 <pt_get_page_permissions>
f01123c9:	83 c4 10             	add    $0x10,%esp
f01123cc:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 0)
f01123cf:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f01123d3:	74 17                	je     f01123ec <test_pt_get_page_permissions+0x7c>
	{
		panic("[EVAL] #2 Get Permission Failed.\n");
f01123d5:	83 ec 04             	sub    $0x4,%esp
f01123d8:	68 bc 32 13 f0       	push   $0xf01332bc
f01123dd:	68 8a 01 00 00       	push   $0x18a
f01123e2:	68 d2 30 13 f0       	push   $0xf01330d2
f01123e7:	e8 c3 eb fe ff       	call   f0100faf <_panic>
	}

	//Case 3: Check getting a permission of an existing VA with an existing table
	va = 0xf0000000;
f01123ec:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f01123f3:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01123f8:	83 ec 08             	sub    $0x8,%esp
f01123fb:	ff 75 f4             	pushl  -0xc(%ebp)
f01123fe:	50                   	push   %eax
f01123ff:	e8 c0 79 ff ff       	call   f0109dc4 <pt_get_page_permissions>
f0112404:	83 c4 10             	add    $0x10,%esp
f0112407:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f011240a:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f011240e:	74 17                	je     f0112427 <test_pt_get_page_permissions+0xb7>
	{
		panic("[EVAL] #3 Get Permission Failed.\n");
f0112410:	83 ec 04             	sub    $0x4,%esp
f0112413:	68 e0 32 13 f0       	push   $0xf01332e0
f0112418:	68 92 01 00 00       	push   $0x192
f011241d:	68 d2 30 13 f0       	push   $0xf01330d2
f0112422:	e8 88 eb fe ff       	call   f0100faf <_panic>
	}

	va = 0xF1000000;
f0112427:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f011242e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112433:	83 ec 08             	sub    $0x8,%esp
f0112436:	ff 75 f4             	pushl  -0xc(%ebp)
f0112439:	50                   	push   %eax
f011243a:	e8 85 79 ff ff       	call   f0109dc4 <pt_get_page_permissions>
f011243f:	83 c4 10             	add    $0x10,%esp
f0112442:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 3)
f0112445:	83 7d f0 03          	cmpl   $0x3,-0x10(%ebp)
f0112449:	74 17                	je     f0112462 <test_pt_get_page_permissions+0xf2>
	{
		panic("[EVAL] #4 Get Permission Failed.\n");
f011244b:	83 ec 04             	sub    $0x4,%esp
f011244e:	68 04 33 13 f0       	push   $0xf0133304
f0112453:	68 99 01 00 00       	push   $0x199
f0112458:	68 d2 30 13 f0       	push   $0xf01330d2
f011245d:	e8 4d eb fe ff       	call   f0100faf <_panic>
	}

	va = 0xF0001000;
f0112462:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	ret = pt_get_page_permissions(ptr_page_directory, va);
f0112469:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011246e:	83 ec 08             	sub    $0x8,%esp
f0112471:	ff 75 f4             	pushl  -0xc(%ebp)
f0112474:	50                   	push   %eax
f0112475:	e8 4a 79 ff ff       	call   f0109dc4 <pt_get_page_permissions>
f011247a:	83 c4 10             	add    $0x10,%esp
f011247d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 99)
f0112480:	83 7d f0 63          	cmpl   $0x63,-0x10(%ebp)
f0112484:	74 17                	je     f011249d <test_pt_get_page_permissions+0x12d>
	{
		panic("[EVAL] #5 Get Permission Failed.\n");
f0112486:	83 ec 04             	sub    $0x4,%esp
f0112489:	68 28 33 13 f0       	push   $0xf0133328
f011248e:	68 a0 01 00 00       	push   $0x1a0
f0112493:	68 d2 30 13 f0       	push   $0xf01330d2
f0112498:	e8 12 eb fe ff       	call   f0100faf <_panic>
	}
	cprintf("Congratulations!! test pt_get_page_permissions completed successfully.\n");
f011249d:	83 ec 0c             	sub    $0xc,%esp
f01124a0:	68 4c 33 13 f0       	push   $0xf013334c
f01124a5:	e8 b2 f7 fe ff       	call   f0101c5c <cprintf>
f01124aa:	83 c4 10             	add    $0x10,%esp
	return 0;
f01124ad:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01124b2:	c9                   	leave  
f01124b3:	c3                   	ret    

f01124b4 <test_pt_clear_page_table_entry>:

//=====================================
// 3) TEST CLEAR PAGE TABLE ENTRY:
//=====================================
int test_pt_clear_page_table_entry()
{
f01124b4:	55                   	push   %ebp
f01124b5:	89 e5                	mov    %esp,%ebp
f01124b7:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0xF1000000;
f01124ba:	c7 45 f4 00 00 00 f1 	movl   $0xf1000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01124c1:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01124c6:	83 ec 08             	sub    $0x8,%esp
f01124c9:	ff 75 f4             	pushl  -0xc(%ebp)
f01124cc:	50                   	push   %eax
f01124cd:	e8 0c 79 ff ff       	call   f0109dde <pt_clear_page_table_entry>
f01124d2:	83 c4 10             	add    $0x10,%esp
	int ret = CE(ptr_page_directory, va);
f01124d5:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01124da:	83 ec 08             	sub    $0x8,%esp
f01124dd:	ff 75 f4             	pushl  -0xc(%ebp)
f01124e0:	50                   	push   %eax
f01124e1:	e8 76 4a 00 00       	call   f0116f5c <CE>
f01124e6:	83 c4 10             	add    $0x10,%esp
f01124e9:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01124ec:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01124f0:	74 17                	je     f0112509 <test_pt_clear_page_table_entry+0x55>
	{
		panic("[EVAL] #1 Clear Page Table Entry Failed.\n");
f01124f2:	83 ec 04             	sub    $0x4,%esp
f01124f5:	68 94 33 13 f0       	push   $0xf0133394
f01124fa:	68 b0 01 00 00       	push   $0x1b0
f01124ff:	68 d2 30 13 f0       	push   $0xf01330d2
f0112504:	e8 a6 ea fe ff       	call   f0100faf <_panic>
	}

	va = 0xF0001000;
f0112509:	c7 45 f4 00 10 00 f0 	movl   $0xf0001000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f0112510:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112515:	83 ec 08             	sub    $0x8,%esp
f0112518:	ff 75 f4             	pushl  -0xc(%ebp)
f011251b:	50                   	push   %eax
f011251c:	e8 bd 78 ff ff       	call   f0109dde <pt_clear_page_table_entry>
f0112521:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112524:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112529:	83 ec 08             	sub    $0x8,%esp
f011252c:	ff 75 f4             	pushl  -0xc(%ebp)
f011252f:	50                   	push   %eax
f0112530:	e8 27 4a 00 00       	call   f0116f5c <CE>
f0112535:	83 c4 10             	add    $0x10,%esp
f0112538:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011253b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011253f:	74 17                	je     f0112558 <test_pt_clear_page_table_entry+0xa4>
	{
		panic("[EVAL] #2 Clear Page Table Entry Failed.\n");
f0112541:	83 ec 04             	sub    $0x4,%esp
f0112544:	68 c0 33 13 f0       	push   $0xf01333c0
f0112549:	68 b8 01 00 00       	push   $0x1b8
f011254e:	68 d2 30 13 f0       	push   $0xf01330d2
f0112553:	e8 57 ea fe ff       	call   f0100faf <_panic>
	}

	va = 0xEF800000;
f0112558:	c7 45 f4 00 00 80 ef 	movl   $0xef800000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011255f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112564:	83 ec 08             	sub    $0x8,%esp
f0112567:	ff 75 f4             	pushl  -0xc(%ebp)
f011256a:	50                   	push   %eax
f011256b:	e8 6e 78 ff ff       	call   f0109dde <pt_clear_page_table_entry>
f0112570:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f0112573:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112578:	83 ec 08             	sub    $0x8,%esp
f011257b:	ff 75 f4             	pushl  -0xc(%ebp)
f011257e:	50                   	push   %eax
f011257f:	e8 d8 49 00 00       	call   f0116f5c <CE>
f0112584:	83 c4 10             	add    $0x10,%esp
f0112587:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f011258a:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f011258e:	74 17                	je     f01125a7 <test_pt_clear_page_table_entry+0xf3>
	{
		panic("[EVAL] #3 Clear Page Table Entry Failed.\n");
f0112590:	83 ec 04             	sub    $0x4,%esp
f0112593:	68 ec 33 13 f0       	push   $0xf01333ec
f0112598:	68 c0 01 00 00       	push   $0x1c0
f011259d:	68 d2 30 13 f0       	push   $0xf01330d2
f01125a2:	e8 08 ea fe ff       	call   f0100faf <_panic>
	}

	va = 0xF0000000;
f01125a7:	c7 45 f4 00 00 00 f0 	movl   $0xf0000000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f01125ae:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01125b3:	83 ec 08             	sub    $0x8,%esp
f01125b6:	ff 75 f4             	pushl  -0xc(%ebp)
f01125b9:	50                   	push   %eax
f01125ba:	e8 1f 78 ff ff       	call   f0109dde <pt_clear_page_table_entry>
f01125bf:	83 c4 10             	add    $0x10,%esp
	ret = CE(ptr_page_directory, va);
f01125c2:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01125c7:	83 ec 08             	sub    $0x8,%esp
f01125ca:	ff 75 f4             	pushl  -0xc(%ebp)
f01125cd:	50                   	push   %eax
f01125ce:	e8 89 49 00 00       	call   f0116f5c <CE>
f01125d3:	83 c4 10             	add    $0x10,%esp
f01125d6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (ret != 1)
f01125d9:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
f01125dd:	74 17                	je     f01125f6 <test_pt_clear_page_table_entry+0x142>
	{
		panic("[EVAL] #4 Clear Page Table Entry Failed.\n");
f01125df:	83 ec 04             	sub    $0x4,%esp
f01125e2:	68 18 34 13 f0       	push   $0xf0133418
f01125e7:	68 c8 01 00 00       	push   $0x1c8
f01125ec:	68 d2 30 13 f0       	push   $0xf01330d2
f01125f1:	e8 b9 e9 fe ff       	call   f0100faf <_panic>
	}

	cprintf("Congratulations!! test pt_clear_page_table_entry completed successfully.\n");
f01125f6:	83 ec 0c             	sub    $0xc,%esp
f01125f9:	68 44 34 13 f0       	push   $0xf0133444
f01125fe:	e8 59 f6 fe ff       	call   f0101c5c <cprintf>
f0112603:	83 c4 10             	add    $0x10,%esp
	return 0;
f0112606:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011260b:	c9                   	leave  
f011260c:	c3                   	ret    

f011260d <test_pt_clear_page_table_entry_invalid_va>:

int test_pt_clear_page_table_entry_invalid_va()
{
f011260d:	55                   	push   %ebp
f011260e:	89 e5                	mov    %esp,%ebp
f0112610:	83 ec 18             	sub    $0x18,%esp
	uint32 va = 0x1000;
f0112613:	c7 45 f4 00 10 00 00 	movl   $0x1000,-0xc(%ebp)
	pt_clear_page_table_entry(ptr_page_directory, va);
f011261a:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011261f:	83 ec 08             	sub    $0x8,%esp
f0112622:	ff 75 f4             	pushl  -0xc(%ebp)
f0112625:	50                   	push   %eax
f0112626:	e8 b3 77 ff ff       	call   f0109dde <pt_clear_page_table_entry>
f011262b:	83 c4 10             	add    $0x10,%esp
	panic("WRONG PANIC - This test shall panic with your error message. Check handling clearing the entry of an invalid virtual address non existing page table.");
f011262e:	83 ec 04             	sub    $0x4,%esp
f0112631:	68 90 34 13 f0       	push   $0xf0133490
f0112636:	68 d3 01 00 00       	push   $0x1d3
f011263b:	68 d2 30 13 f0       	push   $0xf01330d2
f0112640:	e8 6a e9 fe ff       	call   f0100faf <_panic>

f0112645 <test_virtual_to_physical>:

//=====================================
// 4) TEST CONVERTING VA 2 PA:
//=====================================
int test_virtual_to_physical()
{
f0112645:	55                   	push   %ebp
f0112646:	89 e5                	mov    %esp,%ebp
f0112648:	57                   	push   %edi
f0112649:	56                   	push   %esi
f011264a:	53                   	push   %ebx
f011264b:	81 ec ac 01 00 00    	sub    $0x1ac,%esp
	int kilo = 1024 ;
f0112651:	c7 45 e4 00 04 00 00 	movl   $0x400,-0x1c(%ebp)
	int mega = 1024*1024 ;
f0112658:	c7 45 e0 00 00 10 00 	movl   $0x100000,-0x20(%ebp)
	uint32 va;
	ClearUserSpace(ptr_page_directory);
f011265f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112664:	83 ec 0c             	sub    $0xc,%esp
f0112667:	50                   	push   %eax
f0112668:	e8 d1 49 00 00       	call   f011703e <ClearUserSpace>
f011266d:	83 c4 10             	add    $0x10,%esp

	//============================
	//Case 1: Check getting pa of a va with NO table
	va = 0xeebfe000;
f0112670:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	int pa = virtual_to_physical(ptr_page_directory, va);
f0112677:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011267c:	83 ec 08             	sub    $0x8,%esp
f011267f:	ff 75 dc             	pushl  -0x24(%ebp)
f0112682:	50                   	push   %eax
f0112683:	e8 70 77 ff ff       	call   f0109df8 <virtual_to_physical>
f0112688:	83 c4 10             	add    $0x10,%esp
f011268b:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %d\n", va, CA(ptr_page_directory, va), pa);
	if(pa != -1)
f011268e:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%ebp)
f0112692:	74 17                	je     f01126ab <test_virtual_to_physical+0x66>
		panic("[EVAL] #1 Test of virtual_to_physical Entry Failed.\n");
f0112694:	83 ec 04             	sub    $0x4,%esp
f0112697:	68 28 35 13 f0       	push   $0xf0133528
f011269c:	68 e8 01 00 00       	push   $0x1e8
f01126a1:	68 d2 30 13 f0       	push   $0xf01330d2
f01126a6:	e8 04 e9 fe ff       	call   f0100faf <_panic>

	//============================
	//Case 2: Check getting pa of a va with a table
	va = 0xf0000000;
f01126ab:	c7 45 dc 00 00 00 f0 	movl   $0xf0000000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01126b2:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01126b7:	83 ec 08             	sub    $0x8,%esp
f01126ba:	ff 75 dc             	pushl  -0x24(%ebp)
f01126bd:	50                   	push   %eax
f01126be:	e8 35 77 ff ff       	call   f0109df8 <virtual_to_physical>
f01126c3:	83 c4 10             	add    $0x10,%esp
f01126c6:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01126c9:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01126ce:	83 ec 08             	sub    $0x8,%esp
f01126d1:	ff 75 dc             	pushl  -0x24(%ebp)
f01126d4:	50                   	push   %eax
f01126d5:	e8 63 48 00 00       	call   f0116f3d <CA>
f01126da:	83 c4 10             	add    $0x10,%esp
f01126dd:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01126e0:	74 17                	je     f01126f9 <test_virtual_to_physical+0xb4>
		panic("[EVAL] #2 Test of virtual_to_physical Entry Failed.\n");
f01126e2:	83 ec 04             	sub    $0x4,%esp
f01126e5:	68 60 35 13 f0       	push   $0xf0133560
f01126ea:	68 f1 01 00 00       	push   $0x1f1
f01126ef:	68 d2 30 13 f0       	push   $0xf01330d2
f01126f4:	e8 b6 e8 fe ff       	call   f0100faf <_panic>

	//============================
	char ap1[100] = "ap 0x2800000";execute_command(ap1);
f01126f9:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f01126ff:	bb 2c 37 13 f0       	mov    $0xf013372c,%ebx
f0112704:	ba 0d 00 00 00       	mov    $0xd,%edx
f0112709:	89 c7                	mov    %eax,%edi
f011270b:	89 de                	mov    %ebx,%esi
f011270d:	89 d1                	mov    %edx,%ecx
f011270f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112711:	8d 55 81             	lea    -0x7f(%ebp),%edx
f0112714:	b9 57 00 00 00       	mov    $0x57,%ecx
f0112719:	b0 00                	mov    $0x0,%al
f011271b:	89 d7                	mov    %edx,%edi
f011271d:	f3 aa                	rep stos %al,%es:(%edi)
f011271f:	83 ec 0c             	sub    $0xc,%esp
f0112722:	8d 85 74 ff ff ff    	lea    -0x8c(%ebp),%eax
f0112728:	50                   	push   %eax
f0112729:	e8 ed f7 fe ff       	call   f0101f1b <execute_command>
f011272e:	83 c4 10             	add    $0x10,%esp
	va = 0x2800000;
f0112731:	c7 45 dc 00 00 80 02 	movl   $0x2800000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0112738:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011273d:	83 ec 08             	sub    $0x8,%esp
f0112740:	ff 75 dc             	pushl  -0x24(%ebp)
f0112743:	50                   	push   %eax
f0112744:	e8 af 76 ff ff       	call   f0109df8 <virtual_to_physical>
f0112749:	83 c4 10             	add    $0x10,%esp
f011274c:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f011274f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112754:	83 ec 08             	sub    $0x8,%esp
f0112757:	ff 75 dc             	pushl  -0x24(%ebp)
f011275a:	50                   	push   %eax
f011275b:	e8 dd 47 00 00       	call   f0116f3d <CA>
f0112760:	83 c4 10             	add    $0x10,%esp
f0112763:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112766:	74 17                	je     f011277f <test_virtual_to_physical+0x13a>
		panic("[EVAL] #3 Test of virtual_to_physical Entry Failed.\n");
f0112768:	83 ec 04             	sub    $0x4,%esp
f011276b:	68 98 35 13 f0       	push   $0xf0133598
f0112770:	68 fa 01 00 00       	push   $0x1fa
f0112775:	68 d2 30 13 f0       	push   $0xf01330d2
f011277a:	e8 30 e8 fe ff       	call   f0100faf <_panic>

	//============================
	char ap2[100] = "ap 0x2801000";execute_command(ap2);
f011277f:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f0112785:	bb 90 37 13 f0       	mov    $0xf0133790,%ebx
f011278a:	ba 0d 00 00 00       	mov    $0xd,%edx
f011278f:	89 c7                	mov    %eax,%edi
f0112791:	89 de                	mov    %ebx,%esi
f0112793:	89 d1                	mov    %edx,%ecx
f0112795:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112797:	8d 95 1d ff ff ff    	lea    -0xe3(%ebp),%edx
f011279d:	b9 57 00 00 00       	mov    $0x57,%ecx
f01127a2:	b0 00                	mov    $0x0,%al
f01127a4:	89 d7                	mov    %edx,%edi
f01127a6:	f3 aa                	rep stos %al,%es:(%edi)
f01127a8:	83 ec 0c             	sub    $0xc,%esp
f01127ab:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
f01127b1:	50                   	push   %eax
f01127b2:	e8 64 f7 fe ff       	call   f0101f1b <execute_command>
f01127b7:	83 c4 10             	add    $0x10,%esp
	va = 0x2801000;
f01127ba:	c7 45 dc 00 10 80 02 	movl   $0x2801000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01127c1:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01127c6:	83 ec 08             	sub    $0x8,%esp
f01127c9:	ff 75 dc             	pushl  -0x24(%ebp)
f01127cc:	50                   	push   %eax
f01127cd:	e8 26 76 ff ff       	call   f0109df8 <virtual_to_physical>
f01127d2:	83 c4 10             	add    $0x10,%esp
f01127d5:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01127d8:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01127dd:	83 ec 08             	sub    $0x8,%esp
f01127e0:	ff 75 dc             	pushl  -0x24(%ebp)
f01127e3:	50                   	push   %eax
f01127e4:	e8 54 47 00 00       	call   f0116f3d <CA>
f01127e9:	83 c4 10             	add    $0x10,%esp
f01127ec:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01127ef:	74 17                	je     f0112808 <test_virtual_to_physical+0x1c3>
		panic("[EVAL] #4 Test of virtual_to_physical Entry Failed.\n");
f01127f1:	83 ec 04             	sub    $0x4,%esp
f01127f4:	68 d0 35 13 f0       	push   $0xf01335d0
f01127f9:	68 03 02 00 00       	push   $0x203
f01127fe:	68 d2 30 13 f0       	push   $0xf01330d2
f0112803:	e8 a7 e7 fe ff       	call   f0100faf <_panic>

	//============================
	char ap3[100] = "ap 0x2802000";execute_command(ap3);
f0112808:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f011280e:	bb f4 37 13 f0       	mov    $0xf01337f4,%ebx
f0112813:	ba 0d 00 00 00       	mov    $0xd,%edx
f0112818:	89 c7                	mov    %eax,%edi
f011281a:	89 de                	mov    %ebx,%esi
f011281c:	89 d1                	mov    %edx,%ecx
f011281e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112820:	8d 95 b9 fe ff ff    	lea    -0x147(%ebp),%edx
f0112826:	b9 57 00 00 00       	mov    $0x57,%ecx
f011282b:	b0 00                	mov    $0x0,%al
f011282d:	89 d7                	mov    %edx,%edi
f011282f:	f3 aa                	rep stos %al,%es:(%edi)
f0112831:	83 ec 0c             	sub    $0xc,%esp
f0112834:	8d 85 ac fe ff ff    	lea    -0x154(%ebp),%eax
f011283a:	50                   	push   %eax
f011283b:	e8 db f6 fe ff       	call   f0101f1b <execute_command>
f0112840:	83 c4 10             	add    $0x10,%esp
	va = 0x2802000;
f0112843:	c7 45 dc 00 20 80 02 	movl   $0x2802000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011284a:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011284f:	83 ec 08             	sub    $0x8,%esp
f0112852:	ff 75 dc             	pushl  -0x24(%ebp)
f0112855:	50                   	push   %eax
f0112856:	e8 9d 75 ff ff       	call   f0109df8 <virtual_to_physical>
f011285b:	83 c4 10             	add    $0x10,%esp
f011285e:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112861:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112866:	83 ec 08             	sub    $0x8,%esp
f0112869:	ff 75 dc             	pushl  -0x24(%ebp)
f011286c:	50                   	push   %eax
f011286d:	e8 cb 46 00 00       	call   f0116f3d <CA>
f0112872:	83 c4 10             	add    $0x10,%esp
f0112875:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112878:	74 17                	je     f0112891 <test_virtual_to_physical+0x24c>
		panic("[EVAL] #5 Test of virtual_to_physical Entry Failed.\n");
f011287a:	83 ec 04             	sub    $0x4,%esp
f011287d:	68 08 36 13 f0       	push   $0xf0133608
f0112882:	68 0c 02 00 00       	push   $0x20c
f0112887:	68 d2 30 13 f0       	push   $0xf01330d2
f011288c:	e8 1e e7 fe ff       	call   f0100faf <_panic>

	//============================
	va = 0xF0001000;
f0112891:	c7 45 dc 00 10 00 f0 	movl   $0xf0001000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f0112898:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011289d:	83 ec 08             	sub    $0x8,%esp
f01128a0:	ff 75 dc             	pushl  -0x24(%ebp)
f01128a3:	50                   	push   %eax
f01128a4:	e8 4f 75 ff ff       	call   f0109df8 <virtual_to_physical>
f01128a9:	83 c4 10             	add    $0x10,%esp
f01128ac:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01128af:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01128b4:	83 ec 08             	sub    $0x8,%esp
f01128b7:	ff 75 dc             	pushl  -0x24(%ebp)
f01128ba:	50                   	push   %eax
f01128bb:	e8 7d 46 00 00       	call   f0116f3d <CA>
f01128c0:	83 c4 10             	add    $0x10,%esp
f01128c3:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f01128c6:	74 17                	je     f01128df <test_virtual_to_physical+0x29a>
		panic("[EVAL] #6 Test of virtual_to_physical Entry Failed.\n");
f01128c8:	83 ec 04             	sub    $0x4,%esp
f01128cb:	68 40 36 13 f0       	push   $0xf0133640
f01128d0:	68 14 02 00 00       	push   $0x214
f01128d5:	68 d2 30 13 f0       	push   $0xf01330d2
f01128da:	e8 d0 e6 fe ff       	call   f0100faf <_panic>

	//============================
	va = 0xF0001005;
f01128df:	c7 45 dc 05 10 00 f0 	movl   $0xf0001005,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f01128e6:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f01128eb:	83 ec 08             	sub    $0x8,%esp
f01128ee:	ff 75 dc             	pushl  -0x24(%ebp)
f01128f1:	50                   	push   %eax
f01128f2:	e8 01 75 ff ff       	call   f0109df8 <virtual_to_physical>
f01128f7:	83 c4 10             	add    $0x10,%esp
f01128fa:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f01128fd:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112902:	83 ec 08             	sub    $0x8,%esp
f0112905:	ff 75 dc             	pushl  -0x24(%ebp)
f0112908:	50                   	push   %eax
f0112909:	e8 2f 46 00 00       	call   f0116f3d <CA>
f011290e:	83 c4 10             	add    $0x10,%esp
f0112911:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f0112914:	74 17                	je     f011292d <test_virtual_to_physical+0x2e8>
		panic("[EVAL] #7 Test of virtual_to_physical Entry Failed.\n");
f0112916:	83 ec 04             	sub    $0x4,%esp
f0112919:	68 78 36 13 f0       	push   $0xf0133678
f011291e:	68 1c 02 00 00       	push   $0x21c
f0112923:	68 d2 30 13 f0       	push   $0xf01330d2
f0112928:	e8 82 e6 fe ff       	call   f0100faf <_panic>

	//============================
	char ap4[100] = "ap 0xeebfe000";execute_command(ap4);
f011292d:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f0112933:	bb 58 38 13 f0       	mov    $0xf0133858,%ebx
f0112938:	ba 0e 00 00 00       	mov    $0xe,%edx
f011293d:	89 c7                	mov    %eax,%edi
f011293f:	89 de                	mov    %ebx,%esi
f0112941:	89 d1                	mov    %edx,%ecx
f0112943:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0112945:	8d 95 56 fe ff ff    	lea    -0x1aa(%ebp),%edx
f011294b:	b9 56 00 00 00       	mov    $0x56,%ecx
f0112950:	b0 00                	mov    $0x0,%al
f0112952:	89 d7                	mov    %edx,%edi
f0112954:	f3 aa                	rep stos %al,%es:(%edi)
f0112956:	83 ec 0c             	sub    $0xc,%esp
f0112959:	8d 85 48 fe ff ff    	lea    -0x1b8(%ebp),%eax
f011295f:	50                   	push   %eax
f0112960:	e8 b6 f5 fe ff       	call   f0101f1b <execute_command>
f0112965:	83 c4 10             	add    $0x10,%esp
	va = 0xeebfe000;
f0112968:	c7 45 dc 00 e0 bf ee 	movl   $0xeebfe000,-0x24(%ebp)
	pa = virtual_to_physical(ptr_page_directory, va);
f011296f:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f0112974:	83 ec 08             	sub    $0x8,%esp
f0112977:	ff 75 dc             	pushl  -0x24(%ebp)
f011297a:	50                   	push   %eax
f011297b:	e8 78 74 ff ff       	call   f0109df8 <virtual_to_physical>
f0112980:	83 c4 10             	add    $0x10,%esp
f0112983:	89 45 d8             	mov    %eax,-0x28(%ebp)

	//cprintf("va = %x, pa = %x, ret pa = %x\n", va, CA(ptr_page_directory, va), pa);
	if(pa != CA(ptr_page_directory, va))
f0112986:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011298b:	83 ec 08             	sub    $0x8,%esp
f011298e:	ff 75 dc             	pushl  -0x24(%ebp)
f0112991:	50                   	push   %eax
f0112992:	e8 a6 45 00 00       	call   f0116f3d <CA>
f0112997:	83 c4 10             	add    $0x10,%esp
f011299a:	3b 45 d8             	cmp    -0x28(%ebp),%eax
f011299d:	74 17                	je     f01129b6 <test_virtual_to_physical+0x371>
		panic("[EVAL] #8 Test of virtual_to_physical Entry Failed.\n");
f011299f:	83 ec 04             	sub    $0x4,%esp
f01129a2:	68 b0 36 13 f0       	push   $0xf01336b0
f01129a7:	68 25 02 00 00       	push   $0x225
f01129ac:	68 d2 30 13 f0       	push   $0xf01330d2
f01129b1:	e8 f9 e5 fe ff       	call   f0100faf <_panic>

	//============================
	cprintf("Congratulations!! test virtual_to_physical completed successfully.\n");
f01129b6:	83 ec 0c             	sub    $0xc,%esp
f01129b9:	68 e8 36 13 f0       	push   $0xf01336e8
f01129be:	e8 99 f2 fe ff       	call   f0101c5c <cprintf>
f01129c3:	83 c4 10             	add    $0x10,%esp

	return 0;
f01129c6:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01129cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01129ce:	5b                   	pop    %ebx
f01129cf:	5e                   	pop    %esi
f01129d0:	5f                   	pop    %edi
f01129d1:	5d                   	pop    %ebp
f01129d2:	c3                   	ret    

f01129d3 <test_cut_paste_pages>:

//===============================
// 1) TEST CUT-PASTE PAGES:
//===============================
int test_cut_paste_pages()
{
f01129d3:	55                   	push   %ebp
f01129d4:	89 e5                	mov    %esp,%ebp
f01129d6:	57                   	push   %edi
f01129d7:	56                   	push   %esi
f01129d8:	53                   	push   %ebx
f01129d9:	81 ec ec 03 00 00    	sub    $0x3ec,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01129df:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f01129e5:	bb 6c 3b 13 f0       	mov    $0xf0133b6c,%ebx
f01129ea:	ba 0f 00 00 00       	mov    $0xf,%edx
f01129ef:	89 c7                	mov    %eax,%edi
f01129f1:	89 de                	mov    %ebx,%esi
f01129f3:	89 d1                	mov    %edx,%ecx
f01129f5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01129f7:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f01129fd:	b9 23 00 00 00       	mov    $0x23,%ecx
f0112a02:	b0 00                	mov    $0x0,%al
f0112a04:	89 d7                	mov    %edx,%edi
f0112a06:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0112a08:	6a 00                	push   $0x0
f0112a0a:	6a 0a                	push   $0xa
f0112a0c:	6a 14                	push   $0x14
f0112a0e:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0112a14:	50                   	push   %eax
f0112a15:	e8 47 85 ff ff       	call   f010af61 <env_create>
f0112a1a:	83 c4 10             	add    $0x10,%esp
f0112a1d:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0112a20:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112a23:	8b 40 64             	mov    0x64(%eax),%eax
f0112a26:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0112a29:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112a2c:	8b 40 68             	mov    0x68(%eax),%eax
f0112a2f:	89 45 90             	mov    %eax,-0x70(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f0112a32:	8b 45 90             	mov    -0x70(%ebp),%eax
f0112a35:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0112a38:	c7 85 4a ff ff ff 61 	movl   $0x20707561,-0xb6(%ebp)
f0112a3f:	75 70 20 
f0112a42:	c7 85 4e ff ff ff 00 	movl   $0x0,-0xb2(%ebp)
f0112a49:	00 00 00 
f0112a4c:	8d 95 52 ff ff ff    	lea    -0xae(%ebp),%edx
f0112a52:	b9 03 00 00 00       	mov    $0x3,%ecx
f0112a57:	b8 00 00 00 00       	mov    $0x0,%eax
f0112a5c:	89 d7                	mov    %edx,%edi
f0112a5e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0112a60:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0112a63:	8b 40 10             	mov    0x10(%eax),%eax
f0112a66:	83 ec 08             	sub    $0x8,%esp
f0112a69:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f0112a6f:	52                   	push   %edx
f0112a70:	50                   	push   %eax
f0112a71:	e8 5a 86 00 00       	call   f011b0d0 <ltostr>
f0112a76:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0112a79:	83 ec 04             	sub    $0x4,%esp
f0112a7c:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112a82:	50                   	push   %eax
f0112a83:	8d 85 36 ff ff ff    	lea    -0xca(%ebp),%eax
f0112a89:	50                   	push   %eax
f0112a8a:	8d 85 4a ff ff ff    	lea    -0xb6(%ebp),%eax
f0112a90:	50                   	push   %eax
f0112a91:	e8 13 87 00 00       	call   f011b1a9 <strcconcat>
f0112a96:	83 c4 10             	add    $0x10,%esp
	//===================================================
	int numOfArgs = 0;
f0112a99:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6;
	int kilo = 1024 ;
f0112aa0:	c7 45 c8 00 04 00 00 	movl   $0x400,-0x38(%ebp)
	int mega = 1024*1024 ;
f0112aa7:	c7 45 c4 00 00 10 00 	movl   $0x100000,-0x3c(%ebp)

	ClearUserSpace(proc_directory);
f0112aae:	83 ec 0c             	sub    $0xc,%esp
f0112ab1:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ab4:	e8 85 45 00 00       	call   f011703e <ClearUserSpace>
f0112ab9:	83 c4 10             	add    $0x10,%esp

	char ap1[100] ;strcconcat(aup_cmd, " 0x2800000", ap1); execute_command(ap1);
f0112abc:	83 ec 04             	sub    $0x4,%esp
f0112abf:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112ac5:	50                   	push   %eax
f0112ac6:	68 bc 38 13 f0       	push   $0xf01338bc
f0112acb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112ad1:	50                   	push   %eax
f0112ad2:	e8 d2 86 00 00       	call   f011b1a9 <strcconcat>
f0112ad7:	83 c4 10             	add    $0x10,%esp
f0112ada:	83 ec 0c             	sub    $0xc,%esp
f0112add:	8d 85 60 fe ff ff    	lea    -0x1a0(%ebp),%eax
f0112ae3:	50                   	push   %eax
f0112ae4:	e8 32 f4 fe ff       	call   f0101f1b <execute_command>
f0112ae9:	83 c4 10             	add    $0x10,%esp
	char ap2[100] ;strcconcat(aup_cmd, " 0x2801000", ap2); execute_command(ap2);
f0112aec:	83 ec 04             	sub    $0x4,%esp
f0112aef:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112af5:	50                   	push   %eax
f0112af6:	68 c7 38 13 f0       	push   $0xf01338c7
f0112afb:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112b01:	50                   	push   %eax
f0112b02:	e8 a2 86 00 00       	call   f011b1a9 <strcconcat>
f0112b07:	83 c4 10             	add    $0x10,%esp
f0112b0a:	83 ec 0c             	sub    $0xc,%esp
f0112b0d:	8d 85 fc fd ff ff    	lea    -0x204(%ebp),%eax
f0112b13:	50                   	push   %eax
f0112b14:	e8 02 f4 fe ff       	call   f0101f1b <execute_command>
f0112b19:	83 c4 10             	add    $0x10,%esp
	char ap3[100] ;strcconcat(aup_cmd, " 0x2802000", ap3); execute_command(ap3);
f0112b1c:	83 ec 04             	sub    $0x4,%esp
f0112b1f:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112b25:	50                   	push   %eax
f0112b26:	68 d2 38 13 f0       	push   $0xf01338d2
f0112b2b:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112b31:	50                   	push   %eax
f0112b32:	e8 72 86 00 00       	call   f011b1a9 <strcconcat>
f0112b37:	83 c4 10             	add    $0x10,%esp
f0112b3a:	83 ec 0c             	sub    $0xc,%esp
f0112b3d:	8d 85 98 fd ff ff    	lea    -0x268(%ebp),%eax
f0112b43:	50                   	push   %eax
f0112b44:	e8 d2 f3 fe ff       	call   f0101f1b <execute_command>
f0112b49:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x2800000; *ptr1 = 'a';
f0112b4c:	c7 45 c0 00 00 80 02 	movl   $0x2800000,-0x40(%ebp)
f0112b53:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112b56:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x28017FF; *ptr1 = 'b';
f0112b59:	c7 45 c0 ff 17 80 02 	movl   $0x28017ff,-0x40(%ebp)
f0112b60:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112b63:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x2802FFF; *ptr1 = 'c';
f0112b66:	c7 45 c0 ff 2f 80 02 	movl   $0x2802fff,-0x40(%ebp)
f0112b6d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112b70:	c6 00 63             	movb   $0x63,(%eax)

	uint32 perms = GP(proc_directory, (uint32)ptr1);
f0112b73:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112b76:	83 ec 08             	sub    $0x8,%esp
f0112b79:	50                   	push   %eax
f0112b7a:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112b7d:	e8 9d 44 00 00       	call   f011701f <GP>
f0112b82:	83 c4 10             	add    $0x10,%esp
f0112b85:	89 45 bc             	mov    %eax,-0x44(%ebp)

	int eval = 0;
f0112b88:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	int correct = 1;
f0112b8f:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	int ff1 = sys_calculate_free_frames();
f0112b96:	e8 0d be ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0112b9b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	/*=============================================*/
	/*PART I: Destination Pages Does NOT Exist 60% */
	/*=============================================*/
	cprintf("CASE I: Destination Pages Does NOT Exist [60%]\n") ;
f0112b9e:	83 ec 0c             	sub    $0xc,%esp
f0112ba1:	68 e0 38 13 f0       	push   $0xf01338e0
f0112ba6:	e8 b1 f0 fe ff       	call   f0101c5c <cprintf>
f0112bab:	83 c4 10             	add    $0x10,%esp
	int ret = cut_paste_pages(proc_directory, 0x2800000, 0x2900000, 3) ;
f0112bae:	6a 03                	push   $0x3
f0112bb0:	68 00 00 90 02       	push   $0x2900000
f0112bb5:	68 00 00 80 02       	push   $0x2800000
f0112bba:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112bbd:	e8 bd 80 ff ff       	call   f010ac7f <cut_paste_pages>
f0112bc2:	83 c4 10             	add    $0x10,%esp
f0112bc5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	int ff2 = sys_calculate_free_frames();
f0112bc8:	e8 db bd ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0112bcd:	89 45 b0             	mov    %eax,-0x50(%ebp)

	correct = 1 ;
f0112bd0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	if (ret != 0 || ff1 != ff2)
f0112bd7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112bdb:	75 08                	jne    f0112be5 <test_cut_paste_pages+0x212>
f0112bdd:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112be0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0112be3:	74 2b                	je     f0112c10 <test_cut_paste_pages+0x23d>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112be5:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112be8:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112beb:	83 ec 0c             	sub    $0xc,%esp
f0112bee:	50                   	push   %eax
f0112bef:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112bf2:	68 10 39 13 f0       	push   $0xf0133910
f0112bf7:	68 63 02 00 00       	push   $0x263
f0112bfc:	68 d2 30 13 f0       	push   $0xf01330d2
f0112c01:	e8 4e e5 fe ff       	call   f0101154 <_warn>
f0112c06:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112c09:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 5 ;
f0112c10:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c14:	74 04                	je     f0112c1a <test_cut_paste_pages+0x247>
f0112c16:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0112c1a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2800000, 0x2900000, 3*PAGE_SIZE, 1, perms, 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112c21:	83 ec 08             	sub    $0x8,%esp
f0112c24:	6a 00                	push   $0x0
f0112c26:	6a 01                	push   $0x1
f0112c28:	6a 00                	push   $0x0
f0112c2a:	68 ff 0f 00 00       	push   $0xfff
f0112c2f:	ff 75 bc             	pushl  -0x44(%ebp)
f0112c32:	6a 01                	push   $0x1
f0112c34:	68 00 30 00 00       	push   $0x3000
f0112c39:	68 00 00 90 02       	push   $0x2900000
f0112c3e:	68 00 00 80 02       	push   $0x2800000
f0112c43:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c46:	e8 27 44 00 00       	call   f0117072 <CCP>
f0112c4b:	83 c4 30             	add    $0x30,%esp
f0112c4e:	83 f8 01             	cmp    $0x1,%eax
f0112c51:	74 21                	je     f0112c74 <test_cut_paste_pages+0x2a1>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112c53:	83 ec 04             	sub    $0x4,%esp
f0112c56:	68 64 39 13 f0       	push   $0xf0133964
f0112c5b:	68 6b 02 00 00       	push   $0x26b
f0112c60:	68 d2 30 13 f0       	push   $0xf01330d2
f0112c65:	e8 ea e4 fe ff       	call   f0101154 <_warn>
f0112c6a:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112c6d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 15 ;
f0112c74:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112c78:	74 04                	je     f0112c7e <test_cut_paste_pages+0x2ab>
f0112c7a:	83 45 e4 0f          	addl   $0xf,-0x1c(%ebp)
	correct = 1 ;
f0112c7e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2900000, 0) && CB(proc_directory, 0x2901000, 0) && CB(proc_directory, 0x2902000, 0))
f0112c85:	83 ec 04             	sub    $0x4,%esp
f0112c88:	6a 00                	push   $0x0
f0112c8a:	68 00 00 90 02       	push   $0x2900000
f0112c8f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112c92:	e8 b7 41 00 00       	call   f0116e4e <CB>
f0112c97:	83 c4 10             	add    $0x10,%esp
f0112c9a:	85 c0                	test   %eax,%eax
f0112c9c:	0f 84 f6 00 00 00    	je     f0112d98 <test_cut_paste_pages+0x3c5>
f0112ca2:	83 ec 04             	sub    $0x4,%esp
f0112ca5:	6a 00                	push   $0x0
f0112ca7:	68 00 10 90 02       	push   $0x2901000
f0112cac:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112caf:	e8 9a 41 00 00       	call   f0116e4e <CB>
f0112cb4:	83 c4 10             	add    $0x10,%esp
f0112cb7:	85 c0                	test   %eax,%eax
f0112cb9:	0f 84 d9 00 00 00    	je     f0112d98 <test_cut_paste_pages+0x3c5>
f0112cbf:	83 ec 04             	sub    $0x4,%esp
f0112cc2:	6a 00                	push   $0x0
f0112cc4:	68 00 20 90 02       	push   $0x2902000
f0112cc9:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112ccc:	e8 7d 41 00 00       	call   f0116e4e <CB>
f0112cd1:	83 c4 10             	add    $0x10,%esp
f0112cd4:	85 c0                	test   %eax,%eax
f0112cd6:	0f 84 bc 00 00 00    	je     f0112d98 <test_cut_paste_pages+0x3c5>
	{
		ptr1 = (char*)0x2900000;
f0112cdc:	c7 45 c0 00 00 90 02 	movl   $0x2900000,-0x40(%ebp)
		ptr2 = (char*)0x29017FF;
f0112ce3:	c7 45 ac ff 17 90 02 	movl   $0x29017ff,-0x54(%ebp)
		ptr3 = (char*)0x2902FFF;
f0112cea:	c7 45 a8 ff 2f 90 02 	movl   $0x2902fff,-0x58(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'b' || (*ptr3) != 'c')
f0112cf1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112cf4:	8a 00                	mov    (%eax),%al
f0112cf6:	3c 61                	cmp    $0x61,%al
f0112cf8:	75 12                	jne    f0112d0c <test_cut_paste_pages+0x339>
f0112cfa:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112cfd:	8a 00                	mov    (%eax),%al
f0112cff:	3c 62                	cmp    $0x62,%al
f0112d01:	75 09                	jne    f0112d0c <test_cut_paste_pages+0x339>
f0112d03:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0112d06:	8a 00                	mov    (%eax),%al
f0112d08:	3c 63                	cmp    $0x63,%al
f0112d0a:	74 21                	je     f0112d2d <test_cut_paste_pages+0x35a>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112d0c:	83 ec 04             	sub    $0x4,%esp
f0112d0f:	68 b0 39 13 f0       	push   $0xf01339b0
f0112d14:	68 78 02 00 00       	push   $0x278
f0112d19:	68 d2 30 13 f0       	push   $0xf01330d2
f0112d1e:	e8 31 e4 fe ff       	call   f0101154 <_warn>
f0112d23:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112d26:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0112d2d:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d31:	74 04                	je     f0112d37 <test_cut_paste_pages+0x364>
f0112d33:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0112d37:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CB(proc_directory, 0x2901000, 1))
f0112d3e:	83 ec 04             	sub    $0x4,%esp
f0112d41:	6a 01                	push   $0x1
f0112d43:	68 00 10 90 02       	push   $0x2901000
f0112d48:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112d4b:	e8 fe 40 00 00       	call   f0116e4e <CB>
f0112d50:	83 c4 10             	add    $0x10,%esp
f0112d53:	85 c0                	test   %eax,%eax
f0112d55:	74 41                	je     f0112d98 <test_cut_paste_pages+0x3c5>
		{
			*ptr2 = 'y';
f0112d57:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112d5a:	c6 00 79             	movb   $0x79,(%eax)
			if ((*ptr2) != 'y')
f0112d5d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112d60:	8a 00                	mov    (%eax),%al
f0112d62:	3c 79                	cmp    $0x79,%al
f0112d64:	74 21                	je     f0112d87 <test_cut_paste_pages+0x3b4>
			{
				warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112d66:	83 ec 04             	sub    $0x4,%esp
f0112d69:	68 b0 39 13 f0       	push   $0xf01339b0
f0112d6e:	68 83 02 00 00       	push   $0x283
f0112d73:	68 d2 30 13 f0       	push   $0xf01330d2
f0112d78:	e8 d7 e3 fe ff       	call   f0101154 <_warn>
f0112d7d:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0112d80:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f0112d87:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112d8b:	74 04                	je     f0112d91 <test_cut_paste_pages+0x3be>
f0112d8d:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0112d91:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}


	ff1 = ff2 ;
f0112d98:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0112d9b:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x2901000, 0x2BFF000, 2) ;
f0112d9e:	6a 02                	push   $0x2
f0112da0:	68 00 f0 bf 02       	push   $0x2bff000
f0112da5:	68 00 10 90 02       	push   $0x2901000
f0112daa:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112dad:	e8 cd 7e ff ff       	call   f010ac7f <cut_paste_pages>
f0112db2:	83 c4 10             	add    $0x10,%esp
f0112db5:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0112db8:	e8 eb bb ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0112dbd:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != 0 || ff1 - ff2 != 1)
f0112dc0:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
f0112dc4:	75 0b                	jne    f0112dd1 <test_cut_paste_pages+0x3fe>
f0112dc6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112dc9:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112dcc:	83 f8 01             	cmp    $0x1,%eax
f0112dcf:	74 2b                	je     f0112dfc <test_cut_paste_pages+0x429>
	{
		warn("[EVAL] cut_paste_pages: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, ff1 - ff2);
f0112dd1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0112dd4:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0112dd7:	83 ec 0c             	sub    $0xc,%esp
f0112dda:	50                   	push   %eax
f0112ddb:	ff 75 b4             	pushl  -0x4c(%ebp)
f0112dde:	68 10 39 13 f0       	push   $0xf0133910
f0112de3:	68 94 02 00 00       	push   $0x294
f0112de8:	68 d2 30 13 f0       	push   $0xf01330d2
f0112ded:	e8 62 e3 fe ff       	call   f0101154 <_warn>
f0112df2:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0112df5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112dfc:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e00:	74 04                	je     f0112e06 <test_cut_paste_pages+0x433>
f0112e02:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112e06:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CCP(proc_directory, 0x2901000, 0x2BFF000, 2*PAGE_SIZE, 1, perms , 0xFFF, 0, 0x001, CHK_CUT_PASTE) != 1)
f0112e0d:	83 ec 08             	sub    $0x8,%esp
f0112e10:	6a 00                	push   $0x0
f0112e12:	6a 01                	push   $0x1
f0112e14:	6a 00                	push   $0x0
f0112e16:	68 ff 0f 00 00       	push   $0xfff
f0112e1b:	ff 75 bc             	pushl  -0x44(%ebp)
f0112e1e:	6a 01                	push   $0x1
f0112e20:	68 00 20 00 00       	push   $0x2000
f0112e25:	68 00 f0 bf 02       	push   $0x2bff000
f0112e2a:	68 00 10 90 02       	push   $0x2901000
f0112e2f:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112e32:	e8 3b 42 00 00       	call   f0117072 <CCP>
f0112e37:	83 c4 30             	add    $0x30,%esp
f0112e3a:	83 f8 01             	cmp    $0x1,%eax
f0112e3d:	74 21                	je     f0112e60 <test_cut_paste_pages+0x48d>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0112e3f:	83 ec 04             	sub    $0x4,%esp
f0112e42:	68 64 39 13 f0       	push   $0xf0133964
f0112e47:	68 9c 02 00 00       	push   $0x29c
f0112e4c:	68 d2 30 13 f0       	push   $0xf01330d2
f0112e51:	e8 fe e2 fe ff       	call   f0101154 <_warn>
f0112e56:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0112e59:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0112e60:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112e64:	74 04                	je     f0112e6a <test_cut_paste_pages+0x497>
f0112e66:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0112e6a:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (CB(proc_directory, 0x2BFF7FF, 0) && CB(proc_directory, 0x2C00FFF, 0))
f0112e71:	83 ec 04             	sub    $0x4,%esp
f0112e74:	6a 00                	push   $0x0
f0112e76:	68 ff f7 bf 02       	push   $0x2bff7ff
f0112e7b:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112e7e:	e8 cb 3f 00 00       	call   f0116e4e <CB>
f0112e83:	83 c4 10             	add    $0x10,%esp
f0112e86:	85 c0                	test   %eax,%eax
f0112e88:	74 6b                	je     f0112ef5 <test_cut_paste_pages+0x522>
f0112e8a:	83 ec 04             	sub    $0x4,%esp
f0112e8d:	6a 00                	push   $0x0
f0112e8f:	68 ff 0f c0 02       	push   $0x2c00fff
f0112e94:	ff 75 d4             	pushl  -0x2c(%ebp)
f0112e97:	e8 b2 3f 00 00       	call   f0116e4e <CB>
f0112e9c:	83 c4 10             	add    $0x10,%esp
f0112e9f:	85 c0                	test   %eax,%eax
f0112ea1:	74 52                	je     f0112ef5 <test_cut_paste_pages+0x522>
	{
		ptr1 = (char*)0x2BFF7FF;
f0112ea3:	c7 45 c0 ff f7 bf 02 	movl   $0x2bff7ff,-0x40(%ebp)
		ptr2 = (char*)0x2C00FFF;
f0112eaa:	c7 45 ac ff 0f c0 02 	movl   $0x2c00fff,-0x54(%ebp)
		if ((*ptr1) != 'y' || (*ptr2) != 'c')
f0112eb1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112eb4:	8a 00                	mov    (%eax),%al
f0112eb6:	3c 79                	cmp    $0x79,%al
f0112eb8:	75 09                	jne    f0112ec3 <test_cut_paste_pages+0x4f0>
f0112eba:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0112ebd:	8a 00                	mov    (%eax),%al
f0112ebf:	3c 63                	cmp    $0x63,%al
f0112ec1:	74 21                	je     f0112ee4 <test_cut_paste_pages+0x511>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f0112ec3:	83 ec 04             	sub    $0x4,%esp
f0112ec6:	68 b0 39 13 f0       	push   $0xf01339b0
f0112ecb:	68 a8 02 00 00       	push   $0x2a8
f0112ed0:	68 d2 30 13 f0       	push   $0xf01330d2
f0112ed5:	e8 7a e2 fe ff       	call   f0101154 <_warn>
f0112eda:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0112edd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0112ee4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0112ee8:	74 04                	je     f0112eee <test_cut_paste_pages+0x51b>
f0112eea:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0112eee:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}
	cprintf("CASE I: END\n") ;
f0112ef5:	83 ec 0c             	sub    $0xc,%esp
f0112ef8:	68 e9 39 13 f0       	push   $0xf01339e9
f0112efd:	e8 5a ed fe ff       	call   f0101c5c <cprintf>
f0112f02:	83 c4 10             	add    $0x10,%esp

	/*========================================*/
	/*PART II: Destination Pages Exist 40%	  */
	/*========================================*/
	cprintf("\nCASE II: Destination Pages Exist [40%]\n") ;
f0112f05:	83 ec 0c             	sub    $0xc,%esp
f0112f08:	68 f8 39 13 f0       	push   $0xf01339f8
f0112f0d:	e8 4a ed fe ff       	call   f0101c5c <cprintf>
f0112f12:	83 c4 10             	add    $0x10,%esp

	char ap4[100] ;strcconcat(aup_cmd, " 0x1400000", ap4); execute_command(ap4);
f0112f15:	83 ec 04             	sub    $0x4,%esp
f0112f18:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112f1e:	50                   	push   %eax
f0112f1f:	68 21 3a 13 f0       	push   $0xf0133a21
f0112f24:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112f2a:	50                   	push   %eax
f0112f2b:	e8 79 82 00 00       	call   f011b1a9 <strcconcat>
f0112f30:	83 c4 10             	add    $0x10,%esp
f0112f33:	83 ec 0c             	sub    $0xc,%esp
f0112f36:	8d 85 34 fd ff ff    	lea    -0x2cc(%ebp),%eax
f0112f3c:	50                   	push   %eax
f0112f3d:	e8 d9 ef fe ff       	call   f0101f1b <execute_command>
f0112f42:	83 c4 10             	add    $0x10,%esp
	char ap5[100] ;strcconcat(aup_cmd, " 0x1401000", ap5); execute_command(ap5);
f0112f45:	83 ec 04             	sub    $0x4,%esp
f0112f48:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112f4e:	50                   	push   %eax
f0112f4f:	68 2c 3a 13 f0       	push   $0xf0133a2c
f0112f54:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112f5a:	50                   	push   %eax
f0112f5b:	e8 49 82 00 00       	call   f011b1a9 <strcconcat>
f0112f60:	83 c4 10             	add    $0x10,%esp
f0112f63:	83 ec 0c             	sub    $0xc,%esp
f0112f66:	8d 85 d0 fc ff ff    	lea    -0x330(%ebp),%eax
f0112f6c:	50                   	push   %eax
f0112f6d:	e8 a9 ef fe ff       	call   f0101f1b <execute_command>
f0112f72:	83 c4 10             	add    $0x10,%esp
	char ap6[100] ;strcconcat(aup_cmd, " 0x1402000", ap6); execute_command(ap6);
f0112f75:	83 ec 04             	sub    $0x4,%esp
f0112f78:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112f7e:	50                   	push   %eax
f0112f7f:	68 37 3a 13 f0       	push   $0xf0133a37
f0112f84:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112f8a:	50                   	push   %eax
f0112f8b:	e8 19 82 00 00       	call   f011b1a9 <strcconcat>
f0112f90:	83 c4 10             	add    $0x10,%esp
f0112f93:	83 ec 0c             	sub    $0xc,%esp
f0112f96:	8d 85 6c fc ff ff    	lea    -0x394(%ebp),%eax
f0112f9c:	50                   	push   %eax
f0112f9d:	e8 79 ef fe ff       	call   f0101f1b <execute_command>
f0112fa2:	83 c4 10             	add    $0x10,%esp
	char ap7[100] ;strcconcat(aup_cmd, " 0x1C00000", ap7); execute_command(ap7);
f0112fa5:	83 ec 04             	sub    $0x4,%esp
f0112fa8:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112fae:	50                   	push   %eax
f0112faf:	68 42 3a 13 f0       	push   $0xf0133a42
f0112fb4:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
f0112fba:	50                   	push   %eax
f0112fbb:	e8 e9 81 00 00       	call   f011b1a9 <strcconcat>
f0112fc0:	83 c4 10             	add    $0x10,%esp
f0112fc3:	83 ec 0c             	sub    $0xc,%esp
f0112fc6:	8d 85 08 fc ff ff    	lea    -0x3f8(%ebp),%eax
f0112fcc:	50                   	push   %eax
f0112fcd:	e8 49 ef fe ff       	call   f0101f1b <execute_command>
f0112fd2:	83 c4 10             	add    $0x10,%esp

	ptr1 = (char*)0x1400000; *ptr1 = 'a';
f0112fd5:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
f0112fdc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112fdf:	c6 00 61             	movb   $0x61,(%eax)
	ptr1 = (char*)0x14007FF; *ptr1 = 'b';
f0112fe2:	c7 45 c0 ff 07 40 01 	movl   $0x14007ff,-0x40(%ebp)
f0112fe9:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112fec:	c6 00 62             	movb   $0x62,(%eax)
	ptr1 = (char*)0x1400FFF; *ptr1 = 'c';
f0112fef:	c7 45 c0 ff 0f 40 01 	movl   $0x1400fff,-0x40(%ebp)
f0112ff6:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0112ff9:	c6 00 63             	movb   $0x63,(%eax)
	ptr1 = (char*)0x1C00000; *ptr1 = 'x';
f0112ffc:	c7 45 c0 00 00 c0 01 	movl   $0x1c00000,-0x40(%ebp)
f0113003:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113006:	c6 00 78             	movb   $0x78,(%eax)
	ptr1 = (char*)0x1C007FF; *ptr1 = 'y';
f0113009:	c7 45 c0 ff 07 c0 01 	movl   $0x1c007ff,-0x40(%ebp)
f0113010:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113013:	c6 00 79             	movb   $0x79,(%eax)
	ptr1 = (char*)0x1C00FFF; *ptr1 = 'z';
f0113016:	c7 45 c0 ff 0f c0 01 	movl   $0x1c00fff,-0x40(%ebp)
f011301d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113020:	c6 00 7a             	movb   $0x7a,(%eax)
	uint32 srcp = GP(proc_directory, 0x1C00000) ;
f0113023:	83 ec 08             	sub    $0x8,%esp
f0113026:	68 00 00 c0 01       	push   $0x1c00000
f011302b:	ff 75 d4             	pushl  -0x2c(%ebp)
f011302e:	e8 ec 3f 00 00       	call   f011701f <GP>
f0113033:	83 c4 10             	add    $0x10,%esp
f0113036:	89 45 a4             	mov    %eax,-0x5c(%ebp)
	uint32 dstp = GP(proc_directory, 0x1400000) ;
f0113039:	83 ec 08             	sub    $0x8,%esp
f011303c:	68 00 00 40 01       	push   $0x1400000
f0113041:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113044:	e8 d6 3f 00 00       	call   f011701f <GP>
f0113049:	83 c4 10             	add    $0x10,%esp
f011304c:	89 45 a0             	mov    %eax,-0x60(%ebp)

	ff1 = sys_calculate_free_frames();
f011304f:	e8 54 b9 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0113054:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1C00000, 0x1400000, 1) ;
f0113057:	6a 01                	push   $0x1
f0113059:	68 00 00 40 01       	push   $0x1400000
f011305e:	68 00 00 c0 01       	push   $0x1c00000
f0113063:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113066:	e8 14 7c ff ff       	call   f010ac7f <cut_paste_pages>
f011306b:	83 c4 10             	add    $0x10,%esp
f011306e:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f0113071:	e8 32 b9 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0113076:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f0113079:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f011307d:	75 08                	jne    f0113087 <test_cut_paste_pages+0x6b4>
f011307f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113082:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f0113085:	74 2b                	je     f01130b2 <test_cut_paste_pages+0x6df>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f0113087:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011308a:	2b 45 b0             	sub    -0x50(%ebp),%eax
f011308d:	83 ec 0c             	sub    $0xc,%esp
f0113090:	50                   	push   %eax
f0113091:	ff 75 b4             	pushl  -0x4c(%ebp)
f0113094:	68 50 3a 13 f0       	push   $0xf0133a50
f0113099:	68 cb 02 00 00       	push   $0x2cb
f011309e:	68 d2 30 13 f0       	push   $0xf01330d2
f01130a3:	e8 ac e0 fe ff       	call   f0101154 <_warn>
f01130a8:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f01130ab:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f01130b2:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01130b6:	74 04                	je     f01130bc <test_cut_paste_pages+0x6e9>
f01130b8:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f01130bc:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	int chk_cntnt = 1 ;
f01130c3:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CCP(proc_directory, 0x1C00000, 0x1400000, 1*PAGE_SIZE, 1, dstp , 0xFFF, srcp, 0xFFF, CHK_CUT_PASTE) != 1)
f01130ca:	83 ec 08             	sub    $0x8,%esp
f01130cd:	6a 00                	push   $0x0
f01130cf:	68 ff 0f 00 00       	push   $0xfff
f01130d4:	ff 75 a4             	pushl  -0x5c(%ebp)
f01130d7:	68 ff 0f 00 00       	push   $0xfff
f01130dc:	ff 75 a0             	pushl  -0x60(%ebp)
f01130df:	6a 01                	push   $0x1
f01130e1:	68 00 10 00 00       	push   $0x1000
f01130e6:	68 00 00 40 01       	push   $0x1400000
f01130eb:	68 00 00 c0 01       	push   $0x1c00000
f01130f0:	ff 75 d4             	pushl  -0x2c(%ebp)
f01130f3:	e8 7a 3f 00 00       	call   f0117072 <CCP>
f01130f8:	83 c4 30             	add    $0x30,%esp
f01130fb:	83 f8 01             	cmp    $0x1,%eax
f01130fe:	74 28                	je     f0113128 <test_cut_paste_pages+0x755>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions and/or references\n");
f0113100:	83 ec 04             	sub    $0x4,%esp
f0113103:	68 64 39 13 f0       	push   $0xf0133964
f0113108:	68 d4 02 00 00       	push   $0x2d4
f011310d:	68 d2 30 13 f0       	push   $0xf01330d2
f0113112:	e8 3d e0 fe ff       	call   f0101154 <_warn>
f0113117:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f011311a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f0113121:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113128:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011312c:	74 04                	je     f0113132 <test_cut_paste_pages+0x75f>
f011312e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113132:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113139:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011313d:	0f 84 92 00 00 00    	je     f01131d5 <test_cut_paste_pages+0x802>
	{
		ptr1 = (char*)0x1400000;
f0113143:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f011314a:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f0113151:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113158:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011315f:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113166:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011316d:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0113170:	8a 00                	mov    (%eax),%al
f0113172:	3c 61                	cmp    $0x61,%al
f0113174:	75 2d                	jne    f01131a3 <test_cut_paste_pages+0x7d0>
f0113176:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113179:	8a 00                	mov    (%eax),%al
f011317b:	3c 78                	cmp    $0x78,%al
f011317d:	75 24                	jne    f01131a3 <test_cut_paste_pages+0x7d0>
f011317f:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113182:	8a 00                	mov    (%eax),%al
f0113184:	3c 62                	cmp    $0x62,%al
f0113186:	75 1b                	jne    f01131a3 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113188:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011318b:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011318d:	3c 79                	cmp    $0x79,%al
f011318f:	75 12                	jne    f01131a3 <test_cut_paste_pages+0x7d0>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113191:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113194:	8a 00                	mov    (%eax),%al
f0113196:	3c 63                	cmp    $0x63,%al
f0113198:	75 09                	jne    f01131a3 <test_cut_paste_pages+0x7d0>
f011319a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011319d:	8a 00                	mov    (%eax),%al
f011319f:	3c 7a                	cmp    $0x7a,%al
f01131a1:	74 21                	je     f01131c4 <test_cut_paste_pages+0x7f1>
		{
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f01131a3:	83 ec 04             	sub    $0x4,%esp
f01131a6:	68 b0 39 13 f0       	push   $0xf01339b0
f01131ab:	68 e6 02 00 00       	push   $0x2e6
f01131b0:	68 d2 30 13 f0       	push   $0xf01330d2
f01131b5:	e8 9a df fe ff       	call   f0101154 <_warn>
f01131ba:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01131bd:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01131c4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01131c8:	74 04                	je     f01131ce <test_cut_paste_pages+0x7fb>
f01131ca:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01131ce:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	ff1 = sys_calculate_free_frames();
f01131d5:	e8 ce b7 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01131da:	89 45 b8             	mov    %eax,-0x48(%ebp)

	ret = cut_paste_pages(proc_directory, 0x1400000, 0x1BFF000, 3) ;
f01131dd:	6a 03                	push   $0x3
f01131df:	68 00 f0 bf 01       	push   $0x1bff000
f01131e4:	68 00 00 40 01       	push   $0x1400000
f01131e9:	ff 75 d4             	pushl  -0x2c(%ebp)
f01131ec:	e8 8e 7a ff ff       	call   f010ac7f <cut_paste_pages>
f01131f1:	83 c4 10             	add    $0x10,%esp
f01131f4:	89 45 b4             	mov    %eax,-0x4c(%ebp)

	ff2 = sys_calculate_free_frames();
f01131f7:	e8 ac b7 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01131fc:	89 45 b0             	mov    %eax,-0x50(%ebp)

	if (ret != -1 || ff1 - ff2 != 0)
f01131ff:	83 7d b4 ff          	cmpl   $0xffffffff,-0x4c(%ebp)
f0113203:	75 08                	jne    f011320d <test_cut_paste_pages+0x83a>
f0113205:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113208:	3b 45 b0             	cmp    -0x50(%ebp),%eax
f011320b:	74 2b                	je     f0113238 <test_cut_paste_pages+0x865>
	{
		warn("[EVAL] cut_paste_pages: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, ff1 - ff2);
f011320d:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113210:	2b 45 b0             	sub    -0x50(%ebp),%eax
f0113213:	83 ec 0c             	sub    $0xc,%esp
f0113216:	50                   	push   %eax
f0113217:	ff 75 b4             	pushl  -0x4c(%ebp)
f011321a:	68 50 3a 13 f0       	push   $0xf0133a50
f011321f:	68 f5 02 00 00       	push   $0x2f5
f0113224:	68 d2 30 13 f0       	push   $0xf01330d2
f0113229:	e8 26 df fe ff       	call   f0101154 <_warn>
f011322e:	83 c4 20             	add    $0x20,%esp
		correct = 0;
f0113231:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	}
	if (correct) eval += 10 ;
f0113238:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011323c:	74 04                	je     f0113242 <test_cut_paste_pages+0x86f>
f011323e:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
	correct = 1 ;
f0113242:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	chk_cntnt = 1;
f0113249:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f0113250:	83 ec 04             	sub    $0x4,%esp
f0113253:	6a 00                	push   $0x0
f0113255:	68 00 00 40 01       	push   $0x1400000
f011325a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011325d:	e8 ec 3b 00 00       	call   f0116e4e <CB>
f0113262:	83 c4 10             	add    $0x10,%esp
f0113265:	83 f8 01             	cmp    $0x1,%eax
f0113268:	0f 85 80 00 00 00    	jne    f01132ee <test_cut_paste_pages+0x91b>
f011326e:	83 ec 04             	sub    $0x4,%esp
f0113271:	6a 00                	push   $0x0
f0113273:	68 00 10 40 01       	push   $0x1401000
f0113278:	ff 75 d4             	pushl  -0x2c(%ebp)
f011327b:	e8 ce 3b 00 00       	call   f0116e4e <CB>
f0113280:	83 c4 10             	add    $0x10,%esp
f0113283:	83 f8 01             	cmp    $0x1,%eax
f0113286:	75 66                	jne    f01132ee <test_cut_paste_pages+0x91b>
f0113288:	83 ec 04             	sub    $0x4,%esp
f011328b:	6a 00                	push   $0x0
f011328d:	68 00 20 40 01       	push   $0x1402000
f0113292:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113295:	e8 b4 3b 00 00       	call   f0116e4e <CB>
f011329a:	83 c4 10             	add    $0x10,%esp
f011329d:	83 f8 01             	cmp    $0x1,%eax
f01132a0:	75 4c                	jne    f01132ee <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01132a2:	83 ec 04             	sub    $0x4,%esp
f01132a5:	6a 00                	push   $0x0
f01132a7:	68 00 f0 bf 01       	push   $0x1bff000
f01132ac:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132af:	e8 9a 3b 00 00       	call   f0116e4e <CB>
f01132b4:	83 c4 10             	add    $0x10,%esp
		correct = 0;
	}
	if (correct) eval += 10 ;
	correct = 1 ;
	chk_cntnt = 1;
	if (CB(proc_directory, 0x1400000, 0) != 1 || CB(proc_directory, 0x1401000, 0) != 1 || CB(proc_directory, 0x1402000, 0) != 1 ||
f01132b7:	85 c0                	test   %eax,%eax
f01132b9:	75 33                	jne    f01132ee <test_cut_paste_pages+0x91b>
			CB(proc_directory, 0x1BFF000, 0) != 0 || CB(proc_directory, 0x1C00000, 0) != 1 || CB(proc_directory, 0x1C01000, 0) != 0)
f01132bb:	83 ec 04             	sub    $0x4,%esp
f01132be:	6a 00                	push   $0x0
f01132c0:	68 00 00 c0 01       	push   $0x1c00000
f01132c5:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132c8:	e8 81 3b 00 00       	call   f0116e4e <CB>
f01132cd:	83 c4 10             	add    $0x10,%esp
f01132d0:	83 f8 01             	cmp    $0x1,%eax
f01132d3:	75 19                	jne    f01132ee <test_cut_paste_pages+0x91b>
f01132d5:	83 ec 04             	sub    $0x4,%esp
f01132d8:	6a 00                	push   $0x0
f01132da:	68 00 10 c0 01       	push   $0x1c01000
f01132df:	ff 75 d4             	pushl  -0x2c(%ebp)
f01132e2:	e8 67 3b 00 00       	call   f0116e4e <CB>
f01132e7:	83 c4 10             	add    $0x10,%esp
f01132ea:	85 c0                	test   %eax,%eax
f01132ec:	74 28                	je     f0113316 <test_cut_paste_pages+0x943>
	{
		warn("[EVAL] cut_paste_pages: Failed (problem in permissions)\n");
f01132ee:	83 ec 04             	sub    $0x4,%esp
f01132f1:	68 b0 3a 13 f0       	push   $0xf0133ab0
f01132f6:	68 fe 02 00 00       	push   $0x2fe
f01132fb:	68 d2 30 13 f0       	push   $0xf01330d2
f0113300:	e8 4f de fe ff       	call   f0101154 <_warn>
f0113305:	83 c4 10             	add    $0x10,%esp
		correct = 0;
f0113308:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		chk_cntnt = 0;
f011330f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	}
	if (correct) eval += 5 ;
f0113316:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011331a:	74 04                	je     f0113320 <test_cut_paste_pages+0x94d>
f011331c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
	correct = 1 ;
f0113320:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	if (chk_cntnt)
f0113327:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011332b:	0f 84 99 00 00 00    	je     f01133ca <test_cut_paste_pages+0x9f7>
	{
		ptr1 = (char*)0x1400000;
f0113331:	c7 45 c0 00 00 40 01 	movl   $0x1400000,-0x40(%ebp)
		ptr2 = (char*)0x1C00000;
f0113338:	c7 45 ac 00 00 c0 01 	movl   $0x1c00000,-0x54(%ebp)
		ptr3 = (char*)0x14007FF;
f011333f:	c7 45 a8 ff 07 40 01 	movl   $0x14007ff,-0x58(%ebp)
		ptr4 = (char*)0x1C007FF;
f0113346:	c7 45 9c ff 07 c0 01 	movl   $0x1c007ff,-0x64(%ebp)
		ptr5 = (char*)0x1400FFF;
f011334d:	c7 45 98 ff 0f 40 01 	movl   $0x1400fff,-0x68(%ebp)
		ptr6 = (char*)0x1C00FFF;
f0113354:	c7 45 94 ff 0f c0 01 	movl   $0x1c00fff,-0x6c(%ebp)
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011335b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011335e:	8a 00                	mov    (%eax),%al
f0113360:	3c 61                	cmp    $0x61,%al
f0113362:	75 2d                	jne    f0113391 <test_cut_paste_pages+0x9be>
f0113364:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113367:	8a 00                	mov    (%eax),%al
f0113369:	3c 78                	cmp    $0x78,%al
f011336b:	75 24                	jne    f0113391 <test_cut_paste_pages+0x9be>
f011336d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113370:	8a 00                	mov    (%eax),%al
f0113372:	3c 62                	cmp    $0x62,%al
f0113374:	75 1b                	jne    f0113391 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f0113376:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113379:	8a 00                	mov    (%eax),%al
		ptr2 = (char*)0x1C00000;
		ptr3 = (char*)0x14007FF;
		ptr4 = (char*)0x1C007FF;
		ptr5 = (char*)0x1400FFF;
		ptr6 = (char*)0x1C00FFF;
		if ((*ptr1) != 'a' || (*ptr2) != 'x' || (*ptr3) != 'b' ||
f011337b:	3c 79                	cmp    $0x79,%al
f011337d:	75 12                	jne    f0113391 <test_cut_paste_pages+0x9be>
				(*ptr4) != 'y'|| (*ptr5) != 'c'|| (*ptr6) != 'z')
f011337f:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113382:	8a 00                	mov    (%eax),%al
f0113384:	3c 63                	cmp    $0x63,%al
f0113386:	75 09                	jne    f0113391 <test_cut_paste_pages+0x9be>
f0113388:	8b 45 94             	mov    -0x6c(%ebp),%eax
f011338b:	8a 00                	mov    (%eax),%al
f011338d:	3c 7a                	cmp    $0x7a,%al
f011338f:	74 28                	je     f01133b9 <test_cut_paste_pages+0x9e6>
		{
			correct = 0;
f0113391:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chk_cntnt = 0;
f0113398:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			warn("[EVAL] cut_paste_pages: Failed (content is not correct)\n");
f011339f:	83 ec 04             	sub    $0x4,%esp
f01133a2:	68 b0 39 13 f0       	push   $0xf01339b0
f01133a7:	68 12 03 00 00       	push   $0x312
f01133ac:	68 d2 30 13 f0       	push   $0xf01330d2
f01133b1:	e8 9e dd fe ff       	call   f0101154 <_warn>
f01133b6:	83 c4 10             	add    $0x10,%esp
		}
		if (correct) eval += 5 ;
f01133b9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01133bd:	74 04                	je     f01133c3 <test_cut_paste_pages+0x9f0>
f01133bf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01133c3:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	}

	cprintf("CASE II: END\n") ;
f01133ca:	83 ec 0c             	sub    $0xc,%esp
f01133cd:	68 e9 3a 13 f0       	push   $0xf0133ae9
f01133d2:	e8 85 e8 fe ff       	call   f0101c5c <cprintf>
f01133d7:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] cut_paste_pages: FINISHED. Evaluation = %d\n", eval);
f01133da:	83 ec 08             	sub    $0x8,%esp
f01133dd:	ff 75 e4             	pushl  -0x1c(%ebp)
f01133e0:	68 f8 3a 13 f0       	push   $0xf0133af8
f01133e5:	e8 72 e8 fe ff       	call   f0101c5c <cprintf>
f01133ea:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01133ed:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01133f1:	75 10                	jne    f0113403 <test_cut_paste_pages+0xa30>
		cprintf("Congratulations!! test cut_paste_pages completed successfully.\n");
f01133f3:	83 ec 0c             	sub    $0xc,%esp
f01133f6:	68 2c 3b 13 f0       	push   $0xf0133b2c
f01133fb:	e8 5c e8 fe ff       	call   f0101c5c <cprintf>
f0113400:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0113403:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0113408:	89 45 d0             	mov    %eax,-0x30(%ebp)
f011340b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011340e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0113411:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0113416:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0113419:	5b                   	pop    %ebx
f011341a:	5e                   	pop    %esi
f011341b:	5f                   	pop    %edi
f011341c:	5d                   	pop    %ebp
f011341d:	c3                   	ret    

f011341e <test_copy_paste_chunk>:

//===============================
// 2) TEST COPY-PASTE CHUNK:
//===============================
int test_copy_paste_chunk()
{
f011341e:	55                   	push   %ebp
f011341f:	89 e5                	mov    %esp,%ebp
f0113421:	57                   	push   %edi
f0113422:	56                   	push   %esi
f0113423:	53                   	push   %ebx
f0113424:	81 ec ac 05 00 00    	sub    $0x5ac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f011342a:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f0113430:	bb 6c 3b 13 f0       	mov    $0xf0133b6c,%ebx
f0113435:	ba 0f 00 00 00       	mov    $0xf,%edx
f011343a:	89 c7                	mov    %eax,%edi
f011343c:	89 de                	mov    %ebx,%esi
f011343e:	89 d1                	mov    %edx,%ecx
f0113440:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113442:	8d 95 51 ff ff ff    	lea    -0xaf(%ebp),%edx
f0113448:	b9 23 00 00 00       	mov    $0x23,%ecx
f011344d:	b0 00                	mov    $0x0,%al
f011344f:	89 d7                	mov    %edx,%edi
f0113451:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0113453:	6a 00                	push   $0x0
f0113455:	6a 0a                	push   $0xa
f0113457:	6a 14                	push   $0x14
f0113459:	8d 85 42 ff ff ff    	lea    -0xbe(%ebp),%eax
f011345f:	50                   	push   %eax
f0113460:	e8 fc 7a ff ff       	call   f010af61 <env_create>
f0113465:	83 c4 10             	add    $0x10,%esp
f0113468:	89 45 d8             	mov    %eax,-0x28(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011346b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011346e:	8b 40 64             	mov    0x64(%eax),%eax
f0113471:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	lcr3(env->env_cr3) ;
f0113474:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0113477:	8b 40 68             	mov    0x68(%eax),%eax
f011347a:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%ebp)
f0113480:	8b 85 74 ff ff ff    	mov    -0x8c(%ebp),%eax
f0113486:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f0113489:	c7 85 2e ff ff ff 61 	movl   $0x20707561,-0xd2(%ebp)
f0113490:	75 70 20 
f0113493:	c7 85 32 ff ff ff 00 	movl   $0x0,-0xce(%ebp)
f011349a:	00 00 00 
f011349d:	8d 95 36 ff ff ff    	lea    -0xca(%ebp),%edx
f01134a3:	b9 03 00 00 00       	mov    $0x3,%ecx
f01134a8:	b8 00 00 00 00       	mov    $0x0,%eax
f01134ad:	89 d7                	mov    %edx,%edi
f01134af:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01134b1:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01134b4:	8b 40 10             	mov    0x10(%eax),%eax
f01134b7:	83 ec 08             	sub    $0x8,%esp
f01134ba:	8d 95 1a ff ff ff    	lea    -0xe6(%ebp),%edx
f01134c0:	52                   	push   %edx
f01134c1:	50                   	push   %eax
f01134c2:	e8 09 7c 00 00       	call   f011b0d0 <ltostr>
f01134c7:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01134ca:	83 ec 04             	sub    $0x4,%esp
f01134cd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01134d3:	50                   	push   %eax
f01134d4:	8d 85 1a ff ff ff    	lea    -0xe6(%ebp),%eax
f01134da:	50                   	push   %eax
f01134db:	8d 85 2e ff ff ff    	lea    -0xd2(%ebp),%eax
f01134e1:	50                   	push   %eax
f01134e2:	e8 c2 7c 00 00       	call   f011b1a9 <strcconcat>
f01134e7:	83 c4 10             	add    $0x10,%esp
	//===================================================

	ClearUserSpace(proc_directory);
f01134ea:	83 ec 0c             	sub    $0xc,%esp
f01134ed:	ff 75 d4             	pushl  -0x2c(%ebp)
f01134f0:	e8 49 3b 00 00       	call   f011703e <ClearUserSpace>
f01134f5:	83 c4 10             	add    $0x10,%esp
	int numOfArgs = 0;
f01134f8:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
	char *args[MAX_ARGUMENTS] ;
	uint32 res =0;
f01134ff:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint32 eval = 0; int correct = 1 ;
f0113506:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f011350d:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter ;
	char *ch1, *ch2, *ch3, *ch4, *ch5, *ch6, *ch7,*ch8, *ch9, *ch10, *ch11, *ch12 ;
	char tch[13];
	int kilo = 1024 ;
f0113514:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f011351b:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	/*==================================================*/
	/*PART I: Destination page(s) exist & read only 20% */
	/*==================================================*/
	cprintf("\nCASE I: Destination page(s) exist & read only [20%]\n") ;
f0113522:	83 ec 0c             	sub    $0xc,%esp
f0113525:	68 a0 3b 13 f0       	push   $0xf0133ba0
f011352a:	e8 2d e7 fe ff       	call   f0101c5c <cprintf>
f011352f:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0113532:	83 ec 04             	sub    $0x4,%esp
f0113535:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011353b:	50                   	push   %eax
f011353c:	68 d6 3b 13 f0       	push   $0xf0133bd6
f0113541:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113547:	50                   	push   %eax
f0113548:	e8 5c 7c 00 00       	call   f011b1a9 <strcconcat>
f011354d:	83 c4 10             	add    $0x10,%esp
f0113550:	83 ec 0c             	sub    $0xc,%esp
f0113553:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113559:	50                   	push   %eax
f011355a:	e8 bc e9 fe ff       	call   f0101f1b <execute_command>
f011355f:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x1000", c1); execute_command(c1);
f0113562:	83 ec 04             	sub    $0x4,%esp
f0113565:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f011356b:	50                   	push   %eax
f011356c:	68 db 3b 13 f0       	push   $0xf0133bdb
f0113571:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113577:	50                   	push   %eax
f0113578:	e8 2c 7c 00 00       	call   f011b1a9 <strcconcat>
f011357d:	83 c4 10             	add    $0x10,%esp
f0113580:	83 ec 0c             	sub    $0xc,%esp
f0113583:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113589:	50                   	push   %eax
f011358a:	e8 8c e9 fe ff       	call   f0101f1b <execute_command>
f011358f:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x000000 a";execute_command(c2);
f0113592:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113598:	bb e1 3e 13 f0       	mov    $0xf0133ee1,%ebx
f011359d:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135a2:	89 c7                	mov    %eax,%edi
f01135a4:	89 de                	mov    %ebx,%esi
f01135a6:	89 d1                	mov    %edx,%ecx
f01135a8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135aa:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f01135b0:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135b5:	b0 00                	mov    $0x0,%al
f01135b7:	89 d7                	mov    %edx,%edi
f01135b9:	f3 aa                	rep stos %al,%es:(%edi)
f01135bb:	83 ec 0c             	sub    $0xc,%esp
f01135be:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f01135c4:	50                   	push   %eax
f01135c5:	e8 51 e9 fe ff       	call   f0101f1b <execute_command>
f01135ca:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x0007FF b";execute_command(c3);
f01135cd:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01135d3:	bb 45 3f 13 f0       	mov    $0xf0133f45,%ebx
f01135d8:	ba 0f 00 00 00       	mov    $0xf,%edx
f01135dd:	89 c7                	mov    %eax,%edi
f01135df:	89 de                	mov    %ebx,%esi
f01135e1:	89 d1                	mov    %edx,%ecx
f01135e3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01135e5:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f01135eb:	b9 55 00 00 00       	mov    $0x55,%ecx
f01135f0:	b0 00                	mov    $0x0,%al
f01135f2:	89 d7                	mov    %edx,%edi
f01135f4:	f3 aa                	rep stos %al,%es:(%edi)
f01135f6:	83 ec 0c             	sub    $0xc,%esp
f01135f9:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f01135ff:	50                   	push   %eax
f0113600:	e8 16 e9 fe ff       	call   f0101f1b <execute_command>
f0113605:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x000FFF c";execute_command(c4);
f0113608:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011360e:	bb a9 3f 13 f0       	mov    $0xf0133fa9,%ebx
f0113613:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113618:	89 c7                	mov    %eax,%edi
f011361a:	89 de                	mov    %ebx,%esi
f011361c:	89 d1                	mov    %edx,%ecx
f011361e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113620:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113626:	b9 55 00 00 00       	mov    $0x55,%ecx
f011362b:	b0 00                	mov    $0x0,%al
f011362d:	89 d7                	mov    %edx,%edi
f011362f:	f3 aa                	rep stos %al,%es:(%edi)
f0113631:	83 ec 0c             	sub    $0xc,%esp
f0113634:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f011363a:	50                   	push   %eax
f011363b:	e8 db e8 fe ff       	call   f0101f1b <execute_command>
f0113640:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x001000 d";execute_command(c22);
f0113643:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113649:	bb 0d 40 13 f0       	mov    $0xf013400d,%ebx
f011364e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113653:	89 c7                	mov    %eax,%edi
f0113655:	89 de                	mov    %ebx,%esi
f0113657:	89 d1                	mov    %edx,%ecx
f0113659:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011365b:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113661:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113666:	b0 00                	mov    $0x0,%al
f0113668:	89 d7                	mov    %edx,%edi
f011366a:	f3 aa                	rep stos %al,%es:(%edi)
f011366c:	83 ec 0c             	sub    $0xc,%esp
f011366f:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113675:	50                   	push   %eax
f0113676:	e8 a0 e8 fe ff       	call   f0101f1b <execute_command>
f011367b:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x0017FF e";execute_command(c23);
f011367e:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113684:	bb 71 40 13 f0       	mov    $0xf0134071,%ebx
f0113689:	ba 0f 00 00 00       	mov    $0xf,%edx
f011368e:	89 c7                	mov    %eax,%edi
f0113690:	89 de                	mov    %ebx,%esi
f0113692:	89 d1                	mov    %edx,%ecx
f0113694:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113696:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f011369c:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136a1:	b0 00                	mov    $0x0,%al
f01136a3:	89 d7                	mov    %edx,%edi
f01136a5:	f3 aa                	rep stos %al,%es:(%edi)
f01136a7:	83 ec 0c             	sub    $0xc,%esp
f01136aa:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f01136b0:	50                   	push   %eax
f01136b1:	e8 65 e8 fe ff       	call   f0101f1b <execute_command>
f01136b6:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x001FFF f";execute_command(c24);
f01136b9:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01136bf:	bb d5 40 13 f0       	mov    $0xf01340d5,%ebx
f01136c4:	ba 0f 00 00 00       	mov    $0xf,%edx
f01136c9:	89 c7                	mov    %eax,%edi
f01136cb:	89 de                	mov    %ebx,%esi
f01136cd:	89 d1                	mov    %edx,%ecx
f01136cf:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01136d1:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f01136d7:	b9 55 00 00 00       	mov    $0x55,%ecx
f01136dc:	b0 00                	mov    $0x0,%al
f01136de:	89 d7                	mov    %edx,%edi
f01136e0:	f3 aa                	rep stos %al,%es:(%edi)
f01136e2:	83 ec 0c             	sub    $0xc,%esp
f01136e5:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f01136eb:	50                   	push   %eax
f01136ec:	e8 2a e8 fe ff       	call   f0101f1b <execute_command>
f01136f1:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x100000", c5); execute_command(c5);
f01136f4:	83 ec 04             	sub    $0x4,%esp
f01136f7:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01136fd:	50                   	push   %eax
f01136fe:	68 e3 3b 13 f0       	push   $0xf0133be3
f0113703:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113709:	50                   	push   %eax
f011370a:	e8 9a 7a 00 00       	call   f011b1a9 <strcconcat>
f011370f:	83 c4 10             	add    $0x10,%esp
f0113712:	83 ec 0c             	sub    $0xc,%esp
f0113715:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011371b:	50                   	push   %eax
f011371c:	e8 fa e7 fe ff       	call   f0101f1b <execute_command>
f0113721:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x101000 r", c5); execute_command(c5);
f0113724:	83 ec 04             	sub    $0x4,%esp
f0113727:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011372d:	50                   	push   %eax
f011372e:	68 ed 3b 13 f0       	push   $0xf0133bed
f0113733:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113739:	50                   	push   %eax
f011373a:	e8 6a 7a 00 00       	call   f011b1a9 <strcconcat>
f011373f:	83 c4 10             	add    $0x10,%esp
f0113742:	83 ec 0c             	sub    $0xc,%esp
f0113745:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011374b:	50                   	push   %eax
f011374c:	e8 ca e7 fe ff       	call   f0101f1b <execute_command>
f0113751:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x100000 x";execute_command(c6);
f0113754:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f011375a:	bb 39 41 13 f0       	mov    $0xf0134139,%ebx
f011375f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113764:	89 c7                	mov    %eax,%edi
f0113766:	89 de                	mov    %ebx,%esi
f0113768:	89 d1                	mov    %edx,%ecx
f011376a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011376c:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113772:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113777:	b0 00                	mov    $0x0,%al
f0113779:	89 d7                	mov    %edx,%edi
f011377b:	f3 aa                	rep stos %al,%es:(%edi)
f011377d:	83 ec 0c             	sub    $0xc,%esp
f0113780:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113786:	50                   	push   %eax
f0113787:	e8 8f e7 fe ff       	call   f0101f1b <execute_command>
f011378c:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x1007FF y";execute_command(c7);
f011378f:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113795:	bb 9d 41 13 f0       	mov    $0xf013419d,%ebx
f011379a:	ba 0f 00 00 00       	mov    $0xf,%edx
f011379f:	89 c7                	mov    %eax,%edi
f01137a1:	89 de                	mov    %ebx,%esi
f01137a3:	89 d1                	mov    %edx,%ecx
f01137a5:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137a7:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f01137ad:	b9 55 00 00 00       	mov    $0x55,%ecx
f01137b2:	b0 00                	mov    $0x0,%al
f01137b4:	89 d7                	mov    %edx,%edi
f01137b6:	f3 aa                	rep stos %al,%es:(%edi)
f01137b8:	83 ec 0c             	sub    $0xc,%esp
f01137bb:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f01137c1:	50                   	push   %eax
f01137c2:	e8 54 e7 fe ff       	call   f0101f1b <execute_command>
f01137c7:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x100FFF z";execute_command(c8);
f01137ca:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01137d0:	bb 01 42 13 f0       	mov    $0xf0134201,%ebx
f01137d5:	ba 0f 00 00 00       	mov    $0xf,%edx
f01137da:	89 c7                	mov    %eax,%edi
f01137dc:	89 de                	mov    %ebx,%esi
f01137de:	89 d1                	mov    %edx,%ecx
f01137e0:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01137e2:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f01137e8:	b9 55 00 00 00       	mov    $0x55,%ecx
f01137ed:	b0 00                	mov    $0x0,%al
f01137ef:	89 d7                	mov    %edx,%edi
f01137f1:	f3 aa                	rep stos %al,%es:(%edi)
f01137f3:	83 ec 0c             	sub    $0xc,%esp
f01137f6:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f01137fc:	50                   	push   %eax
f01137fd:	e8 19 e7 fe ff       	call   f0101f1b <execute_command>
f0113802:	83 c4 10             	add    $0x10,%esp

		ch1 = (char*)0x000000; ch2 = (char*)0x100000;
f0113805:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%ebp)
f011380c:	c7 45 b8 00 00 10 00 	movl   $0x100000,-0x48(%ebp)
		ch3 = (char*)0x0007FF; ch4 = (char*)0x1007FF;
f0113813:	c7 45 b4 ff 07 00 00 	movl   $0x7ff,-0x4c(%ebp)
f011381a:	c7 45 b0 ff 07 10 00 	movl   $0x1007ff,-0x50(%ebp)
		ch5 = (char*)0x000FFF; ch6 = (char*)0x100FFF;
f0113821:	c7 45 ac ff 0f 00 00 	movl   $0xfff,-0x54(%ebp)
f0113828:	c7 45 a8 ff 0f 10 00 	movl   $0x100fff,-0x58(%ebp)
		ch7 = (char*)0x001000; ch8 = (char*)0x101000;
f011382f:	c7 45 a4 00 10 00 00 	movl   $0x1000,-0x5c(%ebp)
f0113836:	c7 45 a0 00 10 10 00 	movl   $0x101000,-0x60(%ebp)
		ch9 = (char*)0x0017FF; ch10= (char*)0x1017FF;
f011383d:	c7 45 9c ff 17 00 00 	movl   $0x17ff,-0x64(%ebp)
f0113844:	c7 45 98 ff 17 10 00 	movl   $0x1017ff,-0x68(%ebp)
		ch11= (char*)0x001FFF; ch12= (char*)0x101FFF;
f011384b:	c7 45 94 ff 1f 00 00 	movl   $0x1fff,-0x6c(%ebp)
f0113852:	c7 45 90 ff 1f 10 00 	movl   $0x101fff,-0x70(%ebp)

		tch[8] = *ch8 ;tch[10] = *ch10 ;tch[12] = *ch12 ;
f0113859:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011385c:	8a 00                	mov    (%eax),%al
f011385e:	88 85 a3 fe ff ff    	mov    %al,-0x15d(%ebp)
f0113864:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113867:	8a 00                	mov    (%eax),%al
f0113869:	88 85 a5 fe ff ff    	mov    %al,-0x15b(%ebp)
f011386f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113872:	8a 00                	mov    (%eax),%al
f0113874:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f011387a:	e8 29 b1 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011387f:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x0, 0x100000, 6*kilo);
f0113882:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113885:	89 d0                	mov    %edx,%eax
f0113887:	01 c0                	add    %eax,%eax
f0113889:	01 d0                	add    %edx,%eax
f011388b:	01 c0                	add    %eax,%eax
f011388d:	50                   	push   %eax
f011388e:	68 00 00 10 00       	push   $0x100000
f0113893:	6a 00                	push   $0x0
f0113895:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113898:	e8 fc 73 ff ff       	call   f010ac99 <copy_paste_chunk>
f011389d:	83 c4 10             	add    $0x10,%esp
f01138a0:	89 45 88             	mov    %eax,-0x78(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01138a3:	e8 00 b1 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01138a8:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f01138ab:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != -1 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f01138b2:	83 7d 88 ff          	cmpl   $0xffffffff,-0x78(%ebp)
f01138b6:	75 08                	jne    f01138c0 <test_copy_paste_chunk+0x4a2>
f01138b8:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01138bb:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f01138be:	74 2b                	je     f01138eb <test_copy_paste_chunk+0x4cd>
		{
			warn("[EVAL] copy_paste_chunk: Failed (dest is read-only... operation should be denied) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01138c0:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01138c3:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01138c6:	83 ec 0c             	sub    $0xc,%esp
f01138c9:	50                   	push   %eax
f01138ca:	ff 75 88             	pushl  -0x78(%ebp)
f01138cd:	68 fc 3b 13 f0       	push   $0xf0133bfc
f01138d2:	68 65 03 00 00       	push   $0x365
f01138d7:	68 d2 30 13 f0       	push   $0xf01330d2
f01138dc:	e8 73 d8 fe ff       	call   f0101154 <_warn>
f01138e1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01138e4:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f01138eb:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01138ef:	74 04                	je     f01138f5 <test_copy_paste_chunk+0x4d7>
f01138f1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01138f5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'x' || *ch3 != 'b' || *ch4 != 'y' || *ch5 != 'c' || *ch6 != 'z'
f01138fc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01138ff:	8a 00                	mov    (%eax),%al
f0113901:	3c 61                	cmp    $0x61,%al
f0113903:	75 75                	jne    f011397a <test_copy_paste_chunk+0x55c>
f0113905:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113908:	8a 00                	mov    (%eax),%al
f011390a:	3c 78                	cmp    $0x78,%al
f011390c:	75 6c                	jne    f011397a <test_copy_paste_chunk+0x55c>
f011390e:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113911:	8a 00                	mov    (%eax),%al
f0113913:	3c 62                	cmp    $0x62,%al
f0113915:	75 63                	jne    f011397a <test_copy_paste_chunk+0x55c>
f0113917:	8b 45 b0             	mov    -0x50(%ebp),%eax
f011391a:	8a 00                	mov    (%eax),%al
f011391c:	3c 79                	cmp    $0x79,%al
f011391e:	75 5a                	jne    f011397a <test_copy_paste_chunk+0x55c>
f0113920:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113923:	8a 00                	mov    (%eax),%al
f0113925:	3c 63                	cmp    $0x63,%al
f0113927:	75 51                	jne    f011397a <test_copy_paste_chunk+0x55c>
f0113929:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011392c:	8a 00                	mov    (%eax),%al
f011392e:	3c 7a                	cmp    $0x7a,%al
f0113930:	75 48                	jne    f011397a <test_copy_paste_chunk+0x55c>
				||  *ch7 != 'd' || *ch8 != tch[8] || *ch9 != 'e' || *ch10 != tch[10] || *ch11!= 'f' || *ch12 != tch[12])
f0113932:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113935:	8a 00                	mov    (%eax),%al
f0113937:	3c 64                	cmp    $0x64,%al
f0113939:	75 3f                	jne    f011397a <test_copy_paste_chunk+0x55c>
f011393b:	8b 45 a0             	mov    -0x60(%ebp),%eax
f011393e:	8a 10                	mov    (%eax),%dl
f0113940:	8a 85 a3 fe ff ff    	mov    -0x15d(%ebp),%al
f0113946:	38 c2                	cmp    %al,%dl
f0113948:	75 30                	jne    f011397a <test_copy_paste_chunk+0x55c>
f011394a:	8b 45 9c             	mov    -0x64(%ebp),%eax
f011394d:	8a 00                	mov    (%eax),%al
f011394f:	3c 65                	cmp    $0x65,%al
f0113951:	75 27                	jne    f011397a <test_copy_paste_chunk+0x55c>
f0113953:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113956:	8a 10                	mov    (%eax),%dl
f0113958:	8a 85 a5 fe ff ff    	mov    -0x15b(%ebp),%al
f011395e:	38 c2                	cmp    %al,%dl
f0113960:	75 18                	jne    f011397a <test_copy_paste_chunk+0x55c>
f0113962:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113965:	8a 00                	mov    (%eax),%al
f0113967:	3c 66                	cmp    $0x66,%al
f0113969:	75 0f                	jne    f011397a <test_copy_paste_chunk+0x55c>
f011396b:	8b 45 90             	mov    -0x70(%ebp),%eax
f011396e:	8a 10                	mov    (%eax),%dl
f0113970:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113976:	38 c2                	cmp    %al,%dl
f0113978:	74 21                	je     f011399b <test_copy_paste_chunk+0x57d>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f011397a:	83 ec 04             	sub    $0x4,%esp
f011397d:	68 60 3c 13 f0       	push   $0xf0133c60
f0113982:	68 6e 03 00 00       	push   $0x36e
f0113987:	68 d2 30 13 f0       	push   $0xf01330d2
f011398c:	e8 c3 d7 fe ff       	call   f0101154 <_warn>
f0113991:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113994:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f011399b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011399f:	74 04                	je     f01139a5 <test_copy_paste_chunk+0x587>
f01139a1:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01139a5:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE I: END \n") ;
f01139ac:	83 ec 0c             	sub    $0xc,%esp
f01139af:	68 9a 3c 13 f0       	push   $0xf0133c9a
f01139b4:	e8 a3 e2 fe ff       	call   f0101c5c <cprintf>
f01139b9:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: Destination page(s) exist & writable 40% */
	/*==================================================*/
	cprintf("\nCASE II: Destination page(s) exist & writable [40%]\n") ;
f01139bc:	83 ec 0c             	sub    $0xc,%esp
f01139bf:	68 ac 3c 13 f0       	push   $0xf0133cac
f01139c4:	e8 93 e2 fe ff       	call   f0101c5c <cprintf>
f01139c9:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x200000", c1); execute_command(c1);
f01139cc:	83 ec 04             	sub    $0x4,%esp
f01139cf:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01139d5:	50                   	push   %eax
f01139d6:	68 e2 3c 13 f0       	push   $0xf0133ce2
f01139db:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01139e1:	50                   	push   %eax
f01139e2:	e8 c2 77 00 00       	call   f011b1a9 <strcconcat>
f01139e7:	83 c4 10             	add    $0x10,%esp
f01139ea:	83 ec 0c             	sub    $0xc,%esp
f01139ed:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f01139f3:	50                   	push   %eax
f01139f4:	e8 22 e5 fe ff       	call   f0101f1b <execute_command>
f01139f9:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x201000", c1); execute_command(c1);
f01139fc:	83 ec 04             	sub    $0x4,%esp
f01139ff:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113a05:	50                   	push   %eax
f0113a06:	68 ec 3c 13 f0       	push   $0xf0133cec
f0113a0b:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113a11:	50                   	push   %eax
f0113a12:	e8 92 77 00 00       	call   f011b1a9 <strcconcat>
f0113a17:	83 c4 10             	add    $0x10,%esp
f0113a1a:	83 ec 0c             	sub    $0xc,%esp
f0113a1d:	8d 85 4f fa ff ff    	lea    -0x5b1(%ebp),%eax
f0113a23:	50                   	push   %eax
f0113a24:	e8 f2 e4 fe ff       	call   f0101f1b <execute_command>
f0113a29:	83 c4 10             	add    $0x10,%esp
		/*write on 1st page*/
		char c2[100] = "wum 0x200000 a";execute_command(c2);
f0113a2c:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113a32:	bb 65 42 13 f0       	mov    $0xf0134265,%ebx
f0113a37:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a3c:	89 c7                	mov    %eax,%edi
f0113a3e:	89 de                	mov    %ebx,%esi
f0113a40:	89 d1                	mov    %edx,%ecx
f0113a42:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a44:	8d 95 c2 fa ff ff    	lea    -0x53e(%ebp),%edx
f0113a4a:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a4f:	b0 00                	mov    $0x0,%al
f0113a51:	89 d7                	mov    %edx,%edi
f0113a53:	f3 aa                	rep stos %al,%es:(%edi)
f0113a55:	83 ec 0c             	sub    $0xc,%esp
f0113a58:	8d 85 b3 fa ff ff    	lea    -0x54d(%ebp),%eax
f0113a5e:	50                   	push   %eax
f0113a5f:	e8 b7 e4 fe ff       	call   f0101f1b <execute_command>
f0113a64:	83 c4 10             	add    $0x10,%esp
		char c3[100] = "wum 0x2007FF b";execute_command(c3);
f0113a67:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113a6d:	bb c9 42 13 f0       	mov    $0xf01342c9,%ebx
f0113a72:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113a77:	89 c7                	mov    %eax,%edi
f0113a79:	89 de                	mov    %ebx,%esi
f0113a7b:	89 d1                	mov    %edx,%ecx
f0113a7d:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113a7f:	8d 95 26 fb ff ff    	lea    -0x4da(%ebp),%edx
f0113a85:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113a8a:	b0 00                	mov    $0x0,%al
f0113a8c:	89 d7                	mov    %edx,%edi
f0113a8e:	f3 aa                	rep stos %al,%es:(%edi)
f0113a90:	83 ec 0c             	sub    $0xc,%esp
f0113a93:	8d 85 17 fb ff ff    	lea    -0x4e9(%ebp),%eax
f0113a99:	50                   	push   %eax
f0113a9a:	e8 7c e4 fe ff       	call   f0101f1b <execute_command>
f0113a9f:	83 c4 10             	add    $0x10,%esp
		char c4[100] = "wum 0x200FFF c";execute_command(c4);
f0113aa2:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113aa8:	bb 2d 43 13 f0       	mov    $0xf013432d,%ebx
f0113aad:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113ab2:	89 c7                	mov    %eax,%edi
f0113ab4:	89 de                	mov    %ebx,%esi
f0113ab6:	89 d1                	mov    %edx,%ecx
f0113ab8:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113aba:	8d 95 8a fb ff ff    	lea    -0x476(%ebp),%edx
f0113ac0:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113ac5:	b0 00                	mov    $0x0,%al
f0113ac7:	89 d7                	mov    %edx,%edi
f0113ac9:	f3 aa                	rep stos %al,%es:(%edi)
f0113acb:	83 ec 0c             	sub    $0xc,%esp
f0113ace:	8d 85 7b fb ff ff    	lea    -0x485(%ebp),%eax
f0113ad4:	50                   	push   %eax
f0113ad5:	e8 41 e4 fe ff       	call   f0101f1b <execute_command>
f0113ada:	83 c4 10             	add    $0x10,%esp
		/*write on 2nd page*/
		char c22[100] = "wum 0x201000 d";execute_command(c22);
f0113add:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113ae3:	bb 91 43 13 f0       	mov    $0xf0134391,%ebx
f0113ae8:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113aed:	89 c7                	mov    %eax,%edi
f0113aef:	89 de                	mov    %ebx,%esi
f0113af1:	89 d1                	mov    %edx,%ecx
f0113af3:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113af5:	8d 95 ee fb ff ff    	lea    -0x412(%ebp),%edx
f0113afb:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b00:	b0 00                	mov    $0x0,%al
f0113b02:	89 d7                	mov    %edx,%edi
f0113b04:	f3 aa                	rep stos %al,%es:(%edi)
f0113b06:	83 ec 0c             	sub    $0xc,%esp
f0113b09:	8d 85 df fb ff ff    	lea    -0x421(%ebp),%eax
f0113b0f:	50                   	push   %eax
f0113b10:	e8 06 e4 fe ff       	call   f0101f1b <execute_command>
f0113b15:	83 c4 10             	add    $0x10,%esp
		char c23[100] = "wum 0x2017FF e";execute_command(c23);
f0113b18:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113b1e:	bb f5 43 13 f0       	mov    $0xf01343f5,%ebx
f0113b23:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b28:	89 c7                	mov    %eax,%edi
f0113b2a:	89 de                	mov    %ebx,%esi
f0113b2c:	89 d1                	mov    %edx,%ecx
f0113b2e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b30:	8d 95 52 fc ff ff    	lea    -0x3ae(%ebp),%edx
f0113b36:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b3b:	b0 00                	mov    $0x0,%al
f0113b3d:	89 d7                	mov    %edx,%edi
f0113b3f:	f3 aa                	rep stos %al,%es:(%edi)
f0113b41:	83 ec 0c             	sub    $0xc,%esp
f0113b44:	8d 85 43 fc ff ff    	lea    -0x3bd(%ebp),%eax
f0113b4a:	50                   	push   %eax
f0113b4b:	e8 cb e3 fe ff       	call   f0101f1b <execute_command>
f0113b50:	83 c4 10             	add    $0x10,%esp
		char c24[100] = "wum 0x201FFF f";execute_command(c24);
f0113b53:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113b59:	bb 59 44 13 f0       	mov    $0xf0134459,%ebx
f0113b5e:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113b63:	89 c7                	mov    %eax,%edi
f0113b65:	89 de                	mov    %ebx,%esi
f0113b67:	89 d1                	mov    %edx,%ecx
f0113b69:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113b6b:	8d 95 b6 fc ff ff    	lea    -0x34a(%ebp),%edx
f0113b71:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113b76:	b0 00                	mov    $0x0,%al
f0113b78:	89 d7                	mov    %edx,%edi
f0113b7a:	f3 aa                	rep stos %al,%es:(%edi)
f0113b7c:	83 ec 0c             	sub    $0xc,%esp
f0113b7f:	8d 85 a7 fc ff ff    	lea    -0x359(%ebp),%eax
f0113b85:	50                   	push   %eax
f0113b86:	e8 90 e3 fe ff       	call   f0101f1b <execute_command>
f0113b8b:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c5[100] ;strcconcat(aup_cmd, " 0x400000", c5); execute_command(c5);
f0113b8e:	83 ec 04             	sub    $0x4,%esp
f0113b91:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113b97:	50                   	push   %eax
f0113b98:	68 f6 3c 13 f0       	push   $0xf0133cf6
f0113b9d:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113ba3:	50                   	push   %eax
f0113ba4:	e8 00 76 00 00       	call   f011b1a9 <strcconcat>
f0113ba9:	83 c4 10             	add    $0x10,%esp
f0113bac:	83 ec 0c             	sub    $0xc,%esp
f0113baf:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113bb5:	50                   	push   %eax
f0113bb6:	e8 60 e3 fe ff       	call   f0101f1b <execute_command>
f0113bbb:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x401000", c5); execute_command(c5);
f0113bbe:	83 ec 04             	sub    $0x4,%esp
f0113bc1:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113bc7:	50                   	push   %eax
f0113bc8:	68 00 3d 13 f0       	push   $0xf0133d00
f0113bcd:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0113bd3:	50                   	push   %eax
f0113bd4:	e8 d0 75 00 00       	call   f011b1a9 <strcconcat>
f0113bd9:	83 c4 10             	add    $0x10,%esp
f0113bdc:	83 ec 0c             	sub    $0xc,%esp
f0113bdf:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f0113be5:	50                   	push   %eax
f0113be6:	e8 30 e3 fe ff       	call   f0101f1b <execute_command>
f0113beb:	83 c4 10             	add    $0x10,%esp
		char c6[100] = "wum 0x400000 x";execute_command(c6);
f0113bee:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113bf4:	bb bd 44 13 f0       	mov    $0xf01344bd,%ebx
f0113bf9:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113bfe:	89 c7                	mov    %eax,%edi
f0113c00:	89 de                	mov    %ebx,%esi
f0113c02:	89 d1                	mov    %edx,%ecx
f0113c04:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113c06:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0113c0c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113c11:	b0 00                	mov    $0x0,%al
f0113c13:	89 d7                	mov    %edx,%edi
f0113c15:	f3 aa                	rep stos %al,%es:(%edi)
f0113c17:	83 ec 0c             	sub    $0xc,%esp
f0113c1a:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0113c20:	50                   	push   %eax
f0113c21:	e8 f5 e2 fe ff       	call   f0101f1b <execute_command>
f0113c26:	83 c4 10             	add    $0x10,%esp
		char c7[100] = "wum 0x4007FF y";execute_command(c7);
f0113c29:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113c2f:	bb 21 45 13 f0       	mov    $0xf0134521,%ebx
f0113c34:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113c39:	89 c7                	mov    %eax,%edi
f0113c3b:	89 de                	mov    %ebx,%esi
f0113c3d:	89 d1                	mov    %edx,%ecx
f0113c3f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113c41:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f0113c47:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113c4c:	b0 00                	mov    $0x0,%al
f0113c4e:	89 d7                	mov    %edx,%edi
f0113c50:	f3 aa                	rep stos %al,%es:(%edi)
f0113c52:	83 ec 0c             	sub    $0xc,%esp
f0113c55:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0113c5b:	50                   	push   %eax
f0113c5c:	e8 ba e2 fe ff       	call   f0101f1b <execute_command>
f0113c61:	83 c4 10             	add    $0x10,%esp
		char c8[100] = "wum 0x400FFF z";execute_command(c8);
f0113c64:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113c6a:	bb 85 45 13 f0       	mov    $0xf0134585,%ebx
f0113c6f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0113c74:	89 c7                	mov    %eax,%edi
f0113c76:	89 de                	mov    %ebx,%esi
f0113c78:	89 d1                	mov    %edx,%ecx
f0113c7a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0113c7c:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0113c82:	b9 55 00 00 00       	mov    $0x55,%ecx
f0113c87:	b0 00                	mov    $0x0,%al
f0113c89:	89 d7                	mov    %edx,%edi
f0113c8b:	f3 aa                	rep stos %al,%es:(%edi)
f0113c8d:	83 ec 0c             	sub    $0xc,%esp
f0113c90:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f0113c96:	50                   	push   %eax
f0113c97:	e8 7f e2 fe ff       	call   f0101f1b <execute_command>
f0113c9c:	83 c4 10             	add    $0x10,%esp

		//Test1
		ch1 = (char*)0x200000; ch2 = (char*)0x400000;
f0113c9f:	c7 45 bc 00 00 20 00 	movl   $0x200000,-0x44(%ebp)
f0113ca6:	c7 45 b8 00 00 40 00 	movl   $0x400000,-0x48(%ebp)
		ch3 = (char*)0x2007FF; ch4 = (char*)0x4007FF;
f0113cad:	c7 45 b4 ff 07 20 00 	movl   $0x2007ff,-0x4c(%ebp)
f0113cb4:	c7 45 b0 ff 07 40 00 	movl   $0x4007ff,-0x50(%ebp)
		ch5 = (char*)0x200FFF; ch6 = (char*)0x400FFF;
f0113cbb:	c7 45 ac ff 0f 20 00 	movl   $0x200fff,-0x54(%ebp)
f0113cc2:	c7 45 a8 ff 0f 40 00 	movl   $0x400fff,-0x58(%ebp)
		ch7 = (char*)0x201000; ch8 = (char*)0x401000;
f0113cc9:	c7 45 a4 00 10 20 00 	movl   $0x201000,-0x5c(%ebp)
f0113cd0:	c7 45 a0 00 10 40 00 	movl   $0x401000,-0x60(%ebp)
		ch9 = (char*)0x2017FF; ch10= (char*)0x4017FF;
f0113cd7:	c7 45 9c ff 17 20 00 	movl   $0x2017ff,-0x64(%ebp)
f0113cde:	c7 45 98 ff 17 40 00 	movl   $0x4017ff,-0x68(%ebp)
		ch11= (char*)0x201FFF; ch12= (char*)0x401FFF;
f0113ce5:	c7 45 94 ff 1f 20 00 	movl   $0x201fff,-0x6c(%ebp)
f0113cec:	c7 45 90 ff 1f 40 00 	movl   $0x401fff,-0x70(%ebp)

		tch[12] = *ch12 ;
f0113cf3:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113cf6:	8a 00                	mov    (%eax),%al
f0113cf8:	88 85 a7 fe ff ff    	mov    %al,-0x159(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113cfe:	e8 a5 ac ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0113d03:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x200000, 0x400000, 6*kilo);
f0113d06:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0113d09:	89 d0                	mov    %edx,%eax
f0113d0b:	01 c0                	add    %eax,%eax
f0113d0d:	01 d0                	add    %edx,%eax
f0113d0f:	01 c0                	add    %eax,%eax
f0113d11:	50                   	push   %eax
f0113d12:	68 00 00 40 00       	push   $0x400000
f0113d17:	68 00 00 20 00       	push   $0x200000
f0113d1c:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113d1f:	e8 75 6f ff ff       	call   f010ac99 <copy_paste_chunk>
f0113d24:	83 c4 10             	add    $0x10,%esp
f0113d27:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113d2a:	e8 79 ac ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0113d2f:	89 45 84             	mov    %eax,-0x7c(%ebp)

		correct = 1 ;
f0113d32:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113d39:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113d3d:	75 08                	jne    f0113d47 <test_copy_paste_chunk+0x929>
f0113d3f:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113d42:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113d45:	74 2b                	je     f0113d72 <test_copy_paste_chunk+0x954>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113d47:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113d4a:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113d4d:	83 ec 0c             	sub    $0xc,%esp
f0113d50:	50                   	push   %eax
f0113d51:	ff 75 80             	pushl  -0x80(%ebp)
f0113d54:	68 0c 3d 13 f0       	push   $0xf0133d0c
f0113d59:	68 9e 03 00 00       	push   $0x39e
f0113d5e:	68 d2 30 13 f0       	push   $0xf01330d2
f0113d63:	e8 ec d3 fe ff       	call   f0101154 <_warn>
f0113d68:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113d6b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113d72:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113d76:	74 04                	je     f0113d7c <test_copy_paste_chunk+0x95e>
f0113d78:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113d7c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1;
f0113d83:	c7 85 7c ff ff ff 01 	movl   $0x1,-0x84(%ebp)
f0113d8a:	00 00 00 
		if (CCP(proc_directory, 0x200000, 0x400000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113d8d:	83 ec 08             	sub    $0x8,%esp
f0113d90:	6a 01                	push   $0x1
f0113d92:	6a 07                	push   $0x7
f0113d94:	6a 07                	push   $0x7
f0113d96:	6a 07                	push   $0x7
f0113d98:	6a 07                	push   $0x7
f0113d9a:	6a 01                	push   $0x1
f0113d9c:	68 00 20 00 00       	push   $0x2000
f0113da1:	68 00 00 40 00       	push   $0x400000
f0113da6:	68 00 00 20 00       	push   $0x200000
f0113dab:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113dae:	e8 bf 32 00 00       	call   f0117072 <CCP>
f0113db3:	83 c4 30             	add    $0x30,%esp
f0113db6:	83 f8 01             	cmp    $0x1,%eax
f0113db9:	74 2b                	je     f0113de6 <test_copy_paste_chunk+0x9c8>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references)\n");
f0113dbb:	83 ec 04             	sub    $0x4,%esp
f0113dbe:	68 60 3d 13 f0       	push   $0xf0133d60
f0113dc3:	68 a7 03 00 00       	push   $0x3a7
f0113dc8:	68 d2 30 13 f0       	push   $0xf01330d2
f0113dcd:	e8 82 d3 fe ff       	call   f0101154 <_warn>
f0113dd2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113dd5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0;
f0113ddc:	c7 85 7c ff ff ff 00 	movl   $0x0,-0x84(%ebp)
f0113de3:	00 00 00 
		}
		if (correct) eval += 5 ;
f0113de6:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113dea:	74 04                	je     f0113df0 <test_copy_paste_chunk+0x9d2>
f0113dec:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113df0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		*ch3 = 'y' ;	// wum 0x2007FF y
f0113df7:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113dfa:	c6 00 79             	movb   $0x79,(%eax)
		*ch6 = 'z' ;	// wum 0x400FFF z
f0113dfd:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113e00:	c6 00 7a             	movb   $0x7a,(%eax)
		*ch7 = 'w' ;	// wum 0x201000 w
f0113e03:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113e06:	c6 00 77             	movb   $0x77,(%eax)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z'
f0113e09:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113e0c:	8a 00                	mov    (%eax),%al
f0113e0e:	3c 61                	cmp    $0x61,%al
f0113e10:	75 69                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e12:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113e15:	8a 00                	mov    (%eax),%al
f0113e17:	3c 61                	cmp    $0x61,%al
f0113e19:	75 60                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e1b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113e1e:	8a 00                	mov    (%eax),%al
f0113e20:	3c 79                	cmp    $0x79,%al
f0113e22:	75 57                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e24:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113e27:	8a 00                	mov    (%eax),%al
f0113e29:	3c 62                	cmp    $0x62,%al
f0113e2b:	75 4e                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e2d:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113e30:	8a 00                	mov    (%eax),%al
f0113e32:	3c 63                	cmp    $0x63,%al
f0113e34:	75 45                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e36:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113e39:	8a 00                	mov    (%eax),%al
f0113e3b:	3c 7a                	cmp    $0x7a,%al
f0113e3d:	75 3c                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
				||  *ch7 != 'w' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'e' || *ch11!= 'f' || *ch12 != tch[12])
f0113e3f:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113e42:	8a 00                	mov    (%eax),%al
f0113e44:	3c 77                	cmp    $0x77,%al
f0113e46:	75 33                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e48:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113e4b:	8a 00                	mov    (%eax),%al
f0113e4d:	3c 64                	cmp    $0x64,%al
f0113e4f:	75 2a                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e51:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113e54:	8a 00                	mov    (%eax),%al
f0113e56:	3c 65                	cmp    $0x65,%al
f0113e58:	75 21                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e5a:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113e5d:	8a 00                	mov    (%eax),%al
f0113e5f:	3c 65                	cmp    $0x65,%al
f0113e61:	75 18                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e63:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113e66:	8a 00                	mov    (%eax),%al
f0113e68:	3c 66                	cmp    $0x66,%al
f0113e6a:	75 0f                	jne    f0113e7b <test_copy_paste_chunk+0xa5d>
f0113e6c:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113e6f:	8a 10                	mov    (%eax),%dl
f0113e71:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113e77:	38 c2                	cmp    %al,%dl
f0113e79:	74 21                	je     f0113e9c <test_copy_paste_chunk+0xa7e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0113e7b:	83 ec 04             	sub    $0x4,%esp
f0113e7e:	68 60 3c 13 f0       	push   $0xf0133c60
f0113e83:	68 b5 03 00 00       	push   $0x3b5
f0113e88:	68 d2 30 13 f0       	push   $0xf01330d2
f0113e8d:	e8 c2 d2 fe ff       	call   f0101154 <_warn>
f0113e92:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113e95:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0113e9c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113ea0:	74 04                	je     f0113ea6 <test_copy_paste_chunk+0xa88>
f0113ea2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0113ea6:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		//Test2
		*ch10 = 'x';	// wum 0x4017FF y
f0113ead:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113eb0:	c6 00 78             	movb   $0x78,(%eax)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0113eb3:	e8 f0 aa ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0113eb8:	89 45 8c             	mov    %eax,-0x74(%ebp)

		ret = copy_paste_chunk(proc_directory, 0x400800, 0x200800, 3*kilo);
f0113ebb:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0113ebe:	89 c2                	mov    %eax,%edx
f0113ec0:	01 d2                	add    %edx,%edx
f0113ec2:	01 d0                	add    %edx,%eax
f0113ec4:	50                   	push   %eax
f0113ec5:	68 00 08 20 00       	push   $0x200800
f0113eca:	68 00 08 40 00       	push   $0x400800
f0113ecf:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113ed2:	e8 c2 6d ff ff       	call   f010ac99 <copy_paste_chunk>
f0113ed7:	83 c4 10             	add    $0x10,%esp
f0113eda:	89 45 80             	mov    %eax,-0x80(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0113edd:	e8 c6 aa ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0113ee2:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || numOfFreeFramesBefore != numOfFreeFramesAfter)
f0113ee5:	83 7d 80 00          	cmpl   $0x0,-0x80(%ebp)
f0113ee9:	75 08                	jne    f0113ef3 <test_copy_paste_chunk+0xad5>
f0113eeb:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113eee:	3b 45 84             	cmp    -0x7c(%ebp),%eax
f0113ef1:	74 2b                	je     f0113f1e <test_copy_paste_chunk+0xb00>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0113ef3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f0113ef6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f0113ef9:	83 ec 0c             	sub    $0xc,%esp
f0113efc:	50                   	push   %eax
f0113efd:	ff 75 80             	pushl  -0x80(%ebp)
f0113f00:	68 0c 3d 13 f0       	push   $0xf0133d0c
f0113f05:	68 c5 03 00 00       	push   $0x3c5
f0113f0a:	68 d2 30 13 f0       	push   $0xf01330d2
f0113f0f:	e8 40 d2 fe ff       	call   f0101154 <_warn>
f0113f14:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0113f17:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113f1e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f22:	74 04                	je     f0113f28 <test_copy_paste_chunk+0xb0a>
f0113f24:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f28:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (CCP(proc_directory, 0x400000, 0x200000, 2*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0113f2f:	83 ec 08             	sub    $0x8,%esp
f0113f32:	6a 01                	push   $0x1
f0113f34:	6a 07                	push   $0x7
f0113f36:	6a 07                	push   $0x7
f0113f38:	6a 07                	push   $0x7
f0113f3a:	6a 07                	push   $0x7
f0113f3c:	6a 01                	push   $0x1
f0113f3e:	68 00 20 00 00       	push   $0x2000
f0113f43:	68 00 00 20 00       	push   $0x200000
f0113f48:	68 00 00 40 00       	push   $0x400000
f0113f4d:	ff 75 d4             	pushl  -0x2c(%ebp)
f0113f50:	e8 1d 31 00 00       	call   f0117072 <CCP>
f0113f55:	83 c4 30             	add    $0x30,%esp
f0113f58:	83 f8 01             	cmp    $0x1,%eax
f0113f5b:	74 21                	je     f0113f7e <test_copy_paste_chunk+0xb60>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0113f5d:	83 ec 04             	sub    $0x4,%esp
f0113f60:	68 ac 3d 13 f0       	push   $0xf0133dac
f0113f65:	68 cd 03 00 00       	push   $0x3cd
f0113f6a:	68 d2 30 13 f0       	push   $0xf01330d2
f0113f6f:	e8 e0 d1 fe ff       	call   f0101154 <_warn>
f0113f74:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0113f77:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f0113f7e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0113f82:	74 04                	je     f0113f88 <test_copy_paste_chunk+0xb6a>
f0113f84:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0113f88:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113f8f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0113f92:	8a 00                	mov    (%eax),%al
f0113f94:	3c 61                	cmp    $0x61,%al
f0113f96:	75 69                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113f98:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0113f9b:	8a 00                	mov    (%eax),%al
f0113f9d:	3c 61                	cmp    $0x61,%al
f0113f9f:	75 60                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113fa1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0113fa4:	8a 00                	mov    (%eax),%al
f0113fa6:	3c 79                	cmp    $0x79,%al
f0113fa8:	75 57                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113faa:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0113fad:	8a 00                	mov    (%eax),%al
f0113faf:	3c 62                	cmp    $0x62,%al
f0113fb1:	75 4e                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113fb3:	8b 45 ac             	mov    -0x54(%ebp),%eax
f0113fb6:	8a 00                	mov    (%eax),%al
f0113fb8:	3c 7a                	cmp    $0x7a,%al
f0113fba:	75 45                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113fbc:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0113fbf:	8a 00                	mov    (%eax),%al
f0113fc1:	3c 7a                	cmp    $0x7a,%al
f0113fc3:	75 3c                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113fc5:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f0113fc8:	8a 00                	mov    (%eax),%al
			correct = 0;
		}
		if (correct) eval += 5 ;
		correct = 1 ;

		if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'z' || *ch6 != 'z' ||
f0113fca:	3c 64                	cmp    $0x64,%al
f0113fcc:	75 33                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
				*ch7 != 'd' || *ch8 != 'd' || *ch9 != 'e' || *ch10!= 'x' || *ch11!= 'f'  || *ch12 != tch[12])
f0113fce:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0113fd1:	8a 00                	mov    (%eax),%al
f0113fd3:	3c 64                	cmp    $0x64,%al
f0113fd5:	75 2a                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113fd7:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0113fda:	8a 00                	mov    (%eax),%al
f0113fdc:	3c 65                	cmp    $0x65,%al
f0113fde:	75 21                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113fe0:	8b 45 98             	mov    -0x68(%ebp),%eax
f0113fe3:	8a 00                	mov    (%eax),%al
f0113fe5:	3c 78                	cmp    $0x78,%al
f0113fe7:	75 18                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113fe9:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0113fec:	8a 00                	mov    (%eax),%al
f0113fee:	3c 66                	cmp    $0x66,%al
f0113ff0:	75 0f                	jne    f0114001 <test_copy_paste_chunk+0xbe3>
f0113ff2:	8b 45 90             	mov    -0x70(%ebp),%eax
f0113ff5:	8a 10                	mov    (%eax),%dl
f0113ff7:	8a 85 a7 fe ff ff    	mov    -0x159(%ebp),%al
f0113ffd:	38 c2                	cmp    %al,%dl
f0113fff:	74 21                	je     f0114022 <test_copy_paste_chunk+0xc04>
		{
			warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114001:	83 ec 04             	sub    $0x4,%esp
f0114004:	68 60 3c 13 f0       	push   $0xf0133c60
f0114009:	68 d6 03 00 00       	push   $0x3d6
f011400e:	68 d2 30 13 f0       	push   $0xf01330d2
f0114013:	e8 3c d1 fe ff       	call   f0101154 <_warn>
f0114018:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011401b:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 10 ;
f0114022:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114026:	74 04                	je     f011402c <test_copy_paste_chunk+0xc0e>
f0114028:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011402c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

	}
	cprintf("\nCASE II: END\n") ;
f0114033:	83 ec 0c             	sub    $0xc,%esp
f0114036:	68 f7 3d 13 f0       	push   $0xf0133df7
f011403b:	e8 1c dc fe ff       	call   f0101c5c <cprintf>
f0114040:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART III: Destination page(s) doesn't exist 40% */
	/*================================================*/
	cprintf("\nCASE III: Destination page(s) doesn't exist [40%]\n") ;
f0114043:	83 ec 0c             	sub    $0xc,%esp
f0114046:	68 08 3e 13 f0       	push   $0xf0133e08
f011404b:	e8 0c dc fe ff       	call   f0101c5c <cprintf>
f0114050:	83 c4 10             	add    $0x10,%esp
	{
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x800000", c1); execute_command(c1);
f0114053:	83 ec 04             	sub    $0x4,%esp
f0114056:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011405c:	50                   	push   %eax
f011405d:	68 3c 3e 13 f0       	push   $0xf0133e3c
f0114062:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114068:	50                   	push   %eax
f0114069:	e8 3b 71 00 00       	call   f011b1a9 <strcconcat>
f011406e:	83 c4 10             	add    $0x10,%esp
f0114071:	83 ec 0c             	sub    $0xc,%esp
f0114074:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011407a:	50                   	push   %eax
f011407b:	e8 9b de fe ff       	call   f0101f1b <execute_command>
f0114080:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x801000", c1); execute_command(c1);
f0114083:	83 ec 04             	sub    $0x4,%esp
f0114086:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f011408c:	50                   	push   %eax
f011408d:	68 46 3e 13 f0       	push   $0xf0133e46
f0114092:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f0114098:	50                   	push   %eax
f0114099:	e8 0b 71 00 00       	call   f011b1a9 <strcconcat>
f011409e:	83 c4 10             	add    $0x10,%esp
f01140a1:	83 ec 0c             	sub    $0xc,%esp
f01140a4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01140aa:	50                   	push   %eax
f01140ab:	e8 6b de fe ff       	call   f0101f1b <execute_command>
f01140b0:	83 c4 10             	add    $0x10,%esp
		/*allocate another page ====*/ strcconcat(aup_cmd, " 0x802000", c1); execute_command(c1);
f01140b3:	83 ec 04             	sub    $0x4,%esp
f01140b6:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01140bc:	50                   	push   %eax
f01140bd:	68 50 3e 13 f0       	push   $0xf0133e50
f01140c2:	8d 85 e8 fe ff ff    	lea    -0x118(%ebp),%eax
f01140c8:	50                   	push   %eax
f01140c9:	e8 db 70 00 00       	call   f011b1a9 <strcconcat>
f01140ce:	83 c4 10             	add    $0x10,%esp
f01140d1:	83 ec 0c             	sub    $0xc,%esp
f01140d4:	8d 85 0b fd ff ff    	lea    -0x2f5(%ebp),%eax
f01140da:	50                   	push   %eax
f01140db:	e8 3b de fe ff       	call   f0101f1b <execute_command>
f01140e0:	83 c4 10             	add    $0x10,%esp
		char c14[100] = "wum 0x800000 a"; execute_command(c14);
f01140e3:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f01140e9:	bb e9 45 13 f0       	mov    $0xf01345e9,%ebx
f01140ee:	ba 0f 00 00 00       	mov    $0xf,%edx
f01140f3:	89 c7                	mov    %eax,%edi
f01140f5:	89 de                	mov    %ebx,%esi
f01140f7:	89 d1                	mov    %edx,%ecx
f01140f9:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01140fb:	8d 95 7e fd ff ff    	lea    -0x282(%ebp),%edx
f0114101:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114106:	b0 00                	mov    $0x0,%al
f0114108:	89 d7                	mov    %edx,%edi
f011410a:	f3 aa                	rep stos %al,%es:(%edi)
f011410c:	83 ec 0c             	sub    $0xc,%esp
f011410f:	8d 85 6f fd ff ff    	lea    -0x291(%ebp),%eax
f0114115:	50                   	push   %eax
f0114116:	e8 00 de fe ff       	call   f0101f1b <execute_command>
f011411b:	83 c4 10             	add    $0x10,%esp
		char c15[100] = "wum 0x8017FF b"; execute_command(c15);
f011411e:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114124:	bb 4d 46 13 f0       	mov    $0xf013464d,%ebx
f0114129:	ba 0f 00 00 00       	mov    $0xf,%edx
f011412e:	89 c7                	mov    %eax,%edi
f0114130:	89 de                	mov    %ebx,%esi
f0114132:	89 d1                	mov    %edx,%ecx
f0114134:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114136:	8d 95 e2 fd ff ff    	lea    -0x21e(%ebp),%edx
f011413c:	b9 55 00 00 00       	mov    $0x55,%ecx
f0114141:	b0 00                	mov    $0x0,%al
f0114143:	89 d7                	mov    %edx,%edi
f0114145:	f3 aa                	rep stos %al,%es:(%edi)
f0114147:	83 ec 0c             	sub    $0xc,%esp
f011414a:	8d 85 d3 fd ff ff    	lea    -0x22d(%ebp),%eax
f0114150:	50                   	push   %eax
f0114151:	e8 c5 dd fe ff       	call   f0101f1b <execute_command>
f0114156:	83 c4 10             	add    $0x10,%esp
		char c16[100] = "wum 0x802FFF c"; execute_command(c16);
f0114159:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011415f:	bb b1 46 13 f0       	mov    $0xf01346b1,%ebx
f0114164:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114169:	89 c7                	mov    %eax,%edi
f011416b:	89 de                	mov    %ebx,%esi
f011416d:	89 d1                	mov    %edx,%ecx
f011416f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114171:	8d 95 46 fe ff ff    	lea    -0x1ba(%ebp),%edx
f0114177:	b9 55 00 00 00       	mov    $0x55,%ecx
f011417c:	b0 00                	mov    $0x0,%al
f011417e:	89 d7                	mov    %edx,%edi
f0114180:	f3 aa                	rep stos %al,%es:(%edi)
f0114182:	83 ec 0c             	sub    $0xc,%esp
f0114185:	8d 85 37 fe ff ff    	lea    -0x1c9(%ebp),%eax
f011418b:	50                   	push   %eax
f011418c:	e8 8a dd fe ff       	call   f0101f1b <execute_command>
f0114191:	83 c4 10             	add    $0x10,%esp

		//Test3
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114194:	e8 0f a8 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114199:	89 45 8c             	mov    %eax,-0x74(%ebp)

		int ret = copy_paste_chunk(proc_directory, 0x800000, 0x900000, 12*kilo);
f011419c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011419f:	89 d0                	mov    %edx,%eax
f01141a1:	01 c0                	add    %eax,%eax
f01141a3:	01 d0                	add    %edx,%eax
f01141a5:	c1 e0 02             	shl    $0x2,%eax
f01141a8:	50                   	push   %eax
f01141a9:	68 00 00 90 00       	push   $0x900000
f01141ae:	68 00 00 80 00       	push   $0x800000
f01141b3:	ff 75 d4             	pushl  -0x2c(%ebp)
f01141b6:	e8 de 6a ff ff       	call   f010ac99 <copy_paste_chunk>
f01141bb:	83 c4 10             	add    $0x10,%esp
f01141be:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f01141c4:	e8 df a7 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01141c9:	89 45 84             	mov    %eax,-0x7c(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f01141cc:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f01141d3:	75 0b                	jne    f01141e0 <test_copy_paste_chunk+0xdc2>
f01141d5:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01141d8:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01141db:	83 f8 03             	cmp    $0x3,%eax
f01141de:	74 2e                	je     f011420e <test_copy_paste_chunk+0xdf0>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01141e0:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01141e3:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01141e6:	83 ec 0c             	sub    $0xc,%esp
f01141e9:	50                   	push   %eax
f01141ea:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01141f0:	68 0c 3d 13 f0       	push   $0xf0133d0c
f01141f5:	68 f4 03 00 00       	push   $0x3f4
f01141fa:	68 d2 30 13 f0       	push   $0xf01330d2
f01141ff:	e8 50 cf fe ff       	call   f0101154 <_warn>
f0114204:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114207:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f011420e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114212:	74 04                	je     f0114218 <test_copy_paste_chunk+0xdfa>
f0114214:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114218:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		int chkcnt = 1 ;
f011421f:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x800000, 0x900000, 3*PAGE_SIZE, 1, 0x007, 0x007, 0x007, 0x007, CHK_COPY_PASTE) != 1)
f0114226:	83 ec 08             	sub    $0x8,%esp
f0114229:	6a 01                	push   $0x1
f011422b:	6a 07                	push   $0x7
f011422d:	6a 07                	push   $0x7
f011422f:	6a 07                	push   $0x7
f0114231:	6a 07                	push   $0x7
f0114233:	6a 01                	push   $0x1
f0114235:	68 00 30 00 00       	push   $0x3000
f011423a:	68 00 00 90 00       	push   $0x900000
f011423f:	68 00 00 80 00       	push   $0x800000
f0114244:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114247:	e8 26 2e 00 00       	call   f0117072 <CCP>
f011424c:	83 c4 30             	add    $0x30,%esp
f011424f:	83 f8 01             	cmp    $0x1,%eax
f0114252:	74 28                	je     f011427c <test_copy_paste_chunk+0xe5e>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114254:	83 ec 04             	sub    $0x4,%esp
f0114257:	68 ac 3d 13 f0       	push   $0xf0133dac
f011425c:	68 fd 03 00 00       	push   $0x3fd
f0114261:	68 d2 30 13 f0       	push   $0xf01330d2
f0114266:	e8 e9 ce fe ff       	call   f0101154 <_warn>
f011426b:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011426e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114275:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 5 ;
f011427c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114280:	74 04                	je     f0114286 <test_copy_paste_chunk+0xe68>
f0114282:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114286:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f011428d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114291:	0f 84 9e 00 00 00    	je     f0114335 <test_copy_paste_chunk+0xf17>
		{
			ch1 = (char*)0x800000; ch2 = (char*)0x900000;
f0114297:	c7 45 bc 00 00 80 00 	movl   $0x800000,-0x44(%ebp)
f011429e:	c7 45 b8 00 00 90 00 	movl   $0x900000,-0x48(%ebp)
			ch3 = (char*)0x8017FF; ch4 = (char*)0x9017FF;
f01142a5:	c7 45 b4 ff 17 80 00 	movl   $0x8017ff,-0x4c(%ebp)
f01142ac:	c7 45 b0 ff 17 90 00 	movl   $0x9017ff,-0x50(%ebp)
			ch5 = (char*)0x802FFF; ch6 = (char*)0x902FFF;
f01142b3:	c7 45 ac ff 2f 80 00 	movl   $0x802fff,-0x54(%ebp)
f01142ba:	c7 45 a8 ff 2f 90 00 	movl   $0x902fff,-0x58(%ebp)

			*ch3 = 'y';	//wum 0x8017FF y
f01142c1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01142c4:	c6 00 79             	movb   $0x79,(%eax)
			*ch6 = 'z';	//wum 0x902FFF z
f01142c7:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01142ca:	c6 00 7a             	movb   $0x7a,(%eax)

			if (*ch1 != 'a' || *ch2 != 'a' || *ch3 != 'y' || *ch4 != 'b' || *ch5 != 'c' || *ch6 != 'z')
f01142cd:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01142d0:	8a 00                	mov    (%eax),%al
f01142d2:	3c 61                	cmp    $0x61,%al
f01142d4:	75 2d                	jne    f0114303 <test_copy_paste_chunk+0xee5>
f01142d6:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01142d9:	8a 00                	mov    (%eax),%al
f01142db:	3c 61                	cmp    $0x61,%al
f01142dd:	75 24                	jne    f0114303 <test_copy_paste_chunk+0xee5>
f01142df:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01142e2:	8a 00                	mov    (%eax),%al
f01142e4:	3c 79                	cmp    $0x79,%al
f01142e6:	75 1b                	jne    f0114303 <test_copy_paste_chunk+0xee5>
f01142e8:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01142eb:	8a 00                	mov    (%eax),%al
f01142ed:	3c 62                	cmp    $0x62,%al
f01142ef:	75 12                	jne    f0114303 <test_copy_paste_chunk+0xee5>
f01142f1:	8b 45 ac             	mov    -0x54(%ebp),%eax
f01142f4:	8a 00                	mov    (%eax),%al
f01142f6:	3c 63                	cmp    $0x63,%al
f01142f8:	75 09                	jne    f0114303 <test_copy_paste_chunk+0xee5>
f01142fa:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01142fd:	8a 00                	mov    (%eax),%al
f01142ff:	3c 7a                	cmp    $0x7a,%al
f0114301:	74 21                	je     f0114324 <test_copy_paste_chunk+0xf06>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114303:	83 ec 04             	sub    $0x4,%esp
f0114306:	68 60 3c 13 f0       	push   $0xf0133c60
f011430b:	68 0f 04 00 00       	push   $0x40f
f0114310:	68 d2 30 13 f0       	push   $0xf01330d2
f0114315:	e8 3a ce fe ff       	call   f0101154 <_warn>
f011431a:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f011431d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 10 ;
f0114324:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114328:	74 04                	je     f011432e <test_copy_paste_chunk+0xf10>
f011432a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
			correct = 1 ;
f011432e:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
		//Test4
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114335:	e8 6e a6 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011433a:	89 45 8c             	mov    %eax,-0x74(%ebp)
		SB(proc_directory, 0x901000, 2 , 0) ;
f011433d:	6a 00                	push   $0x0
f011433f:	6a 02                	push   $0x2
f0114341:	68 00 10 90 00       	push   $0x901000
f0114346:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114349:	e8 b1 2b 00 00       	call   f0116eff <SB>
f011434e:	83 c4 10             	add    $0x10,%esp
		SB(proc_directory, 0x902000, 2 , 0) ;
f0114351:	6a 00                	push   $0x0
f0114353:	6a 02                	push   $0x2
f0114355:	68 00 20 90 00       	push   $0x902000
f011435a:	ff 75 d4             	pushl  -0x2c(%ebp)
f011435d:	e8 9d 2b 00 00       	call   f0116eff <SB>
f0114362:	83 c4 10             	add    $0x10,%esp

		ret = copy_paste_chunk(proc_directory, 0x901000, 0xBFF000, 8*kilo);
f0114365:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114368:	c1 e0 03             	shl    $0x3,%eax
f011436b:	50                   	push   %eax
f011436c:	68 00 f0 bf 00       	push   $0xbff000
f0114371:	68 00 10 90 00       	push   $0x901000
f0114376:	ff 75 d4             	pushl  -0x2c(%ebp)
f0114379:	e8 1b 69 ff ff       	call   f010ac99 <copy_paste_chunk>
f011437e:	83 c4 10             	add    $0x10,%esp
f0114381:	89 85 78 ff ff ff    	mov    %eax,-0x88(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114387:	e8 1c a6 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011438c:	89 45 84             	mov    %eax,-0x7c(%ebp)
		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 3)
f011438f:	83 bd 78 ff ff ff 00 	cmpl   $0x0,-0x88(%ebp)
f0114396:	75 0b                	jne    f01143a3 <test_copy_paste_chunk+0xf85>
f0114398:	8b 45 8c             	mov    -0x74(%ebp),%eax
f011439b:	2b 45 84             	sub    -0x7c(%ebp),%eax
f011439e:	83 f8 03             	cmp    $0x3,%eax
f01143a1:	74 2e                	je     f01143d1 <test_copy_paste_chunk+0xfb3>
		{
			warn("[EVAL] copy_paste_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f01143a3:	8b 45 8c             	mov    -0x74(%ebp),%eax
f01143a6:	2b 45 84             	sub    -0x7c(%ebp),%eax
f01143a9:	83 ec 0c             	sub    $0xc,%esp
f01143ac:	50                   	push   %eax
f01143ad:	ff b5 78 ff ff ff    	pushl  -0x88(%ebp)
f01143b3:	68 0c 3d 13 f0       	push   $0xf0133d0c
f01143b8:	68 1f 04 00 00       	push   $0x41f
f01143bd:	68 d2 30 13 f0       	push   $0xf01330d2
f01143c2:	e8 8d cd fe ff       	call   f0101154 <_warn>
f01143c7:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01143ca:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		}
		if (correct) eval += 5 ;
f01143d1:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01143d5:	74 04                	je     f01143db <test_copy_paste_chunk+0xfbd>
f01143d7:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01143db:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		chkcnt = 1 ;
f01143e2:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0x901000, 0xBFF000, 2*PAGE_SIZE, 1, 0x003, 0x007, 0x003, 0x007, CHK_COPY_PASTE) != 1)
f01143e9:	83 ec 08             	sub    $0x8,%esp
f01143ec:	6a 01                	push   $0x1
f01143ee:	6a 07                	push   $0x7
f01143f0:	6a 03                	push   $0x3
f01143f2:	6a 07                	push   $0x7
f01143f4:	6a 03                	push   $0x3
f01143f6:	6a 01                	push   $0x1
f01143f8:	68 00 20 00 00       	push   $0x2000
f01143fd:	68 00 f0 bf 00       	push   $0xbff000
f0114402:	68 00 10 90 00       	push   $0x901000
f0114407:	ff 75 d4             	pushl  -0x2c(%ebp)
f011440a:	e8 63 2c 00 00       	call   f0117072 <CCP>
f011440f:	83 c4 30             	add    $0x30,%esp
f0114412:	83 f8 01             	cmp    $0x1,%eax
f0114415:	74 28                	je     f011443f <test_copy_paste_chunk+0x1021>
		{
			warn("[EVAL] copy_paste_chunk: Failed (problem in permissions and/or references\n");
f0114417:	83 ec 04             	sub    $0x4,%esp
f011441a:	68 ac 3d 13 f0       	push   $0xf0133dac
f011441f:	68 28 04 00 00       	push   $0x428
f0114424:	68 d2 30 13 f0       	push   $0xf01330d2
f0114429:	e8 26 cd fe ff       	call   f0101154 <_warn>
f011442e:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114431:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			chkcnt = 0 ;
f0114438:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}
		if (correct) eval += 10 ;
f011443f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0114443:	74 04                	je     f0114449 <test_copy_paste_chunk+0x102b>
f0114445:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114449:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)

		if (chkcnt)
f0114450:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114454:	74 72                	je     f01144c8 <test_copy_paste_chunk+0x10aa>
		{
			ch1 = (char*)0x9017FF; ch2 = (char*)0xBFF7FF; ch3 = (char*)0x902FFF;ch4 = (char*)0xC00FFF;
f0114456:	c7 45 bc ff 17 90 00 	movl   $0x9017ff,-0x44(%ebp)
f011445d:	c7 45 b8 ff f7 bf 00 	movl   $0xbff7ff,-0x48(%ebp)
f0114464:	c7 45 b4 ff 2f 90 00 	movl   $0x902fff,-0x4c(%ebp)
f011446b:	c7 45 b0 ff 0f c0 00 	movl   $0xc00fff,-0x50(%ebp)
			if (*ch1 != 'b' || *ch2 != 'b' || *ch3 != 'z' || *ch4 != 'z')
f0114472:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114475:	8a 00                	mov    (%eax),%al
f0114477:	3c 62                	cmp    $0x62,%al
f0114479:	75 1b                	jne    f0114496 <test_copy_paste_chunk+0x1078>
f011447b:	8b 45 b8             	mov    -0x48(%ebp),%eax
f011447e:	8a 00                	mov    (%eax),%al
f0114480:	3c 62                	cmp    $0x62,%al
f0114482:	75 12                	jne    f0114496 <test_copy_paste_chunk+0x1078>
f0114484:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114487:	8a 00                	mov    (%eax),%al
f0114489:	3c 7a                	cmp    $0x7a,%al
f011448b:	75 09                	jne    f0114496 <test_copy_paste_chunk+0x1078>
f011448d:	8b 45 b0             	mov    -0x50(%ebp),%eax
f0114490:	8a 00                	mov    (%eax),%al
f0114492:	3c 7a                	cmp    $0x7a,%al
f0114494:	74 21                	je     f01144b7 <test_copy_paste_chunk+0x1099>
			{
				warn("[EVAL] copy_paste_chunk: Failed (content is not correct)\n");
f0114496:	83 ec 04             	sub    $0x4,%esp
f0114499:	68 60 3c 13 f0       	push   $0xf0133c60
f011449e:	68 34 04 00 00       	push   $0x434
f01144a3:	68 d2 30 13 f0       	push   $0xf01330d2
f01144a8:	e8 a7 cc fe ff       	call   f0101154 <_warn>
f01144ad:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01144b0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			}
			if (correct) eval += 5 ;
f01144b7:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01144bb:	74 04                	je     f01144c1 <test_copy_paste_chunk+0x10a3>
f01144bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01144c1:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f01144c8:	83 ec 0c             	sub    $0xc,%esp
f01144cb:	68 5a 3e 13 f0       	push   $0xf0133e5a
f01144d0:	e8 87 d7 fe ff       	call   f0101c5c <cprintf>
f01144d5:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] copy_paste_chunk: FINISHED. Evaluation = %d\n", eval);
f01144d8:	83 ec 08             	sub    $0x8,%esp
f01144db:	ff 75 e4             	pushl  -0x1c(%ebp)
f01144de:	68 6c 3e 13 f0       	push   $0xf0133e6c
f01144e3:	e8 74 d7 fe ff       	call   f0101c5c <cprintf>
f01144e8:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f01144eb:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f01144ef:	75 10                	jne    f0114501 <test_copy_paste_chunk+0x10e3>
		cprintf("Congratulations!! test copy_paste_chunk completed successfully.\n");
f01144f1:	83 ec 0c             	sub    $0xc,%esp
f01144f4:	68 a0 3e 13 f0       	push   $0xf0133ea0
f01144f9:	e8 5e d7 fe ff       	call   f0101c5c <cprintf>
f01144fe:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114501:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0114506:	89 45 d0             	mov    %eax,-0x30(%ebp)
f0114509:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011450c:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011450f:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114514:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114517:	5b                   	pop    %ebx
f0114518:	5e                   	pop    %esi
f0114519:	5f                   	pop    %edi
f011451a:	5d                   	pop    %ebp
f011451b:	c3                   	ret    

f011451c <test_share_chunk>:

//===============================
// 3) TEST SHARE CHUNK:
//===============================
int test_share_chunk()
{
f011451c:	55                   	push   %ebp
f011451d:	89 e5                	mov    %esp,%ebp
f011451f:	57                   	push   %edi
f0114520:	56                   	push   %esi
f0114521:	53                   	push   %ebx
f0114522:	81 ec bc 00 00 00    	sub    $0xbc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114528:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011452e:	bb 6c 3b 13 f0       	mov    $0xf0133b6c,%ebx
f0114533:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114538:	89 c7                	mov    %eax,%edi
f011453a:	89 de                	mov    %ebx,%esi
f011453c:	89 d1                	mov    %edx,%ecx
f011453e:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114540:	8d 95 5d ff ff ff    	lea    -0xa3(%ebp),%edx
f0114546:	b9 23 00 00 00       	mov    $0x23,%ecx
f011454b:	b0 00                	mov    $0x0,%al
f011454d:	89 d7                	mov    %edx,%edi
f011454f:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114551:	6a 00                	push   $0x0
f0114553:	6a 0a                	push   $0xa
f0114555:	6a 14                	push   $0x14
f0114557:	8d 85 4e ff ff ff    	lea    -0xb2(%ebp),%eax
f011455d:	50                   	push   %eax
f011455e:	e8 fe 69 ff ff       	call   f010af61 <env_create>
f0114563:	83 c4 10             	add    $0x10,%esp
f0114566:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114569:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011456c:	8b 40 64             	mov    0x64(%eax),%eax
f011456f:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114572:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114575:	8b 40 68             	mov    0x68(%eax),%eax
f0114578:	89 45 80             	mov    %eax,-0x80(%ebp)
f011457b:	8b 45 80             	mov    -0x80(%ebp),%eax
f011457e:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114581:	83 ec 0c             	sub    $0xc,%esp
f0114584:	ff 75 cc             	pushl  -0x34(%ebp)
f0114587:	e8 b2 2a 00 00       	call   f011703e <ClearUserSpace>
f011458c:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f011458f:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114596:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f011459d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct =1 ;
f01145a4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 20% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [20%]\n") ;
f01145a8:	83 ec 0c             	sub    $0xc,%esp
f01145ab:	68 18 47 13 f0       	push   $0xf0134718
f01145b0:	e8 a7 d6 fe ff       	call   f0101c5c <cprintf>
f01145b5:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)0xF0100000;
f01145b8:	c7 45 bc 00 00 10 f0 	movl   $0xf0100000,-0x44(%ebp)
		ptr2 = (char*)0xF0104000;
f01145bf:	c7 45 b8 00 40 10 f0 	movl   $0xf0104000,-0x48(%ebp)
		tptr[1] = *ptr1 ;
f01145c6:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01145c9:	8a 00                	mov    (%eax),%al
f01145cb:	88 85 45 ff ff ff    	mov    %al,-0xbb(%ebp)
		tptr[2] = *ptr2 ;
f01145d1:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01145d4:	8a 00                	mov    (%eax),%al
f01145d6:	88 85 46 ff ff ff    	mov    %al,-0xba(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01145dc:	e8 c7 a3 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01145e1:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0100000,0xF0104000, 6*kilo, PERM_WRITEABLE) ;
f01145e4:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01145e7:	89 d0                	mov    %edx,%eax
f01145e9:	01 c0                	add    %eax,%eax
f01145eb:	01 d0                	add    %edx,%eax
f01145ed:	01 c0                	add    %eax,%eax
f01145ef:	83 ec 0c             	sub    $0xc,%esp
f01145f2:	6a 02                	push   $0x2
f01145f4:	50                   	push   %eax
f01145f5:	68 00 40 10 f0       	push   $0xf0104000
f01145fa:	68 00 00 10 f0       	push   $0xf0100000
f01145ff:	ff 75 cc             	pushl  -0x34(%ebp)
f0114602:	e8 ac 66 ff ff       	call   f010acb3 <share_chunk>
f0114607:	83 c4 20             	add    $0x20,%esp
f011460a:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011460d:	e8 96 a3 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114612:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f0114615:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0114619:	75 08                	jne    f0114623 <test_share_chunk+0x107>
f011461b:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011461e:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f0114621:	74 28                	je     f011464b <test_share_chunk+0x12f>
		{
			warn("[EVAL] share_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter));
f0114623:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114626:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114629:	83 ec 0c             	sub    $0xc,%esp
f011462c:	50                   	push   %eax
f011462d:	ff 75 b0             	pushl  -0x50(%ebp)
f0114630:	68 44 47 13 f0       	push   $0xf0134744
f0114635:	68 70 04 00 00       	push   $0x470
f011463a:	68 d2 30 13 f0       	push   $0xf01330d2
f011463f:	e8 10 cb fe ff       	call   f0101154 <_warn>
f0114644:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114647:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011464b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011464f:	74 04                	je     f0114655 <test_share_chunk+0x139>
f0114651:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114655:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xF0100000, 0xF0104000, 8*kilo, 1, 0x003, 0x007, 0x003, 0x007, ~CHK_SHARE) == 0)
f0114659:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011465c:	c1 e0 03             	shl    $0x3,%eax
f011465f:	83 ec 08             	sub    $0x8,%esp
f0114662:	68 fd 00 00 00       	push   $0xfd
f0114667:	6a 07                	push   $0x7
f0114669:	6a 03                	push   $0x3
f011466b:	6a 07                	push   $0x7
f011466d:	6a 03                	push   $0x3
f011466f:	6a 01                	push   $0x1
f0114671:	50                   	push   %eax
f0114672:	68 00 40 10 f0       	push   $0xf0104000
f0114677:	68 00 00 10 f0       	push   $0xf0100000
f011467c:	ff 75 cc             	pushl  -0x34(%ebp)
f011467f:	e8 ee 29 00 00       	call   f0117072 <CCP>
f0114684:	83 c4 30             	add    $0x30,%esp
f0114687:	85 c0                	test   %eax,%eax
f0114689:	75 1e                	jne    f01146a9 <test_share_chunk+0x18d>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f011468b:	83 ec 04             	sub    $0x4,%esp
f011468e:	68 a0 47 13 f0       	push   $0xf01347a0
f0114693:	68 78 04 00 00       	push   $0x478
f0114698:	68 d2 30 13 f0       	push   $0xf01330d2
f011469d:	e8 b2 ca fe ff       	call   f0101154 <_warn>
f01146a2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146a5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01146a9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146ad:	74 04                	je     f01146b3 <test_share_chunk+0x197>
f01146af:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)

		*ptr1 = 'A' ;
f01146b3:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01146b6:	c6 00 41             	movb   $0x41,(%eax)
		*ptr2 = 'B' ;
f01146b9:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01146bc:	c6 00 42             	movb   $0x42,(%eax)

		if ((*ptr1) != 'A' || (*ptr2) != 'B')
f01146bf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01146c2:	8a 00                	mov    (%eax),%al
f01146c4:	3c 41                	cmp    $0x41,%al
f01146c6:	75 09                	jne    f01146d1 <test_share_chunk+0x1b5>
f01146c8:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01146cb:	8a 00                	mov    (%eax),%al
f01146cd:	3c 42                	cmp    $0x42,%al
f01146cf:	74 1e                	je     f01146ef <test_share_chunk+0x1d3>
		{
			warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f01146d1:	83 ec 04             	sub    $0x4,%esp
f01146d4:	68 e8 47 13 f0       	push   $0xf01347e8
f01146d9:	68 82 04 00 00       	push   $0x482
f01146de:	68 d2 30 13 f0       	push   $0xf01330d2
f01146e3:	e8 6c ca fe ff       	call   f0101154 <_warn>
f01146e8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01146eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f01146ef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01146f3:	74 04                	je     f01146f9 <test_share_chunk+0x1dd>
f01146f5:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f01146f9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		*ptr1 = tptr[1] ;
f01146fd:	8a 95 45 ff ff ff    	mov    -0xbb(%ebp),%dl
f0114703:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114706:	88 10                	mov    %dl,(%eax)
		*ptr2 = tptr[2] ;
f0114708:	8a 95 46 ff ff ff    	mov    -0xba(%ebp),%dl
f011470e:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114711:	88 10                	mov    %dl,(%eax)
	}
	cprintf("\nCASE I: END\n") ;
f0114713:	83 ec 0c             	sub    $0xc,%esp
f0114716:	68 1d 48 13 f0       	push   $0xf013481d
f011471b:	e8 3c d5 fe ff       	call   f0101c5c <cprintf>
f0114720:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART II: Destination page(s) not exist [Supervisor] 25% */
	/*========================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor] [25%]\n") ;
f0114723:	83 ec 0c             	sub    $0xc,%esp
f0114726:	68 2c 48 13 f0       	push   $0xf013482c
f011472b:	e8 2c d5 fe ff       	call   f0101c5c <cprintf>
f0114730:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114733:	e8 70 a2 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114738:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0xF0000000,0x40000000, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f011473b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011473e:	c1 e0 05             	shl    $0x5,%eax
f0114741:	83 ec 0c             	sub    $0xc,%esp
f0114744:	68 02 0e 00 00       	push   $0xe02
f0114749:	50                   	push   %eax
f011474a:	68 00 00 00 40       	push   $0x40000000
f011474f:	68 00 00 00 f0       	push   $0xf0000000
f0114754:	ff 75 cc             	pushl  -0x34(%ebp)
f0114757:	e8 57 65 ff ff       	call   f010acb3 <share_chunk>
f011475c:	83 c4 20             	add    $0x20,%esp
f011475f:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114762:	e8 41 a2 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114767:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (32*mega) / (4*mega))
f011476a:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011476e:	75 1f                	jne    f011478f <test_share_chunk+0x273>
f0114770:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114773:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114776:	89 c1                	mov    %eax,%ecx
f0114778:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011477b:	c1 e0 05             	shl    $0x5,%eax
f011477e:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0114781:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0114788:	99                   	cltd   
f0114789:	f7 fb                	idiv   %ebx
f011478b:	39 c1                	cmp    %eax,%ecx
f011478d:	74 28                	je     f01147b7 <test_share_chunk+0x29b>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f011478f:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114792:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114795:	83 ec 0c             	sub    $0xc,%esp
f0114798:	50                   	push   %eax
f0114799:	ff 75 a8             	pushl  -0x58(%ebp)
f011479c:	68 68 48 13 f0       	push   $0xf0134868
f01147a1:	68 9a 04 00 00       	push   $0x49a
f01147a6:	68 d2 30 13 f0       	push   $0xf01330d2
f01147ab:	e8 a4 c9 fe ff       	call   f0101154 <_warn>
f01147b0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01147b3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01147b7:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01147bb:	74 04                	je     f01147c1 <test_share_chunk+0x2a5>
f01147bd:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01147c1:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f01147c5:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
		if (CCP(proc_directory, 0xF0000000, 0x40000000, 32*mega, -1, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f01147cc:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01147cf:	c1 e0 05             	shl    $0x5,%eax
f01147d2:	83 ec 08             	sub    $0x8,%esp
f01147d5:	6a 02                	push   $0x2
f01147d7:	6a 07                	push   $0x7
f01147d9:	6a 03                	push   $0x3
f01147db:	68 07 0e 00 00       	push   $0xe07
f01147e0:	68 03 0e 00 00       	push   $0xe03
f01147e5:	6a ff                	push   $0xffffffff
f01147e7:	50                   	push   %eax
f01147e8:	68 00 00 00 40       	push   $0x40000000
f01147ed:	68 00 00 00 f0       	push   $0xf0000000
f01147f2:	ff 75 cc             	pushl  -0x34(%ebp)
f01147f5:	e8 78 28 00 00       	call   f0117072 <CCP>
f01147fa:	83 c4 30             	add    $0x30,%esp
f01147fd:	85 c0                	test   %eax,%eax
f01147ff:	75 25                	jne    f0114826 <test_share_chunk+0x30a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114801:	83 ec 04             	sub    $0x4,%esp
f0114804:	68 a0 47 13 f0       	push   $0xf01347a0
f0114809:	68 a3 04 00 00       	push   $0x4a3
f011480e:	68 d2 30 13 f0       	push   $0xf01330d2
f0114813:	e8 3c c9 fe ff       	call   f0101154 <_warn>
f0114818:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011481b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f011481f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		}

		if (CCP(proc_directory, 0xF0000000, 0x40000000, 12*kilo, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f0114826:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114829:	89 d0                	mov    %edx,%eax
f011482b:	01 c0                	add    %eax,%eax
f011482d:	01 d0                	add    %edx,%eax
f011482f:	c1 e0 02             	shl    $0x2,%eax
f0114832:	83 ec 08             	sub    $0x8,%esp
f0114835:	6a 02                	push   $0x2
f0114837:	6a 07                	push   $0x7
f0114839:	6a 03                	push   $0x3
f011483b:	68 07 0e 00 00       	push   $0xe07
f0114840:	68 03 0e 00 00       	push   $0xe03
f0114845:	6a 02                	push   $0x2
f0114847:	50                   	push   %eax
f0114848:	68 00 00 00 40       	push   $0x40000000
f011484d:	68 00 00 00 f0       	push   $0xf0000000
f0114852:	ff 75 cc             	pushl  -0x34(%ebp)
f0114855:	e8 18 28 00 00       	call   f0117072 <CCP>
f011485a:	83 c4 30             	add    $0x30,%esp
f011485d:	85 c0                	test   %eax,%eax
f011485f:	75 1e                	jne    f011487f <test_share_chunk+0x363>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114861:	83 ec 04             	sub    $0x4,%esp
f0114864:	68 a0 47 13 f0       	push   $0xf01347a0
f0114869:	68 aa 04 00 00       	push   $0x4aa
f011486e:	68 d2 30 13 f0       	push   $0xf01330d2
f0114873:	e8 dc c8 fe ff       	call   f0101154 <_warn>
f0114878:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f011487b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011487f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114883:	74 04                	je     f0114889 <test_share_chunk+0x36d>
f0114885:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114889:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		extern char end_of_kernel[];
		uint32 endRange = ((uint32)end_of_kernel - KERNEL_BASE);
f011488d:	b8 d0 d6 87 f0       	mov    $0xf087d6d0,%eax
f0114892:	05 00 00 00 10       	add    $0x10000000,%eax
f0114897:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		if (CCP(proc_directory, 0xF0000000+PHYS_IO_MEM, 0x40000000+PHYS_IO_MEM, endRange - PHYS_IO_MEM, 2, 0xE03, 0xE07, 0x003, 0x007, CHK_SHARE) == 0)
f011489a:	8b 45 a4             	mov    -0x5c(%ebp),%eax
f011489d:	2d 00 00 0a 00       	sub    $0xa0000,%eax
f01148a2:	83 ec 08             	sub    $0x8,%esp
f01148a5:	6a 02                	push   $0x2
f01148a7:	6a 07                	push   $0x7
f01148a9:	6a 03                	push   $0x3
f01148ab:	68 07 0e 00 00       	push   $0xe07
f01148b0:	68 03 0e 00 00       	push   $0xe03
f01148b5:	6a 02                	push   $0x2
f01148b7:	50                   	push   %eax
f01148b8:	68 00 00 0a 40       	push   $0x400a0000
f01148bd:	68 00 00 0a f0       	push   $0xf00a0000
f01148c2:	ff 75 cc             	pushl  -0x34(%ebp)
f01148c5:	e8 a8 27 00 00       	call   f0117072 <CCP>
f01148ca:	83 c4 30             	add    $0x30,%esp
f01148cd:	85 c0                	test   %eax,%eax
f01148cf:	75 1e                	jne    f01148ef <test_share_chunk+0x3d3>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f01148d1:	83 ec 04             	sub    $0x4,%esp
f01148d4:	68 a0 47 13 f0       	push   $0xf01347a0
f01148d9:	68 b4 04 00 00       	push   $0x4b4
f01148de:	68 d2 30 13 f0       	push   $0xf01330d2
f01148e3:	e8 6c c8 fe ff       	call   f0101154 <_warn>
f01148e8:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01148eb:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01148ef:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01148f3:	74 04                	je     f01148f9 <test_share_chunk+0x3dd>
f01148f5:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01148f9:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f01148fd:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0114901:	0f 84 a4 00 00 00    	je     f01149ab <test_share_chunk+0x48f>
		{
			ptr1 = (char*)0xF00007FF; *ptr1 = 'A' ;
f0114907:	c7 45 bc ff 07 00 f0 	movl   $0xf00007ff,-0x44(%ebp)
f011490e:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114911:	c6 00 41             	movb   $0x41,(%eax)
			ptr2 = (char*)0x400007FF;
f0114914:	c7 45 b8 ff 07 00 40 	movl   $0x400007ff,-0x48(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A')
f011491b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011491e:	8a 00                	mov    (%eax),%al
f0114920:	3c 41                	cmp    $0x41,%al
f0114922:	75 09                	jne    f011492d <test_share_chunk+0x411>
f0114924:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114927:	8a 00                	mov    (%eax),%al
f0114929:	3c 41                	cmp    $0x41,%al
f011492b:	74 1e                	je     f011494b <test_share_chunk+0x42f>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011492d:	83 ec 04             	sub    $0x4,%esp
f0114930:	68 e8 47 13 f0       	push   $0xf01347e8
f0114935:	68 c1 04 00 00       	push   $0x4c1
f011493a:	68 d2 30 13 f0       	push   $0xf01330d2
f011493f:	e8 10 c8 fe ff       	call   f0101154 <_warn>
f0114944:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114947:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011494b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011494f:	74 04                	je     f0114955 <test_share_chunk+0x439>
f0114951:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114955:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

			ptr1 = (char*)0x41000FFF; *ptr1 = 'C' ;
f0114959:	c7 45 bc ff 0f 00 41 	movl   $0x41000fff,-0x44(%ebp)
f0114960:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114963:	c6 00 43             	movb   $0x43,(%eax)
			ptr2 = (char*)0xF1000FFF;
f0114966:	c7 45 b8 ff 0f 00 f1 	movl   $0xf1000fff,-0x48(%ebp)

			if ((*ptr1) != 'C' || (*ptr2) != 'C')
f011496d:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114970:	8a 00                	mov    (%eax),%al
f0114972:	3c 43                	cmp    $0x43,%al
f0114974:	75 09                	jne    f011497f <test_share_chunk+0x463>
f0114976:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114979:	8a 00                	mov    (%eax),%al
f011497b:	3c 43                	cmp    $0x43,%al
f011497d:	74 1e                	je     f011499d <test_share_chunk+0x481>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f011497f:	83 ec 04             	sub    $0x4,%esp
f0114982:	68 e8 47 13 f0       	push   $0xf01347e8
f0114987:	68 cc 04 00 00       	push   $0x4cc
f011498c:	68 d2 30 13 f0       	push   $0xf01330d2
f0114991:	e8 be c7 fe ff       	call   f0101154 <_warn>
f0114996:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114999:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f011499d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01149a1:	74 04                	je     f01149a7 <test_share_chunk+0x48b>
f01149a3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f01149a7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01149ab:	83 ec 0c             	sub    $0xc,%esp
f01149ae:	68 f7 3d 13 f0       	push   $0xf0133df7
f01149b3:	e8 a4 d2 fe ff       	call   f0101c5c <cprintf>
f01149b8:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART III: Destination page(s) not exist [User r/w] 25%  */
	/*========================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [User r/w] [25%]\n") ;
f01149bb:	83 ec 0c             	sub    $0xc,%esp
f01149be:	68 b8 48 13 f0       	push   $0xf01348b8
f01149c3:	e8 94 d2 fe ff       	call   f0101c5c <cprintf>
f01149c8:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01149cb:	e8 d8 9f ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01149d0:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x40000000,0x0, 648*kilo, PERM_WRITEABLE|PERM_USER) ;
f01149d3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01149d6:	89 d0                	mov    %edx,%eax
f01149d8:	c1 e0 03             	shl    $0x3,%eax
f01149db:	01 d0                	add    %edx,%eax
f01149dd:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
f01149e4:	01 d0                	add    %edx,%eax
f01149e6:	c1 e0 03             	shl    $0x3,%eax
f01149e9:	83 ec 0c             	sub    $0xc,%esp
f01149ec:	6a 06                	push   $0x6
f01149ee:	50                   	push   %eax
f01149ef:	6a 00                	push   $0x0
f01149f1:	68 00 00 00 40       	push   $0x40000000
f01149f6:	ff 75 cc             	pushl  -0x34(%ebp)
f01149f9:	e8 b5 62 ff ff       	call   f010acb3 <share_chunk>
f01149fe:	83 c4 20             	add    $0x20,%esp
f0114a01:	89 45 a0             	mov    %eax,-0x60(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114a04:	e8 9f 9f ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114a09:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114a0c:	83 7d a0 00          	cmpl   $0x0,-0x60(%ebp)
f0114a10:	75 0b                	jne    f0114a1d <test_share_chunk+0x501>
f0114a12:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a15:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a18:	83 f8 01             	cmp    $0x1,%eax
f0114a1b:	74 28                	je     f0114a45 <test_share_chunk+0x529>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114a1d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114a20:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114a23:	83 ec 0c             	sub    $0xc,%esp
f0114a26:	50                   	push   %eax
f0114a27:	ff 75 a0             	pushl  -0x60(%ebp)
f0114a2a:	68 68 48 13 f0       	push   $0xf0134868
f0114a2f:	68 e2 04 00 00       	push   $0x4e2
f0114a34:	68 d2 30 13 f0       	push   $0xf01330d2
f0114a39:	e8 16 c7 fe ff       	call   f0101154 <_warn>
f0114a3e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114a41:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114a45:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114a49:	74 04                	je     f0114a4f <test_share_chunk+0x533>
f0114a4b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114a4f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114a53:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0x40000000, 0x0, PHYS_IO_MEM + 4*kilo, -1, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114a5a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114a5d:	05 00 80 02 00       	add    $0x28000,%eax
f0114a62:	c1 e0 02             	shl    $0x2,%eax
f0114a65:	83 ec 08             	sub    $0x8,%esp
f0114a68:	6a 02                	push   $0x2
f0114a6a:	6a 07                	push   $0x7
f0114a6c:	6a 03                	push   $0x3
f0114a6e:	6a 07                	push   $0x7
f0114a70:	6a 07                	push   $0x7
f0114a72:	6a ff                	push   $0xffffffff
f0114a74:	50                   	push   %eax
f0114a75:	6a 00                	push   $0x0
f0114a77:	68 00 00 00 40       	push   $0x40000000
f0114a7c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114a7f:	e8 ee 25 00 00       	call   f0117072 <CCP>
f0114a84:	83 c4 30             	add    $0x30,%esp
f0114a87:	85 c0                	test   %eax,%eax
f0114a89:	75 25                	jne    f0114ab0 <test_share_chunk+0x594>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114a8b:	83 ec 04             	sub    $0x4,%esp
f0114a8e:	68 a0 47 13 f0       	push   $0xf01347a0
f0114a93:	68 eb 04 00 00       	push   $0x4eb
f0114a98:	68 d2 30 13 f0       	push   $0xf01330d2
f0114a9d:	e8 b2 c6 fe ff       	call   f0101154 <_warn>
f0114aa2:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114aa5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114aa9:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}

		if (CCP(proc_directory, 0x40000000, 0x0, 12*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114ab0:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114ab3:	89 d0                	mov    %edx,%eax
f0114ab5:	01 c0                	add    %eax,%eax
f0114ab7:	01 d0                	add    %edx,%eax
f0114ab9:	c1 e0 02             	shl    $0x2,%eax
f0114abc:	83 ec 08             	sub    $0x8,%esp
f0114abf:	6a 02                	push   $0x2
f0114ac1:	6a 07                	push   $0x7
f0114ac3:	6a 03                	push   $0x3
f0114ac5:	6a 07                	push   $0x7
f0114ac7:	6a 07                	push   $0x7
f0114ac9:	6a 03                	push   $0x3
f0114acb:	50                   	push   %eax
f0114acc:	6a 00                	push   $0x0
f0114ace:	68 00 00 00 40       	push   $0x40000000
f0114ad3:	ff 75 cc             	pushl  -0x34(%ebp)
f0114ad6:	e8 97 25 00 00       	call   f0117072 <CCP>
f0114adb:	83 c4 30             	add    $0x30,%esp
f0114ade:	85 c0                	test   %eax,%eax
f0114ae0:	75 1e                	jne    f0114b00 <test_share_chunk+0x5e4>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114ae2:	83 ec 04             	sub    $0x4,%esp
f0114ae5:	68 a0 47 13 f0       	push   $0xf01347a0
f0114aea:	68 f2 04 00 00       	push   $0x4f2
f0114aef:	68 d2 30 13 f0       	push   $0xf01330d2
f0114af4:	e8 5b c6 fe ff       	call   f0101154 <_warn>
f0114af9:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114afc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b00:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b04:	74 04                	je     f0114b0a <test_share_chunk+0x5ee>
f0114b06:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b0a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40003000, 0x3000, PHYS_IO_MEM - 12*kilo, 2, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114b0e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114b11:	89 d0                	mov    %edx,%eax
f0114b13:	01 c0                	add    %eax,%eax
f0114b15:	01 d0                	add    %edx,%eax
f0114b17:	c1 e0 02             	shl    $0x2,%eax
f0114b1a:	f7 d8                	neg    %eax
f0114b1c:	05 00 00 0a 00       	add    $0xa0000,%eax
f0114b21:	83 ec 08             	sub    $0x8,%esp
f0114b24:	6a 02                	push   $0x2
f0114b26:	6a 07                	push   $0x7
f0114b28:	6a 03                	push   $0x3
f0114b2a:	6a 07                	push   $0x7
f0114b2c:	6a 07                	push   $0x7
f0114b2e:	6a 02                	push   $0x2
f0114b30:	50                   	push   %eax
f0114b31:	68 00 30 00 00       	push   $0x3000
f0114b36:	68 00 30 00 40       	push   $0x40003000
f0114b3b:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b3e:	e8 2f 25 00 00       	call   f0117072 <CCP>
f0114b43:	83 c4 30             	add    $0x30,%esp
f0114b46:	85 c0                	test   %eax,%eax
f0114b48:	75 1e                	jne    f0114b68 <test_share_chunk+0x64c>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114b4a:	83 ec 04             	sub    $0x4,%esp
f0114b4d:	68 a0 47 13 f0       	push   $0xf01347a0
f0114b52:	68 fa 04 00 00       	push   $0x4fa
f0114b57:	68 d2 30 13 f0       	push   $0xf01330d2
f0114b5c:	e8 f3 c5 fe ff       	call   f0101154 <_warn>
f0114b61:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114b64:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114b68:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114b6c:	74 04                	je     f0114b72 <test_share_chunk+0x656>
f0114b6e:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114b72:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x40000000+PHYS_IO_MEM, PHYS_IO_MEM, 4*kilo, 3, 0x007, 0x007, 0x003, 0x007, CHK_SHARE) == 0)
f0114b76:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114b79:	c1 e0 02             	shl    $0x2,%eax
f0114b7c:	83 ec 08             	sub    $0x8,%esp
f0114b7f:	6a 02                	push   $0x2
f0114b81:	6a 07                	push   $0x7
f0114b83:	6a 03                	push   $0x3
f0114b85:	6a 07                	push   $0x7
f0114b87:	6a 07                	push   $0x7
f0114b89:	6a 03                	push   $0x3
f0114b8b:	50                   	push   %eax
f0114b8c:	68 00 00 0a 00       	push   $0xa0000
f0114b91:	68 00 00 0a 40       	push   $0x400a0000
f0114b96:	ff 75 cc             	pushl  -0x34(%ebp)
f0114b99:	e8 d4 24 00 00       	call   f0117072 <CCP>
f0114b9e:	83 c4 30             	add    $0x30,%esp
f0114ba1:	85 c0                	test   %eax,%eax
f0114ba3:	75 1e                	jne    f0114bc3 <test_share_chunk+0x6a7>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114ba5:	83 ec 04             	sub    $0x4,%esp
f0114ba8:	68 a0 47 13 f0       	push   $0xf01347a0
f0114bad:	68 02 05 00 00       	push   $0x502
f0114bb2:	68 d2 30 13 f0       	push   $0xf01330d2
f0114bb7:	e8 98 c5 fe ff       	call   f0101154 <_warn>
f0114bbc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114bbf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114bc3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114bc7:	74 04                	je     f0114bcd <test_share_chunk+0x6b1>
f0114bc9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114bcd:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114bd1:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0114bd5:	0f 84 92 00 00 00    	je     f0114c6d <test_share_chunk+0x751>
		{
			ptr1 = (char*)0x7FF;
f0114bdb:	c7 45 bc ff 07 00 00 	movl   $0x7ff,-0x44(%ebp)
			ptr2 = (char*)0xF00007FF;
f0114be2:	c7 45 b8 ff 07 00 f0 	movl   $0xf00007ff,-0x48(%ebp)
			ptr3 = (char*)0x400007FF;
f0114be9:	c7 45 9c ff 07 00 40 	movl   $0x400007ff,-0x64(%ebp)
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
f0114bf0:	c7 45 98 ff ff 09 00 	movl   $0x9ffff,-0x68(%ebp)
f0114bf7:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114bfa:	c6 00 44             	movb   $0x44,(%eax)
			ptr5 = (char*)0xF009FFFF;
f0114bfd:	c7 45 94 ff ff 09 f0 	movl   $0xf009ffff,-0x6c(%ebp)
			ptr6 = (char*)0x4009FFFF;
f0114c04:	c7 45 90 ff ff 09 40 	movl   $0x4009ffff,-0x70(%ebp)

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114c0b:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114c0e:	8a 00                	mov    (%eax),%al
f0114c10:	3c 41                	cmp    $0x41,%al
f0114c12:	75 2d                	jne    f0114c41 <test_share_chunk+0x725>
f0114c14:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114c17:	8a 00                	mov    (%eax),%al
f0114c19:	3c 41                	cmp    $0x41,%al
f0114c1b:	75 24                	jne    f0114c41 <test_share_chunk+0x725>
f0114c1d:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114c20:	8a 00                	mov    (%eax),%al
f0114c22:	3c 41                	cmp    $0x41,%al
f0114c24:	75 1b                	jne    f0114c41 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114c26:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114c29:	8a 00                	mov    (%eax),%al
			ptr3 = (char*)0x400007FF;
			ptr4 = (char*)0x9FFFF; *ptr4 = 'D';
			ptr5 = (char*)0xF009FFFF;
			ptr6 = (char*)0x4009FFFF;

			if ((*ptr1) != 'A' || (*ptr2) != 'A' || (*ptr3) != 'A' ||
f0114c2b:	3c 44                	cmp    $0x44,%al
f0114c2d:	75 12                	jne    f0114c41 <test_share_chunk+0x725>
					(*ptr4) != 'D' || (*ptr5) != 'D'|| (*ptr6) != 'D')
f0114c2f:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114c32:	8a 00                	mov    (%eax),%al
f0114c34:	3c 44                	cmp    $0x44,%al
f0114c36:	75 09                	jne    f0114c41 <test_share_chunk+0x725>
f0114c38:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114c3b:	8a 00                	mov    (%eax),%al
f0114c3d:	3c 44                	cmp    $0x44,%al
f0114c3f:	74 1e                	je     f0114c5f <test_share_chunk+0x743>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114c41:	83 ec 04             	sub    $0x4,%esp
f0114c44:	68 e8 47 13 f0       	push   $0xf01347e8
f0114c49:	68 14 05 00 00       	push   $0x514
f0114c4e:	68 d2 30 13 f0       	push   $0xf01330d2
f0114c53:	e8 fc c4 fe ff       	call   f0101154 <_warn>
f0114c58:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114c5b:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114c5f:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114c63:	74 04                	je     f0114c69 <test_share_chunk+0x74d>
f0114c65:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114c69:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE III: END\n") ;
f0114c6d:	83 ec 0c             	sub    $0xc,%esp
f0114c70:	68 5a 3e 13 f0       	push   $0xf0133e5a
f0114c75:	e8 e2 cf fe ff       	call   f0101c5c <cprintf>
f0114c7a:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r] 30%     */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r] [30%]\n") ;
f0114c7d:	83 ec 0c             	sub    $0xc,%esp
f0114c80:	68 f4 48 13 f0       	push   $0xf01348f4
f0114c85:	e8 d2 cf fe ff       	call   f0101c5c <cprintf>
f0114c8a:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0114c8d:	e8 16 9d ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114c92:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = share_chunk(proc_directory, 0x9FC00,0x3FFC00, 7*kilo, PERM_USER) ;
f0114c95:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114c98:	89 d0                	mov    %edx,%eax
f0114c9a:	01 c0                	add    %eax,%eax
f0114c9c:	01 d0                	add    %edx,%eax
f0114c9e:	01 c0                	add    %eax,%eax
f0114ca0:	01 d0                	add    %edx,%eax
f0114ca2:	83 ec 0c             	sub    $0xc,%esp
f0114ca5:	6a 04                	push   $0x4
f0114ca7:	50                   	push   %eax
f0114ca8:	68 00 fc 3f 00       	push   $0x3ffc00
f0114cad:	68 00 fc 09 00       	push   $0x9fc00
f0114cb2:	ff 75 cc             	pushl  -0x34(%ebp)
f0114cb5:	e8 f9 5f ff ff       	call   f010acb3 <share_chunk>
f0114cba:	83 c4 20             	add    $0x20,%esp
f0114cbd:	89 45 8c             	mov    %eax,-0x74(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0114cc0:	e8 e3 9c ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0114cc5:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 1)
f0114cc8:	83 7d 8c 00          	cmpl   $0x0,-0x74(%ebp)
f0114ccc:	75 0b                	jne    f0114cd9 <test_share_chunk+0x7bd>
f0114cce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cd1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114cd4:	83 f8 01             	cmp    $0x1,%eax
f0114cd7:	74 28                	je     f0114d01 <test_share_chunk+0x7e5>
		{
			warn("[EVAL] share_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter);
f0114cd9:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0114cdc:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0114cdf:	83 ec 0c             	sub    $0xc,%esp
f0114ce2:	50                   	push   %eax
f0114ce3:	ff 75 8c             	pushl  -0x74(%ebp)
f0114ce6:	68 68 48 13 f0       	push   $0xf0134868
f0114ceb:	68 2a 05 00 00       	push   $0x52a
f0114cf0:	68 d2 30 13 f0       	push   $0xf01330d2
f0114cf5:	e8 5a c4 fe ff       	call   f0101154 <_warn>
f0114cfa:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0114cfd:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0114d01:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d05:	74 04                	je     f0114d0b <test_share_chunk+0x7ef>
f0114d07:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0114d0b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		int chk_cnt = 1 ;
f0114d0f:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0x9F000, 0x3FF000, 12*kilo, -1, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114d16:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0114d19:	89 d0                	mov    %edx,%eax
f0114d1b:	01 c0                	add    %eax,%eax
f0114d1d:	01 d0                	add    %edx,%eax
f0114d1f:	c1 e0 02             	shl    $0x2,%eax
f0114d22:	83 ec 08             	sub    $0x8,%esp
f0114d25:	6a 02                	push   $0x2
f0114d27:	6a 07                	push   $0x7
f0114d29:	6a 07                	push   $0x7
f0114d2b:	6a 07                	push   $0x7
f0114d2d:	6a 05                	push   $0x5
f0114d2f:	6a ff                	push   $0xffffffff
f0114d31:	50                   	push   %eax
f0114d32:	68 00 f0 3f 00       	push   $0x3ff000
f0114d37:	68 00 f0 09 00       	push   $0x9f000
f0114d3c:	ff 75 cc             	pushl  -0x34(%ebp)
f0114d3f:	e8 2e 23 00 00       	call   f0117072 <CCP>
f0114d44:	83 c4 30             	add    $0x30,%esp
f0114d47:	85 c0                	test   %eax,%eax
f0114d49:	75 25                	jne    f0114d70 <test_share_chunk+0x854>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114d4b:	83 ec 04             	sub    $0x4,%esp
f0114d4e:	68 a0 47 13 f0       	push   $0xf01347a0
f0114d53:	68 33 05 00 00       	push   $0x533
f0114d58:	68 d2 30 13 f0       	push   $0xf01330d2
f0114d5d:	e8 f2 c3 fe ff       	call   f0101154 <_warn>
f0114d62:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114d65:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			chk_cnt = 0 ;
f0114d69:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 5 ;
f0114d70:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114d74:	74 04                	je     f0114d7a <test_share_chunk+0x85e>
f0114d76:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114d7a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0x9F000, 0x3FF000, 4*kilo, 3, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114d7e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114d81:	c1 e0 02             	shl    $0x2,%eax
f0114d84:	83 ec 08             	sub    $0x8,%esp
f0114d87:	6a 02                	push   $0x2
f0114d89:	6a 07                	push   $0x7
f0114d8b:	6a 07                	push   $0x7
f0114d8d:	6a 07                	push   $0x7
f0114d8f:	6a 05                	push   $0x5
f0114d91:	6a 03                	push   $0x3
f0114d93:	50                   	push   %eax
f0114d94:	68 00 f0 3f 00       	push   $0x3ff000
f0114d99:	68 00 f0 09 00       	push   $0x9f000
f0114d9e:	ff 75 cc             	pushl  -0x34(%ebp)
f0114da1:	e8 cc 22 00 00       	call   f0117072 <CCP>
f0114da6:	83 c4 30             	add    $0x30,%esp
f0114da9:	85 c0                	test   %eax,%eax
f0114dab:	75 1e                	jne    f0114dcb <test_share_chunk+0x8af>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114dad:	83 ec 04             	sub    $0x4,%esp
f0114db0:	68 a0 47 13 f0       	push   $0xf01347a0
f0114db5:	68 3c 05 00 00       	push   $0x53c
f0114dba:	68 d2 30 13 f0       	push   $0xf01330d2
f0114dbf:	e8 90 c3 fe ff       	call   f0101154 <_warn>
f0114dc4:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114dc7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114dcb:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114dcf:	74 04                	je     f0114dd5 <test_share_chunk+0x8b9>
f0114dd1:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114dd5:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (CCP(proc_directory, 0xA0000, 0x400000, 8*kilo, 4, 0x005, 0x007, 0x007, 0x007, CHK_SHARE) == 0)
f0114dd9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0114ddc:	c1 e0 03             	shl    $0x3,%eax
f0114ddf:	83 ec 08             	sub    $0x8,%esp
f0114de2:	6a 02                	push   $0x2
f0114de4:	6a 07                	push   $0x7
f0114de6:	6a 07                	push   $0x7
f0114de8:	6a 07                	push   $0x7
f0114dea:	6a 05                	push   $0x5
f0114dec:	6a 04                	push   $0x4
f0114dee:	50                   	push   %eax
f0114def:	68 00 00 40 00       	push   $0x400000
f0114df4:	68 00 00 0a 00       	push   $0xa0000
f0114df9:	ff 75 cc             	pushl  -0x34(%ebp)
f0114dfc:	e8 71 22 00 00       	call   f0117072 <CCP>
f0114e01:	83 c4 30             	add    $0x30,%esp
f0114e04:	85 c0                	test   %eax,%eax
f0114e06:	75 1e                	jne    f0114e26 <test_share_chunk+0x90a>
		{
			warn("[EVAL] share_chunk: Failed (problem in permissions and/or references\n");
f0114e08:	83 ec 04             	sub    $0x4,%esp
f0114e0b:	68 a0 47 13 f0       	push   $0xf01347a0
f0114e10:	68 44 05 00 00       	push   $0x544
f0114e15:	68 d2 30 13 f0       	push   $0xf01330d2
f0114e1a:	e8 35 c3 fe ff       	call   f0101154 <_warn>
f0114e1f:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0114e22:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0114e26:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114e2a:	74 04                	je     f0114e30 <test_share_chunk+0x914>
f0114e2c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0114e30:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		if (chk_cnt)
f0114e34:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0114e38:	0f 84 b2 00 00 00    	je     f0114ef0 <test_share_chunk+0x9d4>
		{
			ptr1 = (char*)0x0009FFFF;
f0114e3e:	c7 45 bc ff ff 09 00 	movl   $0x9ffff,-0x44(%ebp)
			ptr2 = (char*)0x003FFFFF;
f0114e45:	c7 45 b8 ff ff 3f 00 	movl   $0x3fffff,-0x48(%ebp)
			ptr3 = (char*)0x4009FFFF;
f0114e4c:	c7 45 9c ff ff 09 40 	movl   $0x4009ffff,-0x64(%ebp)
			ptr4 = (char*)0xF009FFFF;
f0114e53:	c7 45 98 ff ff 09 f0 	movl   $0xf009ffff,-0x68(%ebp)

			ptr5 = (char*)0x000A1001;
f0114e5a:	c7 45 94 01 10 0a 00 	movl   $0xa1001,-0x6c(%ebp)
			ptr6 = (char*)0x00401001;
f0114e61:	c7 45 90 01 10 40 00 	movl   $0x401001,-0x70(%ebp)
			ptr7 = (char*)0x400A1001;
f0114e68:	c7 45 88 01 10 0a 40 	movl   $0x400a1001,-0x78(%ebp)
			ptr8 = (char*)0xF00A1001;
f0114e6f:	c7 45 84 01 10 0a f0 	movl   $0xf00a1001,-0x7c(%ebp)

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114e76:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0114e79:	8a 00                	mov    (%eax),%al
f0114e7b:	3c 44                	cmp    $0x44,%al
f0114e7d:	75 45                	jne    f0114ec4 <test_share_chunk+0x9a8>
f0114e7f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f0114e82:	8a 00                	mov    (%eax),%al
f0114e84:	3c 44                	cmp    $0x44,%al
f0114e86:	75 3c                	jne    f0114ec4 <test_share_chunk+0x9a8>
f0114e88:	8b 45 9c             	mov    -0x64(%ebp),%eax
f0114e8b:	8a 00                	mov    (%eax),%al
f0114e8d:	3c 44                	cmp    $0x44,%al
f0114e8f:	75 33                	jne    f0114ec4 <test_share_chunk+0x9a8>
f0114e91:	8b 45 98             	mov    -0x68(%ebp),%eax
f0114e94:	8a 00                	mov    (%eax),%al
f0114e96:	3c 44                	cmp    $0x44,%al
f0114e98:	75 2a                	jne    f0114ec4 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114e9a:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114e9d:	8a 10                	mov    (%eax),%dl
f0114e9f:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114ea2:	8a 00                	mov    (%eax),%al
			ptr5 = (char*)0x000A1001;
			ptr6 = (char*)0x00401001;
			ptr7 = (char*)0x400A1001;
			ptr8 = (char*)0xF00A1001;

			if ((*ptr1) != 'D' || (*ptr2) != 'D' || (*ptr3) != 'D' || (*ptr4) != 'D' ||
f0114ea4:	38 c2                	cmp    %al,%dl
f0114ea6:	75 1c                	jne    f0114ec4 <test_share_chunk+0x9a8>
					(*ptr5) != (*ptr6) || (*ptr5) != (*ptr7) ||(*ptr5) != (*ptr8))
f0114ea8:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114eab:	8a 10                	mov    (%eax),%dl
f0114ead:	8b 45 88             	mov    -0x78(%ebp),%eax
f0114eb0:	8a 00                	mov    (%eax),%al
f0114eb2:	38 c2                	cmp    %al,%dl
f0114eb4:	75 0e                	jne    f0114ec4 <test_share_chunk+0x9a8>
f0114eb6:	8b 45 94             	mov    -0x6c(%ebp),%eax
f0114eb9:	8a 10                	mov    (%eax),%dl
f0114ebb:	8b 45 84             	mov    -0x7c(%ebp),%eax
f0114ebe:	8a 00                	mov    (%eax),%al
f0114ec0:	38 c2                	cmp    %al,%dl
f0114ec2:	74 1e                	je     f0114ee2 <test_share_chunk+0x9c6>
			{
				warn("[EVAL] share_chunk: Failed (content is not correct)\n");
f0114ec4:	83 ec 04             	sub    $0x4,%esp
f0114ec7:	68 e8 47 13 f0       	push   $0xf01347e8
f0114ecc:	68 59 05 00 00       	push   $0x559
f0114ed1:	68 d2 30 13 f0       	push   $0xf01330d2
f0114ed6:	e8 79 c2 fe ff       	call   f0101154 <_warn>
f0114edb:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f0114ede:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
			}
			if (correct) eval += 5 ;
f0114ee2:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0114ee6:	74 04                	je     f0114eec <test_share_chunk+0x9d0>
f0114ee8:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
			correct = 1 ;
f0114eec:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
		}
	}
	cprintf("\nCASE IV: END\n") ;
f0114ef0:	83 ec 0c             	sub    $0xc,%esp
f0114ef3:	68 2c 49 13 f0       	push   $0xf013492c
f0114ef8:	e8 5f cd fe ff       	call   f0101c5c <cprintf>
f0114efd:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] share_chunk: FINISHED. Evaluation = %d\n", eval);
f0114f00:	83 ec 08             	sub    $0x8,%esp
f0114f03:	ff 75 e4             	pushl  -0x1c(%ebp)
f0114f06:	68 3c 49 13 f0       	push   $0xf013493c
f0114f0b:	e8 4c cd fe ff       	call   f0101c5c <cprintf>
f0114f10:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0114f13:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0114f17:	75 10                	jne    f0114f29 <test_share_chunk+0xa0d>
		cprintf("Congratulations!! test share_chunk completed successfully.\n");
f0114f19:	83 ec 0c             	sub    $0xc,%esp
f0114f1c:	68 6c 49 13 f0       	push   $0xf013496c
f0114f21:	e8 36 cd fe ff       	call   f0101c5c <cprintf>
f0114f26:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0114f29:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0114f2e:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0114f31:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0114f34:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0114f37:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0114f3c:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0114f3f:	5b                   	pop    %ebx
f0114f40:	5e                   	pop    %esi
f0114f41:	5f                   	pop    %edi
f0114f42:	5d                   	pop    %ebp
f0114f43:	c3                   	ret    

f0114f44 <test_allocate_chunk>:

//===============================
// 4) TEST ALLOCATE CHUNK:
//===============================
int test_allocate_chunk()
{
f0114f44:	55                   	push   %ebp
f0114f45:	89 e5                	mov    %esp,%ebp
f0114f47:	57                   	push   %edi
f0114f48:	56                   	push   %esi
f0114f49:	53                   	push   %ebx
f0114f4a:	81 ec ac 00 00 00    	sub    $0xac,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0114f50:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114f56:	bb 6c 3b 13 f0       	mov    $0xf0133b6c,%ebx
f0114f5b:	ba 0f 00 00 00       	mov    $0xf,%edx
f0114f60:	89 c7                	mov    %eax,%edi
f0114f62:	89 de                	mov    %ebx,%esi
f0114f64:	89 d1                	mov    %edx,%ecx
f0114f66:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0114f68:	8d 95 6d ff ff ff    	lea    -0x93(%ebp),%edx
f0114f6e:	b9 23 00 00 00       	mov    $0x23,%ecx
f0114f73:	b0 00                	mov    $0x0,%al
f0114f75:	89 d7                	mov    %edx,%edi
f0114f77:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f0114f79:	6a 00                	push   $0x0
f0114f7b:	6a 0a                	push   $0xa
f0114f7d:	6a 14                	push   $0x14
f0114f7f:	8d 85 5e ff ff ff    	lea    -0xa2(%ebp),%eax
f0114f85:	50                   	push   %eax
f0114f86:	e8 d6 5f ff ff       	call   f010af61 <env_create>
f0114f8b:	83 c4 10             	add    $0x10,%esp
f0114f8e:	89 45 d0             	mov    %eax,-0x30(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0114f91:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114f94:	8b 40 64             	mov    0x64(%eax),%eax
f0114f97:	89 45 cc             	mov    %eax,-0x34(%ebp)
	lcr3(env->env_cr3) ;
f0114f9a:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0114f9d:	8b 40 68             	mov    0x68(%eax),%eax
f0114fa0:	89 45 90             	mov    %eax,-0x70(%ebp)
f0114fa3:	8b 45 90             	mov    -0x70(%ebp),%eax
f0114fa6:	0f 22 d8             	mov    %eax,%cr3
	//===================================================

	ClearUserSpace(proc_directory);
f0114fa9:	83 ec 0c             	sub    $0xc,%esp
f0114fac:	ff 75 cc             	pushl  -0x34(%ebp)
f0114faf:	e8 8a 20 00 00       	call   f011703e <ClearUserSpace>
f0114fb4:	83 c4 10             	add    $0x10,%esp

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0114fb7:	c7 45 c4 00 04 00 00 	movl   $0x400,-0x3c(%ebp)
	int mega = 1024*1024 ;
f0114fbe:	c7 45 c0 00 00 10 00 	movl   $0x100000,-0x40(%ebp)
	uint32 eval = 0;
f0114fc5:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
	uint8 correct =1 ;
f0114fcc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	extern char end_of_kernel[];

	/*======================================*/
	/*PART I: Destination page(s) exist 30% */
	/*======================================*/
	cprintf("\nCASE I: Destination page(s) exist [30%]\n") ;
f0114fd0:	83 ec 0c             	sub    $0xc,%esp
f0114fd3:	68 a8 49 13 f0       	push   $0xf01349a8
f0114fd8:	e8 7f cc fe ff       	call   f0101c5c <cprintf>
f0114fdd:	83 c4 10             	add    $0x10,%esp
	{
		ptr1 = (char*)KERN_STACK_TOP - 1;
f0114fe0:	c7 45 e4 ff ff bf ef 	movl   $0xefbfffff,-0x1c(%ebp)
		ptr2 = (char*)KERN_STACK_TOP - 2;
f0114fe7:	c7 45 bc fe ff bf ef 	movl   $0xefbffffe,-0x44(%ebp)
		while ((ptr1 > (char*)(KERN_STACK_TOP - PAGE_SIZE)) && *ptr1 == 0)	ptr1-- ;
f0114fee:	eb 03                	jmp    f0114ff3 <test_allocate_chunk+0xaf>
f0114ff0:	ff 4d e4             	decl   -0x1c(%ebp)
f0114ff3:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f0114ffa:	76 09                	jbe    f0115005 <test_allocate_chunk+0xc1>
f0114ffc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0114fff:	8a 00                	mov    (%eax),%al
f0115001:	84 c0                	test   %al,%al
f0115003:	74 eb                	je     f0114ff0 <test_allocate_chunk+0xac>
		if (ptr1 == (char*)(KERN_STACK_TOP - PAGE_SIZE))	*ptr1 = 'A' ;
f0115005:	81 7d e4 00 f0 bf ef 	cmpl   $0xefbff000,-0x1c(%ebp)
f011500c:	75 06                	jne    f0115014 <test_allocate_chunk+0xd0>
f011500e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115011:	c6 00 41             	movb   $0x41,(%eax)
		tptr[1] = *ptr1 ;
f0115014:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115017:	8a 00                	mov    (%eax),%al
f0115019:	88 85 55 ff ff ff    	mov    %al,-0xab(%ebp)
		tptr[2] = *ptr2 ;
f011501f:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115022:	8a 00                	mov    (%eax),%al
f0115024:	88 85 56 ff ff ff    	mov    %al,-0xaa(%ebp)
		cprintf("*ptr1 = %c\n", *ptr1) ;
f011502a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011502d:	8a 00                	mov    (%eax),%al
f011502f:	0f be c0             	movsbl %al,%eax
f0115032:	83 ec 08             	sub    $0x8,%esp
f0115035:	50                   	push   %eax
f0115036:	68 d2 49 13 f0       	push   $0xf01349d2
f011503b:	e8 1c cc fe ff       	call   f0101c5c <cprintf>
f0115040:	83 c4 10             	add    $0x10,%esp
		cprintf("*ptr2 = %c\n", *ptr2) ;
f0115043:	8b 45 bc             	mov    -0x44(%ebp),%eax
f0115046:	8a 00                	mov    (%eax),%al
f0115048:	0f be c0             	movsbl %al,%eax
f011504b:	83 ec 08             	sub    $0x8,%esp
f011504e:	50                   	push   %eax
f011504f:	68 de 49 13 f0       	push   $0xf01349de
f0115054:	e8 03 cc fe ff       	call   f0101c5c <cprintf>
f0115059:	83 c4 10             	add    $0x10,%esp
		uint32 old_perms = GP(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE) ;
f011505c:	83 ec 08             	sub    $0x8,%esp
f011505f:	68 00 f0 bf ef       	push   $0xefbff000
f0115064:	ff 75 cc             	pushl  -0x34(%ebp)
f0115067:	e8 b3 1f 00 00       	call   f011701f <GP>
f011506c:	83 c4 10             	add    $0x10,%esp
f011506f:	89 45 b8             	mov    %eax,-0x48(%ebp)
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115072:	e8 31 99 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0115077:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 1*PAGE_SIZE, 4*kilo, PERM_WRITEABLE) ;
f011507a:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011507d:	c1 e0 02             	shl    $0x2,%eax
f0115080:	6a 02                	push   $0x2
f0115082:	50                   	push   %eax
f0115083:	68 00 f0 bf ef       	push   $0xefbff000
f0115088:	ff 75 cc             	pushl  -0x34(%ebp)
f011508b:	e8 3d 5c ff ff       	call   f010accd <allocate_chunk>
f0115090:	83 c4 10             	add    $0x10,%esp
f0115093:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115096:	e8 0d 99 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011509b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011509e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f01150a2:	75 08                	jne    f01150ac <test_allocate_chunk+0x168>
f01150a4:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01150a7:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f01150aa:	74 2a                	je     f01150d6 <test_allocate_chunk+0x192>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f01150ac:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01150af:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01150b2:	83 ec 08             	sub    $0x8,%esp
f01150b5:	6a 00                	push   $0x0
f01150b7:	50                   	push   %eax
f01150b8:	ff 75 b0             	pushl  -0x50(%ebp)
f01150bb:	68 ec 49 13 f0       	push   $0xf01349ec
f01150c0:	68 99 05 00 00       	push   $0x599
f01150c5:	68 d2 30 13 f0       	push   $0xf01330d2
f01150ca:	e8 85 c0 fe ff       	call   f0101154 <_warn>
f01150cf:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01150d2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01150d6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01150da:	74 04                	je     f01150e0 <test_allocate_chunk+0x19c>
f01150dc:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01150e0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		numOfFreeFramesBefore = sys_calculate_free_frames();
f01150e4:	e8 bf 98 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01150e9:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		ret = allocate_chunk(proc_directory, KERN_STACK_TOP - 5*kilo, 2*kilo, PERM_WRITEABLE) ;
f01150ec:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f01150ef:	01 c0                	add    %eax,%eax
f01150f1:	89 c1                	mov    %eax,%ecx
f01150f3:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01150f6:	89 d0                	mov    %edx,%eax
f01150f8:	c1 e0 02             	shl    $0x2,%eax
f01150fb:	01 d0                	add    %edx,%eax
f01150fd:	f7 d8                	neg    %eax
f01150ff:	2d 00 00 40 10       	sub    $0x10400000,%eax
f0115104:	6a 02                	push   $0x2
f0115106:	51                   	push   %ecx
f0115107:	50                   	push   %eax
f0115108:	ff 75 cc             	pushl  -0x34(%ebp)
f011510b:	e8 bd 5b ff ff       	call   f010accd <allocate_chunk>
f0115110:	83 c4 10             	add    $0x10,%esp
f0115113:	89 45 b0             	mov    %eax,-0x50(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115116:	e8 8d 98 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011511b:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != -1 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != 0)
f011511e:	83 7d b0 ff          	cmpl   $0xffffffff,-0x50(%ebp)
f0115122:	75 08                	jne    f011512c <test_allocate_chunk+0x1e8>
f0115124:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115127:	3b 45 ac             	cmp    -0x54(%ebp),%eax
f011512a:	74 2a                	je     f0115156 <test_allocate_chunk+0x212>
		{
			warn("[EVAL] allocate_chunk: Failed (dest is exist... operation should be denied) ret=%d diff=%d expected=%d\n", ret, (numOfFreeFramesBefore - numOfFreeFramesAfter), 0);
f011512c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011512f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115132:	83 ec 08             	sub    $0x8,%esp
f0115135:	6a 00                	push   $0x0
f0115137:	50                   	push   %eax
f0115138:	ff 75 b0             	pushl  -0x50(%ebp)
f011513b:	68 ec 49 13 f0       	push   $0xf01349ec
f0115140:	68 a7 05 00 00       	push   $0x5a7
f0115145:	68 d2 30 13 f0       	push   $0xf01330d2
f011514a:	e8 05 c0 fe ff       	call   f0101154 <_warn>
f011514f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115152:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115156:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011515a:	74 04                	je     f0115160 <test_allocate_chunk+0x21c>
f011515c:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115160:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (CCP(proc_directory, 0, KERN_STACK_TOP-1*PAGE_SIZE, 4*kilo, 1, old_perms, 0xFFF, 0, 0, CHK_ALLOC) == 0)
f0115164:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115167:	c1 e0 02             	shl    $0x2,%eax
f011516a:	83 ec 08             	sub    $0x8,%esp
f011516d:	6a 03                	push   $0x3
f011516f:	6a 00                	push   $0x0
f0115171:	6a 00                	push   $0x0
f0115173:	68 ff 0f 00 00       	push   $0xfff
f0115178:	ff 75 b8             	pushl  -0x48(%ebp)
f011517b:	6a 01                	push   $0x1
f011517d:	50                   	push   %eax
f011517e:	68 00 f0 bf ef       	push   $0xefbff000
f0115183:	6a 00                	push   $0x0
f0115185:	ff 75 cc             	pushl  -0x34(%ebp)
f0115188:	e8 e5 1e 00 00       	call   f0117072 <CCP>
f011518d:	83 c4 30             	add    $0x30,%esp
f0115190:	85 c0                	test   %eax,%eax
f0115192:	75 1e                	jne    f01151b2 <test_allocate_chunk+0x26e>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f0115194:	83 ec 04             	sub    $0x4,%esp
f0115197:	68 54 4a 13 f0       	push   $0xf0134a54
f011519c:	68 af 05 00 00       	push   $0x5af
f01151a1:	68 d2 30 13 f0       	push   $0xf01330d2
f01151a6:	e8 a9 bf fe ff       	call   f0101154 <_warn>
f01151ab:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01151ae:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01151b2:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01151b6:	74 04                	je     f01151bc <test_allocate_chunk+0x278>
f01151b8:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01151bc:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if ((*ptr1) != tptr[1] || (*ptr2) != tptr[2])
f01151c0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01151c3:	8a 10                	mov    (%eax),%dl
f01151c5:	8a 85 55 ff ff ff    	mov    -0xab(%ebp),%al
f01151cb:	38 c2                	cmp    %al,%dl
f01151cd:	75 0f                	jne    f01151de <test_allocate_chunk+0x29a>
f01151cf:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01151d2:	8a 10                	mov    (%eax),%dl
f01151d4:	8a 85 56 ff ff ff    	mov    -0xaa(%ebp),%al
f01151da:	38 c2                	cmp    %al,%dl
f01151dc:	74 1e                	je     f01151fc <test_allocate_chunk+0x2b8>
		{
			warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01151de:	83 ec 04             	sub    $0x4,%esp
f01151e1:	68 a0 4a 13 f0       	push   $0xf0134aa0
f01151e6:	68 b7 05 00 00       	push   $0x5b7
f01151eb:	68 d2 30 13 f0       	push   $0xf01330d2
f01151f0:	e8 5f bf fe ff       	call   f0101154 <_warn>
f01151f5:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01151f8:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f01151fc:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115200:	74 04                	je     f0115206 <test_allocate_chunk+0x2c2>
f0115202:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115206:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011520a:	83 ec 0c             	sub    $0xc,%esp
f011520d:	68 1d 48 13 f0       	push   $0xf013481d
f0115212:	e8 45 ca fe ff       	call   f0101c5c <cprintf>
f0115217:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART II: Destination page(s) not exist [Supervisor r/w] 20% */
	/*============================================================*/
	cprintf("\nCASE II: Destination page(s) not exist [Supervisor r/w] [20%]\n") ;
f011521a:	83 ec 0c             	sub    $0xc,%esp
f011521d:	68 d8 4a 13 f0       	push   $0xf0134ad8
f0115222:	e8 35 ca fe ff       	call   f0101c5c <cprintf>
f0115227:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f011522a:	e8 79 97 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011522f:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0, 32*mega, PERM_WRITEABLE | PERM_AVAILABLE) ;
f0115232:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115235:	c1 e0 05             	shl    $0x5,%eax
f0115238:	68 02 0e 00 00       	push   $0xe02
f011523d:	50                   	push   %eax
f011523e:	6a 00                	push   $0x0
f0115240:	ff 75 cc             	pushl  -0x34(%ebp)
f0115243:	e8 85 5a ff ff       	call   f010accd <allocate_chunk>
f0115248:	83 c4 10             	add    $0x10,%esp
f011524b:	89 45 a8             	mov    %eax,-0x58(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011524e:	e8 55 97 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0115253:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((32*mega)/(4*mega) + (32*mega)/(4*kilo)))
f0115256:	83 7d a8 00          	cmpl   $0x0,-0x58(%ebp)
f011525a:	75 36                	jne    f0115292 <test_allocate_chunk+0x34e>
f011525c:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f011525f:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115262:	89 c1                	mov    %eax,%ecx
f0115264:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115267:	c1 e0 05             	shl    $0x5,%eax
f011526a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011526d:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115274:	99                   	cltd   
f0115275:	f7 fe                	idiv   %esi
f0115277:	89 c3                	mov    %eax,%ebx
f0115279:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011527c:	c1 e0 05             	shl    $0x5,%eax
f011527f:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115282:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115289:	99                   	cltd   
f011528a:	f7 fe                	idiv   %esi
f011528c:	01 d8                	add    %ebx,%eax
f011528e:	39 c1                	cmp    %eax,%ecx
f0115290:	74 54                	je     f01152e6 <test_allocate_chunk+0x3a2>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((32*mega)/(4*mega) + (32*mega)/(4*kilo)));
f0115292:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115295:	c1 e0 05             	shl    $0x5,%eax
f0115298:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011529b:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01152a2:	99                   	cltd   
f01152a3:	f7 ff                	idiv   %edi
f01152a5:	89 c1                	mov    %eax,%ecx
f01152a7:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152aa:	c1 e0 05             	shl    $0x5,%eax
f01152ad:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01152b0:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f01152b7:	99                   	cltd   
f01152b8:	f7 fe                	idiv   %esi
f01152ba:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01152bd:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01152c0:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01152c3:	83 ec 08             	sub    $0x8,%esp
f01152c6:	52                   	push   %edx
f01152c7:	50                   	push   %eax
f01152c8:	ff 75 a8             	pushl  -0x58(%ebp)
f01152cb:	68 18 4b 13 f0       	push   $0xf0134b18
f01152d0:	68 cc 05 00 00       	push   $0x5cc
f01152d5:	68 d2 30 13 f0       	push   $0xf01330d2
f01152da:	e8 75 be fe ff       	call   f0101154 <_warn>
f01152df:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01152e2:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01152e6:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01152ea:	74 04                	je     f01152f0 <test_allocate_chunk+0x3ac>
f01152ec:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01152f0:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01152f4:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
		if (CCP(proc_directory, 0, 0x0, 32*mega, 1, 0xE03, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01152fb:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01152fe:	c1 e0 05             	shl    $0x5,%eax
f0115301:	83 ec 08             	sub    $0x8,%esp
f0115304:	6a 03                	push   $0x3
f0115306:	6a 00                	push   $0x0
f0115308:	6a 00                	push   $0x0
f011530a:	68 07 0e 00 00       	push   $0xe07
f011530f:	68 03 0e 00 00       	push   $0xe03
f0115314:	6a 01                	push   $0x1
f0115316:	50                   	push   %eax
f0115317:	6a 00                	push   $0x0
f0115319:	6a 00                	push   $0x0
f011531b:	ff 75 cc             	pushl  -0x34(%ebp)
f011531e:	e8 4f 1d 00 00       	call   f0117072 <CCP>
f0115323:	83 c4 30             	add    $0x30,%esp
f0115326:	85 c0                	test   %eax,%eax
f0115328:	75 25                	jne    f011534f <test_allocate_chunk+0x40b>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011532a:	83 ec 04             	sub    $0x4,%esp
f011532d:	68 54 4a 13 f0       	push   $0xf0134a54
f0115332:	68 d5 05 00 00       	push   $0x5d5
f0115337:	68 d2 30 13 f0       	push   $0xf01330d2
f011533c:	e8 13 be fe ff       	call   f0101154 <_warn>
f0115341:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115344:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115348:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
		}
		if (correct) eval += 10 ;
f011534f:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115353:	74 04                	je     f0115359 <test_allocate_chunk+0x415>
f0115355:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115359:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f011535d:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f0115361:	74 5a                	je     f01153bd <test_allocate_chunk+0x479>
		{
			ptr1 = (char*)(0x0+2*kilo); *ptr1 = 'K' ;
f0115363:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0115366:	01 c0                	add    %eax,%eax
f0115368:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011536b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011536e:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(0x0+2*mega); *ptr2 = 'M' ;
f0115371:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115374:	01 c0                	add    %eax,%eax
f0115376:	89 45 bc             	mov    %eax,-0x44(%ebp)
f0115379:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011537c:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f011537f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115382:	8a 00                	mov    (%eax),%al
f0115384:	3c 4b                	cmp    $0x4b,%al
f0115386:	75 09                	jne    f0115391 <test_allocate_chunk+0x44d>
f0115388:	8b 45 bc             	mov    -0x44(%ebp),%eax
f011538b:	8a 00                	mov    (%eax),%al
f011538d:	3c 4d                	cmp    $0x4d,%al
f011538f:	74 1e                	je     f01153af <test_allocate_chunk+0x46b>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f0115391:	83 ec 04             	sub    $0x4,%esp
f0115394:	68 a0 4a 13 f0       	push   $0xf0134aa0
f0115399:	68 e3 05 00 00       	push   $0x5e3
f011539e:	68 d2 30 13 f0       	push   $0xf01330d2
f01153a3:	e8 ac bd fe ff       	call   f0101154 <_warn>
f01153a8:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01153ab:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01153af:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01153b3:	74 04                	je     f01153b9 <test_allocate_chunk+0x475>
f01153b5:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01153b9:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
		}
	}
	cprintf("\nCASE II: END\n") ;
f01153bd:	83 ec 0c             	sub    $0xc,%esp
f01153c0:	68 f7 3d 13 f0       	push   $0xf0133df7
f01153c5:	e8 92 c8 fe ff       	call   f0101c5c <cprintf>
f01153ca:	83 c4 10             	add    $0x10,%esp

	/*============================================================*/
	/*PART III: Destination page(s) not exist [Supervisor r] 15%  */
	/*============================================================*/
	cprintf("\nCASE III: Destination page(s) not exist [Supervisor r] [15%]\n") ;
f01153cd:	83 ec 0c             	sub    $0xc,%esp
f01153d0:	68 78 4b 13 f0       	push   $0xf0134b78
f01153d5:	e8 82 c8 fe ff       	call   f0101c5c <cprintf>
f01153da:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f01153dd:	e8 c6 95 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f01153e2:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, 0x0+32*mega, 64*mega, 0) ;
f01153e5:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153e8:	c1 e0 06             	shl    $0x6,%eax
f01153eb:	89 c2                	mov    %eax,%edx
f01153ed:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01153f0:	c1 e0 05             	shl    $0x5,%eax
f01153f3:	6a 00                	push   $0x0
f01153f5:	52                   	push   %edx
f01153f6:	50                   	push   %eax
f01153f7:	ff 75 cc             	pushl  -0x34(%ebp)
f01153fa:	e8 ce 58 ff ff       	call   f010accd <allocate_chunk>
f01153ff:	83 c4 10             	add    $0x10,%esp
f0115402:	89 45 a4             	mov    %eax,-0x5c(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115405:	e8 9e 95 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011540a:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*mega) + (64*mega)/(4*kilo)))
f011540d:	83 7d a4 00          	cmpl   $0x0,-0x5c(%ebp)
f0115411:	75 36                	jne    f0115449 <test_allocate_chunk+0x505>
f0115413:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115416:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115419:	89 c1                	mov    %eax,%ecx
f011541b:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011541e:	c1 e0 06             	shl    $0x6,%eax
f0115421:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115424:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011542b:	99                   	cltd   
f011542c:	f7 ff                	idiv   %edi
f011542e:	89 c3                	mov    %eax,%ebx
f0115430:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115433:	c1 e0 06             	shl    $0x6,%eax
f0115436:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115439:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115440:	99                   	cltd   
f0115441:	f7 fe                	idiv   %esi
f0115443:	01 d8                	add    %ebx,%eax
f0115445:	39 c1                	cmp    %eax,%ecx
f0115447:	74 54                	je     f011549d <test_allocate_chunk+0x559>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*mega) + (64*mega)/(4*kilo)));
f0115449:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011544c:	c1 e0 06             	shl    $0x6,%eax
f011544f:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115452:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115459:	99                   	cltd   
f011545a:	f7 fb                	idiv   %ebx
f011545c:	89 c1                	mov    %eax,%ecx
f011545e:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115461:	c1 e0 06             	shl    $0x6,%eax
f0115464:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115467:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f011546e:	99                   	cltd   
f011546f:	f7 ff                	idiv   %edi
f0115471:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f0115474:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115477:	2b 45 ac             	sub    -0x54(%ebp),%eax
f011547a:	83 ec 08             	sub    $0x8,%esp
f011547d:	52                   	push   %edx
f011547e:	50                   	push   %eax
f011547f:	ff 75 a4             	pushl  -0x5c(%ebp)
f0115482:	68 18 4b 13 f0       	push   $0xf0134b18
f0115487:	68 f9 05 00 00       	push   $0x5f9
f011548c:	68 d2 30 13 f0       	push   $0xf01330d2
f0115491:	e8 be bc fe ff       	call   f0101154 <_warn>
f0115496:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115499:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f011549d:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01154a1:	74 04                	je     f01154a7 <test_allocate_chunk+0x563>
f01154a3:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01154a7:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f01154ab:	c7 45 a0 01 00 00 00 	movl   $0x1,-0x60(%ebp)
		if (CCP(proc_directory, 0, 0x0+32*mega, 64*mega, 1, 0x001, 0xE07, 0, 0, CHK_ALLOC) == 0)
f01154b2:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154b5:	c1 e0 06             	shl    $0x6,%eax
f01154b8:	89 c2                	mov    %eax,%edx
f01154ba:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01154bd:	c1 e0 05             	shl    $0x5,%eax
f01154c0:	83 ec 08             	sub    $0x8,%esp
f01154c3:	6a 03                	push   $0x3
f01154c5:	6a 00                	push   $0x0
f01154c7:	6a 00                	push   $0x0
f01154c9:	68 07 0e 00 00       	push   $0xe07
f01154ce:	6a 01                	push   $0x1
f01154d0:	6a 01                	push   $0x1
f01154d2:	52                   	push   %edx
f01154d3:	50                   	push   %eax
f01154d4:	6a 00                	push   $0x0
f01154d6:	ff 75 cc             	pushl  -0x34(%ebp)
f01154d9:	e8 94 1b 00 00       	call   f0117072 <CCP>
f01154de:	83 c4 30             	add    $0x30,%esp
f01154e1:	85 c0                	test   %eax,%eax
f01154e3:	75 25                	jne    f011550a <test_allocate_chunk+0x5c6>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01154e5:	83 ec 04             	sub    $0x4,%esp
f01154e8:	68 54 4a 13 f0       	push   $0xf0134a54
f01154ed:	68 02 06 00 00       	push   $0x602
f01154f2:	68 d2 30 13 f0       	push   $0xf01330d2
f01154f7:	e8 58 bc fe ff       	call   f0101154 <_warn>
f01154fc:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01154ff:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f0115503:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%ebp)
		}
		if (correct) eval += 10 ;
f011550a:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011550e:	74 04                	je     f0115514 <test_allocate_chunk+0x5d0>
f0115510:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115514:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)
	}
	cprintf("\nCASE III: END\n") ;
f0115518:	83 ec 0c             	sub    $0xc,%esp
f011551b:	68 5a 3e 13 f0       	push   $0xf0133e5a
f0115520:	e8 37 c7 fe ff       	call   f0101c5c <cprintf>
f0115525:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART IV: Destination page(s) not exist [User r/w] 20%  */
	/*========================================================*/
	cprintf("\nCASE IV: Destination page(s) not exist [User r/w] [20%]\n") ;
f0115528:	83 ec 0c             	sub    $0xc,%esp
f011552b:	68 b8 4b 13 f0       	push   $0xf0134bb8
f0115530:	e8 27 c7 fe ff       	call   f0101c5c <cprintf>
f0115535:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115538:	e8 6b 94 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011553d:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory, USER_HEAP_START, 64*mega, PERM_WRITEABLE|PERM_USER|PERM_AVAILABLE) ;
f0115540:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115543:	c1 e0 06             	shl    $0x6,%eax
f0115546:	68 06 0e 00 00       	push   $0xe06
f011554b:	50                   	push   %eax
f011554c:	68 00 00 00 80       	push   $0x80000000
f0115551:	ff 75 cc             	pushl  -0x34(%ebp)
f0115554:	e8 74 57 ff ff       	call   f010accd <allocate_chunk>
f0115559:	83 c4 10             	add    $0x10,%esp
f011555c:	89 45 9c             	mov    %eax,-0x64(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f011555f:	e8 44 94 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0115564:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != ((64*mega)/(4*kilo)+(64*mega)/(4*mega)))
f0115567:	83 7d 9c 00          	cmpl   $0x0,-0x64(%ebp)
f011556b:	75 36                	jne    f01155a3 <test_allocate_chunk+0x65f>
f011556d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115570:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115573:	89 c1                	mov    %eax,%ecx
f0115575:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0115578:	c1 e0 06             	shl    $0x6,%eax
f011557b:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011557e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115585:	99                   	cltd   
f0115586:	f7 fb                	idiv   %ebx
f0115588:	89 c3                	mov    %eax,%ebx
f011558a:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011558d:	c1 e0 06             	shl    $0x6,%eax
f0115590:	8b 55 c0             	mov    -0x40(%ebp),%edx
f0115593:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f011559a:	99                   	cltd   
f011559b:	f7 fe                	idiv   %esi
f011559d:	01 d8                	add    %ebx,%eax
f011559f:	39 c1                	cmp    %eax,%ecx
f01155a1:	74 54                	je     f01155f7 <test_allocate_chunk+0x6b3>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, ((64*mega)/(4*kilo)+(64*mega)/(4*mega)));
f01155a3:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01155a6:	c1 e0 06             	shl    $0x6,%eax
f01155a9:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01155ac:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
f01155b3:	99                   	cltd   
f01155b4:	f7 ff                	idiv   %edi
f01155b6:	89 c1                	mov    %eax,%ecx
f01155b8:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01155bb:	c1 e0 06             	shl    $0x6,%eax
f01155be:	8b 55 c0             	mov    -0x40(%ebp),%edx
f01155c1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f01155c8:	99                   	cltd   
f01155c9:	f7 fb                	idiv   %ebx
f01155cb:	8d 14 01             	lea    (%ecx,%eax,1),%edx
f01155ce:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01155d1:	2b 45 ac             	sub    -0x54(%ebp),%eax
f01155d4:	83 ec 08             	sub    $0x8,%esp
f01155d7:	52                   	push   %edx
f01155d8:	50                   	push   %eax
f01155d9:	ff 75 9c             	pushl  -0x64(%ebp)
f01155dc:	68 18 4b 13 f0       	push   $0xf0134b18
f01155e1:	68 18 06 00 00       	push   $0x618
f01155e6:	68 d2 30 13 f0       	push   $0xf01330d2
f01155eb:	e8 64 bb fe ff       	call   f0101154 <_warn>
f01155f0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01155f3:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 5 ;
f01155f7:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01155fb:	74 04                	je     f0115601 <test_allocate_chunk+0x6bd>
f01155fd:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f0115601:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115605:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
		if (CCP(proc_directory, 0, USER_HEAP_START, 64*mega, 1, 0xE07, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011560c:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011560f:	c1 e0 06             	shl    $0x6,%eax
f0115612:	83 ec 08             	sub    $0x8,%esp
f0115615:	6a 03                	push   $0x3
f0115617:	6a 00                	push   $0x0
f0115619:	6a 00                	push   $0x0
f011561b:	68 07 0e 00 00       	push   $0xe07
f0115620:	68 07 0e 00 00       	push   $0xe07
f0115625:	6a 01                	push   $0x1
f0115627:	50                   	push   %eax
f0115628:	68 00 00 00 80       	push   $0x80000000
f011562d:	6a 00                	push   $0x0
f011562f:	ff 75 cc             	pushl  -0x34(%ebp)
f0115632:	e8 3b 1a 00 00       	call   f0117072 <CCP>
f0115637:	83 c4 30             	add    $0x30,%esp
f011563a:	85 c0                	test   %eax,%eax
f011563c:	75 25                	jne    f0115663 <test_allocate_chunk+0x71f>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f011563e:	83 ec 04             	sub    $0x4,%esp
f0115641:	68 54 4a 13 f0       	push   $0xf0134a54
f0115646:	68 21 06 00 00       	push   $0x621
f011564b:	68 d2 30 13 f0       	push   $0xf01330d2
f0115650:	e8 ff ba fe ff       	call   f0101154 <_warn>
f0115655:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f0115658:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f011565c:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
		}
		if (correct) eval += 10 ;
f0115663:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f0115667:	74 04                	je     f011566d <test_allocate_chunk+0x729>
f0115669:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f011566d:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		if (chk_cnt)
f0115671:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
f0115675:	74 6f                	je     f01156e6 <test_allocate_chunk+0x7a2>
		{
			ptr1 = (char*)(USER_HEAP_START+2*kilo); *ptr1 = 'K' ;
f0115677:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011567a:	01 c0                	add    %eax,%eax
f011567c:	05 00 00 00 80       	add    $0x80000000,%eax
f0115681:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0115684:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0115687:	c6 00 4b             	movb   $0x4b,(%eax)
			ptr2 = (char*)(USER_HEAP_START+22*mega);*ptr2 = 'M' ;
f011568a:	8b 55 c0             	mov    -0x40(%ebp),%edx
f011568d:	89 d0                	mov    %edx,%eax
f011568f:	c1 e0 02             	shl    $0x2,%eax
f0115692:	01 d0                	add    %edx,%eax
f0115694:	01 c0                	add    %eax,%eax
f0115696:	01 d0                	add    %edx,%eax
f0115698:	01 c0                	add    %eax,%eax
f011569a:	05 00 00 00 80       	add    $0x80000000,%eax
f011569f:	89 45 bc             	mov    %eax,-0x44(%ebp)
f01156a2:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01156a5:	c6 00 4d             	movb   $0x4d,(%eax)

			if ((*ptr1) != 'K' || (*ptr2) != 'M')
f01156a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01156ab:	8a 00                	mov    (%eax),%al
f01156ad:	3c 4b                	cmp    $0x4b,%al
f01156af:	75 09                	jne    f01156ba <test_allocate_chunk+0x776>
f01156b1:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01156b4:	8a 00                	mov    (%eax),%al
f01156b6:	3c 4d                	cmp    $0x4d,%al
f01156b8:	74 1e                	je     f01156d8 <test_allocate_chunk+0x794>
			{
				warn("[EVAL] allocate_chunk: Failed (content is not correct)\n");
f01156ba:	83 ec 04             	sub    $0x4,%esp
f01156bd:	68 a0 4a 13 f0       	push   $0xf0134aa0
f01156c2:	68 2f 06 00 00       	push   $0x62f
f01156c7:	68 d2 30 13 f0       	push   $0xf01330d2
f01156cc:	e8 83 ba fe ff       	call   f0101154 <_warn>
f01156d1:	83 c4 10             	add    $0x10,%esp
				correct = 0;
f01156d4:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			}
			if (correct) eval += 5 ;
f01156d8:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01156dc:	74 04                	je     f01156e2 <test_allocate_chunk+0x79e>
f01156de:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
			correct = 1 ;
f01156e2:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		}
	}
	cprintf("\nCASE IV: END\n") ;
f01156e6:	83 ec 0c             	sub    $0xc,%esp
f01156e9:	68 2c 49 13 f0       	push   $0xf013492c
f01156ee:	e8 69 c5 fe ff       	call   f0101c5c <cprintf>
f01156f3:	83 c4 10             	add    $0x10,%esp

	/*========================================================*/
	/*PART V: Destination page(s) not exist [User r] 15%     */
	/*========================================================*/
	cprintf("\nCASE V: Destination page(s) not exist [User r] [15%]\n") ;
f01156f6:	83 ec 0c             	sub    $0xc,%esp
f01156f9:	68 f4 4b 13 f0       	push   $0xf0134bf4
f01156fe:	e8 59 c5 fe ff       	call   f0101c5c <cprintf>
f0115703:	83 c4 10             	add    $0x10,%esp
	{
		numOfFreeFramesBefore = sys_calculate_free_frames();
f0115706:	e8 9d 92 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f011570b:	89 45 b4             	mov    %eax,-0x4c(%ebp)

		int ret = allocate_chunk(proc_directory,0x403FFC00, 7*kilo, PERM_USER|PERM_AVAILABLE) ;
f011570e:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f0115711:	89 d0                	mov    %edx,%eax
f0115713:	01 c0                	add    %eax,%eax
f0115715:	01 d0                	add    %edx,%eax
f0115717:	01 c0                	add    %eax,%eax
f0115719:	01 d0                	add    %edx,%eax
f011571b:	68 04 0e 00 00       	push   $0xe04
f0115720:	50                   	push   %eax
f0115721:	68 00 fc 3f 40       	push   $0x403ffc00
f0115726:	ff 75 cc             	pushl  -0x34(%ebp)
f0115729:	e8 9f 55 ff ff       	call   f010accd <allocate_chunk>
f011572e:	83 c4 10             	add    $0x10,%esp
f0115731:	89 45 98             	mov    %eax,-0x68(%ebp)

		numOfFreeFramesAfter = sys_calculate_free_frames();
f0115734:	e8 6f 92 ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0115739:	89 45 ac             	mov    %eax,-0x54(%ebp)

		if (ret != 0 || (numOfFreeFramesBefore - numOfFreeFramesAfter) != (3+2))
f011573c:	83 7d 98 00          	cmpl   $0x0,-0x68(%ebp)
f0115740:	75 0b                	jne    f011574d <test_allocate_chunk+0x809>
f0115742:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115745:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115748:	83 f8 05             	cmp    $0x5,%eax
f011574b:	74 2a                	je     f0115777 <test_allocate_chunk+0x833>
		{
			warn("[EVAL] allocate_chunk: Failed (# allocated frames is not correct) ret=%d diff=%d expected=%d\n", ret, numOfFreeFramesBefore - numOfFreeFramesAfter, (3+2));
f011574d:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f0115750:	2b 45 ac             	sub    -0x54(%ebp),%eax
f0115753:	83 ec 08             	sub    $0x8,%esp
f0115756:	6a 05                	push   $0x5
f0115758:	50                   	push   %eax
f0115759:	ff 75 98             	pushl  -0x68(%ebp)
f011575c:	68 18 4b 13 f0       	push   $0xf0134b18
f0115761:	68 46 06 00 00       	push   $0x646
f0115766:	68 d2 30 13 f0       	push   $0xf01330d2
f011576b:	e8 e4 b9 fe ff       	call   f0101154 <_warn>
f0115770:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115773:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
		}
		if (correct) eval += 10 ;
f0115777:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f011577b:	74 04                	je     f0115781 <test_allocate_chunk+0x83d>
f011577d:	83 45 e0 0a          	addl   $0xa,-0x20(%ebp)
		correct = 1 ;
f0115781:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

		int chk_cnt = 1 ;
f0115785:	c7 45 94 01 00 00 00 	movl   $0x1,-0x6c(%ebp)
		if (CCP(proc_directory, 0, 0x403FF000, 12*kilo, 1, 0xE05, 0xE07, 0, 0, CHK_ALLOC) == 0)
f011578c:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f011578f:	89 d0                	mov    %edx,%eax
f0115791:	01 c0                	add    %eax,%eax
f0115793:	01 d0                	add    %edx,%eax
f0115795:	c1 e0 02             	shl    $0x2,%eax
f0115798:	83 ec 08             	sub    $0x8,%esp
f011579b:	6a 03                	push   $0x3
f011579d:	6a 00                	push   $0x0
f011579f:	6a 00                	push   $0x0
f01157a1:	68 07 0e 00 00       	push   $0xe07
f01157a6:	68 05 0e 00 00       	push   $0xe05
f01157ab:	6a 01                	push   $0x1
f01157ad:	50                   	push   %eax
f01157ae:	68 00 f0 3f 40       	push   $0x403ff000
f01157b3:	6a 00                	push   $0x0
f01157b5:	ff 75 cc             	pushl  -0x34(%ebp)
f01157b8:	e8 b5 18 00 00       	call   f0117072 <CCP>
f01157bd:	83 c4 30             	add    $0x30,%esp
f01157c0:	85 c0                	test   %eax,%eax
f01157c2:	75 25                	jne    f01157e9 <test_allocate_chunk+0x8a5>
		{
			warn("[EVAL] allocate_chunk: Failed (problem in permissions and/or references\n");
f01157c4:	83 ec 04             	sub    $0x4,%esp
f01157c7:	68 54 4a 13 f0       	push   $0xf0134a54
f01157cc:	68 4f 06 00 00       	push   $0x64f
f01157d1:	68 d2 30 13 f0       	push   $0xf01330d2
f01157d6:	e8 79 b9 fe ff       	call   f0101154 <_warn>
f01157db:	83 c4 10             	add    $0x10,%esp
			correct = 0;
f01157de:	c6 45 df 00          	movb   $0x0,-0x21(%ebp)
			chk_cnt = 0 ;
f01157e2:	c7 45 94 00 00 00 00 	movl   $0x0,-0x6c(%ebp)
		}
		if (correct) eval += 5 ;
f01157e9:	80 7d df 00          	cmpb   $0x0,-0x21(%ebp)
f01157ed:	74 04                	je     f01157f3 <test_allocate_chunk+0x8af>
f01157ef:	83 45 e0 05          	addl   $0x5,-0x20(%ebp)
		correct = 1 ;
f01157f3:	c6 45 df 01          	movb   $0x1,-0x21(%ebp)

	}
	cprintf("\nCASE V: END\n") ;
f01157f7:	83 ec 0c             	sub    $0xc,%esp
f01157fa:	68 2b 4c 13 f0       	push   $0xf0134c2b
f01157ff:	e8 58 c4 fe ff       	call   f0101c5c <cprintf>
f0115804:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] allocate_chunk: FINISHED. Evaluation = %d\n", eval);
f0115807:	83 ec 08             	sub    $0x8,%esp
f011580a:	ff 75 e0             	pushl  -0x20(%ebp)
f011580d:	68 3c 4c 13 f0       	push   $0xf0134c3c
f0115812:	e8 45 c4 fe ff       	call   f0101c5c <cprintf>
f0115817:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011581a:	83 7d e0 64          	cmpl   $0x64,-0x20(%ebp)
f011581e:	75 10                	jne    f0115830 <test_allocate_chunk+0x8ec>
		cprintf("Congratulations!! test allocate_chunk completed successfully.\n");
f0115820:	83 ec 0c             	sub    $0xc,%esp
f0115823:	68 70 4c 13 f0       	push   $0xf0134c70
f0115828:	e8 2f c4 fe ff       	call   f0101c5c <cprintf>
f011582d:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0115830:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0115835:	89 45 c8             	mov    %eax,-0x38(%ebp)
f0115838:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011583b:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f011583e:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0115843:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0115846:	5b                   	pop    %ebx
f0115847:	5e                   	pop    %esi
f0115848:	5f                   	pop    %edi
f0115849:	5d                   	pop    %ebp
f011584a:	c3                   	ret    

f011584b <test_calculate_required_frames>:

//======================================
// 5) [+]TEST CALCULATE REQUIRED FRAMES:
//======================================
int test_calculate_required_frames()
{
f011584b:	55                   	push   %ebp
f011584c:	89 e5                	mov    %esp,%ebp
f011584e:	57                   	push   %edi
f011584f:	56                   	push   %esi
f0115850:	53                   	push   %ebx
f0115851:	81 ec fc 01 00 00    	sub    $0x1fc,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f0115857:	8d 45 8e             	lea    -0x72(%ebp),%eax
f011585a:	bb 6c 3b 13 f0       	mov    $0xf0133b6c,%ebx
f011585f:	ba 0f 00 00 00       	mov    $0xf,%edx
f0115864:	89 c7                	mov    %eax,%edi
f0115866:	89 de                	mov    %ebx,%esi
f0115868:	89 d1                	mov    %edx,%ecx
f011586a:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f011586c:	8d 55 9d             	lea    -0x63(%ebp),%edx
f011586f:	b9 23 00 00 00       	mov    $0x23,%ecx
f0115874:	b0 00                	mov    $0x0,%al
f0115876:	89 d7                	mov    %edx,%edi
f0115878:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f011587a:	6a 00                	push   $0x0
f011587c:	6a 0a                	push   $0xa
f011587e:	6a 14                	push   $0x14
f0115880:	8d 45 8e             	lea    -0x72(%ebp),%eax
f0115883:	50                   	push   %eax
f0115884:	e8 d8 56 ff ff       	call   f010af61 <env_create>
f0115889:	83 c4 10             	add    $0x10,%esp
f011588c:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f011588f:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0115892:	8b 40 64             	mov    0x64(%eax),%eax
f0115895:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f0115898:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011589b:	8b 40 68             	mov    0x68(%eax),%eax
f011589e:	89 45 c0             	mov    %eax,-0x40(%ebp)
f01158a1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01158a4:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f01158a7:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f01158ae:	75 70 20 
f01158b1:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f01158b8:	00 00 00 
f01158bb:	8d 55 82             	lea    -0x7e(%ebp),%edx
f01158be:	b9 03 00 00 00       	mov    $0x3,%ecx
f01158c3:	b8 00 00 00 00       	mov    $0x0,%eax
f01158c8:	89 d7                	mov    %edx,%edi
f01158ca:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f01158cc:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01158cf:	8b 40 10             	mov    0x10(%eax),%eax
f01158d2:	83 ec 08             	sub    $0x8,%esp
f01158d5:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f01158db:	52                   	push   %edx
f01158dc:	50                   	push   %eax
f01158dd:	e8 ee 57 00 00       	call   f011b0d0 <ltostr>
f01158e2:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f01158e5:	83 ec 04             	sub    $0x4,%esp
f01158e8:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f01158ee:	50                   	push   %eax
f01158ef:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f01158f5:	50                   	push   %eax
f01158f6:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f01158fc:	50                   	push   %eax
f01158fd:	e8 a7 58 00 00       	call   f011b1a9 <strcconcat>
f0115902:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0115905:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f011590c:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0115913:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint32 res =0;
f011591a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
	uint8 correct = 1;
f0115921:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;

	ClearUserSpace(proc_directory);
f0115925:	83 ec 0c             	sub    $0xc,%esp
f0115928:	ff 75 d8             	pushl  -0x28(%ebp)
f011592b:	e8 0e 17 00 00       	call   f011703e <ClearUserSpace>
f0115930:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f0115933:	83 ec 0c             	sub    $0xc,%esp
f0115936:	68 b0 4c 13 f0       	push   $0xf0134cb0
f011593b:	e8 1c c3 fe ff       	call   f0101c5c <cprintf>
f0115940:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115943:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115946:	c1 e0 03             	shl    $0x3,%eax
f0115949:	83 ec 04             	sub    $0x4,%esp
f011594c:	50                   	push   %eax
f011594d:	6a 00                	push   $0x0
f011594f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115952:	e8 c4 53 ff ff       	call   f010ad1b <calculate_required_frames>
f0115957:	83 c4 10             	add    $0x10,%esp
f011595a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f011595d:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115961:	74 23                	je     f0115986 <test_calculate_required_frames+0x13b>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115963:	83 ec 0c             	sub    $0xc,%esp
f0115966:	6a 03                	push   $0x3
f0115968:	ff 75 c8             	pushl  -0x38(%ebp)
f011596b:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115970:	68 88 06 00 00       	push   $0x688
f0115975:	68 d2 30 13 f0       	push   $0xf01330d2
f011597a:	e8 d5 b7 fe ff       	call   f0101154 <_warn>
f011597f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115982:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115986:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011598a:	74 04                	je     f0115990 <test_calculate_required_frames+0x145>
f011598c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115990:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 4*mega);
f0115994:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115997:	c1 e0 02             	shl    $0x2,%eax
f011599a:	83 ec 04             	sub    $0x4,%esp
f011599d:	50                   	push   %eax
f011599e:	6a 00                	push   $0x0
f01159a0:	ff 75 d8             	pushl  -0x28(%ebp)
f01159a3:	e8 73 53 ff ff       	call   f010ad1b <calculate_required_frames>
f01159a8:	83 c4 10             	add    $0x10,%esp
f01159ab:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 1025)
f01159ae:	81 7d c8 01 04 00 00 	cmpl   $0x401,-0x38(%ebp)
f01159b5:	74 26                	je     f01159dd <test_calculate_required_frames+0x192>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 1025);
f01159b7:	83 ec 0c             	sub    $0xc,%esp
f01159ba:	68 01 04 00 00       	push   $0x401
f01159bf:	ff 75 c8             	pushl  -0x38(%ebp)
f01159c2:	68 e4 4c 13 f0       	push   $0xf0134ce4
f01159c7:	68 92 06 00 00       	push   $0x692
f01159cc:	68 d2 30 13 f0       	push   $0xf01330d2
f01159d1:	e8 7e b7 fe ff       	call   f0101154 <_warn>
f01159d6:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01159d9:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01159dd:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01159e1:	74 04                	je     f01159e7 <test_calculate_required_frames+0x19c>
f01159e3:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01159e7:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f01159eb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01159ee:	c1 e0 0a             	shl    $0xa,%eax
f01159f1:	83 ec 04             	sub    $0x4,%esp
f01159f4:	50                   	push   %eax
f01159f5:	6a 00                	push   $0x0
f01159f7:	ff 75 d8             	pushl  -0x28(%ebp)
f01159fa:	e8 1c 53 ff ff       	call   f010ad1b <calculate_required_frames>
f01159ff:	83 c4 10             	add    $0x10,%esp
f0115a02:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)))
f0115a05:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a08:	c1 e0 0a             	shl    $0xa,%eax
f0115a0b:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115a0e:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115a15:	99                   	cltd   
f0115a16:	f7 fb                	idiv   %ebx
f0115a18:	89 c1                	mov    %eax,%ecx
f0115a1a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a1d:	c1 e0 0a             	shl    $0xa,%eax
f0115a20:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115a23:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115a2a:	99                   	cltd   
f0115a2b:	f7 fe                	idiv   %esi
f0115a2d:	01 c8                	add    %ecx,%eax
f0115a2f:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0115a32:	74 4c                	je     f0115a80 <test_calculate_required_frames+0x235>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)));
f0115a34:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a37:	c1 e0 0a             	shl    $0xa,%eax
f0115a3a:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115a3d:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115a44:	99                   	cltd   
f0115a45:	f7 fb                	idiv   %ebx
f0115a47:	89 c1                	mov    %eax,%ecx
f0115a49:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115a4c:	c1 e0 0a             	shl    $0xa,%eax
f0115a4f:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115a52:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115a59:	99                   	cltd   
f0115a5a:	f7 fe                	idiv   %esi
f0115a5c:	01 c8                	add    %ecx,%eax
f0115a5e:	83 ec 0c             	sub    $0xc,%esp
f0115a61:	50                   	push   %eax
f0115a62:	ff 75 c8             	pushl  -0x38(%ebp)
f0115a65:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115a6a:	68 9c 06 00 00       	push   $0x69c
f0115a6f:	68 d2 30 13 f0       	push   $0xf01330d2
f0115a74:	e8 db b6 fe ff       	call   f0101154 <_warn>
f0115a79:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115a7c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115a80:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115a84:	74 04                	je     f0115a8a <test_calculate_required_frames+0x23f>
f0115a86:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115a8a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test4
		res = calculate_required_frames(proc_directory, 0x1000, 6*kilo);
f0115a8e:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115a91:	89 d0                	mov    %edx,%eax
f0115a93:	01 c0                	add    %eax,%eax
f0115a95:	01 d0                	add    %edx,%eax
f0115a97:	01 c0                	add    %eax,%eax
f0115a99:	83 ec 04             	sub    $0x4,%esp
f0115a9c:	50                   	push   %eax
f0115a9d:	68 00 10 00 00       	push   $0x1000
f0115aa2:	ff 75 d8             	pushl  -0x28(%ebp)
f0115aa5:	e8 71 52 ff ff       	call   f010ad1b <calculate_required_frames>
f0115aaa:	83 c4 10             	add    $0x10,%esp
f0115aad:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115ab0:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115ab4:	74 23                	je     f0115ad9 <test_calculate_required_frames+0x28e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115ab6:	83 ec 0c             	sub    $0xc,%esp
f0115ab9:	6a 03                	push   $0x3
f0115abb:	ff 75 c8             	pushl  -0x38(%ebp)
f0115abe:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115ac3:	68 a8 06 00 00       	push   $0x6a8
f0115ac8:	68 d2 30 13 f0       	push   $0xf01330d2
f0115acd:	e8 82 b6 fe ff       	call   f0101154 <_warn>
f0115ad2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ad5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ad9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115add:	74 04                	je     f0115ae3 <test_calculate_required_frames+0x298>
f0115adf:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ae3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115ae7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115aea:	89 c2                	mov    %eax,%edx
f0115aec:	01 d2                	add    %edx,%edx
f0115aee:	01 d0                	add    %edx,%eax
f0115af0:	83 ec 04             	sub    $0x4,%esp
f0115af3:	50                   	push   %eax
f0115af4:	68 00 18 00 00       	push   $0x1800
f0115af9:	ff 75 d8             	pushl  -0x28(%ebp)
f0115afc:	e8 1a 52 ff ff       	call   f010ad1b <calculate_required_frames>
f0115b01:	83 c4 10             	add    $0x10,%esp
f0115b04:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 3)
f0115b07:	83 7d c8 03          	cmpl   $0x3,-0x38(%ebp)
f0115b0b:	74 23                	je     f0115b30 <test_calculate_required_frames+0x2e5>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 3);
f0115b0d:	83 ec 0c             	sub    $0xc,%esp
f0115b10:	6a 03                	push   $0x3
f0115b12:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b15:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115b1a:	68 b2 06 00 00       	push   $0x6b2
f0115b1f:	68 d2 30 13 f0       	push   $0xf01330d2
f0115b24:	e8 2b b6 fe ff       	call   f0101154 <_warn>
f0115b29:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b2c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b30:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b34:	74 04                	je     f0115b3a <test_calculate_required_frames+0x2ef>
f0115b36:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b3a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115b3e:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115b41:	89 d0                	mov    %edx,%eax
f0115b43:	c1 e0 02             	shl    $0x2,%eax
f0115b46:	01 d0                	add    %edx,%eax
f0115b48:	01 c0                	add    %eax,%eax
f0115b4a:	83 ec 04             	sub    $0x4,%esp
f0115b4d:	50                   	push   %eax
f0115b4e:	68 00 00 40 00       	push   $0x400000
f0115b53:	ff 75 d8             	pushl  -0x28(%ebp)
f0115b56:	e8 c0 51 ff ff       	call   f010ad1b <calculate_required_frames>
f0115b5b:	83 c4 10             	add    $0x10,%esp
f0115b5e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2563)
f0115b61:	81 7d c8 03 0a 00 00 	cmpl   $0xa03,-0x38(%ebp)
f0115b68:	74 26                	je     f0115b90 <test_calculate_required_frames+0x345>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115b6a:	83 ec 0c             	sub    $0xc,%esp
f0115b6d:	68 03 0a 00 00       	push   $0xa03
f0115b72:	ff 75 c8             	pushl  -0x38(%ebp)
f0115b75:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115b7a:	68 bc 06 00 00       	push   $0x6bc
f0115b7f:	68 d2 30 13 f0       	push   $0xf01330d2
f0115b84:	e8 cb b5 fe ff       	call   f0101154 <_warn>
f0115b89:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115b8c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115b90:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115b94:	74 04                	je     f0115b9a <test_calculate_required_frames+0x34f>
f0115b96:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115b9a:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115b9e:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115ba1:	01 c0                	add    %eax,%eax
f0115ba3:	83 ec 04             	sub    $0x4,%esp
f0115ba6:	50                   	push   %eax
f0115ba7:	68 00 00 70 00       	push   $0x700000
f0115bac:	ff 75 d8             	pushl  -0x28(%ebp)
f0115baf:	e8 67 51 ff ff       	call   f010ad1b <calculate_required_frames>
f0115bb4:	83 c4 10             	add    $0x10,%esp
f0115bb7:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 514)
f0115bba:	81 7d c8 02 02 00 00 	cmpl   $0x202,-0x38(%ebp)
f0115bc1:	74 26                	je     f0115be9 <test_calculate_required_frames+0x39e>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 514);
f0115bc3:	83 ec 0c             	sub    $0xc,%esp
f0115bc6:	68 02 02 00 00       	push   $0x202
f0115bcb:	ff 75 c8             	pushl  -0x38(%ebp)
f0115bce:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115bd3:	68 c8 06 00 00       	push   $0x6c8
f0115bd8:	68 d2 30 13 f0       	push   $0xf01330d2
f0115bdd:	e8 72 b5 fe ff       	call   f0101154 <_warn>
f0115be2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115be5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115be9:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115bed:	74 04                	je     f0115bf3 <test_calculate_required_frames+0x3a8>
f0115bef:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115bf3:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0115bf7:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115bfa:	83 ec 04             	sub    $0x4,%esp
f0115bfd:	50                   	push   %eax
f0115bfe:	68 ff ff 3f 00       	push   $0x3fffff
f0115c03:	ff 75 d8             	pushl  -0x28(%ebp)
f0115c06:	e8 10 51 ff ff       	call   f010ad1b <calculate_required_frames>
f0115c0b:	83 c4 10             	add    $0x10,%esp
f0115c0e:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 4)
f0115c11:	83 7d c8 04          	cmpl   $0x4,-0x38(%ebp)
f0115c15:	74 23                	je     f0115c3a <test_calculate_required_frames+0x3ef>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 4);
f0115c17:	83 ec 0c             	sub    $0xc,%esp
f0115c1a:	6a 04                	push   $0x4
f0115c1c:	ff 75 c8             	pushl  -0x38(%ebp)
f0115c1f:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115c24:	68 d2 06 00 00       	push   $0x6d2
f0115c29:	68 d2 30 13 f0       	push   $0xf01330d2
f0115c2e:	e8 21 b5 fe ff       	call   f0101154 <_warn>
f0115c33:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115c36:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115c3a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115c3e:	74 04                	je     f0115c44 <test_calculate_required_frames+0x3f9>
f0115c40:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115c44:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f0115c48:	83 ec 0c             	sub    $0xc,%esp
f0115c4b:	68 1d 48 13 f0       	push   $0xf013481d
f0115c50:	e8 07 c0 fe ff       	call   f0101c5c <cprintf>
f0115c55:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f0115c58:	83 ec 0c             	sub    $0xc,%esp
f0115c5b:	68 3c 4d 13 f0       	push   $0xf0134d3c
f0115c60:	e8 f7 bf fe ff       	call   f0101c5c <cprintf>
f0115c65:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f0115c68:	83 ec 04             	sub    $0x4,%esp
f0115c6b:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115c71:	50                   	push   %eax
f0115c72:	68 d6 3b 13 f0       	push   $0xf0133bd6
f0115c77:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115c7d:	50                   	push   %eax
f0115c7e:	e8 26 55 00 00       	call   f011b1a9 <strcconcat>
f0115c83:	83 c4 10             	add    $0x10,%esp
f0115c86:	83 ec 0c             	sub    $0xc,%esp
f0115c89:	8d 85 fe fd ff ff    	lea    -0x202(%ebp),%eax
f0115c8f:	50                   	push   %eax
f0115c90:	e8 86 c2 fe ff       	call   f0101f1b <execute_command>
f0115c95:	83 c4 10             	add    $0x10,%esp

		res = calculate_required_frames(proc_directory, 0x0, 8*kilo);
f0115c98:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115c9b:	c1 e0 03             	shl    $0x3,%eax
f0115c9e:	83 ec 04             	sub    $0x4,%esp
f0115ca1:	50                   	push   %eax
f0115ca2:	6a 00                	push   $0x0
f0115ca4:	ff 75 d8             	pushl  -0x28(%ebp)
f0115ca7:	e8 6f 50 ff ff       	call   f010ad1b <calculate_required_frames>
f0115cac:	83 c4 10             	add    $0x10,%esp
f0115caf:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115cb2:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115cb9:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115cbc:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115cbf:	74 24                	je     f0115ce5 <test_calculate_required_frames+0x49a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115cc1:	83 ec 0c             	sub    $0xc,%esp
f0115cc4:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115cc7:	ff 75 c8             	pushl  -0x38(%ebp)
f0115cca:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115ccf:	68 e6 06 00 00       	push   $0x6e6
f0115cd4:	68 d2 30 13 f0       	push   $0xf01330d2
f0115cd9:	e8 76 b4 fe ff       	call   f0101154 <_warn>
f0115cde:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ce1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115ce5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115ce9:	74 04                	je     f0115cef <test_calculate_required_frames+0x4a4>
f0115ceb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115cef:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0115cf3:	83 ec 04             	sub    $0x4,%esp
f0115cf6:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115cfc:	50                   	push   %eax
f0115cfd:	68 e3 3b 13 f0       	push   $0xf0133be3
f0115d02:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d08:	50                   	push   %eax
f0115d09:	e8 9b 54 00 00       	call   f011b1a9 <strcconcat>
f0115d0e:	83 c4 10             	add    $0x10,%esp
f0115d11:	83 ec 0c             	sub    $0xc,%esp
f0115d14:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115d1a:	50                   	push   %eax
f0115d1b:	e8 fb c1 fe ff       	call   f0101f1b <execute_command>
f0115d20:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0115d23:	83 ec 04             	sub    $0x4,%esp
f0115d26:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115d2c:	50                   	push   %eax
f0115d2d:	68 70 4d 13 f0       	push   $0xf0134d70
f0115d32:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115d38:	50                   	push   %eax
f0115d39:	e8 6b 54 00 00       	call   f011b1a9 <strcconcat>
f0115d3e:	83 c4 10             	add    $0x10,%esp
f0115d41:	83 ec 0c             	sub    $0xc,%esp
f0115d44:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115d4a:	50                   	push   %eax
f0115d4b:	e8 cb c1 fe ff       	call   f0101f1b <execute_command>
f0115d50:	83 c4 10             	add    $0x10,%esp

		//Test2
		res = calculate_required_frames(proc_directory, 0x0, 8*mega);
f0115d53:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115d56:	c1 e0 03             	shl    $0x3,%eax
f0115d59:	83 ec 04             	sub    $0x4,%esp
f0115d5c:	50                   	push   %eax
f0115d5d:	6a 00                	push   $0x0
f0115d5f:	ff 75 d8             	pushl  -0x28(%ebp)
f0115d62:	e8 b4 4f ff ff       	call   f010ad1b <calculate_required_frames>
f0115d67:	83 c4 10             	add    $0x10,%esp
f0115d6a:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 2047;
f0115d6d:	c7 45 c4 ff 07 00 00 	movl   $0x7ff,-0x3c(%ebp)
		if (res != expected)
f0115d74:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115d77:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115d7a:	74 24                	je     f0115da0 <test_calculate_required_frames+0x555>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115d7c:	83 ec 0c             	sub    $0xc,%esp
f0115d7f:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115d82:	ff 75 c8             	pushl  -0x38(%ebp)
f0115d85:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115d8a:	68 f4 06 00 00       	push   $0x6f4
f0115d8f:	68 d2 30 13 f0       	push   $0xf01330d2
f0115d94:	e8 bb b3 fe ff       	call   f0101154 <_warn>
f0115d99:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115d9c:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115da0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115da4:	74 04                	je     f0115daa <test_calculate_required_frames+0x55f>
f0115da6:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115daa:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		res = calculate_required_frames(proc_directory, 0x0, 1024*mega);
f0115dae:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115db1:	c1 e0 0a             	shl    $0xa,%eax
f0115db4:	83 ec 04             	sub    $0x4,%esp
f0115db7:	50                   	push   %eax
f0115db8:	6a 00                	push   $0x0
f0115dba:	ff 75 d8             	pushl  -0x28(%ebp)
f0115dbd:	e8 59 4f ff ff       	call   f010ad1b <calculate_required_frames>
f0115dc2:	83 c4 10             	add    $0x10,%esp
f0115dc5:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = ((1024*mega)/(4*mega) + (1024*mega)/(4*kilo)) - 2 - 1 - 2;
f0115dc8:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115dcb:	c1 e0 0a             	shl    $0xa,%eax
f0115dce:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115dd1:	8d 1c 95 00 00 00 00 	lea    0x0(,%edx,4),%ebx
f0115dd8:	99                   	cltd   
f0115dd9:	f7 fb                	idiv   %ebx
f0115ddb:	89 c1                	mov    %eax,%ecx
f0115ddd:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115de0:	c1 e0 0a             	shl    $0xa,%eax
f0115de3:	8b 55 d0             	mov    -0x30(%ebp),%edx
f0115de6:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
f0115ded:	99                   	cltd   
f0115dee:	f7 fe                	idiv   %esi
f0115df0:	01 c8                	add    %ecx,%eax
f0115df2:	83 e8 05             	sub    $0x5,%eax
f0115df5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		if (res != expected)
f0115df8:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115dfb:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115dfe:	74 24                	je     f0115e24 <test_calculate_required_frames+0x5d9>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115e00:	83 ec 0c             	sub    $0xc,%esp
f0115e03:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115e06:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e09:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115e0e:	68 ff 06 00 00       	push   $0x6ff
f0115e13:	68 d2 30 13 f0       	push   $0xf01330d2
f0115e18:	e8 37 b3 fe ff       	call   f0101154 <_warn>
f0115e1d:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115e20:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0115e24:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115e28:	74 04                	je     f0115e2e <test_calculate_required_frames+0x5e3>
f0115e2a:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0115e2e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0115e32:	83 ec 04             	sub    $0x4,%esp
f0115e35:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115e3b:	50                   	push   %eax
f0115e3c:	68 7c 4d 13 f0       	push   $0xf0134d7c
f0115e41:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115e47:	50                   	push   %eax
f0115e48:	e8 5c 53 00 00       	call   f011b1a9 <strcconcat>
f0115e4d:	83 c4 10             	add    $0x10,%esp
f0115e50:	83 ec 0c             	sub    $0xc,%esp
f0115e53:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115e59:	50                   	push   %eax
f0115e5a:	e8 bc c0 fe ff       	call   f0101f1b <execute_command>
f0115e5f:	83 c4 10             	add    $0x10,%esp

		//Test4
		res = calculate_required_frames(proc_directory, 0x1800, 3*kilo);
f0115e62:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0115e65:	89 c2                	mov    %eax,%edx
f0115e67:	01 d2                	add    %edx,%edx
f0115e69:	01 d0                	add    %edx,%eax
f0115e6b:	83 ec 04             	sub    $0x4,%esp
f0115e6e:	50                   	push   %eax
f0115e6f:	68 00 18 00 00       	push   $0x1800
f0115e74:	ff 75 d8             	pushl  -0x28(%ebp)
f0115e77:	e8 9f 4e ff ff       	call   f010ad1b <calculate_required_frames>
f0115e7c:	83 c4 10             	add    $0x10,%esp
f0115e7f:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 1 ;
f0115e82:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (res != expected)
f0115e89:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115e8c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115e8f:	74 24                	je     f0115eb5 <test_calculate_required_frames+0x66a>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115e91:	83 ec 0c             	sub    $0xc,%esp
f0115e94:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115e97:	ff 75 c8             	pushl  -0x38(%ebp)
f0115e9a:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115e9f:	68 0e 07 00 00       	push   $0x70e
f0115ea4:	68 d2 30 13 f0       	push   $0xf01330d2
f0115ea9:	e8 a6 b2 fe ff       	call   f0101154 <_warn>
f0115eae:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115eb1:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115eb5:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115eb9:	74 04                	je     f0115ebf <test_calculate_required_frames+0x674>
f0115ebb:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115ebf:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0115ec3:	83 ec 04             	sub    $0x4,%esp
f0115ec6:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115ecc:	50                   	push   %eax
f0115ecd:	68 3c 3e 13 f0       	push   $0xf0133e3c
f0115ed2:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115ed8:	50                   	push   %eax
f0115ed9:	e8 cb 52 00 00       	call   f011b1a9 <strcconcat>
f0115ede:	83 c4 10             	add    $0x10,%esp
f0115ee1:	83 ec 0c             	sub    $0xc,%esp
f0115ee4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115eea:	50                   	push   %eax
f0115eeb:	e8 2b c0 fe ff       	call   f0101f1b <execute_command>
f0115ef0:	83 c4 10             	add    $0x10,%esp

		//Test5
		res = calculate_required_frames(proc_directory, 0x400000, 10*mega);
f0115ef3:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0115ef6:	89 d0                	mov    %edx,%eax
f0115ef8:	c1 e0 02             	shl    $0x2,%eax
f0115efb:	01 d0                	add    %edx,%eax
f0115efd:	01 c0                	add    %eax,%eax
f0115eff:	83 ec 04             	sub    $0x4,%esp
f0115f02:	50                   	push   %eax
f0115f03:	68 00 00 40 00       	push   $0x400000
f0115f08:	ff 75 d8             	pushl  -0x28(%ebp)
f0115f0b:	e8 0b 4e ff ff       	call   f010ad1b <calculate_required_frames>
f0115f10:	83 c4 10             	add    $0x10,%esp
f0115f13:	89 45 c8             	mov    %eax,-0x38(%ebp)
		if (res != 2561)
f0115f16:	81 7d c8 01 0a 00 00 	cmpl   $0xa01,-0x38(%ebp)
f0115f1d:	74 26                	je     f0115f45 <test_calculate_required_frames+0x6fa>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, 2563);
f0115f1f:	83 ec 0c             	sub    $0xc,%esp
f0115f22:	68 03 0a 00 00       	push   $0xa03
f0115f27:	ff 75 c8             	pushl  -0x38(%ebp)
f0115f2a:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115f2f:	68 1a 07 00 00       	push   $0x71a
f0115f34:	68 d2 30 13 f0       	push   $0xf01330d2
f0115f39:	e8 16 b2 fe ff       	call   f0101154 <_warn>
f0115f3e:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115f41:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0115f45:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0115f49:	74 04                	je     f0115f4f <test_calculate_required_frames+0x704>
f0115f4b:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0115f4f:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}

	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0115f53:	83 ec 04             	sub    $0x4,%esp
f0115f56:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115f5c:	50                   	push   %eax
f0115f5d:	68 46 3e 13 f0       	push   $0xf0133e46
f0115f62:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115f68:	50                   	push   %eax
f0115f69:	e8 3b 52 00 00       	call   f011b1a9 <strcconcat>
f0115f6e:	83 c4 10             	add    $0x10,%esp
f0115f71:	83 ec 0c             	sub    $0xc,%esp
f0115f74:	8d 85 62 fe ff ff    	lea    -0x19e(%ebp),%eax
f0115f7a:	50                   	push   %eax
f0115f7b:	e8 9b bf fe ff       	call   f0101f1b <execute_command>
f0115f80:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0115f83:	83 ec 04             	sub    $0x4,%esp
f0115f86:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115f8c:	50                   	push   %eax
f0115f8d:	68 84 4d 13 f0       	push   $0xf0134d84
f0115f92:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0115f98:	50                   	push   %eax
f0115f99:	e8 0b 52 00 00       	call   f011b1a9 <strcconcat>
f0115f9e:	83 c4 10             	add    $0x10,%esp
f0115fa1:	83 ec 0c             	sub    $0xc,%esp
f0115fa4:	8d 85 c6 fe ff ff    	lea    -0x13a(%ebp),%eax
f0115faa:	50                   	push   %eax
f0115fab:	e8 6b bf fe ff       	call   f0101f1b <execute_command>
f0115fb0:	83 c4 10             	add    $0x10,%esp

		//Test7
		res = calculate_required_frames(proc_directory, 0x700000, 2*mega);
f0115fb3:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0115fb6:	01 c0                	add    %eax,%eax
f0115fb8:	83 ec 04             	sub    $0x4,%esp
f0115fbb:	50                   	push   %eax
f0115fbc:	68 00 00 70 00       	push   $0x700000
f0115fc1:	ff 75 d8             	pushl  -0x28(%ebp)
f0115fc4:	e8 52 4d ff ff       	call   f010ad1b <calculate_required_frames>
f0115fc9:	83 c4 10             	add    $0x10,%esp
f0115fcc:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 510 ;
f0115fcf:	c7 45 c4 fe 01 00 00 	movl   $0x1fe,-0x3c(%ebp)
		if (res != expected)
f0115fd6:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0115fd9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0115fdc:	74 24                	je     f0116002 <test_calculate_required_frames+0x7b7>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0115fde:	83 ec 0c             	sub    $0xc,%esp
f0115fe1:	ff 75 c4             	pushl  -0x3c(%ebp)
f0115fe4:	ff 75 c8             	pushl  -0x38(%ebp)
f0115fe7:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0115fec:	68 2a 07 00 00       	push   $0x72a
f0115ff1:	68 d2 30 13 f0       	push   $0xf01330d2
f0115ff6:	e8 59 b1 fe ff       	call   f0101154 <_warn>
f0115ffb:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0115ffe:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116002:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116006:	74 04                	je     f011600c <test_calculate_required_frames+0x7c1>
f0116008:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f011600c:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		res = calculate_required_frames(proc_directory, 0x3FFFFF, 1*kilo);
f0116010:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116013:	83 ec 04             	sub    $0x4,%esp
f0116016:	50                   	push   %eax
f0116017:	68 ff ff 3f 00       	push   $0x3fffff
f011601c:	ff 75 d8             	pushl  -0x28(%ebp)
f011601f:	e8 f7 4c ff ff       	call   f010ad1b <calculate_required_frames>
f0116024:	83 c4 10             	add    $0x10,%esp
f0116027:	89 45 c8             	mov    %eax,-0x38(%ebp)
		expected = 3 ;
f011602a:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (res != expected)
f0116031:	8b 45 c8             	mov    -0x38(%ebp),%eax
f0116034:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116037:	74 24                	je     f011605d <test_calculate_required_frames+0x812>
		{
			warn("[EVAL] calculate_required_frames: Failed (count is not correct). res=%d, expected=%d\n", res, expected);
f0116039:	83 ec 0c             	sub    $0xc,%esp
f011603c:	ff 75 c4             	pushl  -0x3c(%ebp)
f011603f:	ff 75 c8             	pushl  -0x38(%ebp)
f0116042:	68 e4 4c 13 f0       	push   $0xf0134ce4
f0116047:	68 35 07 00 00       	push   $0x735
f011604c:	68 d2 30 13 f0       	push   $0xf01330d2
f0116051:	e8 fe b0 fe ff       	call   f0101154 <_warn>
f0116056:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116059:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011605d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116061:	74 04                	je     f0116067 <test_calculate_required_frames+0x81c>
f0116063:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116067:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f011606b:	83 ec 0c             	sub    $0xc,%esp
f011606e:	68 f7 3d 13 f0       	push   $0xf0133df7
f0116073:	e8 e4 bb fe ff       	call   f0101c5c <cprintf>
f0116078:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_required_frames: FINISHED. Evaluation = %d\n", eval);
f011607b:	83 ec 08             	sub    $0x8,%esp
f011607e:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116081:	68 90 4d 13 f0       	push   $0xf0134d90
f0116086:	e8 d1 bb fe ff       	call   f0101c5c <cprintf>
f011608b:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f011608e:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116092:	75 10                	jne    f01160a4 <test_calculate_required_frames+0x859>
		cprintf("Congratulations!! test calculate_required_frames completed successfully.\n");
f0116094:	83 ec 0c             	sub    $0xc,%esp
f0116097:	68 d0 4d 13 f0       	push   $0xf0134dd0
f011609c:	e8 bb bb fe ff       	call   f0101c5c <cprintf>
f01160a1:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f01160a4:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f01160a9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f01160ac:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01160af:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f01160b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01160b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01160ba:	5b                   	pop    %ebx
f01160bb:	5e                   	pop    %esi
f01160bc:	5f                   	pop    %edi
f01160bd:	5d                   	pop    %ebp
f01160be:	c3                   	ret    

f01160bf <test_calculate_allocated_space>:

int test_calculate_allocated_space()
{
f01160bf:	55                   	push   %ebp
f01160c0:	89 e5                	mov    %esp,%ebp
f01160c2:	57                   	push   %edi
f01160c3:	56                   	push   %esi
f01160c4:	53                   	push   %ebx
f01160c5:	81 ec 0c 02 00 00    	sub    $0x20c,%esp
	//Create a Temp. User Process
	char prog_name[50] = "fos_helloWorld";
f01160cb:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01160ce:	bb 6c 3b 13 f0       	mov    $0xf0133b6c,%ebx
f01160d3:	ba 0f 00 00 00       	mov    $0xf,%edx
f01160d8:	89 c7                	mov    %eax,%edi
f01160da:	89 de                	mov    %ebx,%esi
f01160dc:	89 d1                	mov    %edx,%ecx
f01160de:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f01160e0:	8d 55 9d             	lea    -0x63(%ebp),%edx
f01160e3:	b9 23 00 00 00       	mov    $0x23,%ecx
f01160e8:	b0 00                	mov    $0x0,%al
f01160ea:	89 d7                	mov    %edx,%edi
f01160ec:	f3 aa                	rep stos %al,%es:(%edi)
	struct Env* env = env_create(prog_name, 20, 10, 0);
f01160ee:	6a 00                	push   $0x0
f01160f0:	6a 0a                	push   $0xa
f01160f2:	6a 14                	push   $0x14
f01160f4:	8d 45 8e             	lea    -0x72(%ebp),%eax
f01160f7:	50                   	push   %eax
f01160f8:	e8 64 4e ff ff       	call   f010af61 <env_create>
f01160fd:	83 c4 10             	add    $0x10,%esp
f0116100:	89 45 dc             	mov    %eax,-0x24(%ebp)
	uint32 *proc_directory = env->env_page_directory ;
f0116103:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116106:	8b 40 64             	mov    0x64(%eax),%eax
f0116109:	89 45 d8             	mov    %eax,-0x28(%ebp)
	lcr3(env->env_cr3) ;
f011610c:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011610f:	8b 40 68             	mov    0x68(%eax),%eax
f0116112:	89 45 c0             	mov    %eax,-0x40(%ebp)
f0116115:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0116118:	0f 22 d8             	mov    %eax,%cr3
	char aup[20] = "aup " ;
f011611b:	c7 85 7a ff ff ff 61 	movl   $0x20707561,-0x86(%ebp)
f0116122:	75 70 20 
f0116125:	c7 85 7e ff ff ff 00 	movl   $0x0,-0x82(%ebp)
f011612c:	00 00 00 
f011612f:	8d 55 82             	lea    -0x7e(%ebp),%edx
f0116132:	b9 03 00 00 00       	mov    $0x3,%ecx
f0116137:	b8 00 00 00 00       	mov    $0x0,%eax
f011613c:	89 d7                	mov    %edx,%edi
f011613e:	f3 ab                	rep stos %eax,%es:(%edi)
	char env_id[20] ; ltostr(env->env_id, env_id) ;
f0116140:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0116143:	8b 40 10             	mov    0x10(%eax),%eax
f0116146:	83 ec 08             	sub    $0x8,%esp
f0116149:	8d 95 66 ff ff ff    	lea    -0x9a(%ebp),%edx
f011614f:	52                   	push   %edx
f0116150:	50                   	push   %eax
f0116151:	e8 7a 4f 00 00       	call   f011b0d0 <ltostr>
f0116156:	83 c4 10             	add    $0x10,%esp
	char aup_cmd[50];
	strcconcat(aup, env_id, aup_cmd);
f0116159:	83 ec 04             	sub    $0x4,%esp
f011615c:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116162:	50                   	push   %eax
f0116163:	8d 85 66 ff ff ff    	lea    -0x9a(%ebp),%eax
f0116169:	50                   	push   %eax
f011616a:	8d 85 7a ff ff ff    	lea    -0x86(%ebp),%eax
f0116170:	50                   	push   %eax
f0116171:	e8 33 50 00 00       	call   f011b1a9 <strcconcat>
f0116176:	83 c4 10             	add    $0x10,%esp
	//===================================================

	char *ptr1, *ptr2, *ptr3, *ptr4, *ptr5, *ptr6, *ptr7, *ptr8;
	char tptr[10] ;
	int kilo = 1024 ;
f0116179:	c7 45 d0 00 04 00 00 	movl   $0x400,-0x30(%ebp)
	int mega = 1024*1024 ;
f0116180:	c7 45 cc 00 00 10 00 	movl   $0x100000,-0x34(%ebp)
	uint32 eval = 0;
f0116187:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
	uint8 correct = 1;
f011618e:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	uint32 expected_num_pages;
	uint32 expected_num_tables;
	uint32 numOfFreeFramesBefore, numOfFreeFramesAfter;
	uint32 num_pages = 0;
f0116192:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116199:	00 00 00 
	uint32 num_tables = 0;
f011619c:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01161a3:	00 00 00 
	ClearUserSpace(proc_directory);
f01161a6:	83 ec 0c             	sub    $0xc,%esp
f01161a9:	ff 75 d8             	pushl  -0x28(%ebp)
f01161ac:	e8 8d 0e 00 00       	call   f011703e <ClearUserSpace>
f01161b1:	83 c4 10             	add    $0x10,%esp

	/*================================================*/
	/*PART I: ALL pages and tables are not exist 50%  */
	/*================================================*/
	cprintf("\nCASE I: ALL pages and tables are not exist [50%]\n") ;
f01161b4:	83 ec 0c             	sub    $0xc,%esp
f01161b7:	68 b0 4c 13 f0       	push   $0xf0134cb0
f01161bc:	e8 9b ba fe ff       	call   f0101c5c <cprintf>
f01161c1:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f01161c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01161c7:	c1 e0 03             	shl    $0x3,%eax
f01161ca:	89 c2                	mov    %eax,%edx
f01161cc:	83 ec 0c             	sub    $0xc,%esp
f01161cf:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01161d5:	50                   	push   %eax
f01161d6:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01161dc:	50                   	push   %eax
f01161dd:	52                   	push   %edx
f01161de:	6a 00                	push   $0x0
f01161e0:	ff 75 d8             	pushl  -0x28(%ebp)
f01161e3:	e8 19 4b ff ff       	call   f010ad01 <calculate_allocated_space>
f01161e8:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01161eb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161f1:	85 c0                	test   %eax,%eax
f01161f3:	74 27                	je     f011621c <test_calculate_allocated_space+0x15d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01161f5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01161fb:	83 ec 0c             	sub    $0xc,%esp
f01161fe:	6a 00                	push   $0x0
f0116200:	50                   	push   %eax
f0116201:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116206:	68 6a 07 00 00       	push   $0x76a
f011620b:	68 d2 30 13 f0       	push   $0xf01330d2
f0116210:	e8 3f af fe ff       	call   f0101154 <_warn>
f0116215:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116218:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011621c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116222:	85 c0                	test   %eax,%eax
f0116224:	74 27                	je     f011624d <test_calculate_allocated_space+0x18e>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116226:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011622c:	83 ec 0c             	sub    $0xc,%esp
f011622f:	6a 00                	push   $0x0
f0116231:	50                   	push   %eax
f0116232:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116237:	68 6f 07 00 00       	push   $0x76f
f011623c:	68 d2 30 13 f0       	push   $0xf01330d2
f0116241:	e8 0e af fe ff       	call   f0101154 <_warn>
f0116246:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116249:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011624d:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116251:	74 04                	je     f0116257 <test_calculate_allocated_space+0x198>
f0116253:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116257:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test2
		num_tables = 0;
f011625b:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116262:	00 00 00 
		num_pages = 0;
f0116265:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011626c:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+4*mega, &num_tables, &num_pages);
f011626f:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116272:	c1 e0 02             	shl    $0x2,%eax
f0116275:	89 c2                	mov    %eax,%edx
f0116277:	83 ec 0c             	sub    $0xc,%esp
f011627a:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116280:	50                   	push   %eax
f0116281:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116287:	50                   	push   %eax
f0116288:	52                   	push   %edx
f0116289:	6a 00                	push   $0x0
f011628b:	ff 75 d8             	pushl  -0x28(%ebp)
f011628e:	e8 6e 4a ff ff       	call   f010ad01 <calculate_allocated_space>
f0116293:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116296:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011629c:	85 c0                	test   %eax,%eax
f011629e:	74 27                	je     f01162c7 <test_calculate_allocated_space+0x208>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01162a0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01162a6:	83 ec 0c             	sub    $0xc,%esp
f01162a9:	6a 00                	push   $0x0
f01162ab:	50                   	push   %eax
f01162ac:	68 1c 4e 13 f0       	push   $0xf0134e1c
f01162b1:	68 7b 07 00 00       	push   $0x77b
f01162b6:	68 d2 30 13 f0       	push   $0xf01330d2
f01162bb:	e8 94 ae fe ff       	call   f0101154 <_warn>
f01162c0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162c3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01162c7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162cd:	85 c0                	test   %eax,%eax
f01162cf:	74 27                	je     f01162f8 <test_calculate_allocated_space+0x239>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01162d1:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01162d7:	83 ec 0c             	sub    $0xc,%esp
f01162da:	6a 00                	push   $0x0
f01162dc:	50                   	push   %eax
f01162dd:	68 7c 4e 13 f0       	push   $0xf0134e7c
f01162e2:	68 80 07 00 00       	push   $0x780
f01162e7:	68 d2 30 13 f0       	push   $0xf01330d2
f01162ec:	e8 63 ae fe ff       	call   f0101154 <_warn>
f01162f1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01162f4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01162f8:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01162fc:	74 04                	je     f0116302 <test_calculate_allocated_space+0x243>
f01162fe:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116302:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116306:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011630d:	00 00 00 
		num_pages = 0;
f0116310:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116317:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f011631a:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011631d:	c1 e0 0a             	shl    $0xa,%eax
f0116320:	89 c2                	mov    %eax,%edx
f0116322:	83 ec 0c             	sub    $0xc,%esp
f0116325:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011632b:	50                   	push   %eax
f011632c:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116332:	50                   	push   %eax
f0116333:	52                   	push   %edx
f0116334:	6a 00                	push   $0x0
f0116336:	ff 75 d8             	pushl  -0x28(%ebp)
f0116339:	e8 c3 49 ff ff       	call   f010ad01 <calculate_allocated_space>
f011633e:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116341:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116347:	85 c0                	test   %eax,%eax
f0116349:	74 27                	je     f0116372 <test_calculate_allocated_space+0x2b3>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f011634b:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116351:	83 ec 0c             	sub    $0xc,%esp
f0116354:	6a 00                	push   $0x0
f0116356:	50                   	push   %eax
f0116357:	68 1c 4e 13 f0       	push   $0xf0134e1c
f011635c:	68 8c 07 00 00       	push   $0x78c
f0116361:	68 d2 30 13 f0       	push   $0xf01330d2
f0116366:	e8 e9 ad fe ff       	call   f0101154 <_warn>
f011636b:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011636e:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116372:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116378:	85 c0                	test   %eax,%eax
f011637a:	74 27                	je     f01163a3 <test_calculate_allocated_space+0x2e4>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f011637c:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116382:	83 ec 0c             	sub    $0xc,%esp
f0116385:	6a 00                	push   $0x0
f0116387:	50                   	push   %eax
f0116388:	68 7c 4e 13 f0       	push   $0xf0134e7c
f011638d:	68 91 07 00 00       	push   $0x791
f0116392:	68 d2 30 13 f0       	push   $0xf01330d2
f0116397:	e8 b8 ad fe ff       	call   f0101154 <_warn>
f011639c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011639f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01163a3:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01163a7:	74 04                	je     f01163ad <test_calculate_allocated_space+0x2ee>
f01163a9:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01163ad:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test4
		num_tables = 0;
f01163b1:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01163b8:	00 00 00 
		num_pages = 0;
f01163bb:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01163c2:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1000, 0x1000+6*kilo, &num_tables, &num_pages);
f01163c5:	8b 55 d0             	mov    -0x30(%ebp),%edx
f01163c8:	89 d0                	mov    %edx,%eax
f01163ca:	01 c0                	add    %eax,%eax
f01163cc:	01 d0                	add    %edx,%eax
f01163ce:	01 c0                	add    %eax,%eax
f01163d0:	05 00 10 00 00       	add    $0x1000,%eax
f01163d5:	89 c2                	mov    %eax,%edx
f01163d7:	83 ec 0c             	sub    $0xc,%esp
f01163da:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01163e0:	50                   	push   %eax
f01163e1:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01163e7:	50                   	push   %eax
f01163e8:	52                   	push   %edx
f01163e9:	68 00 10 00 00       	push   $0x1000
f01163ee:	ff 75 d8             	pushl  -0x28(%ebp)
f01163f1:	e8 0b 49 ff ff       	call   f010ad01 <calculate_allocated_space>
f01163f6:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01163f9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01163ff:	85 c0                	test   %eax,%eax
f0116401:	74 27                	je     f011642a <test_calculate_allocated_space+0x36b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116403:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116409:	83 ec 0c             	sub    $0xc,%esp
f011640c:	6a 00                	push   $0x0
f011640e:	50                   	push   %eax
f011640f:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116414:	68 9e 07 00 00       	push   $0x79e
f0116419:	68 d2 30 13 f0       	push   $0xf01330d2
f011641e:	e8 31 ad fe ff       	call   f0101154 <_warn>
f0116423:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116426:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011642a:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116430:	85 c0                	test   %eax,%eax
f0116432:	74 27                	je     f011645b <test_calculate_allocated_space+0x39c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116434:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011643a:	83 ec 0c             	sub    $0xc,%esp
f011643d:	6a 00                	push   $0x0
f011643f:	50                   	push   %eax
f0116440:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116445:	68 a3 07 00 00       	push   $0x7a3
f011644a:	68 d2 30 13 f0       	push   $0xf01330d2
f011644f:	e8 00 ad fe ff       	call   f0101154 <_warn>
f0116454:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116457:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f011645b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011645f:	74 04                	je     f0116465 <test_calculate_allocated_space+0x3a6>
f0116461:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116465:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test5
		num_tables = 0;
f0116469:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116470:	00 00 00 
		num_pages = 0;
f0116473:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011647a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f011647d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116480:	89 c2                	mov    %eax,%edx
f0116482:	01 d2                	add    %edx,%edx
f0116484:	01 d0                	add    %edx,%eax
f0116486:	05 00 18 00 00       	add    $0x1800,%eax
f011648b:	89 c2                	mov    %eax,%edx
f011648d:	83 ec 0c             	sub    $0xc,%esp
f0116490:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116496:	50                   	push   %eax
f0116497:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f011649d:	50                   	push   %eax
f011649e:	52                   	push   %edx
f011649f:	68 00 18 00 00       	push   $0x1800
f01164a4:	ff 75 d8             	pushl  -0x28(%ebp)
f01164a7:	e8 55 48 ff ff       	call   f010ad01 <calculate_allocated_space>
f01164ac:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01164af:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164b5:	85 c0                	test   %eax,%eax
f01164b7:	74 27                	je     f01164e0 <test_calculate_allocated_space+0x421>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01164b9:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01164bf:	83 ec 0c             	sub    $0xc,%esp
f01164c2:	6a 00                	push   $0x0
f01164c4:	50                   	push   %eax
f01164c5:	68 1c 4e 13 f0       	push   $0xf0134e1c
f01164ca:	68 af 07 00 00       	push   $0x7af
f01164cf:	68 d2 30 13 f0       	push   $0xf01330d2
f01164d4:	e8 7b ac fe ff       	call   f0101154 <_warn>
f01164d9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01164dc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01164e0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164e6:	85 c0                	test   %eax,%eax
f01164e8:	74 27                	je     f0116511 <test_calculate_allocated_space+0x452>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01164ea:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01164f0:	83 ec 0c             	sub    $0xc,%esp
f01164f3:	6a 00                	push   $0x0
f01164f5:	50                   	push   %eax
f01164f6:	68 7c 4e 13 f0       	push   $0xf0134e7c
f01164fb:	68 b4 07 00 00       	push   $0x7b4
f0116500:	68 d2 30 13 f0       	push   $0xf01330d2
f0116505:	e8 4a ac fe ff       	call   f0101154 <_warn>
f011650a:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011650d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116511:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116515:	74 04                	je     f011651b <test_calculate_allocated_space+0x45c>
f0116517:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f011651b:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test6
		num_tables = 0;
f011651f:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116526:	00 00 00 
		num_pages = 0;
f0116529:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116530:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116533:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116536:	89 d0                	mov    %edx,%eax
f0116538:	c1 e0 02             	shl    $0x2,%eax
f011653b:	01 d0                	add    %edx,%eax
f011653d:	01 c0                	add    %eax,%eax
f011653f:	05 00 00 40 00       	add    $0x400000,%eax
f0116544:	89 c2                	mov    %eax,%edx
f0116546:	83 ec 0c             	sub    $0xc,%esp
f0116549:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f011654f:	50                   	push   %eax
f0116550:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116556:	50                   	push   %eax
f0116557:	52                   	push   %edx
f0116558:	68 00 00 40 00       	push   $0x400000
f011655d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116560:	e8 9c 47 ff ff       	call   f010ad01 <calculate_allocated_space>
f0116565:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f0116568:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011656e:	85 c0                	test   %eax,%eax
f0116570:	74 27                	je     f0116599 <test_calculate_allocated_space+0x4da>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116572:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116578:	83 ec 0c             	sub    $0xc,%esp
f011657b:	6a 00                	push   $0x0
f011657d:	50                   	push   %eax
f011657e:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116583:	68 c0 07 00 00       	push   $0x7c0
f0116588:	68 d2 30 13 f0       	push   $0xf01330d2
f011658d:	e8 c2 ab fe ff       	call   f0101154 <_warn>
f0116592:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116595:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f0116599:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011659f:	85 c0                	test   %eax,%eax
f01165a1:	74 27                	je     f01165ca <test_calculate_allocated_space+0x50b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f01165a3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01165a9:	83 ec 0c             	sub    $0xc,%esp
f01165ac:	6a 00                	push   $0x0
f01165ae:	50                   	push   %eax
f01165af:	68 7c 4e 13 f0       	push   $0xf0134e7c
f01165b4:	68 c5 07 00 00       	push   $0x7c5
f01165b9:	68 d2 30 13 f0       	push   $0xf01330d2
f01165be:	e8 91 ab fe ff       	call   f0101154 <_warn>
f01165c3:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01165c6:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f01165ca:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f01165ce:	74 04                	je     f01165d4 <test_calculate_allocated_space+0x515>
f01165d0:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f01165d4:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		//Test7
		num_tables = 0;
f01165d8:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01165df:	00 00 00 
		num_pages = 0;
f01165e2:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01165e9:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f01165ec:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01165ef:	05 00 00 38 00       	add    $0x380000,%eax
f01165f4:	01 c0                	add    %eax,%eax
f01165f6:	89 c2                	mov    %eax,%edx
f01165f8:	83 ec 0c             	sub    $0xc,%esp
f01165fb:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116601:	50                   	push   %eax
f0116602:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116608:	50                   	push   %eax
f0116609:	52                   	push   %edx
f011660a:	68 00 00 70 00       	push   $0x700000
f011660f:	ff 75 d8             	pushl  -0x28(%ebp)
f0116612:	e8 ea 46 ff ff       	call   f010ad01 <calculate_allocated_space>
f0116617:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f011661a:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116620:	85 c0                	test   %eax,%eax
f0116622:	74 27                	je     f011664b <test_calculate_allocated_space+0x58c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f0116624:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f011662a:	83 ec 0c             	sub    $0xc,%esp
f011662d:	6a 00                	push   $0x0
f011662f:	50                   	push   %eax
f0116630:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116635:	68 d2 07 00 00       	push   $0x7d2
f011663a:	68 d2 30 13 f0       	push   $0xf01330d2
f011663f:	e8 10 ab fe ff       	call   f0101154 <_warn>
f0116644:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116647:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f011664b:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116651:	85 c0                	test   %eax,%eax
f0116653:	74 27                	je     f011667c <test_calculate_allocated_space+0x5bd>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116655:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011665b:	83 ec 0c             	sub    $0xc,%esp
f011665e:	6a 00                	push   $0x0
f0116660:	50                   	push   %eax
f0116661:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116666:	68 d7 07 00 00       	push   $0x7d7
f011666b:	68 d2 30 13 f0       	push   $0xf01330d2
f0116670:	e8 df aa fe ff       	call   f0101154 <_warn>
f0116675:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116678:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011667c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116680:	74 04                	je     f0116686 <test_calculate_allocated_space+0x5c7>
f0116682:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116686:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test8
		num_tables = 0;
f011668a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116691:	00 00 00 
		num_pages = 0;
f0116694:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011669b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f011669e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01166a1:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f01166a6:	89 c2                	mov    %eax,%edx
f01166a8:	83 ec 0c             	sub    $0xc,%esp
f01166ab:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01166b1:	50                   	push   %eax
f01166b2:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01166b8:	50                   	push   %eax
f01166b9:	52                   	push   %edx
f01166ba:	68 ff ff 3f 00       	push   $0x3fffff
f01166bf:	ff 75 d8             	pushl  -0x28(%ebp)
f01166c2:	e8 3a 46 ff ff       	call   f010ad01 <calculate_allocated_space>
f01166c7:	83 c4 20             	add    $0x20,%esp
		if (num_tables != 0)
f01166ca:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166d0:	85 c0                	test   %eax,%eax
f01166d2:	74 27                	je     f01166fb <test_calculate_allocated_space+0x63c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, 0);
f01166d4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01166da:	83 ec 0c             	sub    $0xc,%esp
f01166dd:	6a 00                	push   $0x0
f01166df:	50                   	push   %eax
f01166e0:	68 1c 4e 13 f0       	push   $0xf0134e1c
f01166e5:	68 e3 07 00 00       	push   $0x7e3
f01166ea:	68 d2 30 13 f0       	push   $0xf01330d2
f01166ef:	e8 60 aa fe ff       	call   f0101154 <_warn>
f01166f4:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01166f7:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != 0)
f01166fb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116701:	85 c0                	test   %eax,%eax
f0116703:	74 27                	je     f011672c <test_calculate_allocated_space+0x66d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, 0);
f0116705:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011670b:	83 ec 0c             	sub    $0xc,%esp
f011670e:	6a 00                	push   $0x0
f0116710:	50                   	push   %eax
f0116711:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116716:	68 e8 07 00 00       	push   $0x7e8
f011671b:	68 d2 30 13 f0       	push   $0xf01330d2
f0116720:	e8 2f aa fe ff       	call   f0101154 <_warn>
f0116725:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116728:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f011672c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116730:	74 04                	je     f0116736 <test_calculate_allocated_space+0x677>
f0116732:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116736:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE I: END\n") ;
f011673a:	83 ec 0c             	sub    $0xc,%esp
f011673d:	68 1d 48 13 f0       	push   $0xf013481d
f0116742:	e8 15 b5 fe ff       	call   f0101c5c <cprintf>
f0116747:	83 c4 10             	add    $0x10,%esp

	/*==================================================*/
	/*PART II: SOME pages and/or tables are exist [50%] */
	/*==================================================*/
	cprintf("\nCASE II: SOME pages and/or tables are exist [50%]\n") ;
f011674a:	83 ec 0c             	sub    $0xc,%esp
f011674d:	68 3c 4d 13 f0       	push   $0xf0134d3c
f0116752:	e8 05 b5 fe ff       	call   f0101c5c <cprintf>
f0116757:	83 c4 10             	add    $0x10,%esp
	{
		//Test1
		/*allocate page*/char c1[100] ;strcconcat(aup_cmd, " 0x0", c1); execute_command(c1);
f011675a:	83 ec 04             	sub    $0x4,%esp
f011675d:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116763:	50                   	push   %eax
f0116764:	68 d6 3b 13 f0       	push   $0xf0133bd6
f0116769:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011676f:	50                   	push   %eax
f0116770:	e8 34 4a 00 00       	call   f011b1a9 <strcconcat>
f0116775:	83 c4 10             	add    $0x10,%esp
f0116778:	83 ec 0c             	sub    $0xc,%esp
f011677b:	8d 85 f4 fd ff ff    	lea    -0x20c(%ebp),%eax
f0116781:	50                   	push   %eax
f0116782:	e8 94 b7 fe ff       	call   f0101f1b <execute_command>
f0116787:	83 c4 10             	add    $0x10,%esp

		num_tables = 0;
f011678a:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116791:	00 00 00 
		num_pages = 0;
f0116794:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f011679b:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*kilo, &num_tables, &num_pages);
f011679e:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01167a1:	c1 e0 03             	shl    $0x3,%eax
f01167a4:	89 c2                	mov    %eax,%edx
f01167a6:	83 ec 0c             	sub    $0xc,%esp
f01167a9:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01167af:	50                   	push   %eax
f01167b0:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01167b6:	50                   	push   %eax
f01167b7:	52                   	push   %edx
f01167b8:	6a 00                	push   $0x0
f01167ba:	ff 75 d8             	pushl  -0x28(%ebp)
f01167bd:	e8 3f 45 ff ff       	call   f010ad01 <calculate_allocated_space>
f01167c2:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01167c5:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1 ;
f01167cc:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01167d3:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167d9:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01167dc:	74 28                	je     f0116806 <test_calculate_allocated_space+0x747>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01167de:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01167e4:	83 ec 0c             	sub    $0xc,%esp
f01167e7:	ff 75 c8             	pushl  -0x38(%ebp)
f01167ea:	50                   	push   %eax
f01167eb:	68 1c 4e 13 f0       	push   $0xf0134e1c
f01167f0:	68 ff 07 00 00       	push   $0x7ff
f01167f5:	68 d2 30 13 f0       	push   $0xf01330d2
f01167fa:	e8 55 a9 fe ff       	call   f0101154 <_warn>
f01167ff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116802:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116806:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f011680c:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011680f:	74 28                	je     f0116839 <test_calculate_allocated_space+0x77a>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116811:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116817:	83 ec 0c             	sub    $0xc,%esp
f011681a:	ff 75 c4             	pushl  -0x3c(%ebp)
f011681d:	50                   	push   %eax
f011681e:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116823:	68 04 08 00 00       	push   $0x804
f0116828:	68 d2 30 13 f0       	push   $0xf01330d2
f011682d:	e8 22 a9 fe ff       	call   f0101154 <_warn>
f0116832:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116835:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116839:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011683d:	74 04                	je     f0116843 <test_calculate_allocated_space+0x784>
f011683f:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116843:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c2[100] ;strcconcat(aup_cmd, " 0x100000", c2); execute_command(c2);
f0116847:	83 ec 04             	sub    $0x4,%esp
f011684a:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116850:	50                   	push   %eax
f0116851:	68 e3 3b 13 f0       	push   $0xf0133be3
f0116856:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011685c:	50                   	push   %eax
f011685d:	e8 47 49 00 00       	call   f011b1a9 <strcconcat>
f0116862:	83 c4 10             	add    $0x10,%esp
f0116865:	83 ec 0c             	sub    $0xc,%esp
f0116868:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f011686e:	50                   	push   %eax
f011686f:	e8 a7 b6 fe ff       	call   f0101f1b <execute_command>
f0116874:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x10000000", c3); execute_command(c3);
f0116877:	83 ec 04             	sub    $0x4,%esp
f011687a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116880:	50                   	push   %eax
f0116881:	68 70 4d 13 f0       	push   $0xf0134d70
f0116886:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f011688c:	50                   	push   %eax
f011688d:	e8 17 49 00 00       	call   f011b1a9 <strcconcat>
f0116892:	83 c4 10             	add    $0x10,%esp
f0116895:	83 ec 0c             	sub    $0xc,%esp
f0116898:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f011689e:	50                   	push   %eax
f011689f:	e8 77 b6 fe ff       	call   f0101f1b <execute_command>
f01168a4:	83 c4 10             	add    $0x10,%esp

		//Test2
		num_tables = 0;
f01168a7:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f01168ae:	00 00 00 
		num_pages = 0;
f01168b1:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f01168b8:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+8*mega, &num_tables, &num_pages);
f01168bb:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01168be:	c1 e0 03             	shl    $0x3,%eax
f01168c1:	89 c2                	mov    %eax,%edx
f01168c3:	83 ec 0c             	sub    $0xc,%esp
f01168c6:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f01168cc:	50                   	push   %eax
f01168cd:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f01168d3:	50                   	push   %eax
f01168d4:	52                   	push   %edx
f01168d5:	6a 00                	push   $0x0
f01168d7:	ff 75 d8             	pushl  -0x28(%ebp)
f01168da:	e8 22 44 ff ff       	call   f010ad01 <calculate_allocated_space>
f01168df:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 ;
f01168e2:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 2 ;
f01168e9:	c7 45 c4 02 00 00 00 	movl   $0x2,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01168f0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01168f6:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01168f9:	74 28                	je     f0116923 <test_calculate_allocated_space+0x864>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01168fb:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116901:	83 ec 0c             	sub    $0xc,%esp
f0116904:	ff 75 c8             	pushl  -0x38(%ebp)
f0116907:	50                   	push   %eax
f0116908:	68 1c 4e 13 f0       	push   $0xf0134e1c
f011690d:	68 15 08 00 00       	push   $0x815
f0116912:	68 d2 30 13 f0       	push   $0xf01330d2
f0116917:	e8 38 a8 fe ff       	call   f0101154 <_warn>
f011691c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f011691f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116923:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116929:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f011692c:	74 28                	je     f0116956 <test_calculate_allocated_space+0x897>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f011692e:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116934:	83 ec 0c             	sub    $0xc,%esp
f0116937:	ff 75 c4             	pushl  -0x3c(%ebp)
f011693a:	50                   	push   %eax
f011693b:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116940:	68 1a 08 00 00       	push   $0x81a
f0116945:	68 d2 30 13 f0       	push   $0xf01330d2
f011694a:	e8 05 a8 fe ff       	call   f0101154 <_warn>
f011694f:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116952:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116956:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f011695a:	74 04                	je     f0116960 <test_calculate_allocated_space+0x8a1>
f011695c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116960:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test3
		num_tables = 0;
f0116964:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f011696b:	00 00 00 
		num_pages = 0;
f011696e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116975:	00 00 00 
		calculate_allocated_space(proc_directory, 0x0, 0x0+1024*mega, &num_tables, &num_pages);
f0116978:	8b 45 cc             	mov    -0x34(%ebp),%eax
f011697b:	c1 e0 0a             	shl    $0xa,%eax
f011697e:	89 c2                	mov    %eax,%edx
f0116980:	83 ec 0c             	sub    $0xc,%esp
f0116983:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116989:	50                   	push   %eax
f011698a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116990:	50                   	push   %eax
f0116991:	52                   	push   %edx
f0116992:	6a 00                	push   $0x0
f0116994:	ff 75 d8             	pushl  -0x28(%ebp)
f0116997:	e8 65 43 ff ff       	call   f010ad01 <calculate_allocated_space>
f011699c:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1 + 1;
f011699f:	c7 45 c8 02 00 00 00 	movl   $0x2,-0x38(%ebp)
		expected_num_pages = 1 + 1 + 1;
f01169a6:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f01169ad:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169b3:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f01169b6:	74 28                	je     f01169e0 <test_calculate_allocated_space+0x921>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f01169b8:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f01169be:	83 ec 0c             	sub    $0xc,%esp
f01169c1:	ff 75 c8             	pushl  -0x38(%ebp)
f01169c4:	50                   	push   %eax
f01169c5:	68 1c 4e 13 f0       	push   $0xf0134e1c
f01169ca:	68 28 08 00 00       	push   $0x828
f01169cf:	68 d2 30 13 f0       	push   $0xf01330d2
f01169d4:	e8 7b a7 fe ff       	call   f0101154 <_warn>
f01169d9:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f01169dc:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f01169e0:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169e6:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f01169e9:	74 28                	je     f0116a13 <test_calculate_allocated_space+0x954>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f01169eb:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f01169f1:	83 ec 0c             	sub    $0xc,%esp
f01169f4:	ff 75 c4             	pushl  -0x3c(%ebp)
f01169f7:	50                   	push   %eax
f01169f8:	68 7c 4e 13 f0       	push   $0xf0134e7c
f01169fd:	68 2d 08 00 00       	push   $0x82d
f0116a02:	68 d2 30 13 f0       	push   $0xf01330d2
f0116a07:	e8 48 a7 fe ff       	call   f0101154 <_warn>
f0116a0c:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116a0f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116a13:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116a17:	74 04                	je     f0116a1d <test_calculate_allocated_space+0x95e>
f0116a19:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116a1d:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x2000", c3); execute_command(c3);
f0116a21:	83 ec 04             	sub    $0x4,%esp
f0116a24:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116a2a:	50                   	push   %eax
f0116a2b:	68 7c 4d 13 f0       	push   $0xf0134d7c
f0116a30:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116a36:	50                   	push   %eax
f0116a37:	e8 6d 47 00 00       	call   f011b1a9 <strcconcat>
f0116a3c:	83 c4 10             	add    $0x10,%esp
f0116a3f:	83 ec 0c             	sub    $0xc,%esp
f0116a42:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116a48:	50                   	push   %eax
f0116a49:	e8 cd b4 fe ff       	call   f0101f1b <execute_command>
f0116a4e:	83 c4 10             	add    $0x10,%esp

		//Test4
		num_tables = 0;
f0116a51:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116a58:	00 00 00 
		num_pages = 0;
f0116a5b:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116a62:	00 00 00 
		calculate_allocated_space(proc_directory, 0x1800, 0x1800+3*kilo, &num_tables, &num_pages);
f0116a65:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116a68:	89 c2                	mov    %eax,%edx
f0116a6a:	01 d2                	add    %edx,%edx
f0116a6c:	01 d0                	add    %edx,%eax
f0116a6e:	05 00 18 00 00       	add    $0x1800,%eax
f0116a73:	89 c2                	mov    %eax,%edx
f0116a75:	83 ec 0c             	sub    $0xc,%esp
f0116a78:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116a7e:	50                   	push   %eax
f0116a7f:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116a85:	50                   	push   %eax
f0116a86:	52                   	push   %edx
f0116a87:	68 00 18 00 00       	push   $0x1800
f0116a8c:	ff 75 d8             	pushl  -0x28(%ebp)
f0116a8f:	e8 6d 42 ff ff       	call   f010ad01 <calculate_allocated_space>
f0116a94:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116a97:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116a9e:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116aa5:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116aab:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116aae:	74 28                	je     f0116ad8 <test_calculate_allocated_space+0xa19>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116ab0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ab6:	83 ec 0c             	sub    $0xc,%esp
f0116ab9:	ff 75 c8             	pushl  -0x38(%ebp)
f0116abc:	50                   	push   %eax
f0116abd:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116ac2:	68 3e 08 00 00       	push   $0x83e
f0116ac7:	68 d2 30 13 f0       	push   $0xf01330d2
f0116acc:	e8 83 a6 fe ff       	call   f0101154 <_warn>
f0116ad1:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116ad4:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116ad8:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ade:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116ae1:	74 28                	je     f0116b0b <test_calculate_allocated_space+0xa4c>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116ae3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116ae9:	83 ec 0c             	sub    $0xc,%esp
f0116aec:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116aef:	50                   	push   %eax
f0116af0:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116af5:	68 43 08 00 00       	push   $0x843
f0116afa:	68 d2 30 13 f0       	push   $0xf01330d2
f0116aff:	e8 50 a6 fe ff       	call   f0101154 <_warn>
f0116b04:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116b07:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116b0b:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116b0f:	74 04                	je     f0116b15 <test_calculate_allocated_space+0xa56>
f0116b11:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116b15:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x800000", c4); execute_command(c4);
f0116b19:	83 ec 04             	sub    $0x4,%esp
f0116b1c:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116b22:	50                   	push   %eax
f0116b23:	68 3c 3e 13 f0       	push   $0xf0133e3c
f0116b28:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116b2e:	50                   	push   %eax
f0116b2f:	e8 75 46 00 00       	call   f011b1a9 <strcconcat>
f0116b34:	83 c4 10             	add    $0x10,%esp
f0116b37:	83 ec 0c             	sub    $0xc,%esp
f0116b3a:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116b40:	50                   	push   %eax
f0116b41:	e8 d5 b3 fe ff       	call   f0101f1b <execute_command>
f0116b46:	83 c4 10             	add    $0x10,%esp

		//Test5
		num_tables = 0;
f0116b49:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116b50:	00 00 00 
		num_pages = 0;
f0116b53:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116b5a:	00 00 00 
		calculate_allocated_space(proc_directory, 0x400000, 0x400000+10*mega, &num_tables, &num_pages);
f0116b5d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0116b60:	89 d0                	mov    %edx,%eax
f0116b62:	c1 e0 02             	shl    $0x2,%eax
f0116b65:	01 d0                	add    %edx,%eax
f0116b67:	01 c0                	add    %eax,%eax
f0116b69:	05 00 00 40 00       	add    $0x400000,%eax
f0116b6e:	89 c2                	mov    %eax,%edx
f0116b70:	83 ec 0c             	sub    $0xc,%esp
f0116b73:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116b79:	50                   	push   %eax
f0116b7a:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116b80:	50                   	push   %eax
f0116b81:	52                   	push   %edx
f0116b82:	68 00 00 40 00       	push   $0x400000
f0116b87:	ff 75 d8             	pushl  -0x28(%ebp)
f0116b8a:	e8 72 41 ff ff       	call   f010ad01 <calculate_allocated_space>
f0116b8f:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116b92:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 1;
f0116b99:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116ba0:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116ba6:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116ba9:	74 28                	je     f0116bd3 <test_calculate_allocated_space+0xb14>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116bab:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116bb1:	83 ec 0c             	sub    $0xc,%esp
f0116bb4:	ff 75 c8             	pushl  -0x38(%ebp)
f0116bb7:	50                   	push   %eax
f0116bb8:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116bbd:	68 53 08 00 00       	push   $0x853
f0116bc2:	68 d2 30 13 f0       	push   $0xf01330d2
f0116bc7:	e8 88 a5 fe ff       	call   f0101154 <_warn>
f0116bcc:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116bcf:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116bd3:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116bd9:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116bdc:	74 28                	je     f0116c06 <test_calculate_allocated_space+0xb47>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116bde:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116be4:	83 ec 0c             	sub    $0xc,%esp
f0116be7:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116bea:	50                   	push   %eax
f0116beb:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116bf0:	68 58 08 00 00       	push   $0x858
f0116bf5:	68 d2 30 13 f0       	push   $0xf01330d2
f0116bfa:	e8 55 a5 fe ff       	call   f0101154 <_warn>
f0116bff:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116c02:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 5 ;
f0116c06:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116c0a:	74 04                	je     f0116c10 <test_calculate_allocated_space+0xb51>
f0116c0c:	83 45 e4 05          	addl   $0x5,-0x1c(%ebp)
		correct = 1 ;
f0116c10:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	{
		/*allocate page*/char c3[100] ;strcconcat(aup_cmd, " 0x801000", c3); execute_command(c3);
f0116c14:	83 ec 04             	sub    $0x4,%esp
f0116c17:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116c1d:	50                   	push   %eax
f0116c1e:	68 46 3e 13 f0       	push   $0xf0133e46
f0116c23:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116c29:	50                   	push   %eax
f0116c2a:	e8 7a 45 00 00       	call   f011b1a9 <strcconcat>
f0116c2f:	83 c4 10             	add    $0x10,%esp
f0116c32:	83 ec 0c             	sub    $0xc,%esp
f0116c35:	8d 85 58 fe ff ff    	lea    -0x1a8(%ebp),%eax
f0116c3b:	50                   	push   %eax
f0116c3c:	e8 da b2 fe ff       	call   f0101f1b <execute_command>
f0116c41:	83 c4 10             	add    $0x10,%esp
		/*allocate page*/char c4[100] ;strcconcat(aup_cmd, " 0x810000", c4); execute_command(c4);
f0116c44:	83 ec 04             	sub    $0x4,%esp
f0116c47:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116c4d:	50                   	push   %eax
f0116c4e:	68 84 4d 13 f0       	push   $0xf0134d84
f0116c53:	8d 85 34 ff ff ff    	lea    -0xcc(%ebp),%eax
f0116c59:	50                   	push   %eax
f0116c5a:	e8 4a 45 00 00       	call   f011b1a9 <strcconcat>
f0116c5f:	83 c4 10             	add    $0x10,%esp
f0116c62:	83 ec 0c             	sub    $0xc,%esp
f0116c65:	8d 85 bc fe ff ff    	lea    -0x144(%ebp),%eax
f0116c6b:	50                   	push   %eax
f0116c6c:	e8 aa b2 fe ff       	call   f0101f1b <execute_command>
f0116c71:	83 c4 10             	add    $0x10,%esp

		//Test6
		num_tables = 0;
f0116c74:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116c7b:	00 00 00 
		num_pages = 0;
f0116c7e:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116c85:	00 00 00 
		calculate_allocated_space(proc_directory, 0x700000, 0x700000+2*mega, &num_tables, &num_pages);
f0116c88:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0116c8b:	05 00 00 38 00       	add    $0x380000,%eax
f0116c90:	01 c0                	add    %eax,%eax
f0116c92:	89 c2                	mov    %eax,%edx
f0116c94:	83 ec 0c             	sub    $0xc,%esp
f0116c97:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116c9d:	50                   	push   %eax
f0116c9e:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116ca4:	50                   	push   %eax
f0116ca5:	52                   	push   %edx
f0116ca6:	68 00 00 70 00       	push   $0x700000
f0116cab:	ff 75 d8             	pushl  -0x28(%ebp)
f0116cae:	e8 4e 40 ff ff       	call   f010ad01 <calculate_allocated_space>
f0116cb3:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116cb6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 3;
f0116cbd:	c7 45 c4 03 00 00 00 	movl   $0x3,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116cc4:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116cca:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116ccd:	74 28                	je     f0116cf7 <test_calculate_allocated_space+0xc38>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116ccf:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116cd5:	83 ec 0c             	sub    $0xc,%esp
f0116cd8:	ff 75 c8             	pushl  -0x38(%ebp)
f0116cdb:	50                   	push   %eax
f0116cdc:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116ce1:	68 6a 08 00 00       	push   $0x86a
f0116ce6:	68 d2 30 13 f0       	push   $0xf01330d2
f0116ceb:	e8 64 a4 fe ff       	call   f0101154 <_warn>
f0116cf0:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116cf3:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116cf7:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116cfd:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116d00:	74 28                	je     f0116d2a <test_calculate_allocated_space+0xc6b>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116d02:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116d08:	83 ec 0c             	sub    $0xc,%esp
f0116d0b:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116d0e:	50                   	push   %eax
f0116d0f:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116d14:	68 6f 08 00 00       	push   $0x86f
f0116d19:	68 d2 30 13 f0       	push   $0xf01330d2
f0116d1e:	e8 31 a4 fe ff       	call   f0101154 <_warn>
f0116d23:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116d26:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116d2a:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116d2e:	74 04                	je     f0116d34 <test_calculate_allocated_space+0xc75>
f0116d30:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116d34:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)

		//Test7
		num_tables = 0;
f0116d38:	c7 85 20 ff ff ff 00 	movl   $0x0,-0xe0(%ebp)
f0116d3f:	00 00 00 
		num_pages = 0;
f0116d42:	c7 85 24 ff ff ff 00 	movl   $0x0,-0xdc(%ebp)
f0116d49:	00 00 00 
		calculate_allocated_space(proc_directory, 0x3FFFFF, 0x3FFFFF+1*kilo, &num_tables, &num_pages);
f0116d4c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0116d4f:	05 ff ff 3f 00       	add    $0x3fffff,%eax
f0116d54:	89 c2                	mov    %eax,%edx
f0116d56:	83 ec 0c             	sub    $0xc,%esp
f0116d59:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
f0116d5f:	50                   	push   %eax
f0116d60:	8d 85 20 ff ff ff    	lea    -0xe0(%ebp),%eax
f0116d66:	50                   	push   %eax
f0116d67:	52                   	push   %edx
f0116d68:	68 ff ff 3f 00       	push   $0x3fffff
f0116d6d:	ff 75 d8             	pushl  -0x28(%ebp)
f0116d70:	e8 8c 3f ff ff       	call   f010ad01 <calculate_allocated_space>
f0116d75:	83 c4 20             	add    $0x20,%esp
		expected_num_tables = 1;
f0116d78:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%ebp)
		expected_num_pages = 0;
f0116d7f:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
		if (num_tables != expected_num_tables)
f0116d86:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116d8c:	3b 45 c8             	cmp    -0x38(%ebp),%eax
f0116d8f:	74 28                	je     f0116db9 <test_calculate_allocated_space+0xcfa>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Tables count is not correct). res=%d, expected=%d\n", num_tables, expected_num_tables);
f0116d91:	8b 85 20 ff ff ff    	mov    -0xe0(%ebp),%eax
f0116d97:	83 ec 0c             	sub    $0xc,%esp
f0116d9a:	ff 75 c8             	pushl  -0x38(%ebp)
f0116d9d:	50                   	push   %eax
f0116d9e:	68 1c 4e 13 f0       	push   $0xf0134e1c
f0116da3:	68 7d 08 00 00       	push   $0x87d
f0116da8:	68 d2 30 13 f0       	push   $0xf01330d2
f0116dad:	e8 a2 a3 fe ff       	call   f0101154 <_warn>
f0116db2:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116db5:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (num_pages != expected_num_pages)
f0116db9:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116dbf:	3b 45 c4             	cmp    -0x3c(%ebp),%eax
f0116dc2:	74 28                	je     f0116dec <test_calculate_allocated_space+0xd2d>
		{
			warn("[EVAL] calculate_allocated_space: Failed (Pages count is not correct). res=%d, expected=%d\n", num_pages, expected_num_pages);
f0116dc4:	8b 85 24 ff ff ff    	mov    -0xdc(%ebp),%eax
f0116dca:	83 ec 0c             	sub    $0xc,%esp
f0116dcd:	ff 75 c4             	pushl  -0x3c(%ebp)
f0116dd0:	50                   	push   %eax
f0116dd1:	68 7c 4e 13 f0       	push   $0xf0134e7c
f0116dd6:	68 82 08 00 00       	push   $0x882
f0116ddb:	68 d2 30 13 f0       	push   $0xf01330d2
f0116de0:	e8 6f a3 fe ff       	call   f0101154 <_warn>
f0116de5:	83 c4 20             	add    $0x20,%esp
			correct = 0;
f0116de8:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
		}
		if (correct) eval += 10 ;
f0116dec:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
f0116df0:	74 04                	je     f0116df6 <test_calculate_allocated_space+0xd37>
f0116df2:	83 45 e4 0a          	addl   $0xa,-0x1c(%ebp)
		correct = 1 ;
f0116df6:	c6 45 e3 01          	movb   $0x1,-0x1d(%ebp)
	}
	cprintf("\nCASE II: END\n") ;
f0116dfa:	83 ec 0c             	sub    $0xc,%esp
f0116dfd:	68 f7 3d 13 f0       	push   $0xf0133df7
f0116e02:	e8 55 ae fe ff       	call   f0101c5c <cprintf>
f0116e07:	83 c4 10             	add    $0x10,%esp

	cprintf("[EVAL] calculate_allocated_space: FINISHED. Evaluation = %d\n", eval);
f0116e0a:	83 ec 08             	sub    $0x8,%esp
f0116e0d:	ff 75 e4             	pushl  -0x1c(%ebp)
f0116e10:	68 d8 4e 13 f0       	push   $0xf0134ed8
f0116e15:	e8 42 ae fe ff       	call   f0101c5c <cprintf>
f0116e1a:	83 c4 10             	add    $0x10,%esp
	if(eval == 100)
f0116e1d:	83 7d e4 64          	cmpl   $0x64,-0x1c(%ebp)
f0116e21:	75 10                	jne    f0116e33 <test_calculate_allocated_space+0xd74>
		cprintf("Congratulations!! test calculate_allocated_space completed successfully.\n");
f0116e23:	83 ec 0c             	sub    $0xc,%esp
f0116e26:	68 18 4f 13 f0       	push   $0xf0134f18
f0116e2b:	e8 2c ae fe ff       	call   f0101c5c <cprintf>
f0116e30:	83 c4 10             	add    $0x10,%esp

	//return back to the kernel directory
	lcr3(phys_page_directory) ;
f0116e33:	a1 e0 6d 85 f0       	mov    0xf0856de0,%eax
f0116e38:	89 45 d4             	mov    %eax,-0x2c(%ebp)
f0116e3b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0116e3e:	0f 22 d8             	mov    %eax,%cr3

	return 0;
f0116e41:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0116e46:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0116e49:	5b                   	pop    %ebx
f0116e4a:	5e                   	pop    %esi
f0116e4b:	5f                   	pop    %edi
f0116e4c:	5d                   	pop    %ebp
f0116e4d:	c3                   	ret    

f0116e4e <CB>:
//===========================================================================
//===========================================================================
//===========================================================================

int CB(uint32 *ptr_dir, uint32 va, int bn)
{
f0116e4e:	55                   	push   %ebp
f0116e4f:	89 e5                	mov    %esp,%ebp
f0116e51:	83 ec 18             	sub    $0x18,%esp
	//assert(USE_KHEAP == 0) ;
	uint32 mask = 1<<bn;
f0116e54:	8b 45 10             	mov    0x10(%ebp),%eax
f0116e57:	ba 01 00 00 00       	mov    $0x1,%edx
f0116e5c:	88 c1                	mov    %al,%cl
f0116e5e:	d3 e2                	shl    %cl,%edx
f0116e60:	89 d0                	mov    %edx,%eax
f0116e62:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if (!(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116e65:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e68:	c1 e8 16             	shr    $0x16,%eax
f0116e6b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e72:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e75:	01 d0                	add    %edx,%eax
f0116e77:	8b 00                	mov    (%eax),%eax
f0116e79:	83 e0 01             	and    $0x1,%eax
f0116e7c:	85 c0                	test   %eax,%eax
f0116e7e:	75 07                	jne    f0116e87 <CB+0x39>
f0116e80:	b8 00 00 00 00       	mov    $0x0,%eax
f0116e85:	eb 76                	jmp    f0116efd <CB+0xaf>
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116e87:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116e8a:	c1 e8 16             	shr    $0x16,%eax
f0116e8d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116e94:	8b 45 08             	mov    0x8(%ebp),%eax
f0116e97:	01 d0                	add    %edx,%eax
f0116e99:	8b 00                	mov    (%eax),%eax
f0116e9b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116ea0:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116ea3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116ea6:	c1 e8 0c             	shr    $0xc,%eax
f0116ea9:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0116eac:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0116eb1:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f0116eb4:	72 17                	jb     f0116ecd <CB+0x7f>
f0116eb6:	ff 75 f0             	pushl  -0x10(%ebp)
f0116eb9:	68 64 4f 13 f0       	push   $0xf0134f64
f0116ebe:	68 9d 08 00 00       	push   $0x89d
f0116ec3:	68 d2 30 13 f0       	push   $0xf01330d2
f0116ec8:	e8 e2 a0 fe ff       	call   f0100faf <_panic>
f0116ecd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0116ed0:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116ed5:	89 45 e8             	mov    %eax,-0x18(%ebp)
	return ((table[((((uint32) (va)) >> 12) & 0x3FF)]&mask) == mask)? 1 : 0 ;
f0116ed8:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116edb:	c1 e8 0c             	shr    $0xc,%eax
f0116ede:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116ee3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116eea:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0116eed:	01 d0                	add    %edx,%eax
f0116eef:	8b 00                	mov    (%eax),%eax
f0116ef1:	23 45 f4             	and    -0xc(%ebp),%eax
f0116ef4:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0116ef7:	0f 94 c0             	sete   %al
f0116efa:	0f b6 c0             	movzbl %al,%eax
}
f0116efd:	c9                   	leave  
f0116efe:	c3                   	ret    

f0116eff <SB>:
int SB(uint32 *ptr_dir, uint32 va, int bn , int v)
{
f0116eff:	55                   	push   %ebp
f0116f00:	89 e5                	mov    %esp,%ebp
f0116f02:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f05:	68 93 4f 13 f0       	push   $0xf0134f93
f0116f0a:	68 a2 4f 13 f0       	push   $0xf0134fa2
f0116f0f:	68 a2 08 00 00       	push   $0x8a2
f0116f14:	68 d2 30 13 f0       	push   $0xf01330d2
f0116f19:	e8 91 a0 fe ff       	call   f0100faf <_panic>

f0116f1e <CPs>:
	if (~v) table[((((uint32) (va)) >> 12) & 0x3FF)] &= ~mask ;
	else 	table[((((uint32) (va)) >> 12) & 0x3FF)] |= mask ;
	return 0;
}
int CPs(uint32 *ptr_dir, uint32 va, uint32 perms, uint32 which)
{
f0116f1e:	55                   	push   %ebp
f0116f1f:	89 e5                	mov    %esp,%ebp
f0116f21:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f24:	68 93 4f 13 f0       	push   $0xf0134f93
f0116f29:	68 a2 4f 13 f0       	push   $0xf0134fa2
f0116f2e:	68 ac 08 00 00       	push   $0x8ac
f0116f33:	68 d2 30 13 f0       	push   $0xf01330d2
f0116f38:	e8 72 a0 fe ff       	call   f0100faf <_panic>

f0116f3d <CA>:
	}
	return 1;
}

int CA(uint32 *ptr_dir, uint32 va)
{
f0116f3d:	55                   	push   %ebp
f0116f3e:	89 e5                	mov    %esp,%ebp
f0116f40:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0116f43:	68 93 4f 13 f0       	push   $0xf0134f93
f0116f48:	68 a2 4f 13 f0       	push   $0xf0134fa2
f0116f4d:	68 bb 08 00 00       	push   $0x8bb
f0116f52:	68 d2 30 13 f0       	push   $0xf01330d2
f0116f57:	e8 53 a0 fe ff       	call   f0100faf <_panic>

f0116f5c <CE>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return (table[((((uint32) (va)) >> 12) & 0x3FF)]&~0x00000FFF) + (va & 0xFFF);
}

int CE(uint32 *_d, uint32 va)
{
f0116f5c:	55                   	push   %ebp
f0116f5d:	89 e5                	mov    %esp,%ebp
f0116f5f:	83 ec 18             	sub    $0x18,%esp
	if (!(_d[((((uint32) (va)) >> 22) & 0x3FF)] & 1)) return 0;
f0116f62:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116f65:	c1 e8 16             	shr    $0x16,%eax
f0116f68:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116f6f:	8b 45 08             	mov    0x8(%ebp),%eax
f0116f72:	01 d0                	add    %edx,%eax
f0116f74:	8b 00                	mov    (%eax),%eax
f0116f76:	83 e0 01             	and    $0x1,%eax
f0116f79:	85 c0                	test   %eax,%eax
f0116f7b:	75 07                	jne    f0116f84 <CE+0x28>
f0116f7d:	b8 00 00 00 00       	mov    $0x0,%eax
f0116f82:	eb 7a                	jmp    f0116ffe <CE+0xa2>
	uint32 *_t = (STATIC_KERNEL_VIRTUAL_ADDRESS(_d[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
f0116f84:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116f87:	c1 e8 16             	shr    $0x16,%eax
f0116f8a:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116f91:	8b 45 08             	mov    0x8(%ebp),%eax
f0116f94:	01 d0                	add    %edx,%eax
f0116f96:	8b 00                	mov    (%eax),%eax
f0116f98:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0116f9d:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0116fa0:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116fa3:	c1 e8 0c             	shr    $0xc,%eax
f0116fa6:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0116fa9:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f0116fae:	39 45 f0             	cmp    %eax,-0x10(%ebp)
f0116fb1:	72 17                	jb     f0116fca <CE+0x6e>
f0116fb3:	ff 75 f4             	pushl  -0xc(%ebp)
f0116fb6:	68 64 4f 13 f0       	push   $0xf0134f64
f0116fbb:	68 c4 08 00 00       	push   $0x8c4
f0116fc0:	68 d2 30 13 f0       	push   $0xf01330d2
f0116fc5:	e8 e5 9f fe ff       	call   f0100faf <_panic>
f0116fca:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0116fcd:	2d 00 00 00 10       	sub    $0x10000000,%eax
f0116fd2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	if ((_t[((((uint32) (va)) >> 12) & 0x3FF)])!=0) return 0;
f0116fd5:	8b 45 0c             	mov    0xc(%ebp),%eax
f0116fd8:	c1 e8 0c             	shr    $0xc,%eax
f0116fdb:	25 ff 03 00 00       	and    $0x3ff,%eax
f0116fe0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0116fe7:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0116fea:	01 d0                	add    %edx,%eax
f0116fec:	8b 00                	mov    (%eax),%eax
f0116fee:	85 c0                	test   %eax,%eax
f0116ff0:	74 07                	je     f0116ff9 <CE+0x9d>
f0116ff2:	b8 00 00 00 00       	mov    $0x0,%eax
f0116ff7:	eb 05                	jmp    f0116ffe <CE+0xa2>
	return 1;
f0116ff9:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0116ffe:	c9                   	leave  
f0116fff:	c3                   	ret    

f0117000 <CP>:

int CP(uint32* pd, uint32 va, uint32 ps, uint32 pc)
{
f0117000:	55                   	push   %ebp
f0117001:	89 e5                	mov    %esp,%ebp
f0117003:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117006:	68 93 4f 13 f0       	push   $0xf0134f93
f011700b:	68 a2 4f 13 f0       	push   $0xf0134fa2
f0117010:	68 cb 08 00 00       	push   $0x8cb
f0117015:	68 d2 30 13 f0       	push   $0xf01330d2
f011701a:	e8 90 9f fe ff       	call   f0100faf <_panic>

f011701f <GP>:
	}
	return 0;
}

uint32 GP(uint32 *ptr_dir, uint32 va)
{
f011701f:	55                   	push   %ebp
f0117020:	89 e5                	mov    %esp,%ebp
f0117022:	83 ec 08             	sub    $0x8,%esp
	assert(USE_KHEAP == 0) ;
f0117025:	68 93 4f 13 f0       	push   $0xf0134f93
f011702a:	68 a2 4f 13 f0       	push   $0xf0134fa2
f011702f:	68 db 08 00 00       	push   $0x8db
f0117034:	68 d2 30 13 f0       	push   $0xf01330d2
f0117039:	e8 71 9f fe ff       	call   f0100faf <_panic>

f011703e <ClearUserSpace>:
	uint32 *table = (STATIC_KERNEL_VIRTUAL_ADDRESS(ptr_dir[((((uint32) (va)) >> 22) & 0x3FF)] & ~0xFFF));
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
f011703e:	55                   	push   %ebp
f011703f:	89 e5                	mov    %esp,%ebp
f0117041:	83 ec 10             	sub    $0x10,%esp
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0117044:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011704b:	eb 18                	jmp    f0117065 <ClearUserSpace+0x27>
		ptr_dir[i] = 0;
f011704d:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0117050:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0117057:	8b 45 08             	mov    0x8(%ebp),%eax
f011705a:	01 d0                	add    %edx,%eax
f011705c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return table[((((uint32) (va)) >> 12) & 0x3FF)] & 0xFFF;
}

void ClearUserSpace(uint32 *ptr_dir)
{
	for (int i = 0; i < PDX(USER_TOP); ++i) {
f0117062:	ff 45 fc             	incl   -0x4(%ebp)
f0117065:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0117068:	3d ba 03 00 00       	cmp    $0x3ba,%eax
f011706d:	76 de                	jbe    f011704d <ClearUserSpace+0xf>
		ptr_dir[i] = 0;
	}
}
f011706f:	90                   	nop
f0117070:	c9                   	leave  
f0117071:	c3                   	ret    

f0117072 <CCP>:

int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
f0117072:	55                   	push   %ebp
f0117073:	89 e5                	mov    %esp,%ebp
f0117075:	83 ec 38             	sub    $0x38,%esp
f0117078:	8b 45 2c             	mov    0x2c(%ebp),%eax
f011707b:	88 45 d4             	mov    %al,-0x2c(%ebp)
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
f011707e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0117081:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0117086:	89 45 f4             	mov    %eax,-0xc(%ebp)
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));
f0117089:	8b 45 10             	mov    0x10(%ebp),%eax
f011708c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f0117091:	89 45 f0             	mov    %eax,-0x10(%ebp)

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f0117094:	e9 ea 01 00 00       	jmp    f0117283 <CCP+0x211>
	{
		uint32* ptr_table1;
		uint32* ptr_table2;
		struct FrameInfo * pfi1 ;
		struct FrameInfo * pfi2 ;
		if (chk_type != CHK_ALLOC)
f0117099:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f011709d:	74 44                	je     f01170e3 <CCP+0x71>
		{
			pfi1 = get_frame_info(ptr_dir, (uint32)ptrTemp1, &ptr_table1);
f011709f:	8b 45 f4             	mov    -0xc(%ebp),%eax
f01170a2:	83 ec 04             	sub    $0x4,%esp
f01170a5:	8d 55 dc             	lea    -0x24(%ebp),%edx
f01170a8:	52                   	push   %edx
f01170a9:	50                   	push   %eax
f01170aa:	ff 75 08             	pushl  0x8(%ebp)
f01170ad:	e8 1b 26 ff ff       	call   f01096cd <get_frame_info>
f01170b2:	83 c4 10             	add    $0x10,%esp
f01170b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
			if (ptr_table1 == NULL)
f01170b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01170bb:	85 c0                	test   %eax,%eax
f01170bd:	75 24                	jne    f01170e3 <CCP+0x71>
			{
				warn("[EVAL] Failed. Table of address 1 = NULL\n");
f01170bf:	83 ec 04             	sub    $0x4,%esp
f01170c2:	68 b8 4f 13 f0       	push   $0xf0134fb8
f01170c7:	68 f8 08 00 00       	push   $0x8f8
f01170cc:	68 d2 30 13 f0       	push   $0xf01330d2
f01170d1:	e8 7e a0 fe ff       	call   f0101154 <_warn>
f01170d6:	83 c4 10             	add    $0x10,%esp
				return 0;
f01170d9:	b8 00 00 00 00       	mov    $0x0,%eax
f01170de:	e9 b6 01 00 00       	jmp    f0117299 <CCP+0x227>
			}
		}
		pfi2 = get_frame_info(ptr_dir, (uint32)ptrTemp2, &ptr_table2);
f01170e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01170e6:	83 ec 04             	sub    $0x4,%esp
f01170e9:	8d 55 d8             	lea    -0x28(%ebp),%edx
f01170ec:	52                   	push   %edx
f01170ed:	50                   	push   %eax
f01170ee:	ff 75 08             	pushl  0x8(%ebp)
f01170f1:	e8 d7 25 ff ff       	call   f01096cd <get_frame_info>
f01170f6:	83 c4 10             	add    $0x10,%esp
f01170f9:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (ptr_table2 == NULL)
f01170fc:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01170ff:	85 c0                	test   %eax,%eax
f0117101:	75 24                	jne    f0117127 <CCP+0xb5>
		{
			warn("[EVAL] Failed. Table of address 2 = NULL\n");
f0117103:	83 ec 04             	sub    $0x4,%esp
f0117106:	68 e4 4f 13 f0       	push   $0xf0134fe4
f011710b:	68 ff 08 00 00       	push   $0x8ff
f0117110:	68 d2 30 13 f0       	push   $0xf01330d2
f0117115:	e8 3a a0 fe ff       	call   f0101154 <_warn>
f011711a:	83 c4 10             	add    $0x10,%esp
			return 0;
f011711d:	b8 00 00 00 00       	mov    $0x0,%eax
f0117122:	e9 72 01 00 00       	jmp    f0117299 <CCP+0x227>
		}
		if (chk_type == CHK_SHARE)
f0117127:	80 7d d4 02          	cmpb   $0x2,-0x2c(%ebp)
f011712b:	75 70                	jne    f011719d <CCP+0x12b>
		{
			uint32 fn1 = ptr_table1[PTX(ptrTemp1)] >> 12 ;
f011712d:	8b 45 dc             	mov    -0x24(%ebp),%eax
f0117130:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117133:	c1 ea 0c             	shr    $0xc,%edx
f0117136:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f011713c:	c1 e2 02             	shl    $0x2,%edx
f011713f:	01 d0                	add    %edx,%eax
f0117141:	8b 00                	mov    (%eax),%eax
f0117143:	c1 e8 0c             	shr    $0xc,%eax
f0117146:	89 45 e8             	mov    %eax,-0x18(%ebp)
			uint32 fn2 = ptr_table2[PTX(ptrTemp2)] >> 12 ;
f0117149:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011714c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011714f:	c1 ea 0c             	shr    $0xc,%edx
f0117152:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
f0117158:	c1 e2 02             	shl    $0x2,%edx
f011715b:	01 d0                	add    %edx,%eax
f011715d:	8b 00                	mov    (%eax),%eax
f011715f:	c1 e8 0c             	shr    $0xc,%eax
f0117162:	89 45 e4             	mov    %eax,-0x1c(%ebp)

			if(fn1 != fn2)
f0117165:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0117168:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f011716b:	74 30                	je     f011719d <CCP+0x12b>
			{
				warn("[EVAL] Failed. Frame numbers not equal in the whole range!\nva1=%x, va2=%x, fn1=%x, fn2=%x\n", ptrTemp1, ptrTemp2, fn1, fn2);
f011716d:	83 ec 04             	sub    $0x4,%esp
f0117170:	ff 75 e4             	pushl  -0x1c(%ebp)
f0117173:	ff 75 e8             	pushl  -0x18(%ebp)
f0117176:	ff 75 f0             	pushl  -0x10(%ebp)
f0117179:	ff 75 f4             	pushl  -0xc(%ebp)
f011717c:	68 10 50 13 f0       	push   $0xf0135010
f0117181:	68 09 09 00 00       	push   $0x909
f0117186:	68 d2 30 13 f0       	push   $0xf01330d2
f011718b:	e8 c4 9f fe ff       	call   f0101154 <_warn>
f0117190:	83 c4 20             	add    $0x20,%esp
				return 0;
f0117193:	b8 00 00 00 00       	mov    $0x0,%eax
f0117198:	e9 fc 00 00 00       	jmp    f0117299 <CCP+0x227>
			}
		}
		if (ref != -1)
f011719d:	83 7d 18 ff          	cmpl   $0xffffffff,0x18(%ebp)
f01171a1:	74 52                	je     f01171f5 <CCP+0x183>
		{
			if (pfi2 == NULL || (*pfi2).references != ref)
f01171a3:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01171a7:	74 0e                	je     f01171b7 <CCP+0x145>
f01171a9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01171ac:	8b 40 08             	mov    0x8(%eax),%eax
f01171af:	0f b7 c0             	movzwl %ax,%eax
f01171b2:	3b 45 18             	cmp    0x18(%ebp),%eax
f01171b5:	74 3e                	je     f01171f5 <CCP+0x183>
			{
				warn("[EVAL] Failed. Num of frame references is not correct. MAKE SURE to use the functions of LAB5! va2=%x, ref2=%d\n", ptrTemp2, pfi2==NULL? 0 : (*pfi2).references);
f01171b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f01171bb:	74 0b                	je     f01171c8 <CCP+0x156>
f01171bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01171c0:	8b 40 08             	mov    0x8(%eax),%eax
f01171c3:	0f b7 c0             	movzwl %ax,%eax
f01171c6:	eb 05                	jmp    f01171cd <CCP+0x15b>
f01171c8:	b8 00 00 00 00       	mov    $0x0,%eax
f01171cd:	83 ec 0c             	sub    $0xc,%esp
f01171d0:	50                   	push   %eax
f01171d1:	ff 75 f0             	pushl  -0x10(%ebp)
f01171d4:	68 6c 50 13 f0       	push   $0xf013506c
f01171d9:	68 11 09 00 00       	push   $0x911
f01171de:	68 d2 30 13 f0       	push   $0xf01330d2
f01171e3:	e8 6c 9f fe ff       	call   f0101154 <_warn>
f01171e8:	83 c4 20             	add    $0x20,%esp
				return 0;
f01171eb:	b8 00 00 00 00       	mov    $0x0,%eax
f01171f0:	e9 a4 00 00 00       	jmp    f0117299 <CCP+0x227>
			}
		}
		if (CPs(ptr_dir, (uint32)ptrTemp2, dst_perms, dst_to_chk) <= 0)
f01171f5:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01171f8:	ff 75 20             	pushl  0x20(%ebp)
f01171fb:	ff 75 1c             	pushl  0x1c(%ebp)
f01171fe:	50                   	push   %eax
f01171ff:	ff 75 08             	pushl  0x8(%ebp)
f0117202:	e8 17 fd ff ff       	call   f0116f1e <CPs>
f0117207:	83 c4 10             	add    $0x10,%esp
f011720a:	85 c0                	test   %eax,%eax
f011720c:	7f 21                	jg     f011722f <CCP+0x1bd>
		{
			warn("[EVAL] Failed. one or more permission in destination is not correct\n");
f011720e:	83 ec 04             	sub    $0x4,%esp
f0117211:	68 dc 50 13 f0       	push   $0xf01350dc
f0117216:	68 17 09 00 00       	push   $0x917
f011721b:	68 d2 30 13 f0       	push   $0xf01330d2
f0117220:	e8 2f 9f fe ff       	call   f0101154 <_warn>
f0117225:	83 c4 10             	add    $0x10,%esp
			return 0;
f0117228:	b8 00 00 00 00       	mov    $0x0,%eax
f011722d:	eb 6a                	jmp    f0117299 <CCP+0x227>
		}
		if (chk_type != CHK_ALLOC)
f011722f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117233:	74 3a                	je     f011726f <CCP+0x1fd>
		{
			if (CPs(ptr_dir, (uint32)ptrTemp1, src_perms, src_to_chk) <= 0)
f0117235:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0117238:	ff 75 28             	pushl  0x28(%ebp)
f011723b:	ff 75 24             	pushl  0x24(%ebp)
f011723e:	50                   	push   %eax
f011723f:	ff 75 08             	pushl  0x8(%ebp)
f0117242:	e8 d7 fc ff ff       	call   f0116f1e <CPs>
f0117247:	83 c4 10             	add    $0x10,%esp
f011724a:	85 c0                	test   %eax,%eax
f011724c:	7f 21                	jg     f011726f <CCP+0x1fd>
			{
				warn("[EVAL] Failed. one or more permission in source is not correct\n");
f011724e:	83 ec 04             	sub    $0x4,%esp
f0117251:	68 24 51 13 f0       	push   $0xf0135124
f0117256:	68 1e 09 00 00       	push   $0x91e
f011725b:	68 d2 30 13 f0       	push   $0xf01330d2
f0117260:	e8 ef 9e fe ff       	call   f0101154 <_warn>
f0117265:	83 c4 10             	add    $0x10,%esp
				return 0;
f0117268:	b8 00 00 00 00       	mov    $0x0,%eax
f011726d:	eb 2a                	jmp    f0117299 <CCP+0x227>
			}
		}
		if (chk_type != CHK_ALLOC)
f011726f:	80 7d d4 03          	cmpb   $0x3,-0x2c(%ebp)
f0117273:	74 07                	je     f011727c <CCP+0x20a>
		{
			ptrTemp1 += PAGE_SIZE;
f0117275:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
int CCP(uint32 *ptr_dir, uint32 ptr1, uint32 ptr2, uint32 size, int ref, uint32 dst_perms, uint32 dst_to_chk, uint32 src_perms, uint32 src_to_chk, uint8 chk_type)
{
	void* ptrTemp1 = (void*)(ptr1 - ptr1 % (4096));
	void* ptrTemp2 = (void*)(ptr2 - ptr2 % (4096));

	for( ;ptrTemp2 < (void*)(ptr2+size); ptrTemp2+=PAGE_SIZE)
f011727c:	81 45 f0 00 10 00 00 	addl   $0x1000,-0x10(%ebp)
f0117283:	8b 55 10             	mov    0x10(%ebp),%edx
f0117286:	8b 45 14             	mov    0x14(%ebp),%eax
f0117289:	01 d0                	add    %edx,%eax
f011728b:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011728e:	0f 87 05 fe ff ff    	ja     f0117099 <CCP+0x27>
		{
			ptrTemp1 += PAGE_SIZE;
		}
	}

	return 1;
f0117294:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117299:	c9                   	leave  
f011729a:	c3                   	ret    

f011729b <test_priority_normal_and_higher>:

extern int sys_calculate_free_frames();

uint8 firstTime = 1;
void test_priority_normal_and_higher()
{
f011729b:	55                   	push   %ebp
f011729c:	89 e5                	mov    %esp,%ebp
f011729e:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01172a1:	83 ec 04             	sub    $0x4,%esp
f01172a4:	68 64 51 13 f0       	push   $0xf0135164
f01172a9:	6a 0e                	push   $0xe
f01172ab:	68 74 51 13 f0       	push   $0xf0135174
f01172b0:	e8 fa 9c fe ff       	call   f0100faf <_panic>

f01172b5 <test_priority_normal_and_lower>:
	}
#endif
}

void test_priority_normal_and_lower()
{
f01172b5:	55                   	push   %ebp
f01172b6:	89 e5                	mov    %esp,%ebp
f01172b8:	83 ec 08             	sub    $0x8,%esp
#if USE_KHEAP
	panic("not handled yet");
f01172bb:	83 ec 04             	sub    $0x4,%esp
f01172be:	68 64 51 13 f0       	push   $0xf0135164
f01172c3:	68 d7 00 00 00       	push   $0xd7
f01172c8:	68 74 51 13 f0       	push   $0xf0135174
f01172cd:	e8 dd 9c fe ff       	call   f0100faf <_panic>

f01172d2 <get_kheap_strategy>:
static inline uint32 get_kheap_strategy(){return kheapPlacementStrategy ;}
f01172d2:	55                   	push   %ebp
f01172d3:	89 e5                	mov    %esp,%ebp
f01172d5:	a1 c4 69 85 f0       	mov    0xf08569c4,%eax
f01172da:	5d                   	pop    %ebp
f01172db:	c3                   	ret    

f01172dc <test_kmalloc>:


uint32 da_limit = KERNEL_HEAP_START + DYN_ALLOC_MAX_SIZE ;

int test_kmalloc(uint32 ALLOC_TYPE)
{
f01172dc:	55                   	push   %ebp
f01172dd:	89 e5                	mov    %esp,%ebp
f01172df:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f01172e2:	e8 eb ff ff ff       	call   f01172d2 <get_kheap_strategy>
f01172e7:	83 f8 01             	cmp    $0x1,%eax
f01172ea:	75 34                	jne    f0117320 <test_kmalloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01172ec:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01172f0:	75 0a                	jne    f01172fc <test_kmalloc+0x20>
			test_kmalloc_FF_page();
f01172f2:	e8 d3 03 00 00       	call   f01176ca <test_kmalloc_FF_page>
f01172f7:	e9 f3 00 00 00       	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01172fc:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117300:	75 0a                	jne    f011730c <test_kmalloc+0x30>
			test_kmalloc_FF_block();
f0117302:	e8 54 04 00 00       	call   f011775b <test_kmalloc_FF_block>
f0117307:	e9 e3 00 00 00       	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011730c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117310:	0f 85 d9 00 00 00    	jne    f01173ef <test_kmalloc+0x113>
			test_kmalloc_FF_both();
f0117316:	e8 d1 04 00 00       	call   f01177ec <test_kmalloc_FF_both>
f011731b:	e9 cf 00 00 00       	jmp    f01173ef <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117320:	e8 ad ff ff ff       	call   f01172d2 <get_kheap_strategy>
f0117325:	83 f8 02             	cmp    $0x2,%eax
f0117328:	75 34                	jne    f011735e <test_kmalloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011732a:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011732e:	75 0a                	jne    f011733a <test_kmalloc+0x5e>
			test_kmalloc_BF_page();
f0117330:	e8 cf 03 00 00       	call   f0117704 <test_kmalloc_BF_page>
f0117335:	e9 b5 00 00 00       	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011733a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011733e:	75 0a                	jne    f011734a <test_kmalloc+0x6e>
			test_kmalloc_BF_block();
f0117340:	e8 50 04 00 00       	call   f0117795 <test_kmalloc_BF_block>
f0117345:	e9 a5 00 00 00       	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011734a:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011734e:	0f 85 9b 00 00 00    	jne    f01173ef <test_kmalloc+0x113>
			test_kmalloc_BF_both();
f0117354:	e8 cd 04 00 00       	call   f0117826 <test_kmalloc_BF_both>
f0117359:	e9 91 00 00 00       	jmp    f01173ef <test_kmalloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f011735e:	e8 6f ff ff ff       	call   f01172d2 <get_kheap_strategy>
f0117363:	83 f8 03             	cmp    $0x3,%eax
f0117366:	75 27                	jne    f011738f <test_kmalloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117368:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011736c:	75 07                	jne    f0117375 <test_kmalloc+0x99>
			test_kmalloc_NF_page();
f011736e:	e8 74 03 00 00       	call   f01176e7 <test_kmalloc_NF_page>
f0117373:	eb 7a                	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117375:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117379:	75 07                	jne    f0117382 <test_kmalloc+0xa6>
			test_kmalloc_NF_block();
f011737b:	e8 f8 03 00 00       	call   f0117778 <test_kmalloc_NF_block>
f0117380:	eb 6d                	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117382:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117386:	75 67                	jne    f01173ef <test_kmalloc+0x113>
			test_kmalloc_NF_both();
f0117388:	e8 7c 04 00 00       	call   f0117809 <test_kmalloc_NF_both>
f011738d:	eb 60                	jmp    f01173ef <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f011738f:	e8 3e ff ff ff       	call   f01172d2 <get_kheap_strategy>
f0117394:	83 f8 04             	cmp    $0x4,%eax
f0117397:	75 27                	jne    f01173c0 <test_kmalloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117399:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011739d:	75 07                	jne    f01173a6 <test_kmalloc+0xca>
			test_kmalloc_WF_page();
f011739f:	e8 7d 03 00 00       	call   f0117721 <test_kmalloc_WF_page>
f01173a4:	eb 49                	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01173a6:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01173aa:	75 07                	jne    f01173b3 <test_kmalloc+0xd7>
			test_kmalloc_WF_block();
f01173ac:	e8 01 04 00 00       	call   f01177b2 <test_kmalloc_WF_block>
f01173b1:	eb 3c                	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01173b3:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01173b7:	75 36                	jne    f01173ef <test_kmalloc+0x113>
			test_kmalloc_WF_both();
f01173b9:	e8 85 04 00 00       	call   f0117843 <test_kmalloc_WF_both>
f01173be:	eb 2f                	jmp    f01173ef <test_kmalloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01173c0:	e8 0d ff ff ff       	call   f01172d2 <get_kheap_strategy>
f01173c5:	83 f8 05             	cmp    $0x5,%eax
f01173c8:	75 25                	jne    f01173ef <test_kmalloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01173ca:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01173ce:	75 07                	jne    f01173d7 <test_kmalloc+0xfb>
			test_kmalloc_CF_page();
f01173d0:	e8 69 03 00 00       	call   f011773e <test_kmalloc_CF_page>
f01173d5:	eb 18                	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01173d7:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01173db:	75 07                	jne    f01173e4 <test_kmalloc+0x108>
			test_kmalloc_CF_block();
f01173dd:	e8 ed 03 00 00       	call   f01177cf <test_kmalloc_CF_block>
f01173e2:	eb 0b                	jmp    f01173ef <test_kmalloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01173e4:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01173e8:	75 05                	jne    f01173ef <test_kmalloc+0x113>
			test_kmalloc_CF_both();
f01173ea:	e8 71 04 00 00       	call   f0117860 <test_kmalloc_CF_both>
	}
	return 0;
f01173ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
f01173f4:	c9                   	leave  
f01173f5:	c3                   	ret    

f01173f6 <test_kfree>:

int test_kfree(uint32 ALLOC_TYPE)
{
f01173f6:	55                   	push   %ebp
f01173f7:	89 e5                	mov    %esp,%ebp
f01173f9:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f01173fc:	e8 d1 fe ff ff       	call   f01172d2 <get_kheap_strategy>
f0117401:	83 f8 01             	cmp    $0x1,%eax
f0117404:	75 34                	jne    f011743a <test_kfree+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117406:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f011740a:	75 0a                	jne    f0117416 <test_kfree+0x20>
			test_kfree_FF_page();
f011740c:	e8 6c 04 00 00       	call   f011787d <test_kfree_FF_page>
f0117411:	e9 f3 00 00 00       	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117416:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011741a:	75 0a                	jne    f0117426 <test_kfree+0x30>
			test_kfree_FF_block();
f011741c:	e8 ed 04 00 00       	call   f011790e <test_kfree_FF_block>
f0117421:	e9 e3 00 00 00       	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117426:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011742a:	0f 85 d9 00 00 00    	jne    f0117509 <test_kfree+0x113>
			test_kfree_FF_both();
f0117430:	e8 6a 05 00 00       	call   f011799f <test_kfree_FF_both>
f0117435:	e9 cf 00 00 00       	jmp    f0117509 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f011743a:	e8 93 fe ff ff       	call   f01172d2 <get_kheap_strategy>
f011743f:	83 f8 02             	cmp    $0x2,%eax
f0117442:	75 34                	jne    f0117478 <test_kfree+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117444:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117448:	75 0a                	jne    f0117454 <test_kfree+0x5e>
			test_kfree_BF_page();
f011744a:	e8 68 04 00 00       	call   f01178b7 <test_kfree_BF_page>
f011744f:	e9 b5 00 00 00       	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117454:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117458:	75 0a                	jne    f0117464 <test_kfree+0x6e>
			test_kfree_BF_block();
f011745a:	e8 e9 04 00 00       	call   f0117948 <test_kfree_BF_block>
f011745f:	e9 a5 00 00 00       	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117464:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117468:	0f 85 9b 00 00 00    	jne    f0117509 <test_kfree+0x113>
			test_kfree_BF_both();
f011746e:	e8 66 05 00 00       	call   f01179d9 <test_kfree_BF_both>
f0117473:	e9 91 00 00 00       	jmp    f0117509 <test_kfree+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117478:	e8 55 fe ff ff       	call   f01172d2 <get_kheap_strategy>
f011747d:	83 f8 03             	cmp    $0x3,%eax
f0117480:	75 27                	jne    f01174a9 <test_kfree+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117482:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117486:	75 07                	jne    f011748f <test_kfree+0x99>
			test_kfree_NF_page();
f0117488:	e8 0d 04 00 00       	call   f011789a <test_kfree_NF_page>
f011748d:	eb 7a                	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011748f:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117493:	75 07                	jne    f011749c <test_kfree+0xa6>
			test_kfree_NF_block();
f0117495:	e8 91 04 00 00       	call   f011792b <test_kfree_NF_block>
f011749a:	eb 6d                	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011749c:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01174a0:	75 67                	jne    f0117509 <test_kfree+0x113>
			test_kfree_NF_both();
f01174a2:	e8 15 05 00 00       	call   f01179bc <test_kfree_NF_both>
f01174a7:	eb 60                	jmp    f0117509 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f01174a9:	e8 24 fe ff ff       	call   f01172d2 <get_kheap_strategy>
f01174ae:	83 f8 04             	cmp    $0x4,%eax
f01174b1:	75 27                	jne    f01174da <test_kfree+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01174b3:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01174b7:	75 07                	jne    f01174c0 <test_kfree+0xca>
			test_kfree_WF_page();
f01174b9:	e8 16 04 00 00       	call   f01178d4 <test_kfree_WF_page>
f01174be:	eb 49                	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01174c0:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01174c4:	75 07                	jne    f01174cd <test_kfree+0xd7>
			test_kfree_WF_block();
f01174c6:	e8 9a 04 00 00       	call   f0117965 <test_kfree_WF_block>
f01174cb:	eb 3c                	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01174cd:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01174d1:	75 36                	jne    f0117509 <test_kfree+0x113>
			test_kfree_WF_both();
f01174d3:	e8 1e 05 00 00       	call   f01179f6 <test_kfree_WF_both>
f01174d8:	eb 2f                	jmp    f0117509 <test_kfree+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01174da:	e8 f3 fd ff ff       	call   f01172d2 <get_kheap_strategy>
f01174df:	83 f8 05             	cmp    $0x5,%eax
f01174e2:	75 25                	jne    f0117509 <test_kfree+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01174e4:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01174e8:	75 07                	jne    f01174f1 <test_kfree+0xfb>
			test_kfree_CF_page();
f01174ea:	e8 02 04 00 00       	call   f01178f1 <test_kfree_CF_page>
f01174ef:	eb 18                	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01174f1:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01174f5:	75 07                	jne    f01174fe <test_kfree+0x108>
			test_kfree_CF_block();
f01174f7:	e8 86 04 00 00       	call   f0117982 <test_kfree_CF_block>
f01174fc:	eb 0b                	jmp    f0117509 <test_kfree+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01174fe:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117502:	75 05                	jne    f0117509 <test_kfree+0x113>
			test_kfree_CF_both();
f0117504:	e8 0a 05 00 00       	call   f0117a13 <test_kfree_CF_both>
	}
	return 0;
f0117509:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011750e:	c9                   	leave  
f011750f:	c3                   	ret    

f0117510 <test_krealloc>:
int test_krealloc(uint32 ALLOC_TYPE)
{
f0117510:	55                   	push   %ebp
f0117511:	89 e5                	mov    %esp,%ebp
f0117513:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f0117516:	e8 b7 fd ff ff       	call   f01172d2 <get_kheap_strategy>
f011751b:	83 f8 01             	cmp    $0x1,%eax
f011751e:	75 34                	jne    f0117554 <test_krealloc+0x44>
	{
		//Test FIRST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f0117520:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117524:	75 0a                	jne    f0117530 <test_krealloc+0x20>
			test_krealloc_FF_page();
f0117526:	e8 05 05 00 00       	call   f0117a30 <test_krealloc_FF_page>
f011752b:	e9 f3 00 00 00       	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f0117530:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117534:	75 0a                	jne    f0117540 <test_krealloc+0x30>
			test_krealloc_FF_block();
f0117536:	e8 86 05 00 00       	call   f0117ac1 <test_krealloc_FF_block>
f011753b:	e9 e3 00 00 00       	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117540:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117544:	0f 85 d9 00 00 00    	jne    f0117623 <test_krealloc+0x113>
			test_krealloc_FF_both();
f011754a:	e8 03 06 00 00       	call   f0117b52 <test_krealloc_FF_both>
f011754f:	e9 cf 00 00 00       	jmp    f0117623 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117554:	e8 79 fd ff ff       	call   f01172d2 <get_kheap_strategy>
f0117559:	83 f8 02             	cmp    $0x2,%eax
f011755c:	75 34                	jne    f0117592 <test_krealloc+0x82>
	{
		//Test BEST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011755e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117562:	75 0a                	jne    f011756e <test_krealloc+0x5e>
			test_krealloc_BF_page();
f0117564:	e8 01 05 00 00       	call   f0117a6a <test_krealloc_BF_page>
f0117569:	e9 b5 00 00 00       	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011756e:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f0117572:	75 0a                	jne    f011757e <test_krealloc+0x6e>
			test_krealloc_BF_block();
f0117574:	e8 82 05 00 00       	call   f0117afb <test_krealloc_BF_block>
f0117579:	e9 a5 00 00 00       	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f011757e:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f0117582:	0f 85 9b 00 00 00    	jne    f0117623 <test_krealloc+0x113>
			test_krealloc_BF_both();
f0117588:	e8 ff 05 00 00       	call   f0117b8c <test_krealloc_BF_both>
f011758d:	e9 91 00 00 00       	jmp    f0117623 <test_krealloc+0x113>
	}
	else if(get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117592:	e8 3b fd ff ff       	call   f01172d2 <get_kheap_strategy>
f0117597:	83 f8 03             	cmp    $0x3,%eax
f011759a:	75 27                	jne    f01175c3 <test_krealloc+0xb3>
	{
		//Test NEXT FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f011759c:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01175a0:	75 07                	jne    f01175a9 <test_krealloc+0x99>
			test_krealloc_NF_page();
f01175a2:	e8 a6 04 00 00       	call   f0117a4d <test_krealloc_NF_page>
f01175a7:	eb 7a                	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01175a9:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01175ad:	75 07                	jne    f01175b6 <test_krealloc+0xa6>
			test_krealloc_NF_block();
f01175af:	e8 2a 05 00 00       	call   f0117ade <test_krealloc_NF_block>
f01175b4:	eb 6d                	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01175b6:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01175ba:	75 67                	jne    f0117623 <test_krealloc+0x113>
			test_krealloc_NF_both();
f01175bc:	e8 ae 05 00 00       	call   f0117b6f <test_krealloc_NF_both>
f01175c1:	eb 60                	jmp    f0117623 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f01175c3:	e8 0a fd ff ff       	call   f01172d2 <get_kheap_strategy>
f01175c8:	83 f8 04             	cmp    $0x4,%eax
f01175cb:	75 27                	jne    f01175f4 <test_krealloc+0xe4>
	{
		//Test WORST FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01175cd:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01175d1:	75 07                	jne    f01175da <test_krealloc+0xca>
			test_krealloc_WF_page();
f01175d3:	e8 af 04 00 00       	call   f0117a87 <test_krealloc_WF_page>
f01175d8:	eb 49                	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f01175da:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f01175de:	75 07                	jne    f01175e7 <test_krealloc+0xd7>
			test_krealloc_WF_block();
f01175e0:	e8 33 05 00 00       	call   f0117b18 <test_krealloc_WF_block>
f01175e5:	eb 3c                	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f01175e7:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f01175eb:	75 36                	jne    f0117623 <test_krealloc+0x113>
			test_krealloc_WF_both();
f01175ed:	e8 b7 05 00 00       	call   f0117ba9 <test_krealloc_WF_both>
f01175f2:	eb 2f                	jmp    f0117623 <test_krealloc+0x113>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f01175f4:	e8 d9 fc ff ff       	call   f01172d2 <get_kheap_strategy>
f01175f9:	83 f8 05             	cmp    $0x5,%eax
f01175fc:	75 25                	jne    f0117623 <test_krealloc+0x113>
	{
		//Test CUSTOM FIT allocation
		if (ALLOC_TYPE == TST_PAGE_ALLOC)
f01175fe:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0117602:	75 07                	jne    f011760b <test_krealloc+0xfb>
			test_krealloc_CF_page();
f0117604:	e8 9b 04 00 00       	call   f0117aa4 <test_krealloc_CF_page>
f0117609:	eb 18                	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BLOCK_ALLOC)
f011760b:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
f011760f:	75 07                	jne    f0117618 <test_krealloc+0x108>
			test_krealloc_CF_block();
f0117611:	e8 1f 05 00 00       	call   f0117b35 <test_krealloc_CF_block>
f0117616:	eb 0b                	jmp    f0117623 <test_krealloc+0x113>
		else if (ALLOC_TYPE == TST_BOTH_ALLOC)
f0117618:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
f011761c:	75 05                	jne    f0117623 <test_krealloc+0x113>
			test_krealloc_CF_both();
f011761e:	e8 a3 05 00 00       	call   f0117bc6 <test_krealloc_CF_both>
	}
	return 0;
f0117623:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117628:	c9                   	leave  
f0117629:	c3                   	ret    

f011762a <test_fast_page_alloc>:

void* ptr_fast_allocations[(KERNEL_HEAP_MAX - KERNEL_HEAP_START)/PAGE_SIZE] = {0};
int test_fast_page_alloc()
{
f011762a:	55                   	push   %ebp
f011762b:	89 e5                	mov    %esp,%ebp
f011762d:	83 ec 08             	sub    $0x8,%esp
	if (get_kheap_strategy() == KHP_PLACE_FIRSTFIT)
f0117630:	e8 9d fc ff ff       	call   f01172d2 <get_kheap_strategy>
f0117635:	83 f8 01             	cmp    $0x1,%eax
f0117638:	75 07                	jne    f0117641 <test_fast_page_alloc+0x17>
	{
		test_fast_FF();
f011763a:	e8 a4 05 00 00       	call   f0117be3 <test_fast_FF>
f011763f:	eb 42                	jmp    f0117683 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_NEXTFIT)
f0117641:	e8 8c fc ff ff       	call   f01172d2 <get_kheap_strategy>
f0117646:	83 f8 03             	cmp    $0x3,%eax
f0117649:	75 07                	jne    f0117652 <test_fast_page_alloc+0x28>
	{
		test_fast_NF();
f011764b:	e8 b0 05 00 00       	call   f0117c00 <test_fast_NF>
f0117650:	eb 31                	jmp    f0117683 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_BESTFIT)
f0117652:	e8 7b fc ff ff       	call   f01172d2 <get_kheap_strategy>
f0117657:	83 f8 02             	cmp    $0x2,%eax
f011765a:	75 07                	jne    f0117663 <test_fast_page_alloc+0x39>
	{
		test_fast_BF();
f011765c:	e8 bc 05 00 00       	call   f0117c1d <test_fast_BF>
f0117661:	eb 20                	jmp    f0117683 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_WORSTFIT)
f0117663:	e8 6a fc ff ff       	call   f01172d2 <get_kheap_strategy>
f0117668:	83 f8 04             	cmp    $0x4,%eax
f011766b:	75 07                	jne    f0117674 <test_fast_page_alloc+0x4a>
	{
		test_fast_WF();
f011766d:	e8 c8 05 00 00       	call   f0117c3a <test_fast_WF>
f0117672:	eb 0f                	jmp    f0117683 <test_fast_page_alloc+0x59>
	}
	else if (get_kheap_strategy() == KHP_PLACE_CUSTOMFIT)
f0117674:	e8 59 fc ff ff       	call   f01172d2 <get_kheap_strategy>
f0117679:	83 f8 05             	cmp    $0x5,%eax
f011767c:	75 05                	jne    f0117683 <test_fast_page_alloc+0x59>
	{
		test_fast_CF();
f011767e:	e8 d4 05 00 00       	call   f0117c57 <test_fast_CF>
	}
	return 0;
f0117683:	b8 00 00 00 00       	mov    $0x0,%eax
}
f0117688:	c9                   	leave  
f0117689:	c3                   	ret    

f011768a <test_kheap_phys_addr>:

int test_kheap_phys_addr()
{
f011768a:	55                   	push   %ebp
f011768b:	89 e5                	mov    %esp,%ebp
f011768d:	81 ec 28 35 00 00    	sub    $0x3528,%esp
	panic("update is required!!");
f0117693:	83 ec 04             	sub    $0x4,%esp
f0117696:	68 90 51 13 f0       	push   $0xf0135190
f011769b:	68 28 01 00 00       	push   $0x128
f01176a0:	68 a5 51 13 f0       	push   $0xf01351a5
f01176a5:	e8 05 99 fe ff       	call   f0100faf <_panic>

f01176aa <test_kheap_virt_addr>:
	return 1;

}

int test_kheap_virt_addr()
{
f01176aa:	55                   	push   %ebp
f01176ab:	89 e5                	mov    %esp,%ebp
f01176ad:	81 ec 08 01 00 00    	sub    $0x108,%esp
	panic("update is required!!");
f01176b3:	83 ec 04             	sub    $0x4,%esp
f01176b6:	68 90 51 13 f0       	push   $0xf0135190
f01176bb:	68 6d 02 00 00       	push   $0x26d
f01176c0:	68 a5 51 13 f0       	push   $0xf01351a5
f01176c5:	e8 e5 98 fe ff       	call   f0100faf <_panic>

f01176ca <test_kmalloc_FF_page>:

/**********************************************************************************************/
/********************************** KMALLOC TESTING AREA **************************************/
/**********************************************************************************************/
int test_kmalloc_FF_page()
{
f01176ca:	55                   	push   %ebp
f01176cb:	89 e5                	mov    %esp,%ebp
f01176cd:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176d0:	83 ec 04             	sub    $0x4,%esp
f01176d3:	68 bd 51 13 f0       	push   $0xf01351bd
f01176d8:	68 93 03 00 00       	push   $0x393
f01176dd:	68 a5 51 13 f0       	push   $0xf01351a5
f01176e2:	e8 c8 98 fe ff       	call   f0100faf <_panic>

f01176e7 <test_kmalloc_NF_page>:
}
int test_kmalloc_NF_page()
{
f01176e7:	55                   	push   %ebp
f01176e8:	89 e5                	mov    %esp,%ebp
f01176ea:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01176ed:	83 ec 04             	sub    $0x4,%esp
f01176f0:	68 bd 51 13 f0       	push   $0xf01351bd
f01176f5:	68 97 03 00 00       	push   $0x397
f01176fa:	68 a5 51 13 f0       	push   $0xf01351a5
f01176ff:	e8 ab 98 fe ff       	call   f0100faf <_panic>

f0117704 <test_kmalloc_BF_page>:
}
int test_kmalloc_BF_page()
{
f0117704:	55                   	push   %ebp
f0117705:	89 e5                	mov    %esp,%ebp
f0117707:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011770a:	83 ec 04             	sub    $0x4,%esp
f011770d:	68 bd 51 13 f0       	push   $0xf01351bd
f0117712:	68 9b 03 00 00       	push   $0x39b
f0117717:	68 a5 51 13 f0       	push   $0xf01351a5
f011771c:	e8 8e 98 fe ff       	call   f0100faf <_panic>

f0117721 <test_kmalloc_WF_page>:
}
int test_kmalloc_WF_page()
{
f0117721:	55                   	push   %ebp
f0117722:	89 e5                	mov    %esp,%ebp
f0117724:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117727:	83 ec 04             	sub    $0x4,%esp
f011772a:	68 bd 51 13 f0       	push   $0xf01351bd
f011772f:	68 9f 03 00 00       	push   $0x39f
f0117734:	68 a5 51 13 f0       	push   $0xf01351a5
f0117739:	e8 71 98 fe ff       	call   f0100faf <_panic>

f011773e <test_kmalloc_CF_page>:
}
int test_kmalloc_CF_page()
{
f011773e:	55                   	push   %ebp
f011773f:	89 e5                	mov    %esp,%ebp
f0117741:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117744:	83 ec 04             	sub    $0x4,%esp
f0117747:	68 bd 51 13 f0       	push   $0xf01351bd
f011774c:	68 a3 03 00 00       	push   $0x3a3
f0117751:	68 a5 51 13 f0       	push   $0xf01351a5
f0117756:	e8 54 98 fe ff       	call   f0100faf <_panic>

f011775b <test_kmalloc_FF_block>:
}

int test_kmalloc_FF_block()
{
f011775b:	55                   	push   %ebp
f011775c:	89 e5                	mov    %esp,%ebp
f011775e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117761:	83 ec 04             	sub    $0x4,%esp
f0117764:	68 bd 51 13 f0       	push   $0xf01351bd
f0117769:	68 a8 03 00 00       	push   $0x3a8
f011776e:	68 a5 51 13 f0       	push   $0xf01351a5
f0117773:	e8 37 98 fe ff       	call   f0100faf <_panic>

f0117778 <test_kmalloc_NF_block>:
}
int test_kmalloc_NF_block()
{
f0117778:	55                   	push   %ebp
f0117779:	89 e5                	mov    %esp,%ebp
f011777b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011777e:	83 ec 04             	sub    $0x4,%esp
f0117781:	68 bd 51 13 f0       	push   $0xf01351bd
f0117786:	68 ac 03 00 00       	push   $0x3ac
f011778b:	68 a5 51 13 f0       	push   $0xf01351a5
f0117790:	e8 1a 98 fe ff       	call   f0100faf <_panic>

f0117795 <test_kmalloc_BF_block>:
}
int test_kmalloc_BF_block()
{
f0117795:	55                   	push   %ebp
f0117796:	89 e5                	mov    %esp,%ebp
f0117798:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011779b:	83 ec 04             	sub    $0x4,%esp
f011779e:	68 bd 51 13 f0       	push   $0xf01351bd
f01177a3:	68 b0 03 00 00       	push   $0x3b0
f01177a8:	68 a5 51 13 f0       	push   $0xf01351a5
f01177ad:	e8 fd 97 fe ff       	call   f0100faf <_panic>

f01177b2 <test_kmalloc_WF_block>:
}
int test_kmalloc_WF_block()
{
f01177b2:	55                   	push   %ebp
f01177b3:	89 e5                	mov    %esp,%ebp
f01177b5:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177b8:	83 ec 04             	sub    $0x4,%esp
f01177bb:	68 bd 51 13 f0       	push   $0xf01351bd
f01177c0:	68 b4 03 00 00       	push   $0x3b4
f01177c5:	68 a5 51 13 f0       	push   $0xf01351a5
f01177ca:	e8 e0 97 fe ff       	call   f0100faf <_panic>

f01177cf <test_kmalloc_CF_block>:
}
int test_kmalloc_CF_block()
{
f01177cf:	55                   	push   %ebp
f01177d0:	89 e5                	mov    %esp,%ebp
f01177d2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177d5:	83 ec 04             	sub    $0x4,%esp
f01177d8:	68 bd 51 13 f0       	push   $0xf01351bd
f01177dd:	68 b8 03 00 00       	push   $0x3b8
f01177e2:	68 a5 51 13 f0       	push   $0xf01351a5
f01177e7:	e8 c3 97 fe ff       	call   f0100faf <_panic>

f01177ec <test_kmalloc_FF_both>:
}

int test_kmalloc_FF_both()
{
f01177ec:	55                   	push   %ebp
f01177ed:	89 e5                	mov    %esp,%ebp
f01177ef:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01177f2:	83 ec 04             	sub    $0x4,%esp
f01177f5:	68 bd 51 13 f0       	push   $0xf01351bd
f01177fa:	68 bd 03 00 00       	push   $0x3bd
f01177ff:	68 a5 51 13 f0       	push   $0xf01351a5
f0117804:	e8 a6 97 fe ff       	call   f0100faf <_panic>

f0117809 <test_kmalloc_NF_both>:
}
int test_kmalloc_NF_both()
{
f0117809:	55                   	push   %ebp
f011780a:	89 e5                	mov    %esp,%ebp
f011780c:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011780f:	83 ec 04             	sub    $0x4,%esp
f0117812:	68 bd 51 13 f0       	push   $0xf01351bd
f0117817:	68 c1 03 00 00       	push   $0x3c1
f011781c:	68 a5 51 13 f0       	push   $0xf01351a5
f0117821:	e8 89 97 fe ff       	call   f0100faf <_panic>

f0117826 <test_kmalloc_BF_both>:
}
int test_kmalloc_BF_both()
{
f0117826:	55                   	push   %ebp
f0117827:	89 e5                	mov    %esp,%ebp
f0117829:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011782c:	83 ec 04             	sub    $0x4,%esp
f011782f:	68 bd 51 13 f0       	push   $0xf01351bd
f0117834:	68 c5 03 00 00       	push   $0x3c5
f0117839:	68 a5 51 13 f0       	push   $0xf01351a5
f011783e:	e8 6c 97 fe ff       	call   f0100faf <_panic>

f0117843 <test_kmalloc_WF_both>:
}
int test_kmalloc_WF_both()
{
f0117843:	55                   	push   %ebp
f0117844:	89 e5                	mov    %esp,%ebp
f0117846:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117849:	83 ec 04             	sub    $0x4,%esp
f011784c:	68 bd 51 13 f0       	push   $0xf01351bd
f0117851:	68 c9 03 00 00       	push   $0x3c9
f0117856:	68 a5 51 13 f0       	push   $0xf01351a5
f011785b:	e8 4f 97 fe ff       	call   f0100faf <_panic>

f0117860 <test_kmalloc_CF_both>:
}
int test_kmalloc_CF_both()
{
f0117860:	55                   	push   %ebp
f0117861:	89 e5                	mov    %esp,%ebp
f0117863:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117866:	83 ec 04             	sub    $0x4,%esp
f0117869:	68 bd 51 13 f0       	push   $0xf01351bd
f011786e:	68 cd 03 00 00       	push   $0x3cd
f0117873:	68 a5 51 13 f0       	push   $0xf01351a5
f0117878:	e8 32 97 fe ff       	call   f0100faf <_panic>

f011787d <test_kfree_FF_page>:

/**********************************************************************************************/
/*********************************** KFREE TESTING AREA ***************************************/
/**********************************************************************************************/
int test_kfree_FF_page()
{
f011787d:	55                   	push   %ebp
f011787e:	89 e5                	mov    %esp,%ebp
f0117880:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117883:	83 ec 04             	sub    $0x4,%esp
f0117886:	68 bd 51 13 f0       	push   $0xf01351bd
f011788b:	68 d5 03 00 00       	push   $0x3d5
f0117890:	68 a5 51 13 f0       	push   $0xf01351a5
f0117895:	e8 15 97 fe ff       	call   f0100faf <_panic>

f011789a <test_kfree_NF_page>:
}
int test_kfree_NF_page()
{
f011789a:	55                   	push   %ebp
f011789b:	89 e5                	mov    %esp,%ebp
f011789d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178a0:	83 ec 04             	sub    $0x4,%esp
f01178a3:	68 bd 51 13 f0       	push   $0xf01351bd
f01178a8:	68 d9 03 00 00       	push   $0x3d9
f01178ad:	68 a5 51 13 f0       	push   $0xf01351a5
f01178b2:	e8 f8 96 fe ff       	call   f0100faf <_panic>

f01178b7 <test_kfree_BF_page>:
}
int test_kfree_BF_page()
{
f01178b7:	55                   	push   %ebp
f01178b8:	89 e5                	mov    %esp,%ebp
f01178ba:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178bd:	83 ec 04             	sub    $0x4,%esp
f01178c0:	68 bd 51 13 f0       	push   $0xf01351bd
f01178c5:	68 dd 03 00 00       	push   $0x3dd
f01178ca:	68 a5 51 13 f0       	push   $0xf01351a5
f01178cf:	e8 db 96 fe ff       	call   f0100faf <_panic>

f01178d4 <test_kfree_WF_page>:
}
int test_kfree_WF_page()
{
f01178d4:	55                   	push   %ebp
f01178d5:	89 e5                	mov    %esp,%ebp
f01178d7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178da:	83 ec 04             	sub    $0x4,%esp
f01178dd:	68 bd 51 13 f0       	push   $0xf01351bd
f01178e2:	68 e1 03 00 00       	push   $0x3e1
f01178e7:	68 a5 51 13 f0       	push   $0xf01351a5
f01178ec:	e8 be 96 fe ff       	call   f0100faf <_panic>

f01178f1 <test_kfree_CF_page>:
}
int test_kfree_CF_page()
{
f01178f1:	55                   	push   %ebp
f01178f2:	89 e5                	mov    %esp,%ebp
f01178f4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01178f7:	83 ec 04             	sub    $0x4,%esp
f01178fa:	68 bd 51 13 f0       	push   $0xf01351bd
f01178ff:	68 e5 03 00 00       	push   $0x3e5
f0117904:	68 a5 51 13 f0       	push   $0xf01351a5
f0117909:	e8 a1 96 fe ff       	call   f0100faf <_panic>

f011790e <test_kfree_FF_block>:
}

int test_kfree_FF_block()
{
f011790e:	55                   	push   %ebp
f011790f:	89 e5                	mov    %esp,%ebp
f0117911:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117914:	83 ec 04             	sub    $0x4,%esp
f0117917:	68 bd 51 13 f0       	push   $0xf01351bd
f011791c:	68 ea 03 00 00       	push   $0x3ea
f0117921:	68 a5 51 13 f0       	push   $0xf01351a5
f0117926:	e8 84 96 fe ff       	call   f0100faf <_panic>

f011792b <test_kfree_NF_block>:
}
int test_kfree_NF_block()
{
f011792b:	55                   	push   %ebp
f011792c:	89 e5                	mov    %esp,%ebp
f011792e:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117931:	83 ec 04             	sub    $0x4,%esp
f0117934:	68 bd 51 13 f0       	push   $0xf01351bd
f0117939:	68 ee 03 00 00       	push   $0x3ee
f011793e:	68 a5 51 13 f0       	push   $0xf01351a5
f0117943:	e8 67 96 fe ff       	call   f0100faf <_panic>

f0117948 <test_kfree_BF_block>:
}
int test_kfree_BF_block()
{
f0117948:	55                   	push   %ebp
f0117949:	89 e5                	mov    %esp,%ebp
f011794b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011794e:	83 ec 04             	sub    $0x4,%esp
f0117951:	68 bd 51 13 f0       	push   $0xf01351bd
f0117956:	68 f2 03 00 00       	push   $0x3f2
f011795b:	68 a5 51 13 f0       	push   $0xf01351a5
f0117960:	e8 4a 96 fe ff       	call   f0100faf <_panic>

f0117965 <test_kfree_WF_block>:
}
int test_kfree_WF_block()
{
f0117965:	55                   	push   %ebp
f0117966:	89 e5                	mov    %esp,%ebp
f0117968:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f011796b:	83 ec 04             	sub    $0x4,%esp
f011796e:	68 bd 51 13 f0       	push   $0xf01351bd
f0117973:	68 f6 03 00 00       	push   $0x3f6
f0117978:	68 a5 51 13 f0       	push   $0xf01351a5
f011797d:	e8 2d 96 fe ff       	call   f0100faf <_panic>

f0117982 <test_kfree_CF_block>:
}
int test_kfree_CF_block()
{
f0117982:	55                   	push   %ebp
f0117983:	89 e5                	mov    %esp,%ebp
f0117985:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117988:	83 ec 04             	sub    $0x4,%esp
f011798b:	68 bd 51 13 f0       	push   $0xf01351bd
f0117990:	68 fa 03 00 00       	push   $0x3fa
f0117995:	68 a5 51 13 f0       	push   $0xf01351a5
f011799a:	e8 10 96 fe ff       	call   f0100faf <_panic>

f011799f <test_kfree_FF_both>:
}

int test_kfree_FF_both()
{
f011799f:	55                   	push   %ebp
f01179a0:	89 e5                	mov    %esp,%ebp
f01179a2:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179a5:	83 ec 04             	sub    $0x4,%esp
f01179a8:	68 bd 51 13 f0       	push   $0xf01351bd
f01179ad:	68 ff 03 00 00       	push   $0x3ff
f01179b2:	68 a5 51 13 f0       	push   $0xf01351a5
f01179b7:	e8 f3 95 fe ff       	call   f0100faf <_panic>

f01179bc <test_kfree_NF_both>:
}
int test_kfree_NF_both()
{
f01179bc:	55                   	push   %ebp
f01179bd:	89 e5                	mov    %esp,%ebp
f01179bf:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179c2:	83 ec 04             	sub    $0x4,%esp
f01179c5:	68 bd 51 13 f0       	push   $0xf01351bd
f01179ca:	68 03 04 00 00       	push   $0x403
f01179cf:	68 a5 51 13 f0       	push   $0xf01351a5
f01179d4:	e8 d6 95 fe ff       	call   f0100faf <_panic>

f01179d9 <test_kfree_BF_both>:
}
int test_kfree_BF_both()
{
f01179d9:	55                   	push   %ebp
f01179da:	89 e5                	mov    %esp,%ebp
f01179dc:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179df:	83 ec 04             	sub    $0x4,%esp
f01179e2:	68 bd 51 13 f0       	push   $0xf01351bd
f01179e7:	68 07 04 00 00       	push   $0x407
f01179ec:	68 a5 51 13 f0       	push   $0xf01351a5
f01179f1:	e8 b9 95 fe ff       	call   f0100faf <_panic>

f01179f6 <test_kfree_WF_both>:
}
int test_kfree_WF_both()
{
f01179f6:	55                   	push   %ebp
f01179f7:	89 e5                	mov    %esp,%ebp
f01179f9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f01179fc:	83 ec 04             	sub    $0x4,%esp
f01179ff:	68 bd 51 13 f0       	push   $0xf01351bd
f0117a04:	68 0b 04 00 00       	push   $0x40b
f0117a09:	68 a5 51 13 f0       	push   $0xf01351a5
f0117a0e:	e8 9c 95 fe ff       	call   f0100faf <_panic>

f0117a13 <test_kfree_CF_both>:
}
int test_kfree_CF_both()
{
f0117a13:	55                   	push   %ebp
f0117a14:	89 e5                	mov    %esp,%ebp
f0117a16:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a19:	83 ec 04             	sub    $0x4,%esp
f0117a1c:	68 bd 51 13 f0       	push   $0xf01351bd
f0117a21:	68 0f 04 00 00       	push   $0x40f
f0117a26:	68 a5 51 13 f0       	push   $0xf01351a5
f0117a2b:	e8 7f 95 fe ff       	call   f0100faf <_panic>

f0117a30 <test_krealloc_FF_page>:

/**********************************************************************************************/
/********************************** KREALLOC TESTING AREA *************************************/
/**********************************************************************************************/
int test_krealloc_FF_page()
{
f0117a30:	55                   	push   %ebp
f0117a31:	89 e5                	mov    %esp,%ebp
f0117a33:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a36:	83 ec 04             	sub    $0x4,%esp
f0117a39:	68 bd 51 13 f0       	push   $0xf01351bd
f0117a3e:	68 17 04 00 00       	push   $0x417
f0117a43:	68 a5 51 13 f0       	push   $0xf01351a5
f0117a48:	e8 62 95 fe ff       	call   f0100faf <_panic>

f0117a4d <test_krealloc_NF_page>:
}
int test_krealloc_NF_page()
{
f0117a4d:	55                   	push   %ebp
f0117a4e:	89 e5                	mov    %esp,%ebp
f0117a50:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a53:	83 ec 04             	sub    $0x4,%esp
f0117a56:	68 bd 51 13 f0       	push   $0xf01351bd
f0117a5b:	68 1b 04 00 00       	push   $0x41b
f0117a60:	68 a5 51 13 f0       	push   $0xf01351a5
f0117a65:	e8 45 95 fe ff       	call   f0100faf <_panic>

f0117a6a <test_krealloc_BF_page>:
}
int test_krealloc_BF_page()
{
f0117a6a:	55                   	push   %ebp
f0117a6b:	89 e5                	mov    %esp,%ebp
f0117a6d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a70:	83 ec 04             	sub    $0x4,%esp
f0117a73:	68 bd 51 13 f0       	push   $0xf01351bd
f0117a78:	68 1f 04 00 00       	push   $0x41f
f0117a7d:	68 a5 51 13 f0       	push   $0xf01351a5
f0117a82:	e8 28 95 fe ff       	call   f0100faf <_panic>

f0117a87 <test_krealloc_WF_page>:
}
int test_krealloc_WF_page()
{
f0117a87:	55                   	push   %ebp
f0117a88:	89 e5                	mov    %esp,%ebp
f0117a8a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117a8d:	83 ec 04             	sub    $0x4,%esp
f0117a90:	68 bd 51 13 f0       	push   $0xf01351bd
f0117a95:	68 23 04 00 00       	push   $0x423
f0117a9a:	68 a5 51 13 f0       	push   $0xf01351a5
f0117a9f:	e8 0b 95 fe ff       	call   f0100faf <_panic>

f0117aa4 <test_krealloc_CF_page>:
}
int test_krealloc_CF_page()
{
f0117aa4:	55                   	push   %ebp
f0117aa5:	89 e5                	mov    %esp,%ebp
f0117aa7:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117aaa:	83 ec 04             	sub    $0x4,%esp
f0117aad:	68 bd 51 13 f0       	push   $0xf01351bd
f0117ab2:	68 27 04 00 00       	push   $0x427
f0117ab7:	68 a5 51 13 f0       	push   $0xf01351a5
f0117abc:	e8 ee 94 fe ff       	call   f0100faf <_panic>

f0117ac1 <test_krealloc_FF_block>:
}

int test_krealloc_FF_block()
{
f0117ac1:	55                   	push   %ebp
f0117ac2:	89 e5                	mov    %esp,%ebp
f0117ac4:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117ac7:	83 ec 04             	sub    $0x4,%esp
f0117aca:	68 bd 51 13 f0       	push   $0xf01351bd
f0117acf:	68 2c 04 00 00       	push   $0x42c
f0117ad4:	68 a5 51 13 f0       	push   $0xf01351a5
f0117ad9:	e8 d1 94 fe ff       	call   f0100faf <_panic>

f0117ade <test_krealloc_NF_block>:
}
int test_krealloc_NF_block()
{
f0117ade:	55                   	push   %ebp
f0117adf:	89 e5                	mov    %esp,%ebp
f0117ae1:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117ae4:	83 ec 04             	sub    $0x4,%esp
f0117ae7:	68 bd 51 13 f0       	push   $0xf01351bd
f0117aec:	68 30 04 00 00       	push   $0x430
f0117af1:	68 a5 51 13 f0       	push   $0xf01351a5
f0117af6:	e8 b4 94 fe ff       	call   f0100faf <_panic>

f0117afb <test_krealloc_BF_block>:
}
int test_krealloc_BF_block()
{
f0117afb:	55                   	push   %ebp
f0117afc:	89 e5                	mov    %esp,%ebp
f0117afe:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b01:	83 ec 04             	sub    $0x4,%esp
f0117b04:	68 bd 51 13 f0       	push   $0xf01351bd
f0117b09:	68 34 04 00 00       	push   $0x434
f0117b0e:	68 a5 51 13 f0       	push   $0xf01351a5
f0117b13:	e8 97 94 fe ff       	call   f0100faf <_panic>

f0117b18 <test_krealloc_WF_block>:
}
int test_krealloc_WF_block()
{
f0117b18:	55                   	push   %ebp
f0117b19:	89 e5                	mov    %esp,%ebp
f0117b1b:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b1e:	83 ec 04             	sub    $0x4,%esp
f0117b21:	68 bd 51 13 f0       	push   $0xf01351bd
f0117b26:	68 38 04 00 00       	push   $0x438
f0117b2b:	68 a5 51 13 f0       	push   $0xf01351a5
f0117b30:	e8 7a 94 fe ff       	call   f0100faf <_panic>

f0117b35 <test_krealloc_CF_block>:
}
int test_krealloc_CF_block()
{
f0117b35:	55                   	push   %ebp
f0117b36:	89 e5                	mov    %esp,%ebp
f0117b38:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b3b:	83 ec 04             	sub    $0x4,%esp
f0117b3e:	68 bd 51 13 f0       	push   $0xf01351bd
f0117b43:	68 3c 04 00 00       	push   $0x43c
f0117b48:	68 a5 51 13 f0       	push   $0xf01351a5
f0117b4d:	e8 5d 94 fe ff       	call   f0100faf <_panic>

f0117b52 <test_krealloc_FF_both>:
}

int test_krealloc_FF_both()
{
f0117b52:	55                   	push   %ebp
f0117b53:	89 e5                	mov    %esp,%ebp
f0117b55:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b58:	83 ec 04             	sub    $0x4,%esp
f0117b5b:	68 bd 51 13 f0       	push   $0xf01351bd
f0117b60:	68 41 04 00 00       	push   $0x441
f0117b65:	68 a5 51 13 f0       	push   $0xf01351a5
f0117b6a:	e8 40 94 fe ff       	call   f0100faf <_panic>

f0117b6f <test_krealloc_NF_both>:
}
int test_krealloc_NF_both()
{
f0117b6f:	55                   	push   %ebp
f0117b70:	89 e5                	mov    %esp,%ebp
f0117b72:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b75:	83 ec 04             	sub    $0x4,%esp
f0117b78:	68 bd 51 13 f0       	push   $0xf01351bd
f0117b7d:	68 45 04 00 00       	push   $0x445
f0117b82:	68 a5 51 13 f0       	push   $0xf01351a5
f0117b87:	e8 23 94 fe ff       	call   f0100faf <_panic>

f0117b8c <test_krealloc_BF_both>:
}
int test_krealloc_BF_both()
{
f0117b8c:	55                   	push   %ebp
f0117b8d:	89 e5                	mov    %esp,%ebp
f0117b8f:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117b92:	83 ec 04             	sub    $0x4,%esp
f0117b95:	68 bd 51 13 f0       	push   $0xf01351bd
f0117b9a:	68 49 04 00 00       	push   $0x449
f0117b9f:	68 a5 51 13 f0       	push   $0xf01351a5
f0117ba4:	e8 06 94 fe ff       	call   f0100faf <_panic>

f0117ba9 <test_krealloc_WF_both>:
}
int test_krealloc_WF_both()
{
f0117ba9:	55                   	push   %ebp
f0117baa:	89 e5                	mov    %esp,%ebp
f0117bac:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117baf:	83 ec 04             	sub    $0x4,%esp
f0117bb2:	68 bd 51 13 f0       	push   $0xf01351bd
f0117bb7:	68 4d 04 00 00       	push   $0x44d
f0117bbc:	68 a5 51 13 f0       	push   $0xf01351a5
f0117bc1:	e8 e9 93 fe ff       	call   f0100faf <_panic>

f0117bc6 <test_krealloc_CF_both>:
}
int test_krealloc_CF_both()
{
f0117bc6:	55                   	push   %ebp
f0117bc7:	89 e5                	mov    %esp,%ebp
f0117bc9:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117bcc:	83 ec 04             	sub    $0x4,%esp
f0117bcf:	68 bd 51 13 f0       	push   $0xf01351bd
f0117bd4:	68 51 04 00 00       	push   $0x451
f0117bd9:	68 a5 51 13 f0       	push   $0xf01351a5
f0117bde:	e8 cc 93 fe ff       	call   f0100faf <_panic>

f0117be3 <test_fast_FF>:

/**********************************************************************************************/
/*************************** FAST PAGE ALLOCATOR TESTING AREA *********************************/
/**********************************************************************************************/
int test_fast_FF()
{
f0117be3:	55                   	push   %ebp
f0117be4:	89 e5                	mov    %esp,%ebp
f0117be6:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117be9:	83 ec 04             	sub    $0x4,%esp
f0117bec:	68 bd 51 13 f0       	push   $0xf01351bd
f0117bf1:	68 59 04 00 00       	push   $0x459
f0117bf6:	68 a5 51 13 f0       	push   $0xf01351a5
f0117bfb:	e8 af 93 fe ff       	call   f0100faf <_panic>

f0117c00 <test_fast_NF>:
}
int test_fast_NF()
{
f0117c00:	55                   	push   %ebp
f0117c01:	89 e5                	mov    %esp,%ebp
f0117c03:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117c06:	83 ec 04             	sub    $0x4,%esp
f0117c09:	68 bd 51 13 f0       	push   $0xf01351bd
f0117c0e:	68 5d 04 00 00       	push   $0x45d
f0117c13:	68 a5 51 13 f0       	push   $0xf01351a5
f0117c18:	e8 92 93 fe ff       	call   f0100faf <_panic>

f0117c1d <test_fast_BF>:
}
int test_fast_BF()
{
f0117c1d:	55                   	push   %ebp
f0117c1e:	89 e5                	mov    %esp,%ebp
f0117c20:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117c23:	83 ec 04             	sub    $0x4,%esp
f0117c26:	68 bd 51 13 f0       	push   $0xf01351bd
f0117c2b:	68 61 04 00 00       	push   $0x461
f0117c30:	68 a5 51 13 f0       	push   $0xf01351a5
f0117c35:	e8 75 93 fe ff       	call   f0100faf <_panic>

f0117c3a <test_fast_WF>:
}
int test_fast_WF()
{
f0117c3a:	55                   	push   %ebp
f0117c3b:	89 e5                	mov    %esp,%ebp
f0117c3d:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117c40:	83 ec 04             	sub    $0x4,%esp
f0117c43:	68 bd 51 13 f0       	push   $0xf01351bd
f0117c48:	68 65 04 00 00       	push   $0x465
f0117c4d:	68 a5 51 13 f0       	push   $0xf01351a5
f0117c52:	e8 58 93 fe ff       	call   f0100faf <_panic>

f0117c57 <test_fast_CF>:
}
int test_fast_CF()
{
f0117c57:	55                   	push   %ebp
f0117c58:	89 e5                	mov    %esp,%ebp
f0117c5a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117c5d:	83 ec 04             	sub    $0x4,%esp
f0117c60:	68 bd 51 13 f0       	push   $0xf01351bd
f0117c65:	68 69 04 00 00       	push   $0x469
f0117c6a:	68 a5 51 13 f0       	push   $0xf01351a5
f0117c6f:	e8 3b 93 fe ff       	call   f0100faf <_panic>

f0117c74 <test_three_creation_functions>:

int initFreeFrames;
int initFreeDiskFrames ;
uint8 firstCall = 1 ;
int test_three_creation_functions()
{
f0117c74:	55                   	push   %ebp
f0117c75:	89 e5                	mov    %esp,%ebp
f0117c77:	57                   	push   %edi
f0117c78:	56                   	push   %esi
f0117c79:	53                   	push   %ebx
f0117c7a:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
	if (firstCall)
f0117c80:	a0 a8 01 18 f0       	mov    0xf01801a8,%al
f0117c85:	84 c0                	test   %al,%al
f0117c87:	74 56                	je     f0117cdf <test_three_creation_functions+0x6b>
	{
		firstCall = 0;
f0117c89:	c6 05 a8 01 18 f0 00 	movb   $0x0,0xf01801a8
		initFreeFrames = sys_calculate_free_frames() ;
f0117c90:	e8 13 6d ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0117c95:	a3 c8 d4 87 f0       	mov    %eax,0xf087d4c8
		initFreeDiskFrames = pf_calculate_free_frames() ;
f0117c9a:	e8 8a dc fe ff       	call   f0105929 <pf_calculate_free_frames>
f0117c9f:	a3 c4 d4 87 f0       	mov    %eax,0xf087d4c4
		//Run simple user program
		{
			char command[100] = "run fos_add 4096";
f0117ca4:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0117caa:	bb 95 53 13 f0       	mov    $0xf0135395,%ebx
f0117caf:	ba 11 00 00 00       	mov    $0x11,%edx
f0117cb4:	89 c7                	mov    %eax,%edi
f0117cb6:	89 de                	mov    %ebx,%esi
f0117cb8:	89 d1                	mov    %edx,%ecx
f0117cba:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
f0117cbc:	8d 95 7d ff ff ff    	lea    -0x83(%ebp),%edx
f0117cc2:	b9 53 00 00 00       	mov    $0x53,%ecx
f0117cc7:	b0 00                	mov    $0x0,%al
f0117cc9:	89 d7                	mov    %edx,%edi
f0117ccb:	f3 aa                	rep stos %al,%es:(%edi)
			execute_command(command) ;
f0117ccd:	83 ec 0c             	sub    $0xc,%esp
f0117cd0:	8d 85 6c ff ff ff    	lea    -0x94(%ebp),%eax
f0117cd6:	50                   	push   %eax
f0117cd7:	e8 3f a2 fe ff       	call   f0101f1b <execute_command>
f0117cdc:	83 c4 10             	add    $0x10,%esp
		}
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
f0117cdf:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
		struct Env * ptr_env = NULL;
f0117ce6:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0117ced:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f0117cf2:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117cf5:	eb 2b                	jmp    f0117d22 <test_three_creation_functions+0xae>
		{
			if (strcmp(ptr_env->prog_name, "fos_add") == 0)
f0117cf7:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117cfa:	83 c0 20             	add    $0x20,%eax
f0117cfd:	83 ec 08             	sub    $0x8,%esp
f0117d00:	68 d6 51 13 f0       	push   $0xf01351d6
f0117d05:	50                   	push   %eax
f0117d06:	e8 7c 2f 00 00       	call   f011ac87 <strcmp>
f0117d0b:	83 c4 10             	add    $0x10,%esp
f0117d0e:	85 c0                	test   %eax,%eax
f0117d10:	75 08                	jne    f0117d1a <test_three_creation_functions+0xa6>
			{
				e = ptr_env ;
f0117d12:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117d15:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				break;
f0117d18:	eb 2f                	jmp    f0117d49 <test_three_creation_functions+0xd5>
	}
	//Ensure that the user directory, page WS and page tables are allocated in KERNEL HEAP
	{
		struct Env * e = NULL;
		struct Env * ptr_env = NULL;
		LIST_FOREACH(ptr_env, &ProcessQueues.env_exit_queue)
f0117d1a:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0117d1f:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0117d22:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117d26:	74 08                	je     f0117d30 <test_three_creation_functions+0xbc>
f0117d28:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0117d2b:	8b 40 08             	mov    0x8(%eax),%eax
f0117d2e:	eb 05                	jmp    f0117d35 <test_three_creation_functions+0xc1>
f0117d30:	b8 00 00 00 00       	mov    $0x0,%eax
f0117d35:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f0117d3a:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f0117d3f:	85 c0                	test   %eax,%eax
f0117d41:	75 b4                	jne    f0117cf7 <test_three_creation_functions+0x83>
f0117d43:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0117d47:	75 ae                	jne    f0117cf7 <test_three_creation_functions+0x83>
			{
				e = ptr_env ;
				break;
			}
		}
		if (e->pageFaultsCounter != 0)
f0117d49:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117d4c:	8b 80 98 05 00 00    	mov    0x598(%eax),%eax
f0117d52:	85 c0                	test   %eax,%eax
f0117d54:	74 17                	je     f0117d6d <test_three_creation_functions+0xf9>
			panic("Page fault is occur while not expected to. Review the three creation functions");
f0117d56:	83 ec 04             	sub    $0x4,%esp
f0117d59:	68 e0 51 13 f0       	push   $0xf01351e0
f0117d5e:	68 90 04 00 00       	push   $0x490
f0117d63:	68 a5 51 13 f0       	push   $0xf01351a5
f0117d68:	e8 42 92 fe ff       	call   f0100faf <_panic>

#if USE_KHEAP
		int pagesInWS = LIST_SIZE(&(e->page_WS_list));
f0117d6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0117d70:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0117d76:	89 45 dc             	mov    %eax,-0x24(%ebp)
#else
		int pagesInWS = env_page_ws_get_size(e);
#endif
		int curFreeFrames = sys_calculate_free_frames() ;
f0117d79:	e8 2a 6c ff ff       	call   f010e9a8 <sys_calculate_free_frames>
f0117d7e:	89 45 d8             	mov    %eax,-0x28(%ebp)
		int curFreeDiskFrames = pf_calculate_free_frames() ;
f0117d81:	e8 a3 db fe ff       	call   f0105929 <pf_calculate_free_frames>
f0117d86:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		//cprintf("\ndiff in page file = %d, pages in WS = %d\n", initFreeDiskFrames - curFreeDiskFrames, pagesInWS);
		if ((initFreeDiskFrames - curFreeDiskFrames) != pagesInWS) panic("Page file is changed while it's not expected to. (pages are wrongly allocated/de-allocated in PageFile)");
f0117d89:	a1 c4 d4 87 f0       	mov    0xf087d4c4,%eax
f0117d8e:	2b 45 d4             	sub    -0x2c(%ebp),%eax
f0117d91:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f0117d94:	74 17                	je     f0117dad <test_three_creation_functions+0x139>
f0117d96:	83 ec 04             	sub    $0x4,%esp
f0117d99:	68 30 52 13 f0       	push   $0xf0135230
f0117d9e:	68 9a 04 00 00       	push   $0x49a
f0117da3:	68 a5 51 13 f0       	push   $0xf01351a5
f0117da8:	e8 02 92 fe ff       	call   f0100faf <_panic>
		//cprintf("\ndiff in mem frames = %d, pages in WS = %d\n", initFreeFrames - curFreeFrames, pagesInWS);
		if ((initFreeFrames - curFreeFrames) != 12/*WS*/ + 2*1/*DIR*/ + 2*3/*Tables*/ + 1 /*user WS table*/ + pagesInWS) panic("Wrong allocation: pages are not loaded successfully into memory");
f0117dad:	a1 c8 d4 87 f0       	mov    0xf087d4c8,%eax
f0117db2:	2b 45 d8             	sub    -0x28(%ebp),%eax
f0117db5:	8b 55 dc             	mov    -0x24(%ebp),%edx
f0117db8:	83 c2 15             	add    $0x15,%edx
f0117dbb:	39 d0                	cmp    %edx,%eax
f0117dbd:	74 17                	je     f0117dd6 <test_three_creation_functions+0x162>
f0117dbf:	83 ec 04             	sub    $0x4,%esp
f0117dc2:	68 98 52 13 f0       	push   $0xf0135298
f0117dc7:	68 9c 04 00 00       	push   $0x49c
f0117dcc:	68 a5 51 13 f0       	push   $0xf01351a5
f0117dd1:	e8 d9 91 fe ff       	call   f0100faf <_panic>

		//allocate 4 KB
		char *ptr = kmalloc(4*kilo);
f0117dd6:	83 ec 0c             	sub    $0xc,%esp
f0117dd9:	68 00 10 00 00       	push   $0x1000
f0117dde:	e8 53 1e ff ff       	call   f0109c36 <kmalloc>
f0117de3:	83 c4 10             	add    $0x10,%esp
f0117de6:	89 45 d0             	mov    %eax,-0x30(%ebp)
		if ((uint32) ptr !=  (ACTUAL_START + (12+2*1+2*3+1)*PAGE_SIZE)) panic("Wrong start address for the allocated space... make sure you create the dir, table and page WS in KERNEL HEAP");
f0117de9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0117dec:	3d 00 60 01 f8       	cmp    $0xf8016000,%eax
f0117df1:	74 17                	je     f0117e0a <test_three_creation_functions+0x196>
f0117df3:	83 ec 04             	sub    $0x4,%esp
f0117df6:	68 d8 52 13 f0       	push   $0xf01352d8
f0117dfb:	68 a0 04 00 00       	push   $0x4a0
f0117e00:	68 a5 51 13 f0       	push   $0xf01351a5
f0117e05:	e8 a5 91 fe ff       	call   f0100faf <_panic>
	}

	cprintf("\nCongratulations!! test the 3 creation functions is completed successfully.\n");
f0117e0a:	83 ec 0c             	sub    $0xc,%esp
f0117e0d:	68 48 53 13 f0       	push   $0xf0135348
f0117e12:	e8 45 9e fe ff       	call   f0101c5c <cprintf>
f0117e17:	83 c4 10             	add    $0x10,%esp

	return 1;
f0117e1a:	b8 01 00 00 00       	mov    $0x1,%eax
}
f0117e1f:	8d 65 f4             	lea    -0xc(%ebp),%esp
f0117e22:	5b                   	pop    %ebx
f0117e23:	5e                   	pop    %esi
f0117e24:	5f                   	pop    %edi
f0117e25:	5d                   	pop    %ebp
f0117e26:	c3                   	ret    

f0117e27 <test_kfreeall>:


extern void kfreeall() ;

int test_kfreeall()
{
f0117e27:	55                   	push   %ebp
f0117e28:	89 e5                	mov    %esp,%ebp
f0117e2a:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117e2d:	83 ec 04             	sub    $0x4,%esp
f0117e30:	68 bd 51 13 f0       	push   $0xf01351bd
f0117e35:	68 ae 04 00 00       	push   $0x4ae
f0117e3a:	68 a5 51 13 f0       	push   $0xf01351a5
f0117e3f:	e8 6b 91 fe ff       	call   f0100faf <_panic>

f0117e44 <test_kexpand>:


extern void kexpand(uint32 newSize) ;

int test_kexpand()
{
f0117e44:	55                   	push   %ebp
f0117e45:	89 e5                	mov    %esp,%ebp
f0117e47:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117e4a:	83 ec 04             	sub    $0x4,%esp
f0117e4d:	68 bd 51 13 f0       	push   $0xf01351bd
f0117e52:	68 b6 04 00 00       	push   $0x4b6
f0117e57:	68 a5 51 13 f0       	push   $0xf01351a5
f0117e5c:	e8 4e 91 fe ff       	call   f0100faf <_panic>

f0117e61 <test_kshrink>:
}

extern void kshrink(uint32 newSize) ;

int test_kshrink()
{
f0117e61:	55                   	push   %ebp
f0117e62:	89 e5                	mov    %esp,%ebp
f0117e64:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117e67:	83 ec 04             	sub    $0x4,%esp
f0117e6a:	68 bd 51 13 f0       	push   $0xf01351bd
f0117e6f:	68 bd 04 00 00       	push   $0x4bd
f0117e74:	68 a5 51 13 f0       	push   $0xf01351a5
f0117e79:	e8 31 91 fe ff       	call   f0100faf <_panic>

f0117e7e <test_kfreelast>:
}


int test_kfreelast()
{
f0117e7e:	55                   	push   %ebp
f0117e7f:	89 e5                	mov    %esp,%ebp
f0117e81:	83 ec 08             	sub    $0x8,%esp
	panic("not implemented function");
f0117e84:	83 ec 04             	sub    $0x4,%esp
f0117e87:	68 bd 51 13 f0       	push   $0xf01351bd
f0117e8c:	68 c3 04 00 00       	push   $0x4c3
f0117e91:	68 a5 51 13 f0       	push   $0xf01351a5
f0117e96:	e8 14 91 fe ff       	call   f0100faf <_panic>

f0117e9b <print_order>:
uint8 firstTimeTest = 1;
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
f0117e9b:	55                   	push   %ebp
f0117e9c:	89 e5                	mov    %esp,%ebp
f0117e9e:	83 ec 18             	sub    $0x18,%esp
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0117ea1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0117ea8:	e9 84 00 00 00       	jmp    f0117f31 <print_order+0x96>
	{
		cprintf("\t[%d]: ", i);
f0117ead:	83 ec 08             	sub    $0x8,%esp
f0117eb0:	ff 75 f4             	pushl  -0xc(%ebp)
f0117eb3:	68 00 54 13 f0       	push   $0xf0135400
f0117eb8:	e8 9f 9d fe ff       	call   f0101c5c <cprintf>
f0117ebd:	83 c4 10             	add    $0x10,%esp
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0117ec0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0117ec7:	eb 4c                	jmp    f0117f15 <print_order+0x7a>
		{
			if (prog_orders[i][j] == 0)
f0117ec9:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117ecc:	89 d0                	mov    %edx,%eax
f0117ece:	c1 e0 02             	shl    $0x2,%eax
f0117ed1:	01 d0                	add    %edx,%eax
f0117ed3:	c1 e0 03             	shl    $0x3,%eax
f0117ed6:	89 c2                	mov    %eax,%edx
f0117ed8:	8b 45 08             	mov    0x8(%ebp),%eax
f0117edb:	01 c2                	add    %eax,%edx
f0117edd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117ee0:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0117ee3:	85 c0                	test   %eax,%eax
f0117ee5:	74 36                	je     f0117f1d <print_order+0x82>
				break;
			cprintf("%d, ", prog_orders[i][j]);
f0117ee7:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0117eea:	89 d0                	mov    %edx,%eax
f0117eec:	c1 e0 02             	shl    $0x2,%eax
f0117eef:	01 d0                	add    %edx,%eax
f0117ef1:	c1 e0 03             	shl    $0x3,%eax
f0117ef4:	89 c2                	mov    %eax,%edx
f0117ef6:	8b 45 08             	mov    0x8(%ebp),%eax
f0117ef9:	01 c2                	add    %eax,%edx
f0117efb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117efe:	8b 04 82             	mov    (%edx,%eax,4),%eax
f0117f01:	83 ec 08             	sub    $0x8,%esp
f0117f04:	50                   	push   %eax
f0117f05:	68 08 54 13 f0       	push   $0xf0135408
f0117f0a:	e8 4d 9d fe ff       	call   f0101c5c <cprintf>
f0117f0f:	83 c4 10             	add    $0x10,%esp
void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
	{
		cprintf("\t[%d]: ", i);
		for (int j = 0; j < INSTANCES_NUMBER; j++)
f0117f12:	ff 45 f0             	incl   -0x10(%ebp)
f0117f15:	83 7d f0 09          	cmpl   $0x9,-0x10(%ebp)
f0117f19:	7e ae                	jle    f0117ec9 <print_order+0x2e>
f0117f1b:	eb 01                	jmp    f0117f1e <print_order+0x83>
		{
			if (prog_orders[i][j] == 0)
				break;
f0117f1d:	90                   	nop
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
f0117f1e:	83 ec 0c             	sub    $0xc,%esp
f0117f21:	68 0d 54 13 f0       	push   $0xf013540d
f0117f26:	e8 31 9d fe ff       	call   f0101c5c <cprintf>
f0117f2b:	83 c4 10             	add    $0x10,%esp
int prog_orders[TOTAL_TEST_VALUES+1][INSTANCES_NUMBER] = {0};
int env_count[TOTAL_TEST_VALUES] = {0};

void print_order(int prog_orders[][INSTANCES_NUMBER])
{
	for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0117f2e:	ff 45 f4             	incl   -0xc(%ebp)
f0117f31:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
f0117f35:	0f 8e 72 ff ff ff    	jle    f0117ead <print_order+0x12>
				break;
			cprintf("%d, ", prog_orders[i][j]);
		}
		cprintf("\n");
	}
}
f0117f3b:	90                   	nop
f0117f3c:	c9                   	leave  
f0117f3d:	c3                   	ret    

f0117f3e <find_in_range>:

int find_in_range(int env_id, int start, int count)
{
f0117f3e:	55                   	push   %ebp
f0117f3f:	89 e5                	mov    %esp,%ebp
f0117f41:	83 ec 28             	sub    $0x28,%esp
	int ret = -1;
f0117f44:	c7 45 f4 ff ff ff ff 	movl   $0xffffffff,-0xc(%ebp)
	acquire_kspinlock(&ProcessQueues.qlock);
f0117f4b:	83 ec 0c             	sub    $0xc,%esp
f0117f4e:	68 20 e7 83 f0       	push   $0xf083e720
f0117f53:	e8 23 7f ff ff       	call   f010fe7b <acquire_kspinlock>
f0117f58:	83 c4 10             	add    $0x10,%esp
	{
		struct Env *env = NULL;
f0117f5b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		int i = 0, end = start + count;
f0117f62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
f0117f69:	8b 55 0c             	mov    0xc(%ebp),%edx
f0117f6c:	8b 45 10             	mov    0x10(%ebp),%eax
f0117f6f:	01 d0                	add    %edx,%eax
f0117f71:	89 45 e8             	mov    %eax,-0x18(%ebp)

		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0117f74:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0117f79:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0117f7c:	a1 a4 e7 83 f0       	mov    0xf083e7a4,%eax
f0117f81:	89 45 f0             	mov    %eax,-0x10(%ebp)

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
f0117f84:	ff 75 e8             	pushl  -0x18(%ebp)
f0117f87:	ff 75 0c             	pushl  0xc(%ebp)
f0117f8a:	ff 75 08             	pushl  0x8(%ebp)
f0117f8d:	68 10 54 13 f0       	push   $0xf0135410
f0117f92:	e8 c5 9c fe ff       	call   f0101c5c <cprintf>
f0117f97:	83 c4 10             	add    $0x10,%esp
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0117f9a:	eb 34                	jmp    f0117fd0 <find_in_range+0x92>
			//LIST_FOREACH_R(env, &env_exit_queue)
		{
			if (i < start)
f0117f9c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117f9f:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0117fa2:	7d 05                	jge    f0117fa9 <find_in_range+0x6b>
			{
				i++;
f0117fa4:	ff 45 ec             	incl   -0x14(%ebp)
				continue;
f0117fa7:	eb 1e                	jmp    f0117fc7 <find_in_range+0x89>
			}
			if (i >= end)
f0117fa9:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0117faf:	7d 29                	jge    f0117fda <find_in_range+0x9c>
				//return -1;
				break;

			if (env_id == env->env_id)
f0117fb1:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117fb4:	8b 40 10             	mov    0x10(%eax),%eax
f0117fb7:	3b 45 08             	cmp    0x8(%ebp),%eax
f0117fba:	75 08                	jne    f0117fc4 <find_in_range+0x86>
			{
				ret = i;
f0117fbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fbf:	89 45 f4             	mov    %eax,-0xc(%ebp)
				break;
f0117fc2:	eb 17                	jmp    f0117fdb <find_in_range+0x9d>
			}
			i++;
f0117fc4:	ff 45 ec             	incl   -0x14(%ebp)
		//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
		int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
		env = LIST_LAST(&ProcessQueues.env_exit_queue);

		cprintf("searching for envID %d starting from %d till %d\n", env_id, start, end);
		for (; i < numOfExitEnvs; env = LIST_PREV(env))
f0117fc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0117fca:	8b 40 0c             	mov    0xc(%eax),%eax
f0117fcd:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0117fd0:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0117fd3:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0117fd6:	7c c4                	jl     f0117f9c <find_in_range+0x5e>
f0117fd8:	eb 01                	jmp    f0117fdb <find_in_range+0x9d>
				i++;
				continue;
			}
			if (i >= end)
				//return -1;
				break;
f0117fda:	90                   	nop
				break;
			}
			i++;
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0117fdb:	83 ec 0c             	sub    $0xc,%esp
f0117fde:	68 20 e7 83 f0       	push   $0xf083e720
f0117fe3:	e8 38 7f ff ff       	call   f010ff20 <release_kspinlock>
f0117fe8:	83 c4 10             	add    $0x10,%esp
	return ret;
f0117feb:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f0117fee:	c9                   	leave  
f0117fef:	c3                   	ret    

f0117ff0 <test_bsd_nice_0>:


void test_bsd_nice_0()
{
f0117ff0:	55                   	push   %ebp
f0117ff1:	89 e5                	mov    %esp,%ebp
f0117ff3:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0117ff6:	83 ec 04             	sub    $0x4,%esp
f0117ff9:	68 41 54 13 f0       	push   $0xf0135441
f0117ffe:	6a 49                	push   $0x49
f0118000:	68 51 54 13 f0       	push   $0xf0135451
f0118005:	e8 a5 8f fe ff       	call   f0100faf <_panic>

f011800a <test_bsd_nice_1>:
}


void test_bsd_nice_1()
{
f011800a:	55                   	push   %ebp
f011800b:	89 e5                	mov    %esp,%ebp
f011800d:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f0118010:	83 ec 04             	sub    $0x4,%esp
f0118013:	68 41 54 13 f0       	push   $0xf0135441
f0118018:	6a 4f                	push   $0x4f
f011801a:	68 51 54 13 f0       	push   $0xf0135451
f011801f:	e8 8b 8f fe ff       	call   f0100faf <_panic>

f0118024 <test_bsd_nice_2>:
}

void test_bsd_nice_2()
{
f0118024:	55                   	push   %ebp
f0118025:	89 e5                	mov    %esp,%ebp
f0118027:	83 ec 08             	sub    $0x8,%esp
	panic("Not Implemented");
f011802a:	83 ec 04             	sub    $0x4,%esp
f011802d:	68 41 54 13 f0       	push   $0xf0135441
f0118032:	6a 54                	push   $0x54
f0118034:	68 51 54 13 f0       	push   $0xf0135451
f0118039:	e8 71 8f fe ff       	call   f0100faf <_panic>

f011803e <test_priorityRR_0>:
}


void test_priorityRR_0()
{
f011803e:	55                   	push   %ebp
f011803f:	89 e5                	mov    %esp,%ebp
f0118041:	57                   	push   %edi
f0118042:	56                   	push   %esi
f0118043:	53                   	push   %ebx
f0118044:	83 ec 3c             	sub    $0x3c,%esp
	if (firstTimeTest)
f0118047:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f011804c:	84 c0                	test   %al,%al
f011804e:	0f 84 bd 01 00 00    	je     f0118211 <test_priorityRR_0+0x1d3>
	{
		firstTimeTest = 0;
f0118054:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		int priority_values[] = {0, 2, 4, 6, 8};
f011805b:	8d 45 b8             	lea    -0x48(%ebp),%eax
f011805e:	bb ac 55 13 f0       	mov    $0xf01355ac,%ebx
f0118063:	ba 05 00 00 00       	mov    $0x5,%edx
f0118068:	89 c7                	mov    %eax,%edi
f011806a:	89 de                	mov    %ebx,%esi
f011806c:	89 d1                	mov    %edx,%ecx
f011806e:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f0118070:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f0118077:	e9 66 01 00 00       	jmp    f01181e2 <test_priorityRR_0+0x1a4>
		{
			struct Env *env ;
			if (i == 4)
f011807c:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f0118080:	75 1b                	jne    f011809d <test_priorityRR_0+0x5f>
			{
				env = env_create("priRR_fib_small", 500, 0, 0);
f0118082:	6a 00                	push   $0x0
f0118084:	6a 00                	push   $0x0
f0118086:	68 f4 01 00 00       	push   $0x1f4
f011808b:	68 6d 54 13 f0       	push   $0xf013546d
f0118090:	e8 cc 2e ff ff       	call   f010af61 <env_create>
f0118095:	83 c4 10             	add    $0x10,%esp
f0118098:	89 45 e0             	mov    %eax,-0x20(%ebp)
f011809b:	eb 19                	jmp    f01180b6 <test_priorityRR_0+0x78>
			}
			else
			{
				env = env_create("priRR_fib", 500, 0, 0);
f011809d:	6a 00                	push   $0x0
f011809f:	6a 00                	push   $0x0
f01180a1:	68 f4 01 00 00       	push   $0x1f4
f01180a6:	68 7d 54 13 f0       	push   $0xf013547d
f01180ab:	e8 b1 2e ff ff       	call   f010af61 <env_create>
f01180b0:	83 c4 10             	add    $0x10,%esp
f01180b3:	89 45 e0             	mov    %eax,-0x20(%ebp)
			}
			int priority_index = i % TOTAL_TEST_VALUES;
f01180b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01180b9:	b9 05 00 00 00       	mov    $0x5,%ecx
f01180be:	99                   	cltd   
f01180bf:	f7 f9                	idiv   %ecx
f01180c1:	89 55 d0             	mov    %edx,-0x30(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f01180c4:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01180c7:	8b 54 85 b8          	mov    -0x48(%ebp,%eax,4),%edx
f01180cb:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01180ce:	8b 40 10             	mov    0x10(%eax),%eax
f01180d1:	83 ec 08             	sub    $0x8,%esp
f01180d4:	52                   	push   %edx
f01180d5:	50                   	push   %eax
f01180d6:	e8 83 f6 fe ff       	call   f010775e <env_set_priority>
f01180db:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f01180de:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f01180e2:	75 14                	jne    f01180f8 <test_priorityRR_0+0xba>
				panic("Loading programs failed\n");
f01180e4:	83 ec 04             	sub    $0x4,%esp
f01180e7:	68 87 54 13 f0       	push   $0xf0135487
f01180ec:	6a 6c                	push   $0x6c
f01180ee:	68 51 54 13 f0       	push   $0xf0135451
f01180f3:	e8 b7 8e fe ff       	call   f0100faf <_panic>
			if (env->page_WS_max_size != 500)
f01180f8:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01180fb:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118101:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118106:	74 14                	je     f011811c <test_priorityRR_0+0xde>
				panic("The program working set size is not correct\n");
f0118108:	83 ec 04             	sub    $0x4,%esp
f011810b:	68 a0 54 13 f0       	push   $0xf01354a0
f0118110:	6a 6e                	push   $0x6e
f0118112:	68 51 54 13 f0       	push   $0xf0135451
f0118117:	e8 93 8e fe ff       	call   f0100faf <_panic>

			switch (priority_values[priority_index])
f011811c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011811f:	8b 44 85 b8          	mov    -0x48(%ebp,%eax,4),%eax
f0118123:	83 f8 08             	cmp    $0x8,%eax
f0118126:	0f 87 a5 00 00 00    	ja     f01181d1 <test_priorityRR_0+0x193>
f011812c:	8b 04 85 c0 55 13 f0 	mov    -0xfecaa40(,%eax,4),%eax
f0118133:	ff e0                	jmp    *%eax
			{
			case 0:
				prog_orders[0][env_count[0]++] = env->env_id;
f0118135:	a1 10 e5 83 f0       	mov    0xf083e510,%eax
f011813a:	8d 50 01             	lea    0x1(%eax),%edx
f011813d:	89 15 10 e5 83 f0    	mov    %edx,0xf083e510
f0118143:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118146:	8b 52 10             	mov    0x10(%edx),%edx
f0118149:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f0118150:	eb 7f                	jmp    f01181d1 <test_priorityRR_0+0x193>
			case 2:
				prog_orders[1][env_count[1]++] = env->env_id;
f0118152:	a1 14 e5 83 f0       	mov    0xf083e514,%eax
f0118157:	8d 50 01             	lea    0x1(%eax),%edx
f011815a:	89 15 14 e5 83 f0    	mov    %edx,0xf083e514
f0118160:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118163:	8b 52 10             	mov    0x10(%edx),%edx
f0118166:	83 c0 0a             	add    $0xa,%eax
f0118169:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f0118170:	eb 5f                	jmp    f01181d1 <test_priorityRR_0+0x193>
			case 4:
				prog_orders[2][env_count[2]++] = env->env_id;
f0118172:	a1 18 e5 83 f0       	mov    0xf083e518,%eax
f0118177:	8d 50 01             	lea    0x1(%eax),%edx
f011817a:	89 15 18 e5 83 f0    	mov    %edx,0xf083e518
f0118180:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0118183:	8b 52 10             	mov    0x10(%edx),%edx
f0118186:	83 c0 14             	add    $0x14,%eax
f0118189:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f0118190:	eb 3f                	jmp    f01181d1 <test_priorityRR_0+0x193>
			case 6:
				prog_orders[3][env_count[3]++] = env->env_id;
f0118192:	a1 1c e5 83 f0       	mov    0xf083e51c,%eax
f0118197:	8d 50 01             	lea    0x1(%eax),%edx
f011819a:	89 15 1c e5 83 f0    	mov    %edx,0xf083e51c
f01181a0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01181a3:	8b 52 10             	mov    0x10(%edx),%edx
f01181a6:	83 c0 1e             	add    $0x1e,%eax
f01181a9:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01181b0:	eb 1f                	jmp    f01181d1 <test_priorityRR_0+0x193>
			case 8:
				prog_orders[4][env_count[4]++] = env->env_id;
f01181b2:	a1 20 e5 83 f0       	mov    0xf083e520,%eax
f01181b7:	8d 50 01             	lea    0x1(%eax),%edx
f01181ba:	89 15 20 e5 83 f0    	mov    %edx,0xf083e520
f01181c0:	8b 55 e0             	mov    -0x20(%ebp),%edx
f01181c3:	8b 52 10             	mov    0x10(%edx),%edx
f01181c6:	83 c0 28             	add    $0x28,%eax
f01181c9:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01181d0:	90                   	nop
			}
			sched_new_env(env);
f01181d1:	83 ec 0c             	sub    $0xc,%esp
f01181d4:	ff 75 e0             	pushl  -0x20(%ebp)
f01181d7:	e8 ad e5 fe ff       	call   f0106789 <sched_new_env>
f01181dc:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6, 8};
		for (int i = 0; i < INSTANCES_NUMBER/2; i++)
f01181df:	ff 45 e4             	incl   -0x1c(%ebp)
f01181e2:	83 7d e4 04          	cmpl   $0x4,-0x1c(%ebp)
f01181e6:	0f 8e 90 fe ff ff    	jle    f011807c <test_priorityRR_0+0x3e>
				break;
			}
			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01181ec:	83 ec 0c             	sub    $0xc,%esp
f01181ef:	68 d0 54 13 f0       	push   $0xf01354d0
f01181f4:	e8 63 9a fe ff       	call   f0101c5c <cprintf>
f01181f9:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01181fc:	83 ec 0c             	sub    $0xc,%esp
f01181ff:	68 1f 55 13 f0       	push   $0xf013551f
f0118204:	e8 12 9d fe ff       	call   f0101f1b <execute_command>
f0118209:	83 c4 10             	add    $0x10,%esp
f011820c:	e9 c3 00 00 00       	jmp    f01182d4 <test_priorityRR_0+0x296>
	}
	else
	{
		cprintf("> Checking...\n");
f0118211:	83 ec 0c             	sub    $0xc,%esp
f0118214:	68 26 55 13 f0       	push   $0xf0135526
f0118219:	e8 3e 9a fe ff       	call   f0101c5c <cprintf>
f011821e:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0118221:	e8 af ec fe ff       	call   f0106ed5 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0118226:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011822d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0118234:	e9 8a 00 00 00       	jmp    f01182c3 <test_priorityRR_0+0x285>
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0118239:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0118240:	eb 55                	jmp    f0118297 <test_priorityRR_0+0x259>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f0118242:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0118245:	8b 14 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%edx
f011824c:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f011824f:	89 c8                	mov    %ecx,%eax
f0118251:	c1 e0 02             	shl    $0x2,%eax
f0118254:	01 c8                	add    %ecx,%eax
f0118256:	01 c0                	add    %eax,%eax
f0118258:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
f011825b:	01 c8                	add    %ecx,%eax
f011825d:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f0118264:	83 ec 04             	sub    $0x4,%esp
f0118267:	52                   	push   %edx
f0118268:	ff 75 dc             	pushl  -0x24(%ebp)
f011826b:	50                   	push   %eax
f011826c:	e8 cd fc ff ff       	call   f0117f3e <find_in_range>
f0118271:	83 c4 10             	add    $0x10,%esp
f0118274:	89 45 cc             	mov    %eax,-0x34(%ebp)
				if (exist == -1)
f0118277:	83 7d cc ff          	cmpl   $0xffffffff,-0x34(%ebp)
f011827b:	75 17                	jne    f0118294 <test_priorityRR_0+0x256>
					panic("The programs' order of finishing is not correct\n");
f011827d:	83 ec 04             	sub    $0x4,%esp
f0118280:	68 38 55 13 f0       	push   $0xf0135538
f0118285:	68 94 00 00 00       	push   $0x94
f011828a:	68 51 54 13 f0       	push   $0xf0135451
f011828f:	e8 1b 8d fe ff       	call   f0100faf <_panic>
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			for (int j = 0; prog_orders[i][j] != 0; j++)
f0118294:	ff 45 d4             	incl   -0x2c(%ebp)
f0118297:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011829a:	89 d0                	mov    %edx,%eax
f011829c:	c1 e0 02             	shl    $0x2,%eax
f011829f:	01 d0                	add    %edx,%eax
f01182a1:	01 c0                	add    %eax,%eax
f01182a3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f01182a6:	01 d0                	add    %edx,%eax
f01182a8:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f01182af:	85 c0                	test   %eax,%eax
f01182b1:	75 8f                	jne    f0118242 <test_priorityRR_0+0x204>
			{
				int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += env_count[i];
f01182b3:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01182b6:	8b 04 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%eax
f01182bd:	01 45 dc             	add    %eax,-0x24(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f01182c0:	ff 45 d8             	incl   -0x28(%ebp)
f01182c3:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
f01182c7:	0f 8e 6c ff ff ff    	jle    f0118239 <test_priorityRR_0+0x1fb>
				if (exist == -1)
					panic("The programs' order of finishing is not correct\n");
			}
			start_idx += env_count[i];
		}
		firstTimeTest = 0;
f01182cd:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
	}
	cprintf("\nCongratulations!! test_priorityRR_0 completed successfully.\n");
f01182d4:	83 ec 0c             	sub    $0xc,%esp
f01182d7:	68 6c 55 13 f0       	push   $0xf013556c
f01182dc:	e8 7b 99 fe ff       	call   f0101c5c <cprintf>
f01182e1:	83 c4 10             	add    $0x10,%esp
}
f01182e4:	90                   	nop
f01182e5:	8d 65 f4             	lea    -0xc(%ebp),%esp
f01182e8:	5b                   	pop    %ebx
f01182e9:	5e                   	pop    %esi
f01182ea:	5f                   	pop    %edi
f01182eb:	5d                   	pop    %ebp
f01182ec:	c3                   	ret    

f01182ed <test_priorityRR_1>:

void test_priorityRR_1()
{
f01182ed:	55                   	push   %ebp
f01182ee:	89 e5                	mov    %esp,%ebp
f01182f0:	83 ec 28             	sub    $0x28,%esp
	if (firstTimeTest)
f01182f3:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f01182f8:	84 c0                	test   %al,%al
f01182fa:	0f 84 ad 01 00 00    	je     f01184ad <test_priorityRR_1+0x1c0>
	{
		rsttst();
f0118300:	e8 2e 07 00 00       	call   f0118a33 <rsttst>
		firstTimeTest = 0;
f0118305:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		struct Env *fibPri0Env = env_create("priRR_fib", 500, 0, 0);
f011830c:	6a 00                	push   $0x0
f011830e:	6a 00                	push   $0x0
f0118310:	68 f4 01 00 00       	push   $0x1f4
f0118315:	68 7d 54 13 f0       	push   $0xf013547d
f011831a:	e8 42 2c ff ff       	call   f010af61 <env_create>
f011831f:	83 c4 10             	add    $0x10,%esp
f0118322:	89 45 ec             	mov    %eax,-0x14(%ebp)
		struct Env *fibPri4Env = env_create("priRR_fib_pri4", 500, 0, 0);
f0118325:	6a 00                	push   $0x0
f0118327:	6a 00                	push   $0x0
f0118329:	68 f4 01 00 00       	push   $0x1f4
f011832e:	68 e4 55 13 f0       	push   $0xf01355e4
f0118333:	e8 29 2c ff ff       	call   f010af61 <env_create>
f0118338:	83 c4 10             	add    $0x10,%esp
f011833b:	89 45 e8             	mov    %eax,-0x18(%ebp)
		struct Env *fibPri8Env = env_create("priRR_fib_pri8", 500, 0, 0);
f011833e:	6a 00                	push   $0x0
f0118340:	6a 00                	push   $0x0
f0118342:	68 f4 01 00 00       	push   $0x1f4
f0118347:	68 f3 55 13 f0       	push   $0xf01355f3
f011834c:	e8 10 2c ff ff       	call   f010af61 <env_create>
f0118351:	83 c4 10             	add    $0x10,%esp
f0118354:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		struct Env *fibPri2ParentEnv = env_create("priRR_fib_create", 500, 0, 0);
f0118357:	6a 00                	push   $0x0
f0118359:	6a 00                	push   $0x0
f011835b:	68 f4 01 00 00       	push   $0x1f4
f0118360:	68 02 56 13 f0       	push   $0xf0135602
f0118365:	e8 f7 2b ff ff       	call   f010af61 <env_create>
f011836a:	83 c4 10             	add    $0x10,%esp
f011836d:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (fibPri0Env == NULL || fibPri4Env == NULL || fibPri8Env == NULL || fibPri2ParentEnv == NULL)
f0118370:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f0118374:	74 12                	je     f0118388 <test_priorityRR_1+0x9b>
f0118376:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f011837a:	74 0c                	je     f0118388 <test_priorityRR_1+0x9b>
f011837c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0118380:	74 06                	je     f0118388 <test_priorityRR_1+0x9b>
f0118382:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f0118386:	75 17                	jne    f011839f <test_priorityRR_1+0xb2>
			panic("Loading programs failed\n");
f0118388:	83 ec 04             	sub    $0x4,%esp
f011838b:	68 87 54 13 f0       	push   $0xf0135487
f0118390:	68 a8 00 00 00       	push   $0xa8
f0118395:	68 51 54 13 f0       	push   $0xf0135451
f011839a:	e8 10 8c fe ff       	call   f0100faf <_panic>
		if (fibPri0Env->page_WS_max_size != 500 || fibPri4Env->page_WS_max_size != 500 || fibPri8Env->page_WS_max_size != 500 || fibPri2ParentEnv->page_WS_max_size != 500)
f011839f:	8b 45 ec             	mov    -0x14(%ebp),%eax
f01183a2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01183a8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01183ad:	75 30                	jne    f01183df <test_priorityRR_1+0xf2>
f01183af:	8b 45 e8             	mov    -0x18(%ebp),%eax
f01183b2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01183b8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01183bd:	75 20                	jne    f01183df <test_priorityRR_1+0xf2>
f01183bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01183c2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01183c8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01183cd:	75 10                	jne    f01183df <test_priorityRR_1+0xf2>
f01183cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
f01183d2:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f01183d8:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f01183dd:	74 17                	je     f01183f6 <test_priorityRR_1+0x109>
			panic("The programs should be initially loaded with the given working set size.\n");
f01183df:	83 ec 04             	sub    $0x4,%esp
f01183e2:	68 14 56 13 f0       	push   $0xf0135614
f01183e7:	68 aa 00 00 00       	push   $0xaa
f01183ec:	68 51 54 13 f0       	push   $0xf0135451
f01183f1:	e8 b9 8b fe ff       	call   f0100faf <_panic>
		sched_new_env(fibPri8Env);
f01183f6:	83 ec 0c             	sub    $0xc,%esp
f01183f9:	ff 75 e4             	pushl  -0x1c(%ebp)
f01183fc:	e8 88 e3 fe ff       	call   f0106789 <sched_new_env>
f0118401:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri0Env);
f0118404:	83 ec 0c             	sub    $0xc,%esp
f0118407:	ff 75 ec             	pushl  -0x14(%ebp)
f011840a:	e8 7a e3 fe ff       	call   f0106789 <sched_new_env>
f011840f:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri4Env);
f0118412:	83 ec 0c             	sub    $0xc,%esp
f0118415:	ff 75 e8             	pushl  -0x18(%ebp)
f0118418:	e8 6c e3 fe ff       	call   f0106789 <sched_new_env>
f011841d:	83 c4 10             	add    $0x10,%esp
		sched_new_env(fibPri2ParentEnv);
f0118420:	83 ec 0c             	sub    $0xc,%esp
f0118423:	ff 75 e0             	pushl  -0x20(%ebp)
f0118426:	e8 5e e3 fe ff       	call   f0106789 <sched_new_env>
f011842b:	83 c4 10             	add    $0x10,%esp
		env_set_priority(fibPri2ParentEnv->env_id, 6);
f011842e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118431:	8b 40 10             	mov    0x10(%eax),%eax
f0118434:	83 ec 08             	sub    $0x8,%esp
f0118437:	6a 06                	push   $0x6
f0118439:	50                   	push   %eax
f011843a:	e8 1f f3 fe ff       	call   f010775e <env_set_priority>
f011843f:	83 c4 10             	add    $0x10,%esp

		prog_orders[0][0] = fibPri0Env->env_id;
f0118442:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0118445:	8b 40 10             	mov    0x10(%eax),%eax
f0118448:	a3 20 e4 83 f0       	mov    %eax,0xf083e420
		prog_orders[1][0] = fibPri4Env->env_id;
f011844d:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118450:	8b 40 10             	mov    0x10(%eax),%eax
f0118453:	a3 48 e4 83 f0       	mov    %eax,0xf083e448
		prog_orders[2][0] = fibPri2ParentEnv->env_id ; //id of the parent
f0118458:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011845b:	8b 40 10             	mov    0x10(%eax),%eax
f011845e:	a3 70 e4 83 f0       	mov    %eax,0xf083e470
		prog_orders[3][0] = fibPri2ParentEnv->env_id + 1; //id of the 1st created child fib
f0118463:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118466:	8b 40 10             	mov    0x10(%eax),%eax
f0118469:	40                   	inc    %eax
f011846a:	a3 98 e4 83 f0       	mov    %eax,0xf083e498
		prog_orders[4][0] = fibPri8Env->env_id;
f011846f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0118472:	8b 40 10             	mov    0x10(%eax),%eax
f0118475:	a3 c0 e4 83 f0       	mov    %eax,0xf083e4c0
		prog_orders[5][0] = fibPri2ParentEnv->env_id + 2; //id of the 2nd created child fib
f011847a:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011847d:	8b 40 10             	mov    0x10(%eax),%eax
f0118480:	83 c0 02             	add    $0x2,%eax
f0118483:	a3 e8 e4 83 f0       	mov    %eax,0xf083e4e8

		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f0118488:	83 ec 0c             	sub    $0xc,%esp
f011848b:	68 d0 54 13 f0       	push   $0xf01354d0
f0118490:	e8 c7 97 fe ff       	call   f0101c5c <cprintf>
f0118495:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f0118498:	83 ec 0c             	sub    $0xc,%esp
f011849b:	68 1f 55 13 f0       	push   $0xf013551f
f01184a0:	e8 76 9a fe ff       	call   f0101f1b <execute_command>
f01184a5:	83 c4 10             	add    $0x10,%esp
f01184a8:	e9 c0 00 00 00       	jmp    f011856d <test_priorityRR_1+0x280>
	}
	else
	{
		cprintf("> Checking...\n");
f01184ad:	83 ec 0c             	sub    $0xc,%esp
f01184b0:	68 26 55 13 f0       	push   $0xf0135526
f01184b5:	e8 a2 97 fe ff       	call   f0101c5c <cprintf>
f01184ba:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f01184bd:	e8 13 ea fe ff       	call   f0106ed5 <sched_print_all>
		// print_order(prog_orders);
		int i = 0;
f01184c2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		struct Env *env = NULL;
f01184c9:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
f01184d0:	83 ec 0c             	sub    $0xc,%esp
f01184d3:	68 20 e7 83 f0       	push   $0xf083e720
f01184d8:	e8 9e 79 ff ff       	call   f010fe7b <acquire_kspinlock>
f01184dd:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f01184e0:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f01184e5:	89 45 dc             	mov    %eax,-0x24(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f01184e8:	a1 a4 e7 83 f0       	mov    0xf083e7a4,%eax
f01184ed:	89 45 f0             	mov    %eax,-0x10(%ebp)
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f01184f0:	eb 63                	jmp    f0118555 <test_priorityRR_1+0x268>
				//LIST_FOREACH_R(env, &env_exit_queue)
			{
				cprintf("%s - id=%d, priority=%d\n", env->prog_name, env->env_id, env->priority);
f01184f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01184f5:	8b 50 1c             	mov    0x1c(%eax),%edx
f01184f8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f01184fb:	8b 40 10             	mov    0x10(%eax),%eax
f01184fe:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f0118501:	83 c1 20             	add    $0x20,%ecx
f0118504:	52                   	push   %edx
f0118505:	50                   	push   %eax
f0118506:	51                   	push   %ecx
f0118507:	68 5e 56 13 f0       	push   $0xf013565e
f011850c:	e8 4b 97 fe ff       	call   f0101c5c <cprintf>
f0118511:	83 c4 10             	add    $0x10,%esp
				if (prog_orders[i][0] != env->env_id)
f0118514:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118517:	89 d0                	mov    %edx,%eax
f0118519:	c1 e0 02             	shl    $0x2,%eax
f011851c:	01 d0                	add    %edx,%eax
f011851e:	c1 e0 03             	shl    $0x3,%eax
f0118521:	05 20 e4 83 f0       	add    $0xf083e420,%eax
f0118526:	8b 10                	mov    (%eax),%edx
f0118528:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011852b:	8b 40 10             	mov    0x10(%eax),%eax
f011852e:	39 c2                	cmp    %eax,%edx
f0118530:	74 17                	je     f0118549 <test_priorityRR_1+0x25c>
					panic("The programs' order of finishing is not correct\n");
f0118532:	83 ec 04             	sub    $0x4,%esp
f0118535:	68 38 55 13 f0       	push   $0xf0135538
f011853a:	68 cc 00 00 00       	push   $0xcc
f011853f:	68 51 54 13 f0       	push   $0xf0135451
f0118544:	e8 66 8a fe ff       	call   f0100faf <_panic>
				i++;
f0118549:	ff 45 f4             	incl   -0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (; i < numOfExitEnvs; env = LIST_PREV(env))
f011854c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011854f:	8b 40 0c             	mov    0xc(%eax),%eax
f0118552:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0118555:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118558:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f011855b:	7c 95                	jl     f01184f2 <test_priorityRR_1+0x205>
				if (prog_orders[i][0] != env->env_id)
					panic("The programs' order of finishing is not correct\n");
				i++;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f011855d:	83 ec 0c             	sub    $0xc,%esp
f0118560:	68 20 e7 83 f0       	push   $0xf083e720
f0118565:	e8 b6 79 ff ff       	call   f010ff20 <release_kspinlock>
f011856a:	83 c4 10             	add    $0x10,%esp
	}
	cprintf("\nCongratulations!! test_priorityRR_1 completed successfully.\n");
f011856d:	83 ec 0c             	sub    $0xc,%esp
f0118570:	68 78 56 13 f0       	push   $0xf0135678
f0118575:	e8 e2 96 fe ff       	call   f0101c5c <cprintf>
f011857a:	83 c4 10             	add    $0x10,%esp
}
f011857d:	90                   	nop
f011857e:	c9                   	leave  
f011857f:	c3                   	ret    

f0118580 <test_priorityRR_2>:

void test_priorityRR_2()
{
f0118580:	55                   	push   %ebp
f0118581:	89 e5                	mov    %esp,%ebp
f0118583:	57                   	push   %edi
f0118584:	56                   	push   %esi
f0118585:	53                   	push   %ebx
f0118586:	83 ec 6c             	sub    $0x6c,%esp
	if (firstTimeTest)
f0118589:	a0 a9 01 18 f0       	mov    0xf01801a9,%al
f011858e:	84 c0                	test   %al,%al
f0118590:	0f 84 6c 02 00 00    	je     f0118802 <test_priorityRR_2+0x282>
	{
		firstTimeTest = 0;
f0118596:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
		int priority_values[] = {0, 2, 4, 6};
f011859d:	8d 45 a8             	lea    -0x58(%ebp),%eax
f01185a0:	bb f8 56 13 f0       	mov    $0xf01356f8,%ebx
f01185a5:	ba 04 00 00 00       	mov    $0x4,%edx
f01185aa:	89 c7                	mov    %eax,%edi
f01185ac:	89 de                	mov    %ebx,%esi
f01185ae:	89 d1                	mov    %edx,%ecx
f01185b0:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01185b2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
f01185b9:	e9 41 01 00 00       	jmp    f01186ff <test_priorityRR_2+0x17f>
		{
			struct Env *env = env_create("priRR_fib", 500, 0, 0);
f01185be:	6a 00                	push   $0x0
f01185c0:	6a 00                	push   $0x0
f01185c2:	68 f4 01 00 00       	push   $0x1f4
f01185c7:	68 7d 54 13 f0       	push   $0xf013547d
f01185cc:	e8 90 29 ff ff       	call   f010af61 <env_create>
f01185d1:	83 c4 10             	add    $0x10,%esp
f01185d4:	89 45 cc             	mov    %eax,-0x34(%ebp)
			int priority_index = i % (TOTAL_TEST_VALUES-1);
f01185d7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01185da:	25 03 00 00 80       	and    $0x80000003,%eax
f01185df:	85 c0                	test   %eax,%eax
f01185e1:	79 05                	jns    f01185e8 <test_priorityRR_2+0x68>
f01185e3:	48                   	dec    %eax
f01185e4:	83 c8 fc             	or     $0xfffffffc,%eax
f01185e7:	40                   	inc    %eax
f01185e8:	89 45 c8             	mov    %eax,-0x38(%ebp)
			env_set_priority(env->env_id, priority_values[priority_index]);
f01185eb:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01185ee:	8b 54 85 a8          	mov    -0x58(%ebp,%eax,4),%edx
f01185f2:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01185f5:	8b 40 10             	mov    0x10(%eax),%eax
f01185f8:	83 ec 08             	sub    $0x8,%esp
f01185fb:	52                   	push   %edx
f01185fc:	50                   	push   %eax
f01185fd:	e8 5c f1 fe ff       	call   f010775e <env_set_priority>
f0118602:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0118605:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f0118609:	75 17                	jne    f0118622 <test_priorityRR_2+0xa2>
				panic("Loading programs failed\n");
f011860b:	83 ec 04             	sub    $0x4,%esp
f011860e:	68 87 54 13 f0       	push   $0xf0135487
f0118613:	68 e1 00 00 00       	push   $0xe1
f0118618:	68 51 54 13 f0       	push   $0xf0135451
f011861d:	e8 8d 89 fe ff       	call   f0100faf <_panic>
			if (env->page_WS_max_size != 500)
f0118622:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0118625:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f011862b:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f0118630:	74 17                	je     f0118649 <test_priorityRR_2+0xc9>
				panic("The program working set size is not correct\n");
f0118632:	83 ec 04             	sub    $0x4,%esp
f0118635:	68 a0 54 13 f0       	push   $0xf01354a0
f011863a:	68 e3 00 00 00       	push   $0xe3
f011863f:	68 51 54 13 f0       	push   $0xf0135451
f0118644:	e8 66 89 fe ff       	call   f0100faf <_panic>

			switch (priority_values[priority_index])
f0118649:	8b 45 c8             	mov    -0x38(%ebp),%eax
f011864c:	8b 44 85 a8          	mov    -0x58(%ebp,%eax,4),%eax
f0118650:	83 f8 02             	cmp    $0x2,%eax
f0118653:	74 3a                	je     f011868f <test_priorityRR_2+0x10f>
f0118655:	83 f8 02             	cmp    $0x2,%eax
f0118658:	7f 09                	jg     f0118663 <test_priorityRR_2+0xe3>
f011865a:	85 c0                	test   %eax,%eax
f011865c:	74 11                	je     f011866f <test_priorityRR_2+0xef>
f011865e:	e9 8b 00 00 00       	jmp    f01186ee <test_priorityRR_2+0x16e>
f0118663:	83 f8 04             	cmp    $0x4,%eax
f0118666:	74 47                	je     f01186af <test_priorityRR_2+0x12f>
f0118668:	83 f8 06             	cmp    $0x6,%eax
f011866b:	74 62                	je     f01186cf <test_priorityRR_2+0x14f>
f011866d:	eb 7f                	jmp    f01186ee <test_priorityRR_2+0x16e>
			{
			case 0:
				prog_orders[1][env_count[1]++] = env->env_id;
f011866f:	a1 14 e5 83 f0       	mov    0xf083e514,%eax
f0118674:	8d 50 01             	lea    0x1(%eax),%edx
f0118677:	89 15 14 e5 83 f0    	mov    %edx,0xf083e514
f011867d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f0118680:	8b 52 10             	mov    0x10(%edx),%edx
f0118683:	83 c0 0a             	add    $0xa,%eax
f0118686:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f011868d:	eb 5f                	jmp    f01186ee <test_priorityRR_2+0x16e>
			case 2:
				prog_orders[2][env_count[2]++] = env->env_id;
f011868f:	a1 18 e5 83 f0       	mov    0xf083e518,%eax
f0118694:	8d 50 01             	lea    0x1(%eax),%edx
f0118697:	89 15 18 e5 83 f0    	mov    %edx,0xf083e518
f011869d:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01186a0:	8b 52 10             	mov    0x10(%edx),%edx
f01186a3:	83 c0 14             	add    $0x14,%eax
f01186a6:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01186ad:	eb 3f                	jmp    f01186ee <test_priorityRR_2+0x16e>
			case 4:
				prog_orders[3][env_count[3]++] = env->env_id;
f01186af:	a1 1c e5 83 f0       	mov    0xf083e51c,%eax
f01186b4:	8d 50 01             	lea    0x1(%eax),%edx
f01186b7:	89 15 1c e5 83 f0    	mov    %edx,0xf083e51c
f01186bd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01186c0:	8b 52 10             	mov    0x10(%edx),%edx
f01186c3:	83 c0 1e             	add    $0x1e,%eax
f01186c6:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01186cd:	eb 1f                	jmp    f01186ee <test_priorityRR_2+0x16e>
			case 6:
				prog_orders[4][env_count[4]++] = env->env_id;
f01186cf:	a1 20 e5 83 f0       	mov    0xf083e520,%eax
f01186d4:	8d 50 01             	lea    0x1(%eax),%edx
f01186d7:	89 15 20 e5 83 f0    	mov    %edx,0xf083e520
f01186dd:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01186e0:	8b 52 10             	mov    0x10(%edx),%edx
f01186e3:	83 c0 28             	add    $0x28,%eax
f01186e6:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)
				break;
f01186ed:	90                   	nop
			}
			sched_new_env(env);
f01186ee:	83 ec 0c             	sub    $0xc,%esp
f01186f1:	ff 75 cc             	pushl  -0x34(%ebp)
f01186f4:	e8 90 e0 fe ff       	call   f0106789 <sched_new_env>
f01186f9:	83 c4 10             	add    $0x10,%esp
{
	if (firstTimeTest)
	{
		firstTimeTest = 0;
		int priority_values[] = {0, 2, 4, 6};
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01186fc:	ff 45 e4             	incl   -0x1c(%ebp)
f01186ff:	83 7d e4 07          	cmpl   $0x7,-0x1c(%ebp)
f0118703:	0f 8e b5 fe ff ff    	jle    f01185be <test_priorityRR_2+0x3e>
				break;
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
f0118709:	8d 45 88             	lea    -0x78(%ebp),%eax
f011870c:	bb 20 57 13 f0       	mov    $0xf0135720,%ebx
f0118711:	ba 08 00 00 00       	mov    $0x8,%edx
f0118716:	89 c7                	mov    %eax,%edi
f0118718:	89 de                	mov    %ebx,%esi
f011871a:	89 d1                	mov    %edx,%ecx
f011871c:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f011871e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
f0118725:	e9 a9 00 00 00       	jmp    f01187d3 <test_priorityRR_2+0x253>
		{
			struct Env *env = env_create("priRR_fib_small", 500, 0, 0);
f011872a:	6a 00                	push   $0x0
f011872c:	6a 00                	push   $0x0
f011872e:	68 f4 01 00 00       	push   $0x1f4
f0118733:	68 6d 54 13 f0       	push   $0xf013546d
f0118738:	e8 24 28 ff ff       	call   f010af61 <env_create>
f011873d:	83 c4 10             	add    $0x10,%esp
f0118740:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			int priority_index = i ;
f0118743:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118746:	89 45 c0             	mov    %eax,-0x40(%ebp)
			env_set_priority(env->env_id, priority_values2[priority_index]);
f0118749:	8b 45 c0             	mov    -0x40(%ebp),%eax
f011874c:	8b 54 85 88          	mov    -0x78(%ebp,%eax,4),%edx
f0118750:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118753:	8b 40 10             	mov    0x10(%eax),%eax
f0118756:	83 ec 08             	sub    $0x8,%esp
f0118759:	52                   	push   %edx
f011875a:	50                   	push   %eax
f011875b:	e8 fe ef fe ff       	call   f010775e <env_set_priority>
f0118760:	83 c4 10             	add    $0x10,%esp
			if (env == NULL)
f0118763:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
f0118767:	75 17                	jne    f0118780 <test_priorityRR_2+0x200>
				panic("Loading programs failed\n");
f0118769:	83 ec 04             	sub    $0x4,%esp
f011876c:	68 87 54 13 f0       	push   $0xf0135487
f0118771:	68 fe 00 00 00       	push   $0xfe
f0118776:	68 51 54 13 f0       	push   $0xf0135451
f011877b:	e8 2f 88 fe ff       	call   f0100faf <_panic>
			if (env->page_WS_max_size != 500)
f0118780:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0118783:	8b 80 84 00 00 00    	mov    0x84(%eax),%eax
f0118789:	3d f4 01 00 00       	cmp    $0x1f4,%eax
f011878e:	74 17                	je     f01187a7 <test_priorityRR_2+0x227>
				panic("The program working set size is not correct\n");
f0118790:	83 ec 04             	sub    $0x4,%esp
f0118793:	68 a0 54 13 f0       	push   $0xf01354a0
f0118798:	68 00 01 00 00       	push   $0x100
f011879d:	68 51 54 13 f0       	push   $0xf0135451
f01187a2:	e8 08 88 fe ff       	call   f0100faf <_panic>

			prog_orders[0][env_count[0]++] = env->env_id;
f01187a7:	a1 10 e5 83 f0       	mov    0xf083e510,%eax
f01187ac:	8d 50 01             	lea    0x1(%eax),%edx
f01187af:	89 15 10 e5 83 f0    	mov    %edx,0xf083e510
f01187b5:	8b 55 c4             	mov    -0x3c(%ebp),%edx
f01187b8:	8b 52 10             	mov    0x10(%edx),%edx
f01187bb:	89 14 85 20 e4 83 f0 	mov    %edx,-0xf7c1be0(,%eax,4)

			sched_new_env(env);
f01187c2:	83 ec 0c             	sub    $0xc,%esp
f01187c5:	ff 75 c4             	pushl  -0x3c(%ebp)
f01187c8:	e8 bc df fe ff       	call   f0106789 <sched_new_env>
f01187cd:	83 c4 10             	add    $0x10,%esp
			}
			sched_new_env(env);
		}

		int priority_values2[] = {0, 1, 2, 3, 4, 5, 6, 7 };
		for (int i = 0; i < INSTANCES_NUMBER - 2; i++)
f01187d0:	ff 45 e0             	incl   -0x20(%ebp)
f01187d3:	83 7d e0 07          	cmpl   $0x7,-0x20(%ebp)
f01187d7:	0f 8e 4d ff ff ff    	jle    f011872a <test_priorityRR_2+0x1aa>
			prog_orders[0][env_count[0]++] = env->env_id;

			sched_new_env(env);
		}
		// print_order(prog_orders);
		cprintf("> Running... (After all running programs finish, Run the same command again.)\n");
f01187dd:	83 ec 0c             	sub    $0xc,%esp
f01187e0:	68 d0 54 13 f0       	push   $0xf01354d0
f01187e5:	e8 72 94 fe ff       	call   f0101c5c <cprintf>
f01187ea:	83 c4 10             	add    $0x10,%esp
		execute_command("runall");
f01187ed:	83 ec 0c             	sub    $0xc,%esp
f01187f0:	68 1f 55 13 f0       	push   $0xf013551f
f01187f5:	e8 21 97 fe ff       	call   f0101f1b <execute_command>
f01187fa:	83 c4 10             	add    $0x10,%esp
f01187fd:	e9 36 01 00 00       	jmp    f0118938 <test_priorityRR_2+0x3b8>
	}
	else
	{
		cprintf("> Checking...\n");
f0118802:	83 ec 0c             	sub    $0xc,%esp
f0118805:	68 26 55 13 f0       	push   $0xf0135526
f011880a:	e8 4d 94 fe ff       	call   f0101c5c <cprintf>
f011880f:	83 c4 10             	add    $0x10,%esp
		sched_print_all();
f0118812:	e8 be e6 fe ff       	call   f0106ed5 <sched_print_all>
		// print_order(prog_orders);
		int start_idx = 0;
f0118817:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f011881e:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
f0118825:	e9 fd 00 00 00       	jmp    f0118927 <test_priorityRR_2+0x3a7>
		{
			if (i == 0) //small programs should finish in their strict order
f011882a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011882e:	75 6d                	jne    f011889d <test_priorityRR_2+0x31d>
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f0118830:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
f0118837:	eb 4c                	jmp    f0118885 <test_priorityRR_2+0x305>
				{
					int exist = find_in_range(prog_orders[i][j], j, 1);
f0118839:	8b 55 d8             	mov    -0x28(%ebp),%edx
f011883c:	89 d0                	mov    %edx,%eax
f011883e:	c1 e0 02             	shl    $0x2,%eax
f0118841:	01 d0                	add    %edx,%eax
f0118843:	01 c0                	add    %eax,%eax
f0118845:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f0118848:	01 d0                	add    %edx,%eax
f011884a:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f0118851:	83 ec 04             	sub    $0x4,%esp
f0118854:	6a 01                	push   $0x1
f0118856:	ff 75 d4             	pushl  -0x2c(%ebp)
f0118859:	50                   	push   %eax
f011885a:	e8 df f6 ff ff       	call   f0117f3e <find_in_range>
f011885f:	83 c4 10             	add    $0x10,%esp
f0118862:	89 45 bc             	mov    %eax,-0x44(%ebp)
					if (exist == -1)
f0118865:	83 7d bc ff          	cmpl   $0xffffffff,-0x44(%ebp)
f0118869:	75 17                	jne    f0118882 <test_priorityRR_2+0x302>
						panic("The programs' order of finishing is not correct\n");
f011886b:	83 ec 04             	sub    $0x4,%esp
f011886e:	68 38 55 13 f0       	push   $0xf0135538
f0118873:	68 18 01 00 00       	push   $0x118
f0118878:	68 51 54 13 f0       	push   $0xf0135451
f011887d:	e8 2d 87 fe ff       	call   f0100faf <_panic>
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
		{
			if (i == 0) //small programs should finish in their strict order
			{
				for (int j = 0; j < INSTANCES_NUMBER - 2; j++)
f0118882:	ff 45 d4             	incl   -0x2c(%ebp)
f0118885:	83 7d d4 07          	cmpl   $0x7,-0x2c(%ebp)
f0118889:	7e ae                	jle    f0118839 <test_priorityRR_2+0x2b9>
				{
					int exist = find_in_range(prog_orders[i][j], j, 1);
					if (exist == -1)
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
f011888b:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011888e:	8b 04 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%eax
f0118895:	01 45 dc             	add    %eax,-0x24(%ebp)
f0118898:	e9 87 00 00 00       	jmp    f0118924 <test_priorityRR_2+0x3a4>
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f011889d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
f01188a4:	eb 55                	jmp    f01188fb <test_priorityRR_2+0x37b>
				{
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
f01188a6:	8b 45 d8             	mov    -0x28(%ebp),%eax
f01188a9:	8b 14 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%edx
f01188b0:	8b 4d d8             	mov    -0x28(%ebp),%ecx
f01188b3:	89 c8                	mov    %ecx,%eax
f01188b5:	c1 e0 02             	shl    $0x2,%eax
f01188b8:	01 c8                	add    %ecx,%eax
f01188ba:	01 c0                	add    %eax,%eax
f01188bc:	8b 4d d0             	mov    -0x30(%ebp),%ecx
f01188bf:	01 c8                	add    %ecx,%eax
f01188c1:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f01188c8:	83 ec 04             	sub    $0x4,%esp
f01188cb:	52                   	push   %edx
f01188cc:	ff 75 dc             	pushl  -0x24(%ebp)
f01188cf:	50                   	push   %eax
f01188d0:	e8 69 f6 ff ff       	call   f0117f3e <find_in_range>
f01188d5:	83 c4 10             	add    $0x10,%esp
f01188d8:	89 45 b8             	mov    %eax,-0x48(%ebp)
					if (exist == -1)
f01188db:	83 7d b8 ff          	cmpl   $0xffffffff,-0x48(%ebp)
f01188df:	75 17                	jne    f01188f8 <test_priorityRR_2+0x378>
						panic("The programs' order of finishing is not correct\n");
f01188e1:	83 ec 04             	sub    $0x4,%esp
f01188e4:	68 38 55 13 f0       	push   $0xf0135538
f01188e9:	68 22 01 00 00       	push   $0x122
f01188ee:	68 51 54 13 f0       	push   $0xf0135451
f01188f3:	e8 b7 86 fe ff       	call   f0100faf <_panic>
				}
				start_idx += env_count[i];
			}
			else
			{
				for (int j = 0; prog_orders[i][j] != 0; j++)
f01188f8:	ff 45 d0             	incl   -0x30(%ebp)
f01188fb:	8b 55 d8             	mov    -0x28(%ebp),%edx
f01188fe:	89 d0                	mov    %edx,%eax
f0118900:	c1 e0 02             	shl    $0x2,%eax
f0118903:	01 d0                	add    %edx,%eax
f0118905:	01 c0                	add    %eax,%eax
f0118907:	8b 55 d0             	mov    -0x30(%ebp),%edx
f011890a:	01 d0                	add    %edx,%eax
f011890c:	8b 04 85 20 e4 83 f0 	mov    -0xf7c1be0(,%eax,4),%eax
f0118913:	85 c0                	test   %eax,%eax
f0118915:	75 8f                	jne    f01188a6 <test_priorityRR_2+0x326>
				{
					int exist = find_in_range(prog_orders[i][j], start_idx, env_count[i]);
					if (exist == -1)
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
f0118917:	8b 45 d8             	mov    -0x28(%ebp),%eax
f011891a:	8b 04 85 10 e5 83 f0 	mov    -0xf7c1af0(,%eax,4),%eax
f0118921:	01 45 dc             	add    %eax,-0x24(%ebp)
	{
		cprintf("> Checking...\n");
		sched_print_all();
		// print_order(prog_orders);
		int start_idx = 0;
		for (int i = 0; i < TOTAL_TEST_VALUES; i++)
f0118924:	ff 45 d8             	incl   -0x28(%ebp)
f0118927:	83 7d d8 04          	cmpl   $0x4,-0x28(%ebp)
f011892b:	0f 8e f9 fe ff ff    	jle    f011882a <test_priorityRR_2+0x2aa>
						panic("The programs' order of finishing is not correct\n");
				}
				start_idx += env_count[i];
			}
		}
		firstTimeTest = 0;
f0118931:	c6 05 a9 01 18 f0 00 	movb   $0x0,0xf01801a9
	}
	cprintf("\nCongratulations!! test_priorityRR_2 completed successfully.\n");
f0118938:	83 ec 0c             	sub    $0xc,%esp
f011893b:	68 b8 56 13 f0       	push   $0xf01356b8
f0118940:	e8 17 93 fe ff       	call   f0101c5c <cprintf>
f0118945:	83 c4 10             	add    $0x10,%esp
}
f0118948:	90                   	nop
f0118949:	8d 65 f4             	lea    -0xc(%ebp),%esp
f011894c:	5b                   	pop    %ebx
f011894d:	5e                   	pop    %esi
f011894e:	5f                   	pop    %edi
f011894f:	5d                   	pop    %ebp
f0118950:	c3                   	ret    

f0118951 <__mk_fix>:
fixed_point_t;

/* Returns a fixed-point number with F as its internal value. */
static inline fixed_point_t
__mk_fix (int f)
{
f0118951:	55                   	push   %ebp
f0118952:	89 e5                	mov    %esp,%ebp
f0118954:	83 ec 10             	sub    $0x10,%esp
  fixed_point_t x;
  x.f = f;
f0118957:	8b 45 0c             	mov    0xc(%ebp),%eax
f011895a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return x;
f011895d:	8b 45 08             	mov    0x8(%ebp),%eax
f0118960:	8b 55 fc             	mov    -0x4(%ebp),%edx
f0118963:	89 10                	mov    %edx,(%eax)
}
f0118965:	8b 45 08             	mov    0x8(%ebp),%eax
f0118968:	c9                   	leave  
f0118969:	c2 04 00             	ret    $0x4

f011896c <fix_round>:
}

/* Returns X rounded to the nearest integer. */
static inline int
fix_round (fixed_point_t x)
{
f011896c:	55                   	push   %ebp
f011896d:	89 e5                	mov    %esp,%ebp
	if (x.f >= 0)
f011896f:	8b 45 08             	mov    0x8(%ebp),%eax
f0118972:	85 c0                	test   %eax,%eax
f0118974:	78 16                	js     f011898c <fix_round+0x20>
		return (x.f + FIX_F / 2) / FIX_F;
f0118976:	8b 45 08             	mov    0x8(%ebp),%eax
f0118979:	05 00 20 00 00       	add    $0x2000,%eax
f011897e:	85 c0                	test   %eax,%eax
f0118980:	79 05                	jns    f0118987 <fix_round+0x1b>
f0118982:	05 ff 3f 00 00       	add    $0x3fff,%eax
f0118987:	c1 f8 0e             	sar    $0xe,%eax
f011898a:	eb 14                	jmp    f01189a0 <fix_round+0x34>
	else
		return (x.f - FIX_F / 2) / FIX_F;
f011898c:	8b 45 08             	mov    0x8(%ebp),%eax
f011898f:	2d 00 20 00 00       	sub    $0x2000,%eax
f0118994:	85 c0                	test   %eax,%eax
f0118996:	79 05                	jns    f011899d <fix_round+0x31>
f0118998:	05 ff 3f 00 00       	add    $0x3fff,%eax
f011899d:	c1 f8 0e             	sar    $0xe,%eax
}
f01189a0:	5d                   	pop    %ebp
f01189a1:	c3                   	ret    

f01189a2 <fix_scale>:
}

/* Returns X * N. */
static inline fixed_point_t
fix_scale (fixed_point_t x, int n)
{
f01189a2:	55                   	push   %ebp
f01189a3:	89 e5                	mov    %esp,%ebp
f01189a5:	83 ec 08             	sub    $0x8,%esp
	assert (n >= 0);
f01189a8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f01189ac:	79 16                	jns    f01189c4 <fix_scale+0x22>
f01189ae:	68 40 57 13 f0       	push   $0xf0135740
f01189b3:	68 47 57 13 f0       	push   $0xf0135747
f01189b8:	6a 5a                	push   $0x5a
f01189ba:	68 5c 57 13 f0       	push   $0xf013575c
f01189bf:	e8 eb 85 fe ff       	call   f0100faf <_panic>
  return __mk_fix (x.f * n);
f01189c4:	8b 45 0c             	mov    0xc(%ebp),%eax
f01189c7:	0f af 45 10          	imul   0x10(%ebp),%eax
f01189cb:	89 c2                	mov    %eax,%edx
f01189cd:	8b 45 08             	mov    0x8(%ebp),%eax
f01189d0:	83 ec 08             	sub    $0x8,%esp
f01189d3:	52                   	push   %edx
f01189d4:	50                   	push   %eax
f01189d5:	e8 77 ff ff ff       	call   f0118951 <__mk_fix>
f01189da:	83 c4 0c             	add    $0xc,%esp
}
f01189dd:	8b 45 08             	mov    0x8(%ebp),%eax
f01189e0:	c9                   	leave  
f01189e1:	c2 04 00             	ret    $0x4

f01189e4 <to_frame_number>:
struct FrameInfo *get_frame_info(uint32 *ptr_page_directory, uint32 virtual_address, uint32 **ptr_page_table);
void decrement_references(struct FrameInfo* ptr_frame_info);
void initialize_frame_info(struct FrameInfo *ptr_frame_info);

static inline uint32 to_frame_number(struct FrameInfo *ptr_frame_info)
{
f01189e4:	55                   	push   %ebp
f01189e5:	89 e5                	mov    %esp,%ebp
	return ptr_frame_info - frames_info;
f01189e7:	8b 45 08             	mov    0x8(%ebp),%eax
f01189ea:	8b 15 08 6b 85 f0    	mov    0xf0856b08,%edx
f01189f0:	29 d0                	sub    %edx,%eax
f01189f2:	c1 f8 02             	sar    $0x2,%eax
f01189f5:	89 c2                	mov    %eax,%edx
f01189f7:	89 d0                	mov    %edx,%eax
f01189f9:	c1 e0 02             	shl    $0x2,%eax
f01189fc:	01 d0                	add    %edx,%eax
f01189fe:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
f0118a05:	01 c8                	add    %ecx,%eax
f0118a07:	01 c0                	add    %eax,%eax
f0118a09:	01 d0                	add    %edx,%eax
f0118a0b:	89 c1                	mov    %eax,%ecx
f0118a0d:	c1 e1 08             	shl    $0x8,%ecx
f0118a10:	01 c8                	add    %ecx,%eax
f0118a12:	89 c1                	mov    %eax,%ecx
f0118a14:	c1 e1 10             	shl    $0x10,%ecx
f0118a17:	01 c8                	add    %ecx,%eax
f0118a19:	c1 e0 02             	shl    $0x2,%eax
f0118a1c:	01 d0                	add    %edx,%eax
}
f0118a1e:	5d                   	pop    %ebp
f0118a1f:	c3                   	ret    

f0118a20 <to_physical_address>:

static inline uint32 to_physical_address(struct FrameInfo *ptr_frame_info)
{
f0118a20:	55                   	push   %ebp
f0118a21:	89 e5                	mov    %esp,%ebp
	return to_frame_number(ptr_frame_info) << PGSHIFT;
f0118a23:	ff 75 08             	pushl  0x8(%ebp)
f0118a26:	e8 b9 ff ff ff       	call   f01189e4 <to_frame_number>
f0118a2b:	83 c4 04             	add    $0x4,%esp
f0118a2e:	c1 e0 0c             	shl    $0xc,%eax
}
f0118a31:	c9                   	leave  
f0118a32:	c3                   	ret    

f0118a33 <rsttst>:
#include "../cons/console.h"

#include <kern/trap/fault_handler.h>

void rsttst()
{
f0118a33:	55                   	push   %ebp
f0118a34:	89 e5                	mov    %esp,%ebp
f0118a36:	83 ec 08             	sub    $0x8,%esp
	init_kspinlock(&tstcntlock, "tstcnt lock");
f0118a39:	83 ec 08             	sub    $0x8,%esp
f0118a3c:	68 70 57 13 f0       	push   $0xf0135770
f0118a41:	68 00 6e 85 f0       	push   $0xf0856e00
f0118a46:	e8 ff 73 ff ff       	call   f010fe4a <init_kspinlock>
f0118a4b:	83 c4 10             	add    $0x10,%esp
	acquire_kspinlock(&tstcntlock);
f0118a4e:	83 ec 0c             	sub    $0xc,%esp
f0118a51:	68 00 6e 85 f0       	push   $0xf0856e00
f0118a56:	e8 20 74 ff ff       	call   f010fe7b <acquire_kspinlock>
f0118a5b:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt = 0;
f0118a5e:	c7 05 68 e6 83 f0 00 	movl   $0x0,0xf083e668
f0118a65:	00 00 00 
	}
	release_kspinlock(&tstcntlock);
f0118a68:	83 ec 0c             	sub    $0xc,%esp
f0118a6b:	68 00 6e 85 f0       	push   $0xf0856e00
f0118a70:	e8 ab 74 ff ff       	call   f010ff20 <release_kspinlock>
f0118a75:	83 c4 10             	add    $0x10,%esp
}
f0118a78:	90                   	nop
f0118a79:	c9                   	leave  
f0118a7a:	c3                   	ret    

f0118a7b <inctst>:
void inctst()
{
f0118a7b:	55                   	push   %ebp
f0118a7c:	89 e5                	mov    %esp,%ebp
f0118a7e:	83 ec 08             	sub    $0x8,%esp
	acquire_kspinlock(&tstcntlock);
f0118a81:	83 ec 0c             	sub    $0xc,%esp
f0118a84:	68 00 6e 85 f0       	push   $0xf0856e00
f0118a89:	e8 ed 73 ff ff       	call   f010fe7b <acquire_kspinlock>
f0118a8e:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++;
f0118a91:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
f0118a96:	40                   	inc    %eax
f0118a97:	a3 68 e6 83 f0       	mov    %eax,0xf083e668
	}
	release_kspinlock(&tstcntlock);
f0118a9c:	83 ec 0c             	sub    $0xc,%esp
f0118a9f:	68 00 6e 85 f0       	push   $0xf0856e00
f0118aa4:	e8 77 74 ff ff       	call   f010ff20 <release_kspinlock>
f0118aa9:	83 c4 10             	add    $0x10,%esp
}
f0118aac:	90                   	nop
f0118aad:	c9                   	leave  
f0118aae:	c3                   	ret    

f0118aaf <gettst>:
uint32 gettst()
{
f0118aaf:	55                   	push   %ebp
f0118ab0:	89 e5                	mov    %esp,%ebp
	return tstcnt;
f0118ab2:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
}
f0118ab7:	5d                   	pop    %ebp
f0118ab8:	c3                   	ret    

f0118ab9 <tst>:

void tst(uint32 n, uint32 v1, uint32 v2, char c, int inv)
{
f0118ab9:	55                   	push   %ebp
f0118aba:	89 e5                	mov    %esp,%ebp
f0118abc:	83 ec 28             	sub    $0x28,%esp
f0118abf:	8b 45 14             	mov    0x14(%ebp),%eax
f0118ac2:	88 45 e4             	mov    %al,-0x1c(%ebp)
	int chk = 0;
f0118ac5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	switch (c)
f0118acc:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax
f0118ad0:	83 f8 65             	cmp    $0x65,%eax
f0118ad3:	74 5d                	je     f0118b32 <tst+0x79>
f0118ad5:	83 f8 65             	cmp    $0x65,%eax
f0118ad8:	7f 0a                	jg     f0118ae4 <tst+0x2b>
f0118ada:	83 f8 62             	cmp    $0x62,%eax
f0118add:	74 73                	je     f0118b52 <tst+0x99>
f0118adf:	e9 91 00 00 00       	jmp    f0118b75 <tst+0xbc>
f0118ae4:	83 f8 67             	cmp    $0x67,%eax
f0118ae7:	74 29                	je     f0118b12 <tst+0x59>
f0118ae9:	83 f8 6c             	cmp    $0x6c,%eax
f0118aec:	0f 85 83 00 00 00    	jne    f0118b75 <tst+0xbc>
	{
	case 'l':
		if (n < v1)
f0118af2:	8b 45 08             	mov    0x8(%ebp),%eax
f0118af5:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118af8:	73 09                	jae    f0118b03 <tst+0x4a>
			chk = 1;
f0118afa:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118b01:	eb 68                	jmp    f0118b6b <tst+0xb2>
	switch (c)
	{
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
f0118b03:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118b07:	74 62                	je     f0118b6b <tst+0xb2>
			chk = 1;
f0118b09:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118b10:	eb 59                	jmp    f0118b6b <tst+0xb2>
	case 'g':
		if (n > v1)
f0118b12:	8b 45 08             	mov    0x8(%ebp),%eax
f0118b15:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118b18:	76 09                	jbe    f0118b23 <tst+0x6a>
			chk = 1;
f0118b1a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118b21:	eb 4b                	jmp    f0118b6e <tst+0xb5>
			chk = 1;
		break;
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
f0118b23:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118b27:	74 45                	je     f0118b6e <tst+0xb5>
			chk = 1;
f0118b29:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118b30:	eb 3c                	jmp    f0118b6e <tst+0xb5>
	case 'e':
		if (n == v1)
f0118b32:	8b 45 08             	mov    0x8(%ebp),%eax
f0118b35:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118b38:	75 09                	jne    f0118b43 <tst+0x8a>
			chk = 1;
f0118b3a:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		else if (inv)
			chk = 1;
		break;
f0118b41:	eb 2e                	jmp    f0118b71 <tst+0xb8>
			chk = 1;
		break;
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
f0118b43:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
f0118b47:	74 28                	je     f0118b71 <tst+0xb8>
			chk = 1;
f0118b49:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118b50:	eb 1f                	jmp    f0118b71 <tst+0xb8>
	case 'b':
		if (n >= v1 && n <= v2)
f0118b52:	8b 45 08             	mov    0x8(%ebp),%eax
f0118b55:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118b58:	72 1a                	jb     f0118b74 <tst+0xbb>
f0118b5a:	8b 45 08             	mov    0x8(%ebp),%eax
f0118b5d:	3b 45 10             	cmp    0x10(%ebp),%eax
f0118b60:	77 12                	ja     f0118b74 <tst+0xbb>
			chk = 1;
f0118b62:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
		break;
f0118b69:	eb 09                	jmp    f0118b74 <tst+0xbb>
	case 'l':
		if (n < v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118b6b:	90                   	nop
f0118b6c:	eb 07                	jmp    f0118b75 <tst+0xbc>
	case 'g':
		if (n > v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118b6e:	90                   	nop
f0118b6f:	eb 04                	jmp    f0118b75 <tst+0xbc>
	case 'e':
		if (n == v1)
			chk = 1;
		else if (inv)
			chk = 1;
		break;
f0118b71:	90                   	nop
f0118b72:	eb 01                	jmp    f0118b75 <tst+0xbc>
	case 'b':
		if (n >= v1 && n <= v2)
			chk = 1;
		break;
f0118b74:	90                   	nop
	}

	if (chk == 0) panic("Error!! test fails");
f0118b75:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0118b79:	75 14                	jne    f0118b8f <tst+0xd6>
f0118b7b:	83 ec 04             	sub    $0x4,%esp
f0118b7e:	68 7c 57 13 f0       	push   $0xf013577c
f0118b83:	6a 49                	push   $0x49
f0118b85:	68 8f 57 13 f0       	push   $0xf013578f
f0118b8a:	e8 20 84 fe ff       	call   f0100faf <_panic>

	acquire_kspinlock(&tstcntlock);
f0118b8f:	83 ec 0c             	sub    $0xc,%esp
f0118b92:	68 00 6e 85 f0       	push   $0xf0856e00
f0118b97:	e8 df 72 ff ff       	call   f010fe7b <acquire_kspinlock>
f0118b9c:	83 c4 10             	add    $0x10,%esp
	{
		tstcnt++ ;
f0118b9f:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
f0118ba4:	40                   	inc    %eax
f0118ba5:	a3 68 e6 83 f0       	mov    %eax,0xf083e668
	}
	release_kspinlock(&tstcntlock);
f0118baa:	83 ec 0c             	sub    $0xc,%esp
f0118bad:	68 00 6e 85 f0       	push   $0xf0856e00
f0118bb2:	e8 69 73 ff ff       	call   f010ff20 <release_kspinlock>
f0118bb7:	83 c4 10             	add    $0x10,%esp

	return;
f0118bba:	90                   	nop
}
f0118bbb:	c9                   	leave  
f0118bbc:	c3                   	ret    

f0118bbd <chktst>:

void chktst(uint32 n)
{
f0118bbd:	55                   	push   %ebp
f0118bbe:	89 e5                	mov    %esp,%ebp
f0118bc0:	83 ec 18             	sub    $0x18,%esp
	int __tstcnt;
	acquire_kspinlock(&tstcntlock);
f0118bc3:	83 ec 0c             	sub    $0xc,%esp
f0118bc6:	68 00 6e 85 f0       	push   $0xf0856e00
f0118bcb:	e8 ab 72 ff ff       	call   f010fe7b <acquire_kspinlock>
f0118bd0:	83 c4 10             	add    $0x10,%esp
	{
		__tstcnt = tstcnt;
f0118bd3:	a1 68 e6 83 f0       	mov    0xf083e668,%eax
f0118bd8:	89 45 f4             	mov    %eax,-0xc(%ebp)
	}
	release_kspinlock(&tstcntlock);
f0118bdb:	83 ec 0c             	sub    $0xc,%esp
f0118bde:	68 00 6e 85 f0       	push   $0xf0856e00
f0118be3:	e8 38 73 ff ff       	call   f010ff20 <release_kspinlock>
f0118be8:	83 c4 10             	add    $0x10,%esp
	if (__tstcnt == n)
f0118beb:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118bee:	3b 45 08             	cmp    0x8(%ebp),%eax
f0118bf1:	75 12                	jne    f0118c05 <chktst+0x48>
		cprintf("\nCongratulations... test runs successfully\n");
f0118bf3:	83 ec 0c             	sub    $0xc,%esp
f0118bf6:	68 a8 57 13 f0       	push   $0xf01357a8
f0118bfb:	e8 5c 90 fe ff       	call   f0101c5c <cprintf>
f0118c00:	83 c4 10             	add    $0x10,%esp
	else
		panic("Error!! test fails at final");
}
f0118c03:	eb 14                	jmp    f0118c19 <chktst+0x5c>
	}
	release_kspinlock(&tstcntlock);
	if (__tstcnt == n)
		cprintf("\nCongratulations... test runs successfully\n");
	else
		panic("Error!! test fails at final");
f0118c05:	83 ec 04             	sub    $0x4,%esp
f0118c08:	68 d4 57 13 f0       	push   $0xf01357d4
f0118c0d:	6a 5f                	push   $0x5f
f0118c0f:	68 8f 57 13 f0       	push   $0xf013578f
f0118c14:	e8 96 83 fe ff       	call   f0100faf <_panic>
}
f0118c19:	c9                   	leave  
f0118c1a:	c3                   	ret    

f0118c1b <nearest_pow2_ceil>:

inline unsigned int nearest_pow2_ceil(unsigned int x) {
f0118c1b:	55                   	push   %ebp
f0118c1c:	89 e5                	mov    %esp,%ebp
f0118c1e:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0118c21:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0118c25:	77 07                	ja     f0118c2e <nearest_pow2_ceil+0x13>
f0118c27:	b8 01 00 00 00       	mov    $0x1,%eax
f0118c2c:	eb 20                	jmp    f0118c4e <nearest_pow2_ceil+0x33>
	int power = 2;
f0118c2e:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0118c35:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0118c38:	eb 08                	jmp    f0118c42 <nearest_pow2_ceil+0x27>
		power <<= 1;
f0118c3a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f0118c3d:	01 c0                	add    %eax,%eax
f0118c3f:	89 45 fc             	mov    %eax,-0x4(%ebp)

inline unsigned int nearest_pow2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	int power = 2;
	x--;
	while (x >>= 1) {
f0118c42:	d1 6d 08             	shrl   0x8(%ebp)
f0118c45:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0118c49:	75 ef                	jne    f0118c3a <nearest_pow2_ceil+0x1f>
		power <<= 1;
	}
	return power;
f0118c4b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0118c4e:	c9                   	leave  
f0118c4f:	c3                   	ret    

f0118c50 <log2_ceil>:
inline unsigned int log2_ceil(unsigned int x) {
f0118c50:	55                   	push   %ebp
f0118c51:	89 e5                	mov    %esp,%ebp
f0118c53:	83 ec 10             	sub    $0x10,%esp
	if (x <= 1) return 1;
f0118c56:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f0118c5a:	77 07                	ja     f0118c63 <log2_ceil+0x13>
f0118c5c:	b8 01 00 00 00       	mov    $0x1,%eax
f0118c61:	eb 1b                	jmp    f0118c7e <log2_ceil+0x2e>
	//int power = 2;
	int bits_cnt = 2 ;
f0118c63:	c7 45 fc 02 00 00 00 	movl   $0x2,-0x4(%ebp)
	x--;
f0118c6a:	ff 4d 08             	decl   0x8(%ebp)
	while (x >>= 1) {
f0118c6d:	eb 03                	jmp    f0118c72 <log2_ceil+0x22>
		//power <<= 1;
		bits_cnt++ ;
f0118c6f:	ff 45 fc             	incl   -0x4(%ebp)
inline unsigned int log2_ceil(unsigned int x) {
	if (x <= 1) return 1;
	//int power = 2;
	int bits_cnt = 2 ;
	x--;
	while (x >>= 1) {
f0118c72:	d1 6d 08             	shrl   0x8(%ebp)
f0118c75:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0118c79:	75 f4                	jne    f0118c6f <log2_ceil+0x1f>
		//power <<= 1;
		bits_cnt++ ;
	}
	return bits_cnt;
f0118c7b:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f0118c7e:	c9                   	leave  
f0118c7f:	c3                   	ret    

f0118c80 <fixedPt2Str>:

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
f0118c80:	55                   	push   %ebp
f0118c81:	89 e5                	mov    %esp,%ebp
f0118c83:	83 ec 78             	sub    $0x78,%esp
	int mulFactor = 1;
f0118c86:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	for (int i = 0; i < num_dec_digits; ++i) {
f0118c8d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
f0118c94:	eb 12                	jmp    f0118ca8 <fixedPt2Str+0x28>
		mulFactor *= 10;
f0118c96:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0118c99:	89 d0                	mov    %edx,%eax
f0118c9b:	c1 e0 02             	shl    $0x2,%eax
f0118c9e:	01 d0                	add    %edx,%eax
f0118ca0:	01 c0                	add    %eax,%eax
f0118ca2:	89 45 f4             	mov    %eax,-0xc(%ebp)

/*2023*/
void fixedPt2Str(fixed_point_t f, int num_dec_digits, char* output)
{
	int mulFactor = 1;
	for (int i = 0; i < num_dec_digits; ++i) {
f0118ca5:	ff 45 f0             	incl   -0x10(%ebp)
f0118ca8:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0118cab:	3b 45 0c             	cmp    0xc(%ebp),%eax
f0118cae:	7c e6                	jl     f0118c96 <fixedPt2Str+0x16>
		mulFactor *= 10;
	}
	int scaledVal = fix_round(fix_scale(f, mulFactor)) ;
f0118cb0:	8d 45 dc             	lea    -0x24(%ebp),%eax
f0118cb3:	83 ec 04             	sub    $0x4,%esp
f0118cb6:	ff 75 f4             	pushl  -0xc(%ebp)
f0118cb9:	ff 75 08             	pushl  0x8(%ebp)
f0118cbc:	50                   	push   %eax
f0118cbd:	e8 e0 fc ff ff       	call   f01189a2 <fix_scale>
f0118cc2:	83 c4 0c             	add    $0xc,%esp
f0118cc5:	83 ec 0c             	sub    $0xc,%esp
f0118cc8:	ff 75 dc             	pushl  -0x24(%ebp)
f0118ccb:	e8 9c fc ff ff       	call   f011896c <fix_round>
f0118cd0:	83 c4 10             	add    $0x10,%esp
f0118cd3:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int integer = scaledVal/mulFactor;
f0118cd6:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118cd9:	99                   	cltd   
f0118cda:	f7 7d f4             	idivl  -0xc(%ebp)
f0118cdd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int fraction = scaledVal%mulFactor;
f0118ce0:	8b 45 e8             	mov    -0x18(%ebp),%eax
f0118ce3:	99                   	cltd   
f0118ce4:	f7 7d f4             	idivl  -0xc(%ebp)
f0118ce7:	89 55 e0             	mov    %edx,-0x20(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
f0118cea:	83 ec 08             	sub    $0x8,%esp
f0118ced:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118cf0:	50                   	push   %eax
f0118cf1:	ff 75 e4             	pushl  -0x1c(%ebp)
f0118cf4:	e8 d7 23 00 00       	call   f011b0d0 <ltostr>
f0118cf9:	83 c4 10             	add    $0x10,%esp
	char fractPart[20] ; ltostr(fraction, fractPart);
f0118cfc:	83 ec 08             	sub    $0x8,%esp
f0118cff:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0118d02:	50                   	push   %eax
f0118d03:	ff 75 e0             	pushl  -0x20(%ebp)
f0118d06:	e8 c5 23 00 00       	call   f011b0d0 <ltostr>
f0118d0b:	83 c4 10             	add    $0x10,%esp
	int tmp = mulFactor / 10;
f0118d0e:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f0118d11:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0118d16:	f7 e9                	imul   %ecx
f0118d18:	c1 fa 02             	sar    $0x2,%edx
f0118d1b:	89 c8                	mov    %ecx,%eax
f0118d1d:	c1 f8 1f             	sar    $0x1f,%eax
f0118d20:	29 c2                	sub    %eax,%edx
f0118d22:	89 d0                	mov    %edx,%eax
f0118d24:	89 45 ec             	mov    %eax,-0x14(%ebp)

	char zeros[10] = "";
f0118d27:	c7 45 aa 00 00 00 00 	movl   $0x0,-0x56(%ebp)
f0118d2e:	c7 45 ae 00 00 00 00 	movl   $0x0,-0x52(%ebp)
f0118d35:	66 c7 45 b2 00 00    	movw   $0x0,-0x4e(%ebp)
	while (fraction < tmp)
f0118d3b:	eb 31                	jmp    f0118d6e <fixedPt2Str+0xee>
	{
		strcconcat("0", zeros, zeros);
f0118d3d:	83 ec 04             	sub    $0x4,%esp
f0118d40:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118d43:	50                   	push   %eax
f0118d44:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118d47:	50                   	push   %eax
f0118d48:	68 f0 57 13 f0       	push   $0xf01357f0
f0118d4d:	e8 57 24 00 00       	call   f011b1a9 <strcconcat>
f0118d52:	83 c4 10             	add    $0x10,%esp
		tmp /= 10;
f0118d55:	8b 4d ec             	mov    -0x14(%ebp),%ecx
f0118d58:	b8 67 66 66 66       	mov    $0x66666667,%eax
f0118d5d:	f7 e9                	imul   %ecx
f0118d5f:	c1 fa 02             	sar    $0x2,%edx
f0118d62:	89 c8                	mov    %ecx,%eax
f0118d64:	c1 f8 1f             	sar    $0x1f,%eax
f0118d67:	29 c2                	sub    %eax,%edx
f0118d69:	89 d0                	mov    %edx,%eax
f0118d6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
	char intPart[20] ; ltostr(integer, intPart);
	char fractPart[20] ; ltostr(fraction, fractPart);
	int tmp = mulFactor / 10;

	char zeros[10] = "";
	while (fraction < tmp)
f0118d6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0118d71:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0118d74:	7c c7                	jl     f0118d3d <fixedPt2Str+0xbd>
	{
		strcconcat("0", zeros, zeros);
		tmp /= 10;
	}
	char fractPart2[20];
	strcconcat(zeros, fractPart, fractPart2);
f0118d76:	83 ec 04             	sub    $0x4,%esp
f0118d79:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0118d7c:	50                   	push   %eax
f0118d7d:	8d 45 b4             	lea    -0x4c(%ebp),%eax
f0118d80:	50                   	push   %eax
f0118d81:	8d 45 aa             	lea    -0x56(%ebp),%eax
f0118d84:	50                   	push   %eax
f0118d85:	e8 1f 24 00 00       	call   f011b1a9 <strcconcat>
f0118d8a:	83 c4 10             	add    $0x10,%esp

	//cprintf("integer = %d, intPart = %s - fraction = %d, fractPart = %s\n", integer, intPart, fraction , fractPart2);
	strcconcat(intPart, ".", intPart);
f0118d8d:	83 ec 04             	sub    $0x4,%esp
f0118d90:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118d93:	50                   	push   %eax
f0118d94:	68 f2 57 13 f0       	push   $0xf01357f2
f0118d99:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118d9c:	50                   	push   %eax
f0118d9d:	e8 07 24 00 00       	call   f011b1a9 <strcconcat>
f0118da2:	83 c4 10             	add    $0x10,%esp
	strcconcat(intPart, fractPart2, output);
f0118da5:	83 ec 04             	sub    $0x4,%esp
f0118da8:	ff 75 10             	pushl  0x10(%ebp)
f0118dab:	8d 45 96             	lea    -0x6a(%ebp),%eax
f0118dae:	50                   	push   %eax
f0118daf:	8d 45 c8             	lea    -0x38(%ebp),%eax
f0118db2:	50                   	push   %eax
f0118db3:	e8 f1 23 00 00       	call   f011b1a9 <strcconcat>
f0118db8:	83 c4 10             	add    $0x10,%esp

}
f0118dbb:	90                   	nop
f0118dbc:	c9                   	leave  
f0118dbd:	c3                   	ret    

f0118dbe <sys_utilities>:
struct kspinlock __tstchan_lk__;
int __firstTimeSleepLock = 1;
struct sleeplock __tstslplk__;

void sys_utilities(char* utilityName, int value)
{
f0118dbe:	55                   	push   %ebp
f0118dbf:	89 e5                	mov    %esp,%ebp
f0118dc1:	81 ec c8 00 00 00    	sub    $0xc8,%esp
	if (strncmp(utilityName, "__BSDSetNice@", strlen("__BSDSetNice@")) == 0)
f0118dc7:	83 ec 0c             	sub    $0xc,%esp
f0118dca:	68 f4 57 13 f0       	push   $0xf01357f4
f0118dcf:	e8 a7 1d 00 00       	call   f011ab7b <strlen>
f0118dd4:	83 c4 10             	add    $0x10,%esp
f0118dd7:	83 ec 04             	sub    $0x4,%esp
f0118dda:	50                   	push   %eax
f0118ddb:	68 f4 57 13 f0       	push   $0xf01357f4
f0118de0:	ff 75 08             	pushl  0x8(%ebp)
f0118de3:	e8 d7 1e 00 00       	call   f011acbf <strncmp>
f0118de8:	83 c4 10             	add    $0x10,%esp
f0118deb:	85 c0                	test   %eax,%eax
f0118ded:	0f 85 8a 00 00 00    	jne    f0118e7d <sys_utilities+0xbf>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118df3:	8d 45 94             	lea    -0x6c(%ebp),%eax
f0118df6:	50                   	push   %eax
f0118df7:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118dfd:	50                   	push   %eax
f0118dfe:	68 02 58 13 f0       	push   $0xf0135802
f0118e03:	ff 75 08             	pushl  0x8(%ebp)
f0118e06:	e8 34 24 00 00       	call   f011b23f <strsplit>
f0118e0b:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0118e0e:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118e14:	83 ec 04             	sub    $0x4,%esp
f0118e17:	6a 0a                	push   $0xa
f0118e19:	6a 00                	push   $0x0
f0118e1b:	50                   	push   %eax
f0118e1c:	e8 69 21 00 00       	call   f011af8a <strtol>
f0118e21:	83 c4 10             	add    $0x10,%esp
f0118e24:	89 45 98             	mov    %eax,-0x68(%ebp)
		struct Env* env = NULL ;
f0118e27:	c7 45 90 00 00 00 00 	movl   $0x0,-0x70(%ebp)
		envid2env(envID, &env, 0);
f0118e2e:	83 ec 04             	sub    $0x4,%esp
f0118e31:	6a 00                	push   $0x0
f0118e33:	8d 45 90             	lea    -0x70(%ebp),%eax
f0118e36:	50                   	push   %eax
f0118e37:	ff 75 98             	pushl  -0x68(%ebp)
f0118e3a:	e8 29 2d ff ff       	call   f010bb68 <envid2env>
f0118e3f:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0118e42:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118e45:	8b 40 10             	mov    0x10(%eax),%eax
f0118e48:	3b 45 98             	cmp    -0x68(%ebp),%eax
f0118e4b:	74 19                	je     f0118e66 <sys_utilities+0xa8>
f0118e4d:	68 04 58 13 f0       	push   $0xf0135804
f0118e52:	68 47 57 13 f0       	push   $0xf0135747
f0118e57:	68 a5 00 00 00       	push   $0xa5
f0118e5c:	68 8f 57 13 f0       	push   $0xf013578f
f0118e61:	e8 49 81 fe ff       	call   f0100faf <_panic>
		env_set_nice(env, value);
f0118e66:	8b 45 90             	mov    -0x70(%ebp),%eax
f0118e69:	83 ec 08             	sub    $0x8,%esp
f0118e6c:	ff 75 0c             	pushl  0xc(%ebp)
f0118e6f:	50                   	push   %eax
f0118e70:	e8 92 e8 fe ff       	call   f0107707 <env_set_nice>
f0118e75:	83 c4 10             	add    $0x10,%esp
f0118e78:	e9 8d 07 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strncmp(utilityName, "__PRIRRSetPriority@", strlen("__PRIRRSetPriority@")) == 0)
f0118e7d:	83 ec 0c             	sub    $0xc,%esp
f0118e80:	68 19 58 13 f0       	push   $0xf0135819
f0118e85:	e8 f1 1c 00 00       	call   f011ab7b <strlen>
f0118e8a:	83 c4 10             	add    $0x10,%esp
f0118e8d:	83 ec 04             	sub    $0x4,%esp
f0118e90:	50                   	push   %eax
f0118e91:	68 19 58 13 f0       	push   $0xf0135819
f0118e96:	ff 75 08             	pushl  0x8(%ebp)
f0118e99:	e8 21 1e 00 00       	call   f011acbf <strncmp>
f0118e9e:	83 c4 10             	add    $0x10,%esp
f0118ea1:	85 c0                	test   %eax,%eax
f0118ea3:	0f 85 89 00 00 00    	jne    f0118f32 <sys_utilities+0x174>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118ea9:	8d 45 8c             	lea    -0x74(%ebp),%eax
f0118eac:	50                   	push   %eax
f0118ead:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118eb3:	50                   	push   %eax
f0118eb4:	68 02 58 13 f0       	push   $0xf0135802
f0118eb9:	ff 75 08             	pushl  0x8(%ebp)
f0118ebc:	e8 7e 23 00 00       	call   f011b23f <strsplit>
f0118ec1:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0118ec4:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118eca:	83 ec 04             	sub    $0x4,%esp
f0118ecd:	6a 0a                	push   $0xa
f0118ecf:	6a 00                	push   $0x0
f0118ed1:	50                   	push   %eax
f0118ed2:	e8 b3 20 00 00       	call   f011af8a <strtol>
f0118ed7:	83 c4 10             	add    $0x10,%esp
f0118eda:	89 45 9c             	mov    %eax,-0x64(%ebp)
		struct Env* env = NULL ;
f0118edd:	c7 45 88 00 00 00 00 	movl   $0x0,-0x78(%ebp)
		envid2env(envID, &env, 0);
f0118ee4:	83 ec 04             	sub    $0x4,%esp
f0118ee7:	6a 00                	push   $0x0
f0118ee9:	8d 45 88             	lea    -0x78(%ebp),%eax
f0118eec:	50                   	push   %eax
f0118eed:	ff 75 9c             	pushl  -0x64(%ebp)
f0118ef0:	e8 73 2c ff ff       	call   f010bb68 <envid2env>
f0118ef5:	83 c4 10             	add    $0x10,%esp
		assert(env->env_id == envID) ;
f0118ef8:	8b 45 88             	mov    -0x78(%ebp),%eax
f0118efb:	8b 40 10             	mov    0x10(%eax),%eax
f0118efe:	3b 45 9c             	cmp    -0x64(%ebp),%eax
f0118f01:	74 19                	je     f0118f1c <sys_utilities+0x15e>
f0118f03:	68 04 58 13 f0       	push   $0xf0135804
f0118f08:	68 47 57 13 f0       	push   $0xf0135747
f0118f0d:	68 b1 00 00 00       	push   $0xb1
f0118f12:	68 8f 57 13 f0       	push   $0xf013578f
f0118f17:	e8 93 80 fe ff       	call   f0100faf <_panic>
		env_set_priority(envID, value);
f0118f1c:	83 ec 08             	sub    $0x8,%esp
f0118f1f:	ff 75 0c             	pushl  0xc(%ebp)
f0118f22:	ff 75 9c             	pushl  -0x64(%ebp)
f0118f25:	e8 34 e8 fe ff       	call   f010775e <env_set_priority>
f0118f2a:	83 c4 10             	add    $0x10,%esp
f0118f2d:	e9 d8 06 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strncmp(utilityName, "__CheckExitOrder@", strlen("__CheckExitOrder@")) == 0)
f0118f32:	83 ec 0c             	sub    $0xc,%esp
f0118f35:	68 2d 58 13 f0       	push   $0xf013582d
f0118f3a:	e8 3c 1c 00 00       	call   f011ab7b <strlen>
f0118f3f:	83 c4 10             	add    $0x10,%esp
f0118f42:	83 ec 04             	sub    $0x4,%esp
f0118f45:	50                   	push   %eax
f0118f46:	68 2d 58 13 f0       	push   $0xf013582d
f0118f4b:	ff 75 08             	pushl  0x8(%ebp)
f0118f4e:	e8 6c 1d 00 00       	call   f011acbf <strncmp>
f0118f53:	83 c4 10             	add    $0x10,%esp
f0118f56:	85 c0                	test   %eax,%eax
f0118f58:	0f 85 ba 01 00 00    	jne    f0119118 <sys_utilities+0x35a>
	{
		int* numOfInstances = (int*) value ;
f0118f5e:	8b 45 0c             	mov    0xc(%ebp),%eax
f0118f61:	89 45 a8             	mov    %eax,-0x58(%ebp)
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0118f64:	8d 45 84             	lea    -0x7c(%ebp),%eax
f0118f67:	50                   	push   %eax
f0118f68:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0118f6e:	50                   	push   %eax
f0118f6f:	68 02 58 13 f0       	push   $0xf0135802
f0118f74:	ff 75 08             	pushl  0x8(%ebp)
f0118f77:	e8 c3 22 00 00       	call   f011b23f <strsplit>
f0118f7c:	83 c4 10             	add    $0x10,%esp
		char *progName = tokens[1];
f0118f7f:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0118f85:	89 45 a4             	mov    %eax,-0x5c(%ebp)
		struct Env* env = NULL ;
f0118f88:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		bool chkAscending = 1;
f0118f8f:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
		int prevEnvID = -1 ;
f0118f96:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		if (*numOfInstances < 0)
f0118f9d:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fa0:	8b 00                	mov    (%eax),%eax
f0118fa2:	85 c0                	test   %eax,%eax
f0118fa4:	79 1c                	jns    f0118fc2 <sys_utilities+0x204>
		{
			chkAscending = 0;
f0118fa6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
			*numOfInstances *= -1;
f0118fad:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fb0:	8b 00                	mov    (%eax),%eax
f0118fb2:	f7 d8                	neg    %eax
f0118fb4:	89 c2                	mov    %eax,%edx
f0118fb6:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0118fb9:	89 10                	mov    %edx,(%eax)
			prevEnvID = 1<<30 ;
f0118fbb:	c7 45 ec 00 00 00 40 	movl   $0x40000000,-0x14(%ebp)
		}
		bool success = 1;
f0118fc2:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%ebp)

		acquire_kspinlock(&ProcessQueues.qlock);
f0118fc9:	83 ec 0c             	sub    $0xc,%esp
f0118fcc:	68 20 e7 83 f0       	push   $0xf083e720
f0118fd1:	e8 a5 6e ff ff       	call   f010fe7b <acquire_kspinlock>
f0118fd6:	83 c4 10             	add    $0x10,%esp
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0118fd9:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0118fde:	89 45 a0             	mov    %eax,-0x60(%ebp)
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
f0118fe1:	a1 a4 e7 83 f0       	mov    0xf083e7a4,%eax
f0118fe6:	89 45 f4             	mov    %eax,-0xc(%ebp)
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0118fe9:	8b 45 a0             	mov    -0x60(%ebp),%eax
f0118fec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0118fef:	eb 6c                	jmp    f011905d <sys_utilities+0x29f>
			{
				if (strcmp(env->prog_name, progName) != 0)
f0118ff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0118ff4:	83 c0 20             	add    $0x20,%eax
f0118ff7:	83 ec 08             	sub    $0x8,%esp
f0118ffa:	ff 75 a4             	pushl  -0x5c(%ebp)
f0118ffd:	50                   	push   %eax
f0118ffe:	e8 84 1c 00 00       	call   f011ac87 <strcmp>
f0119003:	83 c4 10             	add    $0x10,%esp
f0119006:	85 c0                	test   %eax,%eax
f0119008:	75 46                	jne    f0119050 <sys_utilities+0x292>
					continue;
				(*numOfInstances)-- ;
f011900a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011900d:	8b 00                	mov    (%eax),%eax
f011900f:	8d 50 ff             	lea    -0x1(%eax),%edx
f0119012:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119015:	89 10                	mov    %edx,(%eax)

				//cprintf("%s: prevID = %d, nextID = %d\n", progName, prevEnvID, env->env_id);
				if (chkAscending)
f0119017:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011901b:	74 14                	je     f0119031 <sys_utilities+0x273>
				{
					if (prevEnvID > env->env_id)
f011901d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119020:	8b 40 10             	mov    0x10(%eax),%eax
f0119023:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119026:	7d 1d                	jge    f0119045 <sys_utilities+0x287>
					{
						success = 0;
f0119028:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f011902f:	eb 32                	jmp    f0119063 <sys_utilities+0x2a5>
					}
				}
				else
				{
					if (prevEnvID < env->env_id)
f0119031:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119034:	8b 40 10             	mov    0x10(%eax),%eax
f0119037:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f011903a:	7e 09                	jle    f0119045 <sys_utilities+0x287>
					{
						success = 0;
f011903c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
						break;
f0119043:	eb 1e                	jmp    f0119063 <sys_utilities+0x2a5>
					}
				}
				prevEnvID = env->env_id;
f0119045:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119048:	8b 40 10             	mov    0x10(%eax),%eax
f011904b:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011904e:	eb 01                	jmp    f0119051 <sys_utilities+0x293>
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
			{
				if (strcmp(env->prog_name, progName) != 0)
					continue;
f0119050:	90                   	nop
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			//REVERSE LOOP ON EXIT LIST (to be the same as the queue order)
			int numOfExitEnvs = LIST_SIZE(&ProcessQueues.env_exit_queue);
			env = LIST_LAST(&ProcessQueues.env_exit_queue);
			for (int i = numOfExitEnvs; i > 0; --i, env = LIST_PREV(env))
f0119051:	ff 4d e4             	decl   -0x1c(%ebp)
f0119054:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119057:	8b 40 0c             	mov    0xc(%eax),%eax
f011905a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011905d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f0119061:	7f 8e                	jg     f0118ff1 <sys_utilities+0x233>
					}
				}
				prevEnvID = env->env_id;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119063:	83 ec 0c             	sub    $0xc,%esp
f0119066:	68 20 e7 83 f0       	push   $0xf083e720
f011906b:	e8 b0 6e ff ff       	call   f010ff20 <release_kspinlock>
f0119070:	83 c4 10             	add    $0x10,%esp
		if (*numOfInstances != 0 || success == 0)
f0119073:	8b 45 a8             	mov    -0x58(%ebp),%eax
f0119076:	8b 00                	mov    (%eax),%eax
f0119078:	85 c0                	test   %eax,%eax
f011907a:	75 06                	jne    f0119082 <sys_utilities+0x2c4>
f011907c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
f0119080:	75 4b                	jne    f01190cd <sys_utilities+0x30f>
		{
			cons_lock();
f0119082:	e8 fa 8a fe ff       	call   f0101b81 <cons_lock>
			{
				cprintf("###########################################\n");
f0119087:	83 ec 0c             	sub    $0xc,%esp
f011908a:	68 40 58 13 f0       	push   $0xf0135840
f011908f:	e8 c8 8b fe ff       	call   f0101c5c <cprintf>
f0119094:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is FAILED\n", progName);
f0119097:	83 ec 08             	sub    $0x8,%esp
f011909a:	ff 75 a4             	pushl  -0x5c(%ebp)
f011909d:	68 70 58 13 f0       	push   $0xf0135870
f01190a2:	e8 b5 8b fe ff       	call   f0101c5c <cprintf>
f01190a7:	83 c4 10             	add    $0x10,%esp
				cprintf("###########################################\n");
f01190aa:	83 ec 0c             	sub    $0xc,%esp
f01190ad:	68 40 58 13 f0       	push   $0xf0135840
f01190b2:	e8 a5 8b fe ff       	call   f0101c5c <cprintf>
f01190b7:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f01190ba:	e8 09 8b fe ff       	call   f0101bc8 <cons_unlock>
			*numOfInstances = 0; //to indicate the failure of test
f01190bf:	8b 45 a8             	mov    -0x58(%ebp),%eax
f01190c2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
f01190c8:	e9 3d 05 00 00       	jmp    f011960a <sys_utilities+0x84c>
		}
		else
		{
			cons_lock();
f01190cd:	e8 af 8a fe ff       	call   f0101b81 <cons_lock>
			{
				cprintf("####################################################\n");
f01190d2:	83 ec 0c             	sub    $0xc,%esp
f01190d5:	68 90 58 13 f0       	push   $0xf0135890
f01190da:	e8 7d 8b fe ff       	call   f0101c5c <cprintf>
f01190df:	83 c4 10             	add    $0x10,%esp
				cprintf("%s: check exit order is SUCCEEDED\n", progName);
f01190e2:	83 ec 08             	sub    $0x8,%esp
f01190e5:	ff 75 a4             	pushl  -0x5c(%ebp)
f01190e8:	68 c8 58 13 f0       	push   $0xf01358c8
f01190ed:	e8 6a 8b fe ff       	call   f0101c5c <cprintf>
f01190f2:	83 c4 10             	add    $0x10,%esp
				cprintf("####################################################\n");
f01190f5:	83 ec 0c             	sub    $0xc,%esp
f01190f8:	68 90 58 13 f0       	push   $0xf0135890
f01190fd:	e8 5a 8b fe ff       	call   f0101c5c <cprintf>
f0119102:	83 c4 10             	add    $0x10,%esp
			}
			cons_unlock();
f0119105:	e8 be 8a fe ff       	call   f0101bc8 <cons_unlock>
			*numOfInstances = 1; //to indicate the success of test
f011910a:	8b 45 a8             	mov    -0x58(%ebp),%eax
f011910d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
f0119113:	e9 f2 04 00 00       	jmp    f011960a <sys_utilities+0x84c>
		}
	}
	else if (strncmp(utilityName, "__NthClkRepl@", strlen("__NthClkRepl@")) == 0)
f0119118:	83 ec 0c             	sub    $0xc,%esp
f011911b:	68 eb 58 13 f0       	push   $0xf01358eb
f0119120:	e8 56 1a 00 00       	call   f011ab7b <strlen>
f0119125:	83 c4 10             	add    $0x10,%esp
f0119128:	83 ec 04             	sub    $0x4,%esp
f011912b:	50                   	push   %eax
f011912c:	68 eb 58 13 f0       	push   $0xf01358eb
f0119131:	ff 75 08             	pushl  0x8(%ebp)
f0119134:	e8 86 1b 00 00       	call   f011acbf <strncmp>
f0119139:	83 c4 10             	add    $0x10,%esp
f011913c:	85 c0                	test   %eax,%eax
f011913e:	75 76                	jne    f01191b6 <sys_utilities+0x3f8>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0119140:	8d 45 80             	lea    -0x80(%ebp),%eax
f0119143:	50                   	push   %eax
f0119144:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f011914a:	50                   	push   %eax
f011914b:	68 02 58 13 f0       	push   $0xf0135802
f0119150:	ff 75 08             	pushl  0x8(%ebp)
f0119153:	e8 e7 20 00 00       	call   f011b23f <strsplit>
f0119158:	83 c4 10             	add    $0x10,%esp
		int type = strtol(tokens[1], NULL, 10);
f011915b:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0119161:	83 ec 04             	sub    $0x4,%esp
f0119164:	6a 0a                	push   $0xa
f0119166:	6a 00                	push   $0x0
f0119168:	50                   	push   %eax
f0119169:	e8 1c 1e 00 00       	call   f011af8a <strtol>
f011916e:	83 c4 10             	add    $0x10,%esp
f0119171:	89 45 ac             	mov    %eax,-0x54(%ebp)
		int N = value;
f0119174:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119177:	89 45 e0             	mov    %eax,-0x20(%ebp)
		if (type == 2)
f011917a:	83 7d ac 02          	cmpl   $0x2,-0x54(%ebp)
f011917e:	75 03                	jne    f0119183 <sys_utilities+0x3c5>
			N *= -1;
f0119180:	f7 5d e0             	negl   -0x20(%ebp)
		setPageReplacmentAlgorithmNchanceCLOCK(N);
f0119183:	83 ec 0c             	sub    $0xc,%esp
f0119186:	ff 75 e0             	pushl  -0x20(%ebp)
f0119189:	e8 5f 67 ff ff       	call   f010f8ed <setPageReplacmentAlgorithmNchanceCLOCK>
f011918e:	83 c4 10             	add    $0x10,%esp
		cons_lock();
f0119191:	e8 eb 89 fe ff       	call   f0101b81 <cons_lock>
		{
			cprintf("\n*********************************************************"
f0119196:	83 ec 04             	sub    $0x4,%esp
f0119199:	ff 75 e0             	pushl  -0x20(%ebp)
f011919c:	ff 75 ac             	pushl  -0x54(%ebp)
f011919f:	68 fc 58 13 f0       	push   $0xf01358fc
f01191a4:	e8 b3 8a fe ff       	call   f0101c5c <cprintf>
f01191a9:	83 c4 10             	add    $0x10,%esp
					"\nPAGE REPLACEMENT IS SET TO Nth Clock type = %d (N = %d)."
					"\n*********************************************************\n", type, N);
		}
		cons_unlock();
f01191ac:	e8 17 8a fe ff       	call   f0101bc8 <cons_unlock>
f01191b1:	e9 54 04 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__Sleep__") == 0)
f01191b6:	83 ec 08             	sub    $0x8,%esp
f01191b9:	68 ab 59 13 f0       	push   $0xf01359ab
f01191be:	ff 75 08             	pushl  0x8(%ebp)
f01191c1:	e8 c1 1a 00 00       	call   f011ac87 <strcmp>
f01191c6:	83 c4 10             	add    $0x10,%esp
f01191c9:	85 c0                	test   %eax,%eax
f01191cb:	75 77                	jne    f0119244 <sys_utilities+0x486>
	{
		if (__firstTimeSleep)
f01191cd:	a1 ac 01 18 f0       	mov    0xf01801ac,%eax
f01191d2:	85 c0                	test   %eax,%eax
f01191d4:	74 34                	je     f011920a <sys_utilities+0x44c>
		{
			__firstTimeSleep = 0;
f01191d6:	c7 05 ac 01 18 f0 00 	movl   $0x0,0xf01801ac
f01191dd:	00 00 00 
			init_channel(&__tstchan__, "Test Channel");
f01191e0:	83 ec 08             	sub    $0x8,%esp
f01191e3:	68 b5 59 13 f0       	push   $0xf01359b5
f01191e8:	68 e0 d4 87 f0       	push   $0xf087d4e0
f01191ed:	e8 61 70 ff ff       	call   f0110253 <init_channel>
f01191f2:	83 c4 10             	add    $0x10,%esp
			init_kspinlock(&__tstchan_lk__, "Test Channel Lock");
f01191f5:	83 ec 08             	sub    $0x8,%esp
f01191f8:	68 c2 59 13 f0       	push   $0xf01359c2
f01191fd:	68 60 d6 87 f0       	push   $0xf087d660
f0119202:	e8 43 6c ff ff       	call   f010fe4a <init_kspinlock>
f0119207:	83 c4 10             	add    $0x10,%esp
		}
		acquire_kspinlock(&__tstchan_lk__);
f011920a:	83 ec 0c             	sub    $0xc,%esp
f011920d:	68 60 d6 87 f0       	push   $0xf087d660
f0119212:	e8 64 6c ff ff       	call   f010fe7b <acquire_kspinlock>
f0119217:	83 c4 10             	add    $0x10,%esp
		sleep(&__tstchan__, &__tstchan_lk__);
f011921a:	83 ec 08             	sub    $0x8,%esp
f011921d:	68 60 d6 87 f0       	push   $0xf087d660
f0119222:	68 e0 d4 87 f0       	push   $0xf087d4e0
f0119227:	e8 54 70 ff ff       	call   f0110280 <sleep>
f011922c:	83 c4 10             	add    $0x10,%esp
		release_kspinlock(&__tstchan_lk__);
f011922f:	83 ec 0c             	sub    $0xc,%esp
f0119232:	68 60 d6 87 f0       	push   $0xf087d660
f0119237:	e8 e4 6c ff ff       	call   f010ff20 <release_kspinlock>
f011923c:	83 c4 10             	add    $0x10,%esp
f011923f:	e9 c6 03 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__WakeupOne__") == 0)
f0119244:	83 ec 08             	sub    $0x8,%esp
f0119247:	68 d4 59 13 f0       	push   $0xf01359d4
f011924c:	ff 75 08             	pushl  0x8(%ebp)
f011924f:	e8 33 1a 00 00       	call   f011ac87 <strcmp>
f0119254:	83 c4 10             	add    $0x10,%esp
f0119257:	85 c0                	test   %eax,%eax
f0119259:	75 15                	jne    f0119270 <sys_utilities+0x4b2>
	{
		wakeup_one(&__tstchan__);
f011925b:	83 ec 0c             	sub    $0xc,%esp
f011925e:	68 e0 d4 87 f0       	push   $0xf087d4e0
f0119263:	e8 32 70 ff ff       	call   f011029a <wakeup_one>
f0119268:	83 c4 10             	add    $0x10,%esp
f011926b:	e9 9a 03 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__WakeupAll__") == 0)
f0119270:	83 ec 08             	sub    $0x8,%esp
f0119273:	68 e2 59 13 f0       	push   $0xf01359e2
f0119278:	ff 75 08             	pushl  0x8(%ebp)
f011927b:	e8 07 1a 00 00       	call   f011ac87 <strcmp>
f0119280:	83 c4 10             	add    $0x10,%esp
f0119283:	85 c0                	test   %eax,%eax
f0119285:	75 15                	jne    f011929c <sys_utilities+0x4de>
	{
		wakeup_all(&__tstchan__);
f0119287:	83 ec 0c             	sub    $0xc,%esp
f011928a:	68 e0 d4 87 f0       	push   $0xf087d4e0
f011928f:	e8 20 70 ff ff       	call   f01102b4 <wakeup_all>
f0119294:	83 c4 10             	add    $0x10,%esp
f0119297:	e9 6e 03 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetChanQueueSize__") == 0)
f011929c:	83 ec 08             	sub    $0x8,%esp
f011929f:	68 f0 59 13 f0       	push   $0xf01359f0
f01192a4:	ff 75 08             	pushl  0x8(%ebp)
f01192a7:	e8 db 19 00 00       	call   f011ac87 <strcmp>
f01192ac:	83 c4 10             	add    $0x10,%esp
f01192af:	85 c0                	test   %eax,%eax
f01192b1:	75 17                	jne    f01192ca <sys_utilities+0x50c>
	{
		int* numOfProcesses = (int*) value ;
f01192b3:	8b 45 0c             	mov    0xc(%ebp),%eax
f01192b6:	89 45 b0             	mov    %eax,-0x50(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstchan__.queue);
f01192b9:	a1 ec d4 87 f0       	mov    0xf087d4ec,%eax
f01192be:	89 c2                	mov    %eax,%edx
f01192c0:	8b 45 b0             	mov    -0x50(%ebp),%eax
f01192c3:	89 10                	mov    %edx,(%eax)
f01192c5:	e9 40 03 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetReadyQueueSize__") == 0)
f01192ca:	83 ec 08             	sub    $0x8,%esp
f01192cd:	68 05 5a 13 f0       	push   $0xf0135a05
f01192d2:	ff 75 08             	pushl  0x8(%ebp)
f01192d5:	e8 ad 19 00 00       	call   f011ac87 <strcmp>
f01192da:	83 c4 10             	add    $0x10,%esp
f01192dd:	85 c0                	test   %eax,%eax
f01192df:	75 1a                	jne    f01192fb <sys_utilities+0x53d>
	{
		int* numOfProcesses = (int*) value ;
f01192e1:	8b 45 0c             	mov    0xc(%ebp),%eax
f01192e4:	89 45 b4             	mov    %eax,-0x4c(%ebp)
		*numOfProcesses = LIST_SIZE(&ProcessQueues.env_ready_queues[0]);
f01192e7:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01192ec:	8b 40 0c             	mov    0xc(%eax),%eax
f01192ef:	89 c2                	mov    %eax,%edx
f01192f1:	8b 45 b4             	mov    -0x4c(%ebp),%eax
f01192f4:	89 10                	mov    %edx,(%eax)
f01192f6:	e9 0f 03 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__AcquireSleepLock__") == 0)
f01192fb:	83 ec 08             	sub    $0x8,%esp
f01192fe:	68 1b 5a 13 f0       	push   $0xf0135a1b
f0119303:	ff 75 08             	pushl  0x8(%ebp)
f0119306:	e8 7c 19 00 00       	call   f011ac87 <strcmp>
f011930b:	83 c4 10             	add    $0x10,%esp
f011930e:	85 c0                	test   %eax,%eax
f0119310:	75 3d                	jne    f011934f <sys_utilities+0x591>
	{
		if (__firstTimeSleepLock)
f0119312:	a1 b0 01 18 f0       	mov    0xf01801b0,%eax
f0119317:	85 c0                	test   %eax,%eax
f0119319:	74 1f                	je     f011933a <sys_utilities+0x57c>
		{
			__firstTimeSleepLock = 0;
f011931b:	c7 05 b0 01 18 f0 00 	movl   $0x0,0xf01801b0
f0119322:	00 00 00 
			init_sleeplock(&__tstslplk__, "Test Sleep Lock");
f0119325:	83 ec 08             	sub    $0x8,%esp
f0119328:	68 30 5a 13 f0       	push   $0xf0135a30
f011932d:	68 40 d5 87 f0       	push   $0xf087d540
f0119332:	e8 da 6d ff ff       	call   f0110111 <init_sleeplock>
f0119337:	83 c4 10             	add    $0x10,%esp
		}
		acquire_sleeplock(&__tstslplk__);
f011933a:	83 ec 0c             	sub    $0xc,%esp
f011933d:	68 40 d5 87 f0       	push   $0xf087d540
f0119342:	e8 78 6e ff ff       	call   f01101bf <acquire_sleeplock>
f0119347:	83 c4 10             	add    $0x10,%esp
f011934a:	e9 bb 02 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__ReleaseSleepLock__") == 0)
f011934f:	83 ec 08             	sub    $0x8,%esp
f0119352:	68 40 5a 13 f0       	push   $0xf0135a40
f0119357:	ff 75 08             	pushl  0x8(%ebp)
f011935a:	e8 28 19 00 00       	call   f011ac87 <strcmp>
f011935f:	83 c4 10             	add    $0x10,%esp
f0119362:	85 c0                	test   %eax,%eax
f0119364:	75 15                	jne    f011937b <sys_utilities+0x5bd>
	{
		release_sleeplock(&__tstslplk__);
f0119366:	83 ec 0c             	sub    $0xc,%esp
f0119369:	68 40 d5 87 f0       	push   $0xf087d540
f011936e:	e8 66 6e ff ff       	call   f01101d9 <release_sleeplock>
f0119373:	83 c4 10             	add    $0x10,%esp
f0119376:	e9 8f 02 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockQueueSize__") == 0)
f011937b:	83 ec 08             	sub    $0x8,%esp
f011937e:	68 55 5a 13 f0       	push   $0xf0135a55
f0119383:	ff 75 08             	pushl  0x8(%ebp)
f0119386:	e8 fc 18 00 00       	call   f011ac87 <strcmp>
f011938b:	83 c4 10             	add    $0x10,%esp
f011938e:	85 c0                	test   %eax,%eax
f0119390:	75 17                	jne    f01193a9 <sys_utilities+0x5eb>
	{
		int* numOfProcesses = (int*) value ;
f0119392:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119395:	89 45 b8             	mov    %eax,-0x48(%ebp)
		*numOfProcesses = LIST_SIZE(&__tstslplk__.chan.queue);
f0119398:	a1 c0 d5 87 f0       	mov    0xf087d5c0,%eax
f011939d:	89 c2                	mov    %eax,%edx
f011939f:	8b 45 b8             	mov    -0x48(%ebp),%eax
f01193a2:	89 10                	mov    %edx,(%eax)
f01193a4:	e9 61 02 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockValue__") == 0)
f01193a9:	83 ec 08             	sub    $0x8,%esp
f01193ac:	68 6a 5a 13 f0       	push   $0xf0135a6a
f01193b1:	ff 75 08             	pushl  0x8(%ebp)
f01193b4:	e8 ce 18 00 00       	call   f011ac87 <strcmp>
f01193b9:	83 c4 10             	add    $0x10,%esp
f01193bc:	85 c0                	test   %eax,%eax
f01193be:	75 16                	jne    f01193d6 <sys_utilities+0x618>
	{
		int* lockVal = (int*) value ;
f01193c0:	8b 45 0c             	mov    0xc(%ebp),%eax
f01193c3:	89 45 bc             	mov    %eax,-0x44(%ebp)
		*lockVal =__tstslplk__.locked;
f01193c6:	8b 15 40 d5 87 f0    	mov    0xf087d540,%edx
f01193cc:	8b 45 bc             	mov    -0x44(%ebp),%eax
f01193cf:	89 10                	mov    %edx,(%eax)
f01193d1:	e9 34 02 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetLockOwner__") == 0)
f01193d6:	83 ec 08             	sub    $0x8,%esp
f01193d9:	68 7b 5a 13 f0       	push   $0xf0135a7b
f01193de:	ff 75 08             	pushl  0x8(%ebp)
f01193e1:	e8 a1 18 00 00       	call   f011ac87 <strcmp>
f01193e6:	83 c4 10             	add    $0x10,%esp
f01193e9:	85 c0                	test   %eax,%eax
f01193eb:	75 17                	jne    f0119404 <sys_utilities+0x646>
	{
		uint32* lockOwnerID = (uint32*) value ;
f01193ed:	8b 45 0c             	mov    0xc(%ebp),%eax
f01193f0:	89 45 c0             	mov    %eax,-0x40(%ebp)
		*lockOwnerID =__tstslplk__.pid;
f01193f3:	a1 44 d6 87 f0       	mov    0xf087d644,%eax
f01193f8:	89 c2                	mov    %eax,%edx
f01193fa:	8b 45 c0             	mov    -0x40(%ebp),%eax
f01193fd:	89 10                	mov    %edx,(%eax)
f01193ff:	e9 06 02 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__GetConsLockedCnt__") == 0)
f0119404:	83 ec 08             	sub    $0x8,%esp
f0119407:	68 8c 5a 13 f0       	push   $0xf0135a8c
f011940c:	ff 75 08             	pushl  0x8(%ebp)
f011940f:	e8 73 18 00 00       	call   f011ac87 <strcmp>
f0119414:	83 c4 10             	add    $0x10,%esp
f0119417:	85 c0                	test   %eax,%eax
f0119419:	75 22                	jne    f011943d <sys_utilities+0x67f>
	{
		uint32* consLockCnt = (uint32*) value ;
f011941b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011941e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		*consLockCnt = queue_size(&(conslock.chan.queue));
f0119421:	83 ec 0c             	sub    $0xc,%esp
f0119424:	68 d4 e5 83 f0       	push   $0xf083e5d4
f0119429:	e8 c5 cb fe ff       	call   f0105ff3 <queue_size>
f011942e:	83 c4 10             	add    $0x10,%esp
f0119431:	89 c2                	mov    %eax,%edx
f0119433:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119436:	89 10                	mov    %edx,(%eax)
f0119438:	e9 cd 01 00 00       	jmp    f011960a <sys_utilities+0x84c>
	}
	else if (strcmp(utilityName, "__tmpReleaseConsLock__") == 0)
f011943d:	83 ec 08             	sub    $0x8,%esp
f0119440:	68 a1 5a 13 f0       	push   $0xf0135aa1
f0119445:	ff 75 08             	pushl  0x8(%ebp)
f0119448:	e8 3a 18 00 00       	call   f011ac87 <strcmp>
f011944d:	83 c4 10             	add    $0x10,%esp
f0119450:	85 c0                	test   %eax,%eax
f0119452:	0f 84 b2 01 00 00    	je     f011960a <sys_utilities+0x84c>
	/*else if (strcmp(utilityName, "__getKernelSBreak__") == 0)
	{
		uint32* ksbrk = (uint32*) value ;
		*ksbrk = (uint32)sbrk(0);
	}*/
	else if (strcmp(utilityName, "__changeInterruptStatus__") == 0)
f0119458:	83 ec 08             	sub    $0x8,%esp
f011945b:	68 b8 5a 13 f0       	push   $0xf0135ab8
f0119460:	ff 75 08             	pushl  0x8(%ebp)
f0119463:	e8 1f 18 00 00       	call   f011ac87 <strcmp>
f0119468:	83 c4 10             	add    $0x10,%esp
f011946b:	85 c0                	test   %eax,%eax
f011946d:	0f 85 96 00 00 00    	jne    f0119509 <sys_utilities+0x74b>
	{
		if (value == 0)
f0119473:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f0119477:	75 43                	jne    f01194bc <sys_utilities+0x6fe>
		{
			kclock_stop();
f0119479:	e8 9d c8 fe ff       	call   f0105d1b <kclock_stop>
 */
//clear interrupt flag
static __inline void
cli(void)
{
	__asm __volatile("cli");
f011947e:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f011947f:	e8 94 26 ff ff       	call   f010bb18 <get_cpu_proc>
f0119484:	89 45 cc             	mov    %eax,-0x34(%ebp)
			if (p == NULL)
f0119487:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
f011948b:	75 17                	jne    f01194a4 <sys_utilities+0x6e6>
			{
				panic("cons_lock: no running process to block");
f011948d:	83 ec 04             	sub    $0x4,%esp
f0119490:	68 d4 5a 13 f0       	push   $0xf0135ad4
f0119495:	68 67 01 00 00       	push   $0x167
f011949a:	68 8f 57 13 f0       	push   $0xf013578f
f011949f:	e8 0b 7b fe ff       	call   f0100faf <_panic>
			}
			p->env_tf->tf_eflags &= ~FL_IF ;
f01194a4:	8b 45 cc             	mov    -0x34(%ebp),%eax
f01194a7:	8b 00                	mov    (%eax),%eax
f01194a9:	8b 55 cc             	mov    -0x34(%ebp),%edx
f01194ac:	8b 12                	mov    (%edx),%edx
f01194ae:	8b 52 38             	mov    0x38(%edx),%edx
f01194b1:	80 e6 fd             	and    $0xfd,%dh
f01194b4:	89 50 38             	mov    %edx,0x38(%eax)
f01194b7:	e9 4e 01 00 00       	jmp    f011960a <sys_utilities+0x84c>
			//cprintf("\nINTERRUPT WILL BE DISABLED\n");
		}
		else if (value == 1)
f01194bc:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f01194c0:	0f 85 44 01 00 00    	jne    f011960a <sys_utilities+0x84c>
		{
			kclock_stop();
f01194c6:	e8 50 c8 fe ff       	call   f0105d1b <kclock_stop>
f01194cb:	fa                   	cli    
			cli();
			struct Env * p = get_cpu_proc();
f01194cc:	e8 47 26 ff ff       	call   f010bb18 <get_cpu_proc>
f01194d1:	89 45 c8             	mov    %eax,-0x38(%ebp)
			if (p == NULL)
f01194d4:	83 7d c8 00          	cmpl   $0x0,-0x38(%ebp)
f01194d8:	75 17                	jne    f01194f1 <sys_utilities+0x733>
			{
				panic("cons_unlock: no running process to block");
f01194da:	83 ec 04             	sub    $0x4,%esp
f01194dd:	68 fc 5a 13 f0       	push   $0xf0135afc
f01194e2:	68 73 01 00 00       	push   $0x173
f01194e7:	68 8f 57 13 f0       	push   $0xf013578f
f01194ec:	e8 be 7a fe ff       	call   f0100faf <_panic>
			}
			p->env_tf->tf_eflags |= FL_IF ;
f01194f1:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01194f4:	8b 00                	mov    (%eax),%eax
f01194f6:	8b 55 c8             	mov    -0x38(%ebp),%edx
f01194f9:	8b 12                	mov    (%edx),%edx
f01194fb:	8b 52 38             	mov    0x38(%edx),%edx
f01194fe:	80 ce 02             	or     $0x2,%dh
f0119501:	89 50 38             	mov    %edx,0x38(%eax)
f0119504:	e9 01 01 00 00       	jmp    f011960a <sys_utilities+0x84c>
			//cprintf("\nINTERRUPT WILL BE ENABLED\n");
		}
	}
	else if (strncmp(utilityName, "__getProcState@", strlen("__getProcState@")) == 0)
f0119509:	83 ec 0c             	sub    $0xc,%esp
f011950c:	68 25 5b 13 f0       	push   $0xf0135b25
f0119511:	e8 65 16 00 00       	call   f011ab7b <strlen>
f0119516:	83 c4 10             	add    $0x10,%esp
f0119519:	83 ec 04             	sub    $0x4,%esp
f011951c:	50                   	push   %eax
f011951d:	68 25 5b 13 f0       	push   $0xf0135b25
f0119522:	ff 75 08             	pushl  0x8(%ebp)
f0119525:	e8 95 17 00 00       	call   f011acbf <strncmp>
f011952a:	83 c4 10             	add    $0x10,%esp
f011952d:	85 c0                	test   %eax,%eax
f011952f:	0f 85 ac 00 00 00    	jne    f01195e1 <sys_utilities+0x823>
	{
		int number_of_tokens;
		//allocate array of char * of size MAX_ARGUMENTS = 16 found in string.h
		char *tokens[MAX_ARGUMENTS];
		strsplit(utilityName, "@", tokens, &number_of_tokens) ;
f0119535:	8d 85 7c ff ff ff    	lea    -0x84(%ebp),%eax
f011953b:	50                   	push   %eax
f011953c:	8d 85 38 ff ff ff    	lea    -0xc8(%ebp),%eax
f0119542:	50                   	push   %eax
f0119543:	68 02 58 13 f0       	push   $0xf0135802
f0119548:	ff 75 08             	pushl  0x8(%ebp)
f011954b:	e8 ef 1c 00 00       	call   f011b23f <strsplit>
f0119550:	83 c4 10             	add    $0x10,%esp
		int envID = strtol(tokens[1], NULL, 10);
f0119553:	8b 85 3c ff ff ff    	mov    -0xc4(%ebp),%eax
f0119559:	83 ec 04             	sub    $0x4,%esp
f011955c:	6a 0a                	push   $0xa
f011955e:	6a 00                	push   $0x0
f0119560:	50                   	push   %eax
f0119561:	e8 24 1a 00 00       	call   f011af8a <strtol>
f0119566:	83 c4 10             	add    $0x10,%esp
f0119569:	89 45 dc             	mov    %eax,-0x24(%ebp)
		struct Env* env = NULL ;
f011956c:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%ebp)
f0119573:	00 00 00 
		int ret = envid2env(envID, &env, 0);
f0119576:	83 ec 04             	sub    $0x4,%esp
f0119579:	6a 00                	push   $0x0
f011957b:	8d 85 78 ff ff ff    	lea    -0x88(%ebp),%eax
f0119581:	50                   	push   %eax
f0119582:	ff 75 dc             	pushl  -0x24(%ebp)
f0119585:	e8 de 25 ff ff       	call   f010bb68 <envid2env>
f011958a:	83 c4 10             	add    $0x10,%esp
f011958d:	89 45 d8             	mov    %eax,-0x28(%ebp)
		uint32* procState = (uint32*) value ;
f0119590:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119593:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if (ret == E_BAD_ENV)
f0119596:	83 7d d8 fe          	cmpl   $0xfffffffe,-0x28(%ebp)
f011959a:	75 0e                	jne    f01195aa <sys_utilities+0x7ec>
		{
			//cprintf("\n\n<<<<<<<<<<< BAD ENV >>>>>>>>>>>\n\n");
			*procState = E_BAD_ENV;
f011959c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f011959f:	c7 00 fe ff ff ff    	movl   $0xfffffffe,(%eax)
f01195a5:	e9 5d 01 00 00       	jmp    f0119707 <sys_utilities+0x949>
			return;
		}
		else
		{
			assert(env->env_id == envID) ;
f01195aa:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01195b0:	8b 40 10             	mov    0x10(%eax),%eax
f01195b3:	3b 45 dc             	cmp    -0x24(%ebp),%eax
f01195b6:	74 19                	je     f01195d1 <sys_utilities+0x813>
f01195b8:	68 04 58 13 f0       	push   $0xf0135804
f01195bd:	68 47 57 13 f0       	push   $0xf0135747
f01195c2:	68 8b 01 00 00       	push   $0x18b
f01195c7:	68 8f 57 13 f0       	push   $0xf013578f
f01195cc:	e8 de 79 fe ff       	call   f0100faf <_panic>
			*procState = env->env_status;
f01195d1:	8b 85 78 ff ff ff    	mov    -0x88(%ebp),%eax
f01195d7:	8b 50 18             	mov    0x18(%eax),%edx
f01195da:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f01195dd:	89 10                	mov    %edx,(%eax)
f01195df:	eb 29                	jmp    f011960a <sys_utilities+0x84c>
		}
	}
	else if (strcmp(utilityName, "__IsOPTRepl__") == 0)
f01195e1:	83 ec 08             	sub    $0x8,%esp
f01195e4:	68 35 5b 13 f0       	push   $0xf0135b35
f01195e9:	ff 75 08             	pushl  0x8(%ebp)
f01195ec:	e8 96 16 00 00       	call   f011ac87 <strcmp>
f01195f1:	83 c4 10             	add    $0x10,%esp
f01195f4:	85 c0                	test   %eax,%eax
f01195f6:	75 12                	jne    f011960a <sys_utilities+0x84c>
	{
		uint32* isOPTRepl = (uint32*) value ;
f01195f8:	8b 45 0c             	mov    0xc(%ebp),%eax
f01195fb:	89 45 d0             	mov    %eax,-0x30(%ebp)
		*isOPTRepl = isPageReplacmentAlgorithmOPTIMAL();
f01195fe:	e8 bd 63 ff ff       	call   f010f9c0 <isPageReplacmentAlgorithmOPTIMAL>
f0119603:	89 c2                	mov    %eax,%edx
f0119605:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119608:	89 10                	mov    %edx,(%eax)
	}
	if ((int)value < 0)
f011960a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011960e:	0f 89 f3 00 00 00    	jns    f0119707 <sys_utilities+0x949>
	{
		if (strcmp(utilityName, "__ReplStrat__") == 0)
f0119614:	83 ec 08             	sub    $0x8,%esp
f0119617:	68 43 5b 13 f0       	push   $0xf0135b43
f011961c:	ff 75 08             	pushl  0x8(%ebp)
f011961f:	e8 63 16 00 00       	call   f011ac87 <strcmp>
f0119624:	83 c4 10             	add    $0x10,%esp
f0119627:	85 c0                	test   %eax,%eax
f0119629:	0f 85 d8 00 00 00    	jne    f0119707 <sys_utilities+0x949>
		{
			switch (value)
f011962f:	8b 45 0c             	mov    0xc(%ebp),%eax
f0119632:	83 c0 08             	add    $0x8,%eax
f0119635:	83 f8 07             	cmp    $0x7,%eax
f0119638:	0f 87 c8 00 00 00    	ja     f0119706 <sys_utilities+0x948>
f011963e:	8b 04 85 90 5e 13 f0 	mov    -0xfeca170(,%eax,4),%eax
f0119645:	ff e0                	jmp    *%eax
			{
			case -PG_REP_FIFO:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO FIFO.\n*************************************\n");
f0119647:	83 ec 0c             	sub    $0xc,%esp
f011964a:	68 54 5b 13 f0       	push   $0xf0135b54
f011964f:	e8 08 86 fe ff       	call   f0101c5c <cprintf>
f0119654:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmFIFO();
f0119657:	e8 61 62 ff ff       	call   f010f8bd <setPageReplacmentAlgorithmFIFO>
				break;
f011965c:	e9 a6 00 00 00       	jmp    f0119707 <sys_utilities+0x949>
			case -PG_REP_CLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO CLOCK.\n*************************************\n");
f0119661:	83 ec 0c             	sub    $0xc,%esp
f0119664:	68 c4 5b 13 f0       	push   $0xf0135bc4
f0119669:	e8 ee 85 fe ff       	call   f0101c5c <cprintf>
f011966e:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmCLOCK();
f0119671:	e8 37 62 ff ff       	call   f010f8ad <setPageReplacmentAlgorithmCLOCK>
				break;
f0119676:	e9 8c 00 00 00       	jmp    f0119707 <sys_utilities+0x949>
			case -PG_REP_MODIFIEDCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO MODIFIED CLOCK.\n*************************************\n");
f011967b:	83 ec 0c             	sub    $0xc,%esp
f011967e:	68 34 5c 13 f0       	push   $0xf0135c34
f0119683:	e8 d4 85 fe ff       	call   f0101c5c <cprintf>
f0119688:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmModifiedCLOCK();
f011968b:	e8 3d 62 ff ff       	call   f010f8cd <setPageReplacmentAlgorithmModifiedCLOCK>
				break;
f0119690:	eb 75                	jmp    f0119707 <sys_utilities+0x949>
			case -PG_REP_OPTIMAL:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO OPTIMAL.\n*************************************\n");
f0119692:	83 ec 0c             	sub    $0xc,%esp
f0119695:	68 b0 5c 13 f0       	push   $0xf0135cb0
f011969a:	e8 bd 85 fe ff       	call   f0101c5c <cprintf>
f011969f:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmOPTIMAL();
f01196a2:	e8 6c 62 ff ff       	call   f010f913 <setPageReplacmentAlgorithmOPTIMAL>
				break;
f01196a7:	eb 5e                	jmp    f0119707 <sys_utilities+0x949>
			case -PG_REP_LRU_TIME_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU AGING.\n*************************************\n");
f01196a9:	83 ec 0c             	sub    $0xc,%esp
f01196ac:	68 24 5d 13 f0       	push   $0xf0135d24
f01196b1:	e8 a6 85 fe ff       	call   f0101c5c <cprintf>
f01196b6:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_TIME_APPROX);
f01196b9:	83 ec 0c             	sub    $0xc,%esp
f01196bc:	6a 01                	push   $0x1
f01196be:	e8 b7 61 ff ff       	call   f010f87a <setPageReplacmentAlgorithmLRU>
f01196c3:	83 c4 10             	add    $0x10,%esp
				break;
f01196c6:	eb 3f                	jmp    f0119707 <sys_utilities+0x949>
			case -PG_REP_LRU_LISTS_APPROX:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO LRU LISTS.\n*************************************\n");
f01196c8:	83 ec 0c             	sub    $0xc,%esp
f01196cb:	68 98 5d 13 f0       	push   $0xf0135d98
f01196d0:	e8 87 85 fe ff       	call   f0101c5c <cprintf>
f01196d5:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmLRU(PG_REP_LRU_LISTS_APPROX);
f01196d8:	83 ec 0c             	sub    $0xc,%esp
f01196db:	6a 02                	push   $0x2
f01196dd:	e8 98 61 ff ff       	call   f010f87a <setPageReplacmentAlgorithmLRU>
f01196e2:	83 c4 10             	add    $0x10,%esp
				break;
f01196e5:	eb 20                	jmp    f0119707 <sys_utilities+0x949>
			case -PG_REP_NchanceCLOCK:
				cprintf("\n*************************************\nPAGE REPLACEMENT IS SET TO Nth Clock Normal (N=1).\n*************************************\n");
f01196e7:	83 ec 0c             	sub    $0xc,%esp
f01196ea:	68 0c 5e 13 f0       	push   $0xf0135e0c
f01196ef:	e8 68 85 fe ff       	call   f0101c5c <cprintf>
f01196f4:	83 c4 10             	add    $0x10,%esp
				setPageReplacmentAlgorithmNchanceCLOCK(1);
f01196f7:	83 ec 0c             	sub    $0xc,%esp
f01196fa:	6a 01                	push   $0x1
f01196fc:	e8 ec 61 ff ff       	call   f010f8ed <setPageReplacmentAlgorithmNchanceCLOCK>
f0119701:	83 c4 10             	add    $0x10,%esp
				break;
f0119704:	eb 01                	jmp    f0119707 <sys_utilities+0x949>
			default:
				break;
f0119706:	90                   	nop
			}
		}
	}
	/*****************************************************************************************/

}
f0119707:	c9                   	leave  
f0119708:	c3                   	ret    

f0119709 <detect_loop_in_FrameInfo_list>:
/*=======================================*/
void detect_loop_in_FrameInfo_list(struct FrameInfo_List* fi_list)
{
f0119709:	55                   	push   %ebp
f011970a:	89 e5                	mov    %esp,%ebp
f011970c:	83 ec 18             	sub    $0x18,%esp
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
f011970f:	8b 45 08             	mov    0x8(%ebp),%eax
f0119712:	8b 00                	mov    (%eax),%eax
f0119714:	89 45 f4             	mov    %eax,-0xc(%ebp)
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);
f0119717:	8b 45 08             	mov    0x8(%ebp),%eax
f011971a:	8b 00                	mov    (%eax),%eax
f011971c:	89 45 f0             	mov    %eax,-0x10(%ebp)


	while (slowPtr && fastPtr) {
f011971f:	eb 52                	jmp    f0119773 <detect_loop_in_FrameInfo_list+0x6a>
		fastPtr = LIST_NEXT(fastPtr); // advance the fast pointer
f0119721:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119724:	8b 00                	mov    (%eax),%eax
f0119726:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) // and check if its equal to the slow pointer
f0119729:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011972c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011972f:	75 12                	jne    f0119743 <detect_loop_in_FrameInfo_list+0x3a>
		{
			cprintf("loop detected in modiflist\n");
f0119731:	83 ec 0c             	sub    $0xc,%esp
f0119734:	68 b0 5e 13 f0       	push   $0xf0135eb0
f0119739:	e8 1e 85 fe ff       	call   f0101c5c <cprintf>
f011973e:	83 c4 10             	add    $0x10,%esp
			break;
f0119741:	eb 3f                	jmp    f0119782 <detect_loop_in_FrameInfo_list+0x79>
		}

		if (fastPtr == NULL) {
f0119743:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119747:	74 38                	je     f0119781 <detect_loop_in_FrameInfo_list+0x78>
			break; // since fastPtr is NULL we reached the tail
		}

		fastPtr = LIST_NEXT(fastPtr); //advance and check again
f0119749:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011974c:	8b 00                	mov    (%eax),%eax
f011974e:	89 45 f0             	mov    %eax,-0x10(%ebp)
		if (fastPtr == slowPtr) {
f0119751:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119754:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119757:	75 12                	jne    f011976b <detect_loop_in_FrameInfo_list+0x62>
			cprintf("loop detected in list\n");
f0119759:	83 ec 0c             	sub    $0xc,%esp
f011975c:	68 cc 5e 13 f0       	push   $0xf0135ecc
f0119761:	e8 f6 84 fe ff       	call   f0101c5c <cprintf>
f0119766:	83 c4 10             	add    $0x10,%esp
			break;
f0119769:	eb 17                	jmp    f0119782 <detect_loop_in_FrameInfo_list+0x79>
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
f011976b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011976e:	8b 00                	mov    (%eax),%eax
f0119770:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
	struct  FrameInfo * slowPtr = LIST_FIRST(fi_list);
	struct  FrameInfo * fastPtr = LIST_FIRST(fi_list);


	while (slowPtr && fastPtr) {
f0119773:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0119777:	74 09                	je     f0119782 <detect_loop_in_FrameInfo_list+0x79>
f0119779:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011977d:	75 a2                	jne    f0119721 <detect_loop_in_FrameInfo_list+0x18>
f011977f:	eb 01                	jmp    f0119782 <detect_loop_in_FrameInfo_list+0x79>
			cprintf("loop detected in modiflist\n");
			break;
		}

		if (fastPtr == NULL) {
			break; // since fastPtr is NULL we reached the tail
f0119781:	90                   	nop
			break;
		}

		slowPtr = LIST_NEXT(slowPtr); // advance the slow pointer only once
	}
	cprintf("finished  loop detection\n");
f0119782:	83 ec 0c             	sub    $0xc,%esp
f0119785:	68 e3 5e 13 f0       	push   $0xf0135ee3
f011978a:	e8 cd 84 fe ff       	call   f0101c5c <cprintf>
f011978f:	83 c4 10             	add    $0x10,%esp
}
f0119792:	90                   	nop
f0119793:	c9                   	leave  
f0119794:	c3                   	ret    

f0119795 <scarce_memory>:

void scarce_memory()
{
f0119795:	55                   	push   %ebp
f0119796:	89 e5                	mov    %esp,%ebp
f0119798:	83 ec 28             	sub    $0x28,%esp
	uint32 total_size_tobe_allocated = ((100 - memory_scarce_threshold_percentage)*number_of_frames)/100;
f011979b:	a1 f0 e8 83 f0       	mov    0xf083e8f0,%eax
f01197a0:	ba 64 00 00 00       	mov    $0x64,%edx
f01197a5:	29 c2                	sub    %eax,%edx
f01197a7:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f01197ac:	0f af c2             	imul   %edx,%eax
f01197af:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f01197b4:	f7 e2                	mul    %edx
f01197b6:	89 d0                	mov    %edx,%eax
f01197b8:	c1 e8 05             	shr    $0x5,%eax
f01197bb:	89 45 f4             	mov    %eax,-0xc(%ebp)
	//	cprintf("total_size_tobe_allocated %d\n", number_of_frames);
	if (((100 - memory_scarce_threshold_percentage)*number_of_frames) % 100 > 0)
f01197be:	a1 f0 e8 83 f0       	mov    0xf083e8f0,%eax
f01197c3:	ba 64 00 00 00       	mov    $0x64,%edx
f01197c8:	29 c2                	sub    %eax,%edx
f01197ca:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f01197cf:	89 d1                	mov    %edx,%ecx
f01197d1:	0f af c8             	imul   %eax,%ecx
f01197d4:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f01197d9:	f7 e1                	mul    %ecx
f01197db:	c1 ea 05             	shr    $0x5,%edx
f01197de:	89 d0                	mov    %edx,%eax
f01197e0:	c1 e0 02             	shl    $0x2,%eax
f01197e3:	01 d0                	add    %edx,%eax
f01197e5:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f01197ec:	01 d0                	add    %edx,%eax
f01197ee:	c1 e0 02             	shl    $0x2,%eax
f01197f1:	29 c1                	sub    %eax,%ecx
f01197f3:	89 ca                	mov    %ecx,%edx
f01197f5:	85 d2                	test   %edx,%edx
f01197f7:	74 03                	je     f01197fc <scarce_memory+0x67>
		total_size_tobe_allocated++;
f01197f9:	ff 45 f4             	incl   -0xc(%ebp)

	int fflSize = 0;
f01197fc:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	acquire_kspinlock(&MemFrameLists.mfllock);
f0119803:	83 ec 0c             	sub    $0xc,%esp
f0119806:	68 e0 e7 83 f0       	push   $0xf083e7e0
f011980b:	e8 6b 66 ff ff       	call   f010fe7b <acquire_kspinlock>
f0119810:	83 c4 10             	add    $0x10,%esp
	{
		fflSize = LIST_SIZE(&MemFrameLists.free_frame_list);
f0119813:	a1 cc e7 83 f0       	mov    0xf083e7cc,%eax
f0119818:	89 45 ec             	mov    %eax,-0x14(%ebp)

		uint32 size_of_already_allocated = number_of_frames - fflSize ;
f011981b:	8b 15 b8 e9 83 f0    	mov    0xf083e9b8,%edx
f0119821:	8b 45 ec             	mov    -0x14(%ebp),%eax
f0119824:	29 c2                	sub    %eax,%edx
f0119826:	89 d0                	mov    %edx,%eax
f0119828:	89 45 e8             	mov    %eax,-0x18(%ebp)
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
f011982b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011982e:	2b 45 e8             	sub    -0x18(%ebp),%eax
f0119831:	89 45 e4             	mov    %eax,-0x1c(%ebp)
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
f0119834:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011983b:	eb 12                	jmp    f011984f <scarce_memory+0xba>
		{
			allocate_frame(&ptr_tmp_FI) ;
f011983d:	83 ec 0c             	sub    $0xc,%esp
f0119840:	8d 45 e0             	lea    -0x20(%ebp),%eax
f0119843:	50                   	push   %eax
f0119844:	e8 f9 f8 fe ff       	call   f0109142 <allocate_frame>
f0119849:	83 c4 10             	add    $0x10,%esp
		uint32 size_tobe_allocated = total_size_tobe_allocated - size_of_already_allocated;
		//	cprintf("size_of_already_allocated %d\n", size_of_already_allocated);
		//	cprintf("size to be allocated %d\n", size_tobe_allocated);
		int i = 0 ;
		struct FrameInfo* ptr_tmp_FI ;
		for (; i <= size_tobe_allocated ; i++)
f011984c:	ff 45 f0             	incl   -0x10(%ebp)
f011984f:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119852:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
f0119855:	76 e6                	jbe    f011983d <scarce_memory+0xa8>
		{
			allocate_frame(&ptr_tmp_FI) ;
		}
	}
	release_kspinlock(&MemFrameLists.mfllock);
f0119857:	83 ec 0c             	sub    $0xc,%esp
f011985a:	68 e0 e7 83 f0       	push   $0xf083e7e0
f011985f:	e8 bc 66 ff ff       	call   f010ff20 <release_kspinlock>
f0119864:	83 c4 10             	add    $0x10,%esp

}
f0119867:	90                   	nop
f0119868:	c9                   	leave  
f0119869:	c3                   	ret    

f011986a <calc_no_pages_tobe_removed_from_ready_exit_queues>:

uint32 calc_no_pages_tobe_removed_from_ready_exit_queues(uint32 WS_or_MEMORY_flag)
{
f011986a:	55                   	push   %ebp
f011986b:	89 e5                	mov    %esp,%ebp
f011986d:	83 ec 48             	sub    $0x48,%esp
	uint32 no_of_pages_tobe_removed_from_ready = 0;
f0119870:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	uint32 no_of_pages_tobe_removed_from_exit = 0;
f0119877:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	uint32 no_of_pages_tobe_removed_from_curenv = 0;
f011987e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
	struct Env* cur_env = get_cpu_proc();
f0119885:	e8 8e 22 ff ff       	call   f010bb18 <get_cpu_proc>
f011988a:	89 45 d0             	mov    %eax,-0x30(%ebp)
	assert(cur_env != NULL);
f011988d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0119891:	75 19                	jne    f01198ac <calc_no_pages_tobe_removed_from_ready_exit_queues+0x42>
f0119893:	68 fd 5e 13 f0       	push   $0xf0135efd
f0119898:	68 47 57 13 f0       	push   $0xf0135747
f011989d:	68 fd 01 00 00       	push   $0x1fd
f01198a2:	68 8f 57 13 f0       	push   $0xf013578f
f01198a7:	e8 03 77 fe ff       	call   f0100faf <_panic>
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
f01198ac:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
f01198b0:	0f 85 d6 01 00 00    	jne    f0119a8c <calc_no_pages_tobe_removed_from_ready_exit_queues+0x222>
	{
		acquire_kspinlock(&ProcessQueues.qlock);
f01198b6:	83 ec 0c             	sub    $0xc,%esp
f01198b9:	68 20 e7 83 f0       	push   $0xf083e720
f01198be:	e8 b8 65 ff ff       	call   f010fe7b <acquire_kspinlock>
f01198c3:	83 c4 10             	add    $0x10,%esp
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01198c6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
f01198cd:	e9 d2 00 00 00       	jmp    f01199a4 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x13a>
			{
				struct Env * ptr_ready_env = NULL;
f01198d2:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f01198d9:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f01198de:	8b 55 e8             	mov    -0x18(%ebp),%edx
f01198e1:	c1 e2 04             	shl    $0x4,%edx
f01198e4:	01 d0                	add    %edx,%eax
f01198e6:	8b 00                	mov    (%eax),%eax
f01198e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f01198eb:	eb 7c                	jmp    f0119969 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xff>
				{
#if USE_KHEAP
					int num_of_pages_in_WS = LIST_SIZE(&(ptr_ready_env->page_WS_list));
f01198ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f01198f0:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01198f6:	89 45 cc             	mov    %eax,-0x34(%ebp)
#else
					int num_of_pages_in_WS = env_page_ws_get_size(ptr_ready_env);
#endif
					int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f01198f9:	8b 45 d0             	mov    -0x30(%ebp),%eax
f01198fc:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119902:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119905:	0f af c2             	imul   %edx,%eax
f0119908:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f011990d:	f7 e2                	mul    %edx
f011990f:	89 d0                	mov    %edx,%eax
f0119911:	c1 e8 05             	shr    $0x5,%eax
f0119914:	89 45 e0             	mov    %eax,-0x20(%ebp)
					if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0119917:	8b 45 d0             	mov    -0x30(%ebp),%eax
f011991a:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119920:	8b 45 cc             	mov    -0x34(%ebp),%eax
f0119923:	89 d1                	mov    %edx,%ecx
f0119925:	0f af c8             	imul   %eax,%ecx
f0119928:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f011992d:	f7 e1                	mul    %ecx
f011992f:	c1 ea 05             	shr    $0x5,%edx
f0119932:	89 d0                	mov    %edx,%eax
f0119934:	c1 e0 02             	shl    $0x2,%eax
f0119937:	01 d0                	add    %edx,%eax
f0119939:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119940:	01 d0                	add    %edx,%eax
f0119942:	c1 e0 02             	shl    $0x2,%eax
f0119945:	29 c1                	sub    %eax,%ecx
f0119947:	89 ca                	mov    %ecx,%edx
f0119949:	85 d2                	test   %edx,%edx
f011994b:	74 03                	je     f0119950 <calc_no_pages_tobe_removed_from_ready_exit_queues+0xe6>
						num_of_pages_to_be_removed++;
f011994d:	ff 45 e0             	incl   -0x20(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
f0119950:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119953:	01 45 f4             	add    %eax,-0xc(%ebp)
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
			{
				struct Env * ptr_ready_env = NULL;
				LIST_FOREACH(ptr_ready_env, &(ProcessQueues.env_ready_queues[i]))
f0119956:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f011995b:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011995e:	c1 e2 04             	shl    $0x4,%edx
f0119961:	01 d0                	add    %edx,%eax
f0119963:	8b 40 08             	mov    0x8(%eax),%eax
f0119966:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f0119969:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f011996e:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119971:	c1 e2 04             	shl    $0x4,%edx
f0119974:	01 d0                	add    %edx,%eax
f0119976:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011997a:	74 08                	je     f0119984 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11a>
f011997c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011997f:	8b 52 08             	mov    0x8(%edx),%edx
f0119982:	eb 05                	jmp    f0119989 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x11f>
f0119984:	ba 00 00 00 00       	mov    $0x0,%edx
f0119989:	89 50 08             	mov    %edx,0x8(%eax)
f011998c:	8b 40 08             	mov    0x8(%eax),%eax
f011998f:	85 c0                	test   %eax,%eax
f0119991:	0f 85 56 ff ff ff    	jne    f01198ed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
f0119997:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011999b:	0f 85 4c ff ff ff    	jne    f01198ed <calc_no_pages_tobe_removed_from_ready_exit_queues+0x83>
	assert(cur_env != NULL);
	if(WS_or_MEMORY_flag == 1)	// THEN MEMORY SHALL BE FREED
	{
		acquire_kspinlock(&ProcessQueues.qlock);
		{
			for(int i = 0; i < num_of_ready_queues; i++)
f01199a1:	ff 45 e8             	incl   -0x18(%ebp)
f01199a4:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f01199a9:	0f b6 c0             	movzbl %al,%eax
f01199ac:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f01199af:	0f 8f 1d ff ff ff    	jg     f01198d2 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x68>
						num_of_pages_to_be_removed++;
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
f01199b5:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01199bc:	a1 a0 e7 83 f0       	mov    0xf083e7a0,%eax
f01199c1:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01199c4:	eb 1a                	jmp    f01199e0 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x176>
			{
#if USE_KHEAP
				int num_of_pages_in_WS = LIST_SIZE(&(ptr_exit_env->page_WS_list));
f01199c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01199c9:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f01199cf:	89 45 c8             	mov    %eax,-0x38(%ebp)
#else
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
f01199d2:	8b 45 c8             	mov    -0x38(%ebp),%eax
f01199d5:	01 45 f0             	add    %eax,-0x10(%ebp)
					no_of_pages_tobe_removed_from_ready += num_of_pages_to_be_removed;
				}
			}

			struct Env * ptr_exit_env = NULL;
			LIST_FOREACH(ptr_exit_env, &ProcessQueues.env_exit_queue)
f01199d8:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01199dd:	89 45 dc             	mov    %eax,-0x24(%ebp)
f01199e0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f01199e4:	74 08                	je     f01199ee <calc_no_pages_tobe_removed_from_ready_exit_queues+0x184>
f01199e6:	8b 45 dc             	mov    -0x24(%ebp),%eax
f01199e9:	8b 40 08             	mov    0x8(%eax),%eax
f01199ec:	eb 05                	jmp    f01199f3 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x189>
f01199ee:	b8 00 00 00 00       	mov    $0x0,%eax
f01199f3:	a3 a8 e7 83 f0       	mov    %eax,0xf083e7a8
f01199f8:	a1 a8 e7 83 f0       	mov    0xf083e7a8,%eax
f01199fd:	85 c0                	test   %eax,%eax
f01199ff:	75 c5                	jne    f01199c6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
f0119a01:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f0119a05:	75 bf                	jne    f01199c6 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x15c>
				int num_of_pages_in_WS = env_page_ws_get_size(ptr_exit_env);
#endif
				no_of_pages_tobe_removed_from_exit += num_of_pages_in_WS;
			}
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119a07:	83 ec 0c             	sub    $0xc,%esp
f0119a0a:	68 20 e7 83 f0       	push   $0xf083e720
f0119a0f:	e8 0c 65 ff ff       	call   f010ff20 <release_kspinlock>
f0119a14:	83 c4 10             	add    $0x10,%esp
		if(cur_env != NULL)
f0119a17:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
f0119a1b:	0f 84 d4 00 00 00    	je     f0119af5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		{
#if USE_KHEAP
			int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0119a21:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119a24:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0119a2a:	89 45 c4             	mov    %eax,-0x3c(%ebp)
#else
			int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
			int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0119a2d:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119a30:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119a36:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119a39:	0f af c2             	imul   %edx,%eax
f0119a3c:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0119a41:	f7 e2                	mul    %edx
f0119a43:	89 d0                	mov    %edx,%eax
f0119a45:	c1 e8 05             	shr    $0x5,%eax
f0119a48:	89 45 d8             	mov    %eax,-0x28(%ebp)
			if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0119a4b:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119a4e:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119a54:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f0119a57:	89 d1                	mov    %edx,%ecx
f0119a59:	0f af c8             	imul   %eax,%ecx
f0119a5c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119a61:	f7 e1                	mul    %ecx
f0119a63:	c1 ea 05             	shr    $0x5,%edx
f0119a66:	89 d0                	mov    %edx,%eax
f0119a68:	c1 e0 02             	shl    $0x2,%eax
f0119a6b:	01 d0                	add    %edx,%eax
f0119a6d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119a74:	01 d0                	add    %edx,%eax
f0119a76:	c1 e0 02             	shl    $0x2,%eax
f0119a79:	29 c1                	sub    %eax,%ecx
f0119a7b:	89 ca                	mov    %ecx,%edx
f0119a7d:	85 d2                	test   %edx,%edx
f0119a7f:	74 03                	je     f0119a84 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x21a>
				num_of_pages_to_be_removed++;
f0119a81:	ff 45 d8             	incl   -0x28(%ebp)
			no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0119a84:	8b 45 d8             	mov    -0x28(%ebp),%eax
f0119a87:	89 45 ec             	mov    %eax,-0x14(%ebp)
f0119a8a:	eb 69                	jmp    f0119af5 <calc_no_pages_tobe_removed_from_ready_exit_queues+0x28b>
		}
	}
	else	// THEN RAPID PROCESS SHALL BE FREED ONLY
	{
#if USE_KHEAP
		int num_of_pages_in_WS = LIST_SIZE(&(cur_env->page_WS_list));
f0119a8c:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119a8f:	8b 80 94 00 00 00    	mov    0x94(%eax),%eax
f0119a95:	89 45 c0             	mov    %eax,-0x40(%ebp)
#else
		int num_of_pages_in_WS = env_page_ws_get_size(cur_env);
#endif
		int num_of_pages_to_be_removed = cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS / 100;
f0119a98:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119a9b:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119aa1:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119aa4:	0f af c2             	imul   %edx,%eax
f0119aa7:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
f0119aac:	f7 e2                	mul    %edx
f0119aae:	89 d0                	mov    %edx,%eax
f0119ab0:	c1 e8 05             	shr    $0x5,%eax
f0119ab3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		if ((cur_env->percentage_of_WS_pages_to_be_removed * num_of_pages_in_WS) % 100 > 0)
f0119ab6:	8b 45 d0             	mov    -0x30(%ebp),%eax
f0119ab9:	8b 90 94 05 00 00    	mov    0x594(%eax),%edx
f0119abf:	8b 45 c0             	mov    -0x40(%ebp),%eax
f0119ac2:	89 d1                	mov    %edx,%ecx
f0119ac4:	0f af c8             	imul   %eax,%ecx
f0119ac7:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119acc:	f7 e1                	mul    %ecx
f0119ace:	c1 ea 05             	shr    $0x5,%edx
f0119ad1:	89 d0                	mov    %edx,%eax
f0119ad3:	c1 e0 02             	shl    $0x2,%eax
f0119ad6:	01 d0                	add    %edx,%eax
f0119ad8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119adf:	01 d0                	add    %edx,%eax
f0119ae1:	c1 e0 02             	shl    $0x2,%eax
f0119ae4:	29 c1                	sub    %eax,%ecx
f0119ae6:	89 ca                	mov    %ecx,%edx
f0119ae8:	85 d2                	test   %edx,%edx
f0119aea:	74 03                	je     f0119aef <calc_no_pages_tobe_removed_from_ready_exit_queues+0x285>
			num_of_pages_to_be_removed++;
f0119aec:	ff 45 d4             	incl   -0x2c(%ebp)
		no_of_pages_tobe_removed_from_curenv = num_of_pages_to_be_removed;
f0119aef:	8b 45 d4             	mov    -0x2c(%ebp),%eax
f0119af2:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	return no_of_pages_tobe_removed_from_curenv + no_of_pages_tobe_removed_from_ready + no_of_pages_tobe_removed_from_exit;
f0119af5:	8b 55 ec             	mov    -0x14(%ebp),%edx
f0119af8:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119afb:	01 c2                	add    %eax,%edx
f0119afd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119b00:	01 d0                	add    %edx,%eax
}
f0119b02:	c9                   	leave  
f0119b03:	c3                   	ret    

f0119b04 <schenv>:


void schenv()
{
f0119b04:	55                   	push   %ebp
f0119b05:	89 e5                	mov    %esp,%ebp
f0119b07:	83 ec 18             	sub    $0x18,%esp

	__nl = 0;
f0119b0a:	c6 05 dc 6d 85 f0 00 	movb   $0x0,0xf0856ddc
	__ne = NULL;
f0119b11:	c7 05 f4 6a 85 f0 00 	movl   $0x0,0xf0856af4
f0119b18:	00 00 00 
	acquire_kspinlock(&ProcessQueues.qlock);
f0119b1b:	83 ec 0c             	sub    $0xc,%esp
f0119b1e:	68 20 e7 83 f0       	push   $0xf083e720
f0119b23:	e8 53 63 ff ff       	call   f010fe7b <acquire_kspinlock>
f0119b28:	83 c4 10             	add    $0x10,%esp
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0119b2b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f0119b32:	eb 3f                	jmp    f0119b73 <schenv+0x6f>
		{
			if (queue_size(&(ProcessQueues.env_ready_queues[i])))
f0119b34:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119b39:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119b3c:	c1 e2 04             	shl    $0x4,%edx
f0119b3f:	01 d0                	add    %edx,%eax
f0119b41:	83 ec 0c             	sub    $0xc,%esp
f0119b44:	50                   	push   %eax
f0119b45:	e8 a9 c4 fe ff       	call   f0105ff3 <queue_size>
f0119b4a:	83 c4 10             	add    $0x10,%esp
f0119b4d:	85 c0                	test   %eax,%eax
f0119b4f:	74 1f                	je     f0119b70 <schenv+0x6c>
			{
				__ne = LIST_LAST(&(ProcessQueues.env_ready_queues[i]));
f0119b51:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119b56:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119b59:	c1 e2 04             	shl    $0x4,%edx
f0119b5c:	01 d0                	add    %edx,%eax
f0119b5e:	8b 40 04             	mov    0x4(%eax),%eax
f0119b61:	a3 f4 6a 85 f0       	mov    %eax,0xf0856af4
				__nl = i;
f0119b66:	8b 45 f4             	mov    -0xc(%ebp),%eax
f0119b69:	a2 dc 6d 85 f0       	mov    %al,0xf0856ddc
				break;
f0119b6e:	eb 10                	jmp    f0119b80 <schenv+0x7c>

	__nl = 0;
	__ne = NULL;
	acquire_kspinlock(&ProcessQueues.qlock);
	{
		for (int i = 0; i < num_of_ready_queues; ++i)
f0119b70:	ff 45 f4             	incl   -0xc(%ebp)
f0119b73:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0119b78:	0f b6 c0             	movzbl %al,%eax
f0119b7b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f0119b7e:	7f b4                	jg     f0119b34 <schenv+0x30>
				__nl = i;
				break;
			}
		}
	}
	release_kspinlock(&ProcessQueues.qlock);
f0119b80:	83 ec 0c             	sub    $0xc,%esp
f0119b83:	68 20 e7 83 f0       	push   $0xf083e720
f0119b88:	e8 93 63 ff ff       	call   f010ff20 <release_kspinlock>
f0119b8d:	83 c4 10             	add    $0x10,%esp
	struct Env* cur_env = get_cpu_proc();
f0119b90:	e8 83 1f ff ff       	call   f010bb18 <get_cpu_proc>
f0119b95:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (cur_env != NULL)
f0119b98:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119b9c:	0f 84 82 00 00 00    	je     f0119c24 <schenv+0x120>
	{
		if (__ne != NULL)
f0119ba2:	a1 f4 6a 85 f0       	mov    0xf0856af4,%eax
f0119ba7:	85 c0                	test   %eax,%eax
f0119ba9:	74 49                	je     f0119bf4 <schenv+0xf0>
		{
			if ((__pl + 1) < __nl)
f0119bab:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119bb0:	0f b6 c0             	movzbl %al,%eax
f0119bb3:	8d 50 01             	lea    0x1(%eax),%edx
f0119bb6:	a0 dc 6d 85 f0       	mov    0xf0856ddc,%al
f0119bbb:	0f b6 c0             	movzbl %al,%eax
f0119bbe:	39 c2                	cmp    %eax,%edx
f0119bc0:	7d 62                	jge    f0119c24 <schenv+0x120>
			{
				__ne = cur_env;
f0119bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119bc5:	a3 f4 6a 85 f0       	mov    %eax,0xf0856af4
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0119bca:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119bcf:	0f b6 c0             	movzbl %al,%eax
f0119bd2:	8a 15 60 6d 85 f0    	mov    0xf0856d60,%dl
f0119bd8:	0f b6 d2             	movzbl %dl,%edx
f0119bdb:	4a                   	dec    %edx
f0119bdc:	39 d0                	cmp    %edx,%eax
f0119bde:	7d 08                	jge    f0119be8 <schenv+0xe4>
f0119be0:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119be5:	40                   	inc    %eax
f0119be6:	eb 05                	jmp    f0119bed <schenv+0xe9>
f0119be8:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119bed:	a2 dc 6d 85 f0       	mov    %al,0xf0856ddc
		{
			__ne = cur_env;
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
		}
	}
}
f0119bf2:	eb 30                	jmp    f0119c24 <schenv+0x120>
				__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
			}
		}
		else
		{
			__ne = cur_env;
f0119bf4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f0119bf7:	a3 f4 6a 85 f0       	mov    %eax,0xf0856af4
			__nl = __pl < num_of_ready_queues-1? __pl + 1 : __pl ;
f0119bfc:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119c01:	0f b6 c0             	movzbl %al,%eax
f0119c04:	8a 15 60 6d 85 f0    	mov    0xf0856d60,%dl
f0119c0a:	0f b6 d2             	movzbl %dl,%edx
f0119c0d:	4a                   	dec    %edx
f0119c0e:	39 d0                	cmp    %edx,%eax
f0119c10:	7d 08                	jge    f0119c1a <schenv+0x116>
f0119c12:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119c17:	40                   	inc    %eax
f0119c18:	eb 05                	jmp    f0119c1f <schenv+0x11b>
f0119c1a:	a0 01 e7 83 f0       	mov    0xf083e701,%al
f0119c1f:	a2 dc 6d 85 f0       	mov    %al,0xf0856ddc
		}
	}
}
f0119c24:	90                   	nop
f0119c25:	c9                   	leave  
f0119c26:	c3                   	ret    

f0119c27 <chksch>:

void chksch(uint8 onoff)
{
f0119c27:	55                   	push   %ebp
f0119c28:	89 e5                	mov    %esp,%ebp
f0119c2a:	83 ec 18             	sub    $0x18,%esp
f0119c2d:	8b 45 08             	mov    0x8(%ebp),%eax
f0119c30:	88 45 f4             	mov    %al,-0xc(%ebp)
	//		__pl = 0 ;
	//		__nl = 0 ;
	//	}

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0119c33:	e8 85 db fe ff       	call   f01077bd <isSchedMethodBSD>
f0119c38:	85 c0                	test   %eax,%eax
f0119c3a:	74 48                	je     f0119c84 <chksch+0x5d>
	{
		__histla = __pla = get_load_average();
f0119c3c:	e8 00 db fe ff       	call   f0107741 <get_load_average>
f0119c41:	a3 7c 6d 85 f0       	mov    %eax,0xf0856d7c
f0119c46:	a1 7c 6d 85 f0       	mov    0xf0856d7c,%eax
f0119c4b:	a3 bc e9 83 f0       	mov    %eax,0xf083e9bc
		acquire_kspinlock(&ProcessQueues.qlock);
f0119c50:	83 ec 0c             	sub    $0xc,%esp
f0119c53:	68 20 e7 83 f0       	push   $0xf083e720
f0119c58:	e8 1e 62 ff ff       	call   f010fe7b <acquire_kspinlock>
f0119c5d:	83 c4 10             	add    $0x10,%esp
		{
			__pnexit = LIST_SIZE(&ProcessQueues.env_exit_queue) ;
f0119c60:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0119c65:	a3 50 e8 83 f0       	mov    %eax,0xf083e850
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119c6a:	83 ec 0c             	sub    $0xc,%esp
f0119c6d:	68 20 e7 83 f0       	push   $0xf083e720
f0119c72:	e8 a9 62 ff ff       	call   f010ff20 <release_kspinlock>
f0119c77:	83 c4 10             	add    $0x10,%esp
		__firsttime = 1;
f0119c7a:	c7 05 04 6b 85 f0 01 	movl   $0x1,0xf0856b04
f0119c81:	00 00 00 
	}
	__chkstatus = onoff;
f0119c84:	8a 45 f4             	mov    -0xc(%ebp),%al
f0119c87:	a2 ec 6a 85 f0       	mov    %al,0xf0856aec
}
f0119c8c:	90                   	nop
f0119c8d:	c9                   	leave  
f0119c8e:	c3                   	ret    

f0119c8f <chk1>:
void chk1()
{
f0119c8f:	55                   	push   %ebp
f0119c90:	89 e5                	mov    %esp,%ebp
	//			__pl = 0;
	//		}
	//		//cprintf("chk1: current = %s @ level %d\n", __pe == NULL? "NULL" : __pe->prog_name, __pl);
	//		schenv();
	//	}
}
f0119c92:	90                   	nop
f0119c93:	5d                   	pop    %ebp
f0119c94:	c3                   	ret    

f0119c95 <chk2>:
void chk2(struct Env* __se)
{
f0119c95:	55                   	push   %ebp
f0119c96:	89 e5                	mov    %esp,%ebp
f0119c98:	83 ec 28             	sub    $0x28,%esp
	if (__chkstatus == 0)
f0119c9b:	a0 ec 6a 85 f0       	mov    0xf0856aec,%al
f0119ca0:	84 c0                	test   %al,%al
f0119ca2:	0f 84 59 03 00 00    	je     f011a001 <chk2+0x36c>
		return ;

	/*TEST BSD*/
	if (isSchedMethodBSD())
f0119ca8:	e8 10 db fe ff       	call   f01077bd <isSchedMethodBSD>
f0119cad:	85 c0                	test   %eax,%eax
f0119caf:	0f 84 4d 03 00 00    	je     f011a002 <chk2+0x36d>
	{
		__nla = get_load_average();
f0119cb5:	e8 87 da fe ff       	call   f0107741 <get_load_average>
f0119cba:	a3 f4 e8 83 f0       	mov    %eax,0xf083e8f4
		acquire_kspinlock(&ProcessQueues.qlock);
f0119cbf:	83 ec 0c             	sub    $0xc,%esp
f0119cc2:	68 20 e7 83 f0       	push   $0xf083e720
f0119cc7:	e8 af 61 ff ff       	call   f010fe7b <acquire_kspinlock>
f0119ccc:	83 c4 10             	add    $0x10,%esp
		{
			__nnexit = LIST_SIZE(&ProcessQueues.env_exit_queue);
f0119ccf:	a1 ac e7 83 f0       	mov    0xf083e7ac,%eax
f0119cd4:	a3 f8 6a 85 f0       	mov    %eax,0xf0856af8
		}
		release_kspinlock(&ProcessQueues.qlock);
f0119cd9:	83 ec 0c             	sub    $0xc,%esp
f0119cdc:	68 20 e7 83 f0       	push   $0xf083e720
f0119ce1:	e8 3a 62 ff ff       	call   f010ff20 <release_kspinlock>
f0119ce6:	83 c4 10             	add    $0x10,%esp

		if (__firsttime)
f0119ce9:	a1 04 6b 85 f0       	mov    0xf0856b04,%eax
f0119cee:	85 c0                	test   %eax,%eax
f0119cf0:	74 72                	je     f0119d64 <chk2+0xcf>
		{
			acquire_kspinlock(&ProcessQueues.qlock);
f0119cf2:	83 ec 0c             	sub    $0xc,%esp
f0119cf5:	68 20 e7 83 f0       	push   $0xf083e720
f0119cfa:	e8 7c 61 ff ff       	call   f010fe7b <acquire_kspinlock>
f0119cff:	83 c4 10             	add    $0x10,%esp
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
f0119d02:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0119d06:	0f 95 c0             	setne  %al
f0119d09:	0f b6 c0             	movzbl %al,%eax
f0119d0c:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119d11:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0119d16:	0f b6 c0             	movzbl %al,%eax
f0119d19:	48                   	dec    %eax
f0119d1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
f0119d1d:	eb 20                	jmp    f0119d3f <chk2+0xaa>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0119d1f:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119d24:	8b 55 f4             	mov    -0xc(%ebp),%edx
f0119d27:	c1 e2 04             	shl    $0x4,%edx
f0119d2a:	01 d0                	add    %edx,%eax
f0119d2c:	8b 40 0c             	mov    0xc(%eax),%eax
f0119d2f:	8b 15 34 6c 85 f0    	mov    0xf0856c34,%edx
f0119d35:	01 d0                	add    %edx,%eax
f0119d37:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
		{
			acquire_kspinlock(&ProcessQueues.qlock);
			{
				//Cnt #Processes
				__nproc = __se != NULL? 1 : 0;
				for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119d3c:	ff 4d f4             	decl   -0xc(%ebp)
f0119d3f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f0119d43:	79 da                	jns    f0119d1f <chk2+0x8a>
				{
					__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
				}
				__firsttime = 0;
f0119d45:	c7 05 04 6b 85 f0 00 	movl   $0x0,0xf0856b04
f0119d4c:	00 00 00 
			}
			release_kspinlock(&ProcessQueues.qlock);
f0119d4f:	83 ec 0c             	sub    $0xc,%esp
f0119d52:	68 20 e7 83 f0       	push   $0xf083e720
f0119d57:	e8 c4 61 ff ff       	call   f010ff20 <release_kspinlock>
f0119d5c:	83 c4 10             	add    $0x10,%esp
f0119d5f:	e9 91 02 00 00       	jmp    f0119ff5 <chk2+0x360>
		}
		else
		{
			if (__pnexit != __nnexit)
f0119d64:	8b 15 50 e8 83 f0    	mov    0xf083e850,%edx
f0119d6a:	a1 f8 6a 85 f0       	mov    0xf0856af8,%eax
f0119d6f:	39 c2                	cmp    %eax,%edx
f0119d71:	74 63                	je     f0119dd6 <chk2+0x141>
			{
				acquire_kspinlock(&ProcessQueues.qlock);
f0119d73:	83 ec 0c             	sub    $0xc,%esp
f0119d76:	68 20 e7 83 f0       	push   $0xf083e720
f0119d7b:	e8 fb 60 ff ff       	call   f010fe7b <acquire_kspinlock>
f0119d80:	83 c4 10             	add    $0x10,%esp
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
f0119d83:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f0119d87:	0f 95 c0             	setne  %al
f0119d8a:	0f b6 c0             	movzbl %al,%eax
f0119d8d:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119d92:	a0 60 6d 85 f0       	mov    0xf0856d60,%al
f0119d97:	0f b6 c0             	movzbl %al,%eax
f0119d9a:	48                   	dec    %eax
f0119d9b:	89 45 f0             	mov    %eax,-0x10(%ebp)
f0119d9e:	eb 20                	jmp    f0119dc0 <chk2+0x12b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
f0119da0:	a1 b0 e7 83 f0       	mov    0xf083e7b0,%eax
f0119da5:	8b 55 f0             	mov    -0x10(%ebp),%edx
f0119da8:	c1 e2 04             	shl    $0x4,%edx
f0119dab:	01 d0                	add    %edx,%eax
f0119dad:	8b 40 0c             	mov    0xc(%eax),%eax
f0119db0:	8b 15 34 6c 85 f0    	mov    0xf0856c34,%edx
f0119db6:	01 d0                	add    %edx,%eax
f0119db8:	a3 34 6c 85 f0       	mov    %eax,0xf0856c34
			{
				acquire_kspinlock(&ProcessQueues.qlock);
				{
					//Cnt #Processes
					__nproc = __se != NULL? 1 : 0;
					for (int l = num_of_ready_queues-1; l >= 0; --l)
f0119dbd:	ff 4d f0             	decl   -0x10(%ebp)
f0119dc0:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f0119dc4:	79 da                	jns    f0119da0 <chk2+0x10b>
					{
						__nproc += LIST_SIZE(&(ProcessQueues.env_ready_queues[l]));
					}
				}
				release_kspinlock(&ProcessQueues.qlock);
f0119dc6:	83 ec 0c             	sub    $0xc,%esp
f0119dc9:	68 20 e7 83 f0       	push   $0xf083e720
f0119dce:	e8 4d 61 ff ff       	call   f010ff20 <release_kspinlock>
f0119dd3:	83 c4 10             	add    $0x10,%esp
			}

			//Make sure that the la is changed over long period of time
			if (timer_ticks() % 1000 == 0)
f0119dd6:	e8 ff d8 fe ff       	call   f01076da <timer_ticks>
f0119ddb:	6a 00                	push   $0x0
f0119ddd:	68 e8 03 00 00       	push   $0x3e8
f0119de2:	52                   	push   %edx
f0119de3:	50                   	push   %eax
f0119de4:	e8 33 1a 00 00       	call   f011b81c <__moddi3>
f0119de9:	83 c4 10             	add    $0x10,%esp
f0119dec:	09 d0                	or     %edx,%eax
f0119dee:	85 c0                	test   %eax,%eax
f0119df0:	75 32                	jne    f0119e24 <chk2+0x18f>
			{
				assert_endall(__histla != __nla) ;
f0119df2:	8b 15 bc e9 83 f0    	mov    0xf083e9bc,%edx
f0119df8:	a1 f4 e8 83 f0       	mov    0xf083e8f4,%eax
f0119dfd:	39 c2                	cmp    %eax,%edx
f0119dff:	75 19                	jne    f0119e1a <chk2+0x185>
f0119e01:	68 0d 5f 13 f0       	push   $0xf0135f0d
f0119e06:	68 47 57 13 f0       	push   $0xf0135747
f0119e0b:	68 b9 02 00 00       	push   $0x2b9
f0119e10:	68 8f 57 13 f0       	push   $0xf013578f
f0119e15:	e8 24 72 fe ff       	call   f010103e <_panic_all>
				__histla = __nla;
f0119e1a:	a1 f4 e8 83 f0       	mov    0xf083e8f4,%eax
f0119e1f:	a3 bc e9 83 f0       	mov    %eax,0xf083e9bc
			}

			//check every 1 sec, assuming quantum >= 10
			if (timer_ticks() % 100 == 0)
f0119e24:	e8 b1 d8 fe ff       	call   f01076da <timer_ticks>
f0119e29:	6a 00                	push   $0x0
f0119e2b:	6a 64                	push   $0x64
f0119e2d:	52                   	push   %edx
f0119e2e:	50                   	push   %eax
f0119e2f:	e8 e8 19 00 00       	call   f011b81c <__moddi3>
f0119e34:	83 c4 10             	add    $0x10,%esp
f0119e37:	09 d0                	or     %edx,%eax
f0119e39:	85 c0                	test   %eax,%eax
f0119e3b:	0f 85 b4 01 00 00    	jne    f0119ff5 <chk2+0x360>
			{
				int plaint = __pla / 100 ;
f0119e41:	8b 0d 7c 6d 85 f0    	mov    0xf0856d7c,%ecx
f0119e47:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119e4c:	f7 e9                	imul   %ecx
f0119e4e:	c1 fa 05             	sar    $0x5,%edx
f0119e51:	89 c8                	mov    %ecx,%eax
f0119e53:	c1 f8 1f             	sar    $0x1f,%eax
f0119e56:	29 c2                	sub    %eax,%edx
f0119e58:	89 d0                	mov    %edx,%eax
f0119e5a:	89 45 ec             	mov    %eax,-0x14(%ebp)
				int plafrc = __pla % 100 ;
f0119e5d:	8b 0d 7c 6d 85 f0    	mov    0xf0856d7c,%ecx
f0119e63:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119e68:	f7 e9                	imul   %ecx
f0119e6a:	c1 fa 05             	sar    $0x5,%edx
f0119e6d:	89 c8                	mov    %ecx,%eax
f0119e6f:	c1 f8 1f             	sar    $0x1f,%eax
f0119e72:	29 c2                	sub    %eax,%edx
f0119e74:	89 d0                	mov    %edx,%eax
f0119e76:	89 45 e8             	mov    %eax,-0x18(%ebp)
f0119e79:	8b 55 e8             	mov    -0x18(%ebp),%edx
f0119e7c:	89 d0                	mov    %edx,%eax
f0119e7e:	c1 e0 02             	shl    $0x2,%eax
f0119e81:	01 d0                	add    %edx,%eax
f0119e83:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119e8a:	01 d0                	add    %edx,%eax
f0119e8c:	c1 e0 02             	shl    $0x2,%eax
f0119e8f:	29 c1                	sub    %eax,%ecx
f0119e91:	89 c8                	mov    %ecx,%eax
f0119e93:	89 45 e8             	mov    %eax,-0x18(%ebp)

				int nlaint = __nla / 100 ;
f0119e96:	8b 0d f4 e8 83 f0    	mov    0xf083e8f4,%ecx
f0119e9c:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119ea1:	f7 e9                	imul   %ecx
f0119ea3:	c1 fa 05             	sar    $0x5,%edx
f0119ea6:	89 c8                	mov    %ecx,%eax
f0119ea8:	c1 f8 1f             	sar    $0x1f,%eax
f0119eab:	29 c2                	sub    %eax,%edx
f0119ead:	89 d0                	mov    %edx,%eax
f0119eaf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				int nlafrc = __nla % 100 ;
f0119eb2:	8b 0d f4 e8 83 f0    	mov    0xf083e8f4,%ecx
f0119eb8:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
f0119ebd:	f7 e9                	imul   %ecx
f0119ebf:	c1 fa 05             	sar    $0x5,%edx
f0119ec2:	89 c8                	mov    %ecx,%eax
f0119ec4:	c1 f8 1f             	sar    $0x1f,%eax
f0119ec7:	29 c2                	sub    %eax,%edx
f0119ec9:	89 d0                	mov    %edx,%eax
f0119ecb:	89 45 e0             	mov    %eax,-0x20(%ebp)
f0119ece:	8b 55 e0             	mov    -0x20(%ebp),%edx
f0119ed1:	89 d0                	mov    %edx,%eax
f0119ed3:	c1 e0 02             	shl    $0x2,%eax
f0119ed6:	01 d0                	add    %edx,%eax
f0119ed8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f0119edf:	01 d0                	add    %edx,%eax
f0119ee1:	c1 e0 02             	shl    $0x2,%eax
f0119ee4:	29 c1                	sub    %eax,%ecx
f0119ee6:	89 c8                	mov    %ecx,%eax
f0119ee8:	89 45 e0             	mov    %eax,-0x20(%ebp)

				//Check at steady state of nproc (include equality)
				if (__nnexit == __pnexit)
f0119eeb:	8b 15 f8 6a 85 f0    	mov    0xf0856af8,%edx
f0119ef1:	a1 50 e8 83 f0       	mov    0xf083e850,%eax
f0119ef6:	39 c2                	cmp    %eax,%edx
f0119ef8:	0f 85 ed 00 00 00    	jne    f0119feb <chk2+0x356>
				{
					//cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
					if (__nproc > plaint)
f0119efe:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119f03:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119f06:	7e 5b                	jle    f0119f63 <chk2+0x2ce>
					{
						cprintf("++++++++++++++++++# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0119f08:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119f0d:	83 ec 08             	sub    $0x8,%esp
f0119f10:	ff 75 e0             	pushl  -0x20(%ebp)
f0119f13:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119f16:	ff 75 e8             	pushl  -0x18(%ebp)
f0119f19:	ff 75 ec             	pushl  -0x14(%ebp)
f0119f1c:	50                   	push   %eax
f0119f1d:	68 20 5f 13 f0       	push   $0xf0135f20
f0119f22:	e8 35 7d fe ff       	call   f0101c5c <cprintf>
f0119f27:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla > __pla);
						assert_endall((nlaint > plaint) || ((nlaint == plaint) && (nlafrc >= plafrc)));
f0119f2a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119f2d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119f30:	0f 8f b5 00 00 00    	jg     f0119feb <chk2+0x356>
f0119f36:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119f39:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119f3c:	75 0c                	jne    f0119f4a <chk2+0x2b5>
f0119f3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119f41:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119f44:	0f 8d a1 00 00 00    	jge    f0119feb <chk2+0x356>
f0119f4a:	68 68 5f 13 f0       	push   $0xf0135f68
f0119f4f:	68 47 57 13 f0       	push   $0xf0135747
f0119f54:	68 ce 02 00 00       	push   $0x2ce
f0119f59:	68 8f 57 13 f0       	push   $0xf013578f
f0119f5e:	e8 db 70 fe ff       	call   f010103e <_panic_all>
					}
					else if (__nproc < plaint)
f0119f63:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119f68:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119f6b:	7d 53                	jge    f0119fc0 <chk2+0x32b>
					{
						cprintf("------------------# processes = %d, prev la = %d.%d, next la = %d.%d\n", __nproc, plaint, plafrc, nlaint, nlafrc);
f0119f6d:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119f72:	83 ec 08             	sub    $0x8,%esp
f0119f75:	ff 75 e0             	pushl  -0x20(%ebp)
f0119f78:	ff 75 e4             	pushl  -0x1c(%ebp)
f0119f7b:	ff 75 e8             	pushl  -0x18(%ebp)
f0119f7e:	ff 75 ec             	pushl  -0x14(%ebp)
f0119f81:	50                   	push   %eax
f0119f82:	68 a8 5f 13 f0       	push   $0xf0135fa8
f0119f87:	e8 d0 7c fe ff       	call   f0101c5c <cprintf>
f0119f8c:	83 c4 20             	add    $0x20,%esp
						//assert_endall(__nla < __pla);
						assert_endall((nlaint < plaint) || ((nlaint == plaint) && (nlafrc <= plafrc)));
f0119f8f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119f92:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119f95:	7c 54                	jl     f0119feb <chk2+0x356>
f0119f97:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119f9a:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119f9d:	75 08                	jne    f0119fa7 <chk2+0x312>
f0119f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
f0119fa2:	3b 45 e8             	cmp    -0x18(%ebp),%eax
f0119fa5:	7e 44                	jle    f0119feb <chk2+0x356>
f0119fa7:	68 f0 5f 13 f0       	push   $0xf0135ff0
f0119fac:	68 47 57 13 f0       	push   $0xf0135747
f0119fb1:	68 d4 02 00 00       	push   $0x2d4
f0119fb6:	68 8f 57 13 f0       	push   $0xf013578f
f0119fbb:	e8 7e 70 fe ff       	call   f010103e <_panic_all>
					}
					else if (__nproc == plaint)
f0119fc0:	a1 34 6c 85 f0       	mov    0xf0856c34,%eax
f0119fc5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119fc8:	75 21                	jne    f0119feb <chk2+0x356>
					{
						assert_endall((nlaint == plaint));
f0119fca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f0119fcd:	3b 45 ec             	cmp    -0x14(%ebp),%eax
f0119fd0:	74 19                	je     f0119feb <chk2+0x356>
f0119fd2:	68 30 60 13 f0       	push   $0xf0136030
f0119fd7:	68 47 57 13 f0       	push   $0xf0135747
f0119fdc:	68 d8 02 00 00       	push   $0x2d8
f0119fe1:	68 8f 57 13 f0       	push   $0xf013578f
f0119fe6:	e8 53 70 fe ff       	call   f010103e <_panic_all>
					}
				}
				__pla = __nla;
f0119feb:	a1 f4 e8 83 f0       	mov    0xf083e8f4,%eax
f0119ff0:	a3 7c 6d 85 f0       	mov    %eax,0xf0856d7c
			}
		}
		__pnexit = __nnexit;
f0119ff5:	a1 f8 6a 85 f0       	mov    0xf0856af8,%eax
f0119ffa:	a3 50 e8 83 f0       	mov    %eax,0xf083e850
f0119fff:	eb 01                	jmp    f011a002 <chk2+0x36d>
	//	}
}
void chk2(struct Env* __se)
{
	if (__chkstatus == 0)
		return ;
f011a001:	90                   	nop
	//				if (i == __tl) continue;
	//				assert_endall(find_env_in_queue(&(env_ready_queues[i]), __pe->env_id) == NULL) ;
	//			}
	//		}
	//	}
}
f011a002:	c9                   	leave  
f011a003:	c3                   	ret    

f011a004 <check_boot_pgdir>:
// but it is a pretty good check.
//
uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va);

void check_boot_pgdir()
{
f011a004:	55                   	push   %ebp
f011a005:	89 e5                	mov    %esp,%ebp
f011a007:	83 ec 18             	sub    $0x18,%esp

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011a00a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a011:	eb 40                	jmp    f011a053 <check_boot_pgdir+0x4f>
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
f011a013:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a016:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011a01c:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a021:	83 ec 08             	sub    $0x8,%esp
f011a024:	52                   	push   %edx
f011a025:	50                   	push   %eax
f011a026:	e8 af 01 00 00       	call   f011a1da <check_va2pa>
f011a02b:	83 c4 10             	add    $0x10,%esp
f011a02e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011a031:	74 19                	je     f011a04c <check_boot_pgdir+0x48>
f011a033:	68 44 60 13 f0       	push   $0xf0136044
f011a038:	68 47 57 13 f0       	push   $0xf0135747
f011a03d:	68 1f 03 00 00       	push   $0x31f
f011a042:	68 8f 57 13 f0       	push   $0xf013578f
f011a047:	e8 63 6f fe ff       	call   f0100faf <_panic>

	//2016
	// check phys mem
#if USE_KHEAP
	{
		for (i = 0; KERNEL_BASE + i < (uint32)ptr_free_mem; i += PAGE_SIZE)
f011a04c:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011a053:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a056:	8d 90 00 00 00 f0    	lea    -0x10000000(%eax),%edx
f011a05c:	a1 d0 6c 85 f0       	mov    0xf0856cd0,%eax
f011a061:	39 c2                	cmp    %eax,%edx
f011a063:	72 ae                	jb     f011a013 <check_boot_pgdir+0xf>
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011a065:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a06c:	e9 81 00 00 00       	jmp    f011a0f2 <check_boot_pgdir+0xee>
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
f011a071:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a074:	25 ff 7f 00 00       	and    $0x7fff,%eax
f011a079:	85 c0                	test   %eax,%eax
f011a07b:	74 6d                	je     f011a0ea <check_boot_pgdir+0xe6>
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
f011a07d:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a080:	8d 90 00 80 bf ef    	lea    -0x10408000(%eax),%edx
f011a086:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a08b:	83 ec 08             	sub    $0x8,%esp
f011a08e:	52                   	push   %edx
f011a08f:	50                   	push   %eax
f011a090:	e8 45 01 00 00       	call   f011a1da <check_va2pa>
f011a095:	83 c4 10             	add    $0x10,%esp
f011a098:	c7 45 f0 00 70 17 f0 	movl   $0xf0177000,-0x10(%ebp)
f011a09f:	81 7d f0 ff ff ff ef 	cmpl   $0xefffffff,-0x10(%ebp)
f011a0a6:	77 17                	ja     f011a0bf <check_boot_pgdir+0xbb>
f011a0a8:	ff 75 f0             	pushl  -0x10(%ebp)
f011a0ab:	68 7c 60 13 f0       	push   $0xf013607c
f011a0b0:	68 2d 03 00 00       	push   $0x32d
f011a0b5:	68 8f 57 13 f0       	push   $0xf013578f
f011a0ba:	e8 f0 6e fe ff       	call   f0100faf <_panic>
f011a0bf:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011a0c2:	8d 8a 00 00 00 10    	lea    0x10000000(%edx),%ecx
f011a0c8:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a0cb:	01 ca                	add    %ecx,%edx
f011a0cd:	39 d0                	cmp    %edx,%eax
f011a0cf:	74 1a                	je     f011a0eb <check_boot_pgdir+0xe7>
f011a0d1:	68 b0 60 13 f0       	push   $0xf01360b0
f011a0d6:	68 47 57 13 f0       	push   $0xf0135747
f011a0db:	68 2d 03 00 00       	push   $0x32d
f011a0e0:	68 8f 57 13 f0       	push   $0xf013578f
f011a0e5:	e8 c5 6e fe ff       	call   f0100faf <_panic>
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
	{
		//skip GUARD page of each CPU Stack
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
f011a0ea:	90                   	nop
		for (i = 0; KERNEL_BASE + i != 0; i += PAGE_SIZE)
			assert(check_va2pa(ptr_page_directory, KERNEL_BASE + i) == i);
	}
#endif
	// check scheduler kernel stack
	for (i = 0; i < NCPUS*KERNEL_STACK_SIZE; i += PAGE_SIZE)
f011a0eb:	81 45 f4 00 10 00 00 	addl   $0x1000,-0xc(%ebp)
f011a0f2:	81 7d f4 ff 7f 00 00 	cmpl   $0x7fff,-0xc(%ebp)
f011a0f9:	0f 86 72 ff ff ff    	jbe    f011a071 <check_boot_pgdir+0x6d>
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011a0ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a106:	e9 af 00 00 00       	jmp    f011a1ba <check_boot_pgdir+0x1b6>
		switch (i) {
f011a10b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a10e:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011a113:	74 11                	je     f011a126 <check_boot_pgdir+0x122>
f011a115:	3d bb 03 00 00       	cmp    $0x3bb,%eax
f011a11a:	72 36                	jb     f011a152 <check_boot_pgdir+0x14e>
f011a11c:	2d bd 03 00 00       	sub    $0x3bd,%eax
f011a121:	83 f8 02             	cmp    $0x2,%eax
f011a124:	77 2c                	ja     f011a152 <check_boot_pgdir+0x14e>
		case PDX(UVPT):
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
f011a126:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a12b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a12e:	c1 e2 02             	shl    $0x2,%edx
f011a131:	01 d0                	add    %edx,%eax
f011a133:	8b 00                	mov    (%eax),%eax
f011a135:	85 c0                	test   %eax,%eax
f011a137:	75 7a                	jne    f011a1b3 <check_boot_pgdir+0x1af>
f011a139:	68 36 61 13 f0       	push   $0xf0136136
f011a13e:	68 47 57 13 f0       	push   $0xf0135747
f011a143:	68 38 03 00 00       	push   $0x338
f011a148:	68 8f 57 13 f0       	push   $0xf013578f
f011a14d:	e8 5d 6e fe ff       	call   f0100faf <_panic>
		break;
		default:
			if (i >= PDX(KERNEL_BASE))
f011a152:	81 7d f4 bf 03 00 00 	cmpl   $0x3bf,-0xc(%ebp)
f011a159:	76 2c                	jbe    f011a187 <check_boot_pgdir+0x183>
				assert(ptr_page_directory[i]);
f011a15b:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a160:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a163:	c1 e2 02             	shl    $0x2,%edx
f011a166:	01 d0                	add    %edx,%eax
f011a168:	8b 00                	mov    (%eax),%eax
f011a16a:	85 c0                	test   %eax,%eax
f011a16c:	75 48                	jne    f011a1b6 <check_boot_pgdir+0x1b2>
f011a16e:	68 36 61 13 f0       	push   $0xf0136136
f011a173:	68 47 57 13 f0       	push   $0xf0135747
f011a178:	68 3c 03 00 00       	push   $0x33c
f011a17d:	68 8f 57 13 f0       	push   $0xf013578f
f011a182:	e8 28 6e fe ff       	call   f0100faf <_panic>
			else
				assert(ptr_page_directory[i] == 0);
f011a187:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a18c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a18f:	c1 e2 02             	shl    $0x2,%edx
f011a192:	01 d0                	add    %edx,%eax
f011a194:	8b 00                	mov    (%eax),%eax
f011a196:	85 c0                	test   %eax,%eax
f011a198:	74 1c                	je     f011a1b6 <check_boot_pgdir+0x1b2>
f011a19a:	68 4c 61 13 f0       	push   $0xf013614c
f011a19f:	68 47 57 13 f0       	push   $0xf0135747
f011a1a4:	68 3e 03 00 00       	push   $0x33e
f011a1a9:	68 8f 57 13 f0       	push   $0xf013578f
f011a1ae:	e8 fc 6d fe ff       	call   f0100faf <_panic>
		case PDX(KERN_STACK_TOP-1):
		case PDX(UENVS):
		//2016: READ_ONLY_FRAMES_INFO not valid any more since it can't fit in 4 MB space
		//case PDX(READ_ONLY_FRAMES_INFO):
		assert(ptr_page_directory[i]);
		break;
f011a1b3:	90                   	nop
f011a1b4:	eb 01                	jmp    f011a1b7 <check_boot_pgdir+0x1b3>
		default:
			if (i >= PDX(KERNEL_BASE))
				assert(ptr_page_directory[i]);
			else
				assert(ptr_page_directory[i] == 0);
			break;
f011a1b6:	90                   	nop
		if (i%KERNEL_STACK_SIZE == 0)
			continue;
		assert(check_va2pa(ptr_page_directory, KERN_STACK_TOP - NCPUS*KERNEL_STACK_SIZE + i) == STATIC_KERNEL_PHYSICAL_ADDRESS(ptr_stack_bottom) + i);
	}
	// check for zero/non-zero in PDEs
	for (i = 0; i < NPDENTRIES; i++) {
f011a1b7:	ff 45 f4             	incl   -0xc(%ebp)
f011a1ba:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011a1c1:	0f 86 44 ff ff ff    	jbe    f011a10b <check_boot_pgdir+0x107>
			else
				assert(ptr_page_directory[i] == 0);
			break;
		}
	}
	cprintf("*	check_boot_pgdir() succeeded!\n");
f011a1c7:	83 ec 0c             	sub    $0xc,%esp
f011a1ca:	68 68 61 13 f0       	push   $0xf0136168
f011a1cf:	e8 88 7a fe ff       	call   f0101c5c <cprintf>
f011a1d4:	83 c4 10             	add    $0x10,%esp
}
f011a1d7:	90                   	nop
f011a1d8:	c9                   	leave  
f011a1d9:	c3                   	ret    

f011a1da <check_va2pa>:
// defined by the page directory 'ptr_page_directory'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_boot_pgdir() function; it shouldn't be used elsewhere.

uint32 check_va2pa(uint32 *ptr_page_directory, uint32 va)
{
f011a1da:	55                   	push   %ebp
f011a1db:	89 e5                	mov    %esp,%ebp
f011a1dd:	83 ec 18             	sub    $0x18,%esp
	uint32 *p;

	uint32* dirEntry = &(ptr_page_directory[PDX(va)]);
f011a1e0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a1e3:	c1 e8 16             	shr    $0x16,%eax
f011a1e6:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a1ed:	8b 45 08             	mov    0x8(%ebp),%eax
f011a1f0:	01 d0                	add    %edx,%eax
f011a1f2:	89 45 f4             	mov    %eax,-0xc(%ebp)

	//LOG_VARS("dir table entry %x", *dirEntry);

	if (!(*dirEntry & PERM_PRESENT))
f011a1f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a1f8:	8b 00                	mov    (%eax),%eax
f011a1fa:	83 e0 01             	and    $0x1,%eax
f011a1fd:	85 c0                	test   %eax,%eax
f011a1ff:	75 0a                	jne    f011a20b <check_va2pa+0x31>
		return ~0;
f011a201:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011a206:	e9 87 00 00 00       	jmp    f011a292 <check_va2pa+0xb8>
	p = (uint32*) STATIC_KERNEL_VIRTUAL_ADDRESS(EXTRACT_ADDRESS(*dirEntry));
f011a20b:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a20e:	8b 00                	mov    (%eax),%eax
f011a210:	25 00 f0 ff ff       	and    $0xfffff000,%eax
f011a215:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a218:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a21b:	c1 e8 0c             	shr    $0xc,%eax
f011a21e:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a221:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f011a226:	39 45 ec             	cmp    %eax,-0x14(%ebp)
f011a229:	72 17                	jb     f011a242 <check_va2pa+0x68>
f011a22b:	ff 75 f0             	pushl  -0x10(%ebp)
f011a22e:	68 8c 61 13 f0       	push   $0xf013618c
f011a233:	68 54 03 00 00       	push   $0x354
f011a238:	68 8f 57 13 f0       	push   $0xf013578f
f011a23d:	e8 6d 6d fe ff       	call   f0100faf <_panic>
f011a242:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a245:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a24a:	89 45 e8             	mov    %eax,-0x18(%ebp)

	//LOG_VARS("ptr to page table  = %x", p);

	if (!(p[PTX(va)] & PERM_PRESENT))
f011a24d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a250:	c1 e8 0c             	shr    $0xc,%eax
f011a253:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a258:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a25f:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a262:	01 d0                	add    %edx,%eax
f011a264:	8b 00                	mov    (%eax),%eax
f011a266:	83 e0 01             	and    $0x1,%eax
f011a269:	85 c0                	test   %eax,%eax
f011a26b:	75 07                	jne    f011a274 <check_va2pa+0x9a>
		return ~0;
f011a26d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
f011a272:	eb 1e                	jmp    f011a292 <check_va2pa+0xb8>

	//LOG_VARS("page phys addres = %x",EXTRACT_ADDRESS(p[PTX(va)]));
	return EXTRACT_ADDRESS(p[PTX(va)]);
f011a274:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a277:	c1 e8 0c             	shr    $0xc,%eax
f011a27a:	25 ff 03 00 00       	and    $0x3ff,%eax
f011a27f:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a286:	8b 45 e8             	mov    -0x18(%ebp),%eax
f011a289:	01 d0                	add    %edx,%eax
f011a28b:	8b 00                	mov    (%eax),%eax
f011a28d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
f011a292:	c9                   	leave  
f011a293:	c3                   	ret    

f011a294 <clone_kern_dir>:
}
 */

//

uint32* clone_kern_dir() {
f011a294:	55                   	push   %ebp
f011a295:	89 e5                	mov    %esp,%ebp
f011a297:	83 ec 28             	sub    $0x28,%esp
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
f011a29a:	83 ec 0c             	sub    $0xc,%esp
f011a29d:	8d 45 dc             	lea    -0x24(%ebp),%eax
f011a2a0:	50                   	push   %eax
f011a2a1:	e8 9c ee fe ff       	call   f0109142 <allocate_frame>
f011a2a6:	83 c4 10             	add    $0x10,%esp
	uint32 dir_pa = to_physical_address(ptr_fi);
f011a2a9:	8b 45 dc             	mov    -0x24(%ebp),%eax
f011a2ac:	83 ec 0c             	sub    $0xc,%esp
f011a2af:	50                   	push   %eax
f011a2b0:	e8 6b e7 ff ff       	call   f0118a20 <to_physical_address>
f011a2b5:	83 c4 10             	add    $0x10,%esp
f011a2b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
f011a2bb:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a2be:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a2c1:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a2c4:	c1 e8 0c             	shr    $0xc,%eax
f011a2c7:	89 45 e8             	mov    %eax,-0x18(%ebp)
f011a2ca:	a1 b8 e9 83 f0       	mov    0xf083e9b8,%eax
f011a2cf:	39 45 e8             	cmp    %eax,-0x18(%ebp)
f011a2d2:	72 17                	jb     f011a2eb <clone_kern_dir+0x57>
f011a2d4:	ff 75 ec             	pushl  -0x14(%ebp)
f011a2d7:	68 8c 61 13 f0       	push   $0xf013618c
f011a2dc:	68 d4 03 00 00       	push   $0x3d4
f011a2e1:	68 8f 57 13 f0       	push   $0xf013578f
f011a2e6:	e8 c4 6c fe ff       	call   f0100faf <_panic>
f011a2eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a2ee:	2d 00 00 00 10       	sub    $0x10000000,%eax
f011a2f3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	for (int i = 0; i < 1024; ++i) {
f011a2f6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
f011a2fd:	eb 23                	jmp    f011a322 <clone_kern_dir+0x8e>
		dir_ptr[i] = ptr_page_directory[i];
f011a2ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a302:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011a309:	8b 45 e4             	mov    -0x1c(%ebp),%eax
f011a30c:	01 c2                	add    %eax,%edx
f011a30e:	a1 d8 6c 85 f0       	mov    0xf0856cd8,%eax
f011a313:	8b 4d f4             	mov    -0xc(%ebp),%ecx
f011a316:	c1 e1 02             	shl    $0x2,%ecx
f011a319:	01 c8                	add    %ecx,%eax
f011a31b:	8b 00                	mov    (%eax),%eax
f011a31d:	89 02                	mov    %eax,(%edx)
uint32* clone_kern_dir() {
	struct FrameInfo* ptr_fi;
	allocate_frame(&ptr_fi);
	uint32 dir_pa = to_physical_address(ptr_fi);
	uint32* dir_ptr = STATIC_KERNEL_VIRTUAL_ADDRESS(dir_pa);
	for (int i = 0; i < 1024; ++i) {
f011a31f:	ff 45 f4             	incl   -0xc(%ebp)
f011a322:	81 7d f4 ff 03 00 00 	cmpl   $0x3ff,-0xc(%ebp)
f011a329:	7e d4                	jle    f011a2ff <clone_kern_dir+0x6b>
f011a32b:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a32e:	89 45 e0             	mov    %eax,-0x20(%ebp)
}

static __inline void
lcr3(uint32 val)
{
	__asm __volatile("movl %0,%%cr3" : : "r" (val));
f011a331:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a334:	0f 22 d8             	mov    %eax,%cr3
		dir_ptr[i] = ptr_page_directory[i];
	}
	lcr3(dir_pa);
	return dir_ptr;
f011a337:	8b 45 e4             	mov    -0x1c(%ebp),%eax
}
f011a33a:	c9                   	leave  
f011a33b:	c3                   	ret    

f011a33c <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
f011a33c:	55                   	push   %ebp
f011a33d:	89 e5                	mov    %esp,%ebp
f011a33f:	53                   	push   %ebx
f011a340:	83 ec 14             	sub    $0x14,%esp
f011a343:	8b 45 10             	mov    0x10(%ebp),%eax
f011a346:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a349:	8b 45 14             	mov    0x14(%ebp),%eax
f011a34c:	89 45 f4             	mov    %eax,-0xc(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
f011a34f:	8b 45 18             	mov    0x18(%ebp),%eax
f011a352:	ba 00 00 00 00       	mov    $0x0,%edx
f011a357:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011a35a:	77 55                	ja     f011a3b1 <printnum+0x75>
f011a35c:	3b 55 f4             	cmp    -0xc(%ebp),%edx
f011a35f:	72 05                	jb     f011a366 <printnum+0x2a>
f011a361:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011a364:	77 4b                	ja     f011a3b1 <printnum+0x75>
		printnum(putch, putdat, num / base, base, width - 1, padc);
f011a366:	8b 45 1c             	mov    0x1c(%ebp),%eax
f011a369:	8d 58 ff             	lea    -0x1(%eax),%ebx
f011a36c:	8b 45 18             	mov    0x18(%ebp),%eax
f011a36f:	ba 00 00 00 00       	mov    $0x0,%edx
f011a374:	52                   	push   %edx
f011a375:	50                   	push   %eax
f011a376:	ff 75 f4             	pushl  -0xc(%ebp)
f011a379:	ff 75 f0             	pushl  -0x10(%ebp)
f011a37c:	e8 33 16 00 00       	call   f011b9b4 <__udivdi3>
f011a381:	83 c4 10             	add    $0x10,%esp
f011a384:	83 ec 04             	sub    $0x4,%esp
f011a387:	ff 75 20             	pushl  0x20(%ebp)
f011a38a:	53                   	push   %ebx
f011a38b:	ff 75 18             	pushl  0x18(%ebp)
f011a38e:	52                   	push   %edx
f011a38f:	50                   	push   %eax
f011a390:	ff 75 0c             	pushl  0xc(%ebp)
f011a393:	ff 75 08             	pushl  0x8(%ebp)
f011a396:	e8 a1 ff ff ff       	call   f011a33c <printnum>
f011a39b:	83 c4 20             	add    $0x20,%esp
f011a39e:	eb 1a                	jmp    f011a3ba <printnum+0x7e>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
f011a3a0:	83 ec 08             	sub    $0x8,%esp
f011a3a3:	ff 75 0c             	pushl  0xc(%ebp)
f011a3a6:	ff 75 20             	pushl  0x20(%ebp)
f011a3a9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3ac:	ff d0                	call   *%eax
f011a3ae:	83 c4 10             	add    $0x10,%esp
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
f011a3b1:	ff 4d 1c             	decl   0x1c(%ebp)
f011a3b4:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
f011a3b8:	7f e6                	jg     f011a3a0 <printnum+0x64>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
f011a3ba:	8b 4d 18             	mov    0x18(%ebp),%ecx
f011a3bd:	bb 00 00 00 00       	mov    $0x0,%ebx
f011a3c2:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a3c5:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a3c8:	53                   	push   %ebx
f011a3c9:	51                   	push   %ecx
f011a3ca:	52                   	push   %edx
f011a3cb:	50                   	push   %eax
f011a3cc:	e8 f3 16 00 00       	call   f011bac4 <__umoddi3>
f011a3d1:	83 c4 10             	add    $0x10,%esp
f011a3d4:	05 d4 63 13 f0       	add    $0xf01363d4,%eax
f011a3d9:	8a 00                	mov    (%eax),%al
f011a3db:	0f be c0             	movsbl %al,%eax
f011a3de:	83 ec 08             	sub    $0x8,%esp
f011a3e1:	ff 75 0c             	pushl  0xc(%ebp)
f011a3e4:	50                   	push   %eax
f011a3e5:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3e8:	ff d0                	call   *%eax
f011a3ea:	83 c4 10             	add    $0x10,%esp
}
f011a3ed:	90                   	nop
f011a3ee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
f011a3f1:	c9                   	leave  
f011a3f2:	c3                   	ret    

f011a3f3 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
f011a3f3:	55                   	push   %ebp
f011a3f4:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011a3f6:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011a3fa:	7e 1c                	jle    f011a418 <getuint+0x25>
		return va_arg(*ap, unsigned long long);
f011a3fc:	8b 45 08             	mov    0x8(%ebp),%eax
f011a3ff:	8b 00                	mov    (%eax),%eax
f011a401:	8d 50 08             	lea    0x8(%eax),%edx
f011a404:	8b 45 08             	mov    0x8(%ebp),%eax
f011a407:	89 10                	mov    %edx,(%eax)
f011a409:	8b 45 08             	mov    0x8(%ebp),%eax
f011a40c:	8b 00                	mov    (%eax),%eax
f011a40e:	83 e8 08             	sub    $0x8,%eax
f011a411:	8b 50 04             	mov    0x4(%eax),%edx
f011a414:	8b 00                	mov    (%eax),%eax
f011a416:	eb 40                	jmp    f011a458 <getuint+0x65>
	else if (lflag)
f011a418:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a41c:	74 1e                	je     f011a43c <getuint+0x49>
		return va_arg(*ap, unsigned long);
f011a41e:	8b 45 08             	mov    0x8(%ebp),%eax
f011a421:	8b 00                	mov    (%eax),%eax
f011a423:	8d 50 04             	lea    0x4(%eax),%edx
f011a426:	8b 45 08             	mov    0x8(%ebp),%eax
f011a429:	89 10                	mov    %edx,(%eax)
f011a42b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a42e:	8b 00                	mov    (%eax),%eax
f011a430:	83 e8 04             	sub    $0x4,%eax
f011a433:	8b 00                	mov    (%eax),%eax
f011a435:	ba 00 00 00 00       	mov    $0x0,%edx
f011a43a:	eb 1c                	jmp    f011a458 <getuint+0x65>
	else
		return va_arg(*ap, unsigned int);
f011a43c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a43f:	8b 00                	mov    (%eax),%eax
f011a441:	8d 50 04             	lea    0x4(%eax),%edx
f011a444:	8b 45 08             	mov    0x8(%ebp),%eax
f011a447:	89 10                	mov    %edx,(%eax)
f011a449:	8b 45 08             	mov    0x8(%ebp),%eax
f011a44c:	8b 00                	mov    (%eax),%eax
f011a44e:	83 e8 04             	sub    $0x4,%eax
f011a451:	8b 00                	mov    (%eax),%eax
f011a453:	ba 00 00 00 00       	mov    $0x0,%edx
}
f011a458:	5d                   	pop    %ebp
f011a459:	c3                   	ret    

f011a45a <getint>:

// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
f011a45a:	55                   	push   %ebp
f011a45b:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
f011a45d:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
f011a461:	7e 1c                	jle    f011a47f <getint+0x25>
		return va_arg(*ap, long long);
f011a463:	8b 45 08             	mov    0x8(%ebp),%eax
f011a466:	8b 00                	mov    (%eax),%eax
f011a468:	8d 50 08             	lea    0x8(%eax),%edx
f011a46b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a46e:	89 10                	mov    %edx,(%eax)
f011a470:	8b 45 08             	mov    0x8(%ebp),%eax
f011a473:	8b 00                	mov    (%eax),%eax
f011a475:	83 e8 08             	sub    $0x8,%eax
f011a478:	8b 50 04             	mov    0x4(%eax),%edx
f011a47b:	8b 00                	mov    (%eax),%eax
f011a47d:	eb 38                	jmp    f011a4b7 <getint+0x5d>
	else if (lflag)
f011a47f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a483:	74 1a                	je     f011a49f <getint+0x45>
		return va_arg(*ap, long);
f011a485:	8b 45 08             	mov    0x8(%ebp),%eax
f011a488:	8b 00                	mov    (%eax),%eax
f011a48a:	8d 50 04             	lea    0x4(%eax),%edx
f011a48d:	8b 45 08             	mov    0x8(%ebp),%eax
f011a490:	89 10                	mov    %edx,(%eax)
f011a492:	8b 45 08             	mov    0x8(%ebp),%eax
f011a495:	8b 00                	mov    (%eax),%eax
f011a497:	83 e8 04             	sub    $0x4,%eax
f011a49a:	8b 00                	mov    (%eax),%eax
f011a49c:	99                   	cltd   
f011a49d:	eb 18                	jmp    f011a4b7 <getint+0x5d>
	else
		return va_arg(*ap, int);
f011a49f:	8b 45 08             	mov    0x8(%ebp),%eax
f011a4a2:	8b 00                	mov    (%eax),%eax
f011a4a4:	8d 50 04             	lea    0x4(%eax),%edx
f011a4a7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a4aa:	89 10                	mov    %edx,(%eax)
f011a4ac:	8b 45 08             	mov    0x8(%ebp),%eax
f011a4af:	8b 00                	mov    (%eax),%eax
f011a4b1:	83 e8 04             	sub    $0x4,%eax
f011a4b4:	8b 00                	mov    (%eax),%eax
f011a4b6:	99                   	cltd   
}
f011a4b7:	5d                   	pop    %ebp
f011a4b8:	c3                   	ret    

f011a4b9 <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
f011a4b9:	55                   	push   %ebp
f011a4ba:	89 e5                	mov    %esp,%ebp
f011a4bc:	56                   	push   %esi
f011a4bd:	53                   	push   %ebx
f011a4be:	83 ec 20             	sub    $0x20,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011a4c1:	eb 17                	jmp    f011a4da <vprintfmt+0x21>
			if (ch == '\0')
f011a4c3:	85 db                	test   %ebx,%ebx
f011a4c5:	0f 84 c1 03 00 00    	je     f011a88c <vprintfmt+0x3d3>
				return;
			putch(ch, putdat);
f011a4cb:	83 ec 08             	sub    $0x8,%esp
f011a4ce:	ff 75 0c             	pushl  0xc(%ebp)
f011a4d1:	53                   	push   %ebx
f011a4d2:	8b 45 08             	mov    0x8(%ebp),%eax
f011a4d5:	ff d0                	call   *%eax
f011a4d7:	83 c4 10             	add    $0x10,%esp
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
f011a4da:	8b 45 10             	mov    0x10(%ebp),%eax
f011a4dd:	8d 50 01             	lea    0x1(%eax),%edx
f011a4e0:	89 55 10             	mov    %edx,0x10(%ebp)
f011a4e3:	8a 00                	mov    (%eax),%al
f011a4e5:	0f b6 d8             	movzbl %al,%ebx
f011a4e8:	83 fb 25             	cmp    $0x25,%ebx
f011a4eb:	75 d6                	jne    f011a4c3 <vprintfmt+0xa>
				return;
			putch(ch, putdat);
		}

		// Process a %-escape sequence
		padc = ' ';
f011a4ed:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
		width = -1;
f011a4f1:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
		precision = -1;
f011a4f8:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
		lflag = 0;
f011a4ff:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
		altflag = 0;
f011a506:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
f011a50d:	8b 45 10             	mov    0x10(%ebp),%eax
f011a510:	8d 50 01             	lea    0x1(%eax),%edx
f011a513:	89 55 10             	mov    %edx,0x10(%ebp)
f011a516:	8a 00                	mov    (%eax),%al
f011a518:	0f b6 d8             	movzbl %al,%ebx
f011a51b:	8d 43 dd             	lea    -0x23(%ebx),%eax
f011a51e:	83 f8 5b             	cmp    $0x5b,%eax
f011a521:	0f 87 3d 03 00 00    	ja     f011a864 <vprintfmt+0x3ab>
f011a527:	8b 04 85 f8 63 13 f0 	mov    -0xfec9c08(,%eax,4),%eax
f011a52e:	ff e0                	jmp    *%eax

		// flag to pad on the right
		case '-':
			padc = '-';
f011a530:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
			goto reswitch;
f011a534:	eb d7                	jmp    f011a50d <vprintfmt+0x54>

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
f011a536:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
			goto reswitch;
f011a53a:	eb d1                	jmp    f011a50d <vprintfmt+0x54>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011a53c:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
				precision = precision * 10 + ch - '0';
f011a543:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011a546:	89 d0                	mov    %edx,%eax
f011a548:	c1 e0 02             	shl    $0x2,%eax
f011a54b:	01 d0                	add    %edx,%eax
f011a54d:	01 c0                	add    %eax,%eax
f011a54f:	01 d8                	add    %ebx,%eax
f011a551:	83 e8 30             	sub    $0x30,%eax
f011a554:	89 45 e0             	mov    %eax,-0x20(%ebp)
				ch = *fmt;
f011a557:	8b 45 10             	mov    0x10(%ebp),%eax
f011a55a:	8a 00                	mov    (%eax),%al
f011a55c:	0f be d8             	movsbl %al,%ebx
				if (ch < '0' || ch > '9')
f011a55f:	83 fb 2f             	cmp    $0x2f,%ebx
f011a562:	7e 3e                	jle    f011a5a2 <vprintfmt+0xe9>
f011a564:	83 fb 39             	cmp    $0x39,%ebx
f011a567:	7f 39                	jg     f011a5a2 <vprintfmt+0xe9>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
f011a569:	ff 45 10             	incl   0x10(%ebp)
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
f011a56c:	eb d5                	jmp    f011a543 <vprintfmt+0x8a>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
f011a56e:	8b 45 14             	mov    0x14(%ebp),%eax
f011a571:	83 c0 04             	add    $0x4,%eax
f011a574:	89 45 14             	mov    %eax,0x14(%ebp)
f011a577:	8b 45 14             	mov    0x14(%ebp),%eax
f011a57a:	83 e8 04             	sub    $0x4,%eax
f011a57d:	8b 00                	mov    (%eax),%eax
f011a57f:	89 45 e0             	mov    %eax,-0x20(%ebp)
			goto process_precision;
f011a582:	eb 1f                	jmp    f011a5a3 <vprintfmt+0xea>

		case '.':
			if (width < 0)
f011a584:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a588:	79 83                	jns    f011a50d <vprintfmt+0x54>
				width = 0;
f011a58a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
			goto reswitch;
f011a591:	e9 77 ff ff ff       	jmp    f011a50d <vprintfmt+0x54>

		case '#':
			altflag = 1;
f011a596:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
f011a59d:	e9 6b ff ff ff       	jmp    f011a50d <vprintfmt+0x54>
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
			goto process_precision;
f011a5a2:	90                   	nop
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
f011a5a3:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a5a7:	0f 89 60 ff ff ff    	jns    f011a50d <vprintfmt+0x54>
				width = precision, precision = -1;
f011a5ad:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a5b0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
f011a5b3:	c7 45 e0 ff ff ff ff 	movl   $0xffffffff,-0x20(%ebp)
			goto reswitch;
f011a5ba:	e9 4e ff ff ff       	jmp    f011a50d <vprintfmt+0x54>

		// long flag (doubled for long long)
		case 'l':
			lflag++;
f011a5bf:	ff 45 e8             	incl   -0x18(%ebp)
			goto reswitch;
f011a5c2:	e9 46 ff ff ff       	jmp    f011a50d <vprintfmt+0x54>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
f011a5c7:	8b 45 14             	mov    0x14(%ebp),%eax
f011a5ca:	83 c0 04             	add    $0x4,%eax
f011a5cd:	89 45 14             	mov    %eax,0x14(%ebp)
f011a5d0:	8b 45 14             	mov    0x14(%ebp),%eax
f011a5d3:	83 e8 04             	sub    $0x4,%eax
f011a5d6:	8b 00                	mov    (%eax),%eax
f011a5d8:	83 ec 08             	sub    $0x8,%esp
f011a5db:	ff 75 0c             	pushl  0xc(%ebp)
f011a5de:	50                   	push   %eax
f011a5df:	8b 45 08             	mov    0x8(%ebp),%eax
f011a5e2:	ff d0                	call   *%eax
f011a5e4:	83 c4 10             	add    $0x10,%esp
			break;
f011a5e7:	e9 9b 02 00 00       	jmp    f011a887 <vprintfmt+0x3ce>

		// error message
		case 'e':
			err = va_arg(ap, int);
f011a5ec:	8b 45 14             	mov    0x14(%ebp),%eax
f011a5ef:	83 c0 04             	add    $0x4,%eax
f011a5f2:	89 45 14             	mov    %eax,0x14(%ebp)
f011a5f5:	8b 45 14             	mov    0x14(%ebp),%eax
f011a5f8:	83 e8 04             	sub    $0x4,%eax
f011a5fb:	8b 18                	mov    (%eax),%ebx
			if (err < 0)
f011a5fd:	85 db                	test   %ebx,%ebx
f011a5ff:	79 02                	jns    f011a603 <vprintfmt+0x14a>
				err = -err;
f011a601:	f7 db                	neg    %ebx
			if (err > MAXERROR || (p = error_string[err]) == NULL)
f011a603:	83 fb 64             	cmp    $0x64,%ebx
f011a606:	7f 0b                	jg     f011a613 <vprintfmt+0x15a>
f011a608:	8b 34 9d 40 62 13 f0 	mov    -0xfec9dc0(,%ebx,4),%esi
f011a60f:	85 f6                	test   %esi,%esi
f011a611:	75 19                	jne    f011a62c <vprintfmt+0x173>
				printfmt(putch, putdat, "error %d", err);
f011a613:	53                   	push   %ebx
f011a614:	68 e5 63 13 f0       	push   $0xf01363e5
f011a619:	ff 75 0c             	pushl  0xc(%ebp)
f011a61c:	ff 75 08             	pushl  0x8(%ebp)
f011a61f:	e8 70 02 00 00       	call   f011a894 <printfmt>
f011a624:	83 c4 10             	add    $0x10,%esp
			else
				printfmt(putch, putdat, "%s", p);
			break;
f011a627:	e9 5b 02 00 00       	jmp    f011a887 <vprintfmt+0x3ce>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
f011a62c:	56                   	push   %esi
f011a62d:	68 ee 63 13 f0       	push   $0xf01363ee
f011a632:	ff 75 0c             	pushl  0xc(%ebp)
f011a635:	ff 75 08             	pushl  0x8(%ebp)
f011a638:	e8 57 02 00 00       	call   f011a894 <printfmt>
f011a63d:	83 c4 10             	add    $0x10,%esp
			break;
f011a640:	e9 42 02 00 00       	jmp    f011a887 <vprintfmt+0x3ce>

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
f011a645:	8b 45 14             	mov    0x14(%ebp),%eax
f011a648:	83 c0 04             	add    $0x4,%eax
f011a64b:	89 45 14             	mov    %eax,0x14(%ebp)
f011a64e:	8b 45 14             	mov    0x14(%ebp),%eax
f011a651:	83 e8 04             	sub    $0x4,%eax
f011a654:	8b 30                	mov    (%eax),%esi
f011a656:	85 f6                	test   %esi,%esi
f011a658:	75 05                	jne    f011a65f <vprintfmt+0x1a6>
				p = "(null)";
f011a65a:	be f1 63 13 f0       	mov    $0xf01363f1,%esi
			if (width > 0 && padc != '-')
f011a65f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a663:	7e 6d                	jle    f011a6d2 <vprintfmt+0x219>
f011a665:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
f011a669:	74 67                	je     f011a6d2 <vprintfmt+0x219>
				for (width -= strnlen(p, precision); width > 0; width--)
f011a66b:	8b 45 e0             	mov    -0x20(%ebp),%eax
f011a66e:	83 ec 08             	sub    $0x8,%esp
f011a671:	50                   	push   %eax
f011a672:	56                   	push   %esi
f011a673:	e8 26 05 00 00       	call   f011ab9e <strnlen>
f011a678:	83 c4 10             	add    $0x10,%esp
f011a67b:	29 45 e4             	sub    %eax,-0x1c(%ebp)
f011a67e:	eb 16                	jmp    f011a696 <vprintfmt+0x1dd>
					putch(padc, putdat);
f011a680:	0f be 45 db          	movsbl -0x25(%ebp),%eax
f011a684:	83 ec 08             	sub    $0x8,%esp
f011a687:	ff 75 0c             	pushl  0xc(%ebp)
f011a68a:	50                   	push   %eax
f011a68b:	8b 45 08             	mov    0x8(%ebp),%eax
f011a68e:	ff d0                	call   *%eax
f011a690:	83 c4 10             	add    $0x10,%esp
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
f011a693:	ff 4d e4             	decl   -0x1c(%ebp)
f011a696:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a69a:	7f e4                	jg     f011a680 <vprintfmt+0x1c7>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011a69c:	eb 34                	jmp    f011a6d2 <vprintfmt+0x219>
				if (altflag && (ch < ' ' || ch > '~'))
f011a69e:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
f011a6a2:	74 1c                	je     f011a6c0 <vprintfmt+0x207>
f011a6a4:	83 fb 1f             	cmp    $0x1f,%ebx
f011a6a7:	7e 05                	jle    f011a6ae <vprintfmt+0x1f5>
f011a6a9:	83 fb 7e             	cmp    $0x7e,%ebx
f011a6ac:	7e 12                	jle    f011a6c0 <vprintfmt+0x207>
					putch('?', putdat);
f011a6ae:	83 ec 08             	sub    $0x8,%esp
f011a6b1:	ff 75 0c             	pushl  0xc(%ebp)
f011a6b4:	6a 3f                	push   $0x3f
f011a6b6:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6b9:	ff d0                	call   *%eax
f011a6bb:	83 c4 10             	add    $0x10,%esp
f011a6be:	eb 0f                	jmp    f011a6cf <vprintfmt+0x216>
				else
					putch(ch, putdat);
f011a6c0:	83 ec 08             	sub    $0x8,%esp
f011a6c3:	ff 75 0c             	pushl  0xc(%ebp)
f011a6c6:	53                   	push   %ebx
f011a6c7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6ca:	ff d0                	call   *%eax
f011a6cc:	83 c4 10             	add    $0x10,%esp
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
f011a6cf:	ff 4d e4             	decl   -0x1c(%ebp)
f011a6d2:	89 f0                	mov    %esi,%eax
f011a6d4:	8d 70 01             	lea    0x1(%eax),%esi
f011a6d7:	8a 00                	mov    (%eax),%al
f011a6d9:	0f be d8             	movsbl %al,%ebx
f011a6dc:	85 db                	test   %ebx,%ebx
f011a6de:	74 24                	je     f011a704 <vprintfmt+0x24b>
f011a6e0:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011a6e4:	78 b8                	js     f011a69e <vprintfmt+0x1e5>
f011a6e6:	ff 4d e0             	decl   -0x20(%ebp)
f011a6e9:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
f011a6ed:	79 af                	jns    f011a69e <vprintfmt+0x1e5>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011a6ef:	eb 13                	jmp    f011a704 <vprintfmt+0x24b>
				putch(' ', putdat);
f011a6f1:	83 ec 08             	sub    $0x8,%esp
f011a6f4:	ff 75 0c             	pushl  0xc(%ebp)
f011a6f7:	6a 20                	push   $0x20
f011a6f9:	8b 45 08             	mov    0x8(%ebp),%eax
f011a6fc:	ff d0                	call   *%eax
f011a6fe:	83 c4 10             	add    $0x10,%esp
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
f011a701:	ff 4d e4             	decl   -0x1c(%ebp)
f011a704:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
f011a708:	7f e7                	jg     f011a6f1 <vprintfmt+0x238>
				putch(' ', putdat);
			break;
f011a70a:	e9 78 01 00 00       	jmp    f011a887 <vprintfmt+0x3ce>

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
f011a70f:	83 ec 08             	sub    $0x8,%esp
f011a712:	ff 75 e8             	pushl  -0x18(%ebp)
f011a715:	8d 45 14             	lea    0x14(%ebp),%eax
f011a718:	50                   	push   %eax
f011a719:	e8 3c fd ff ff       	call   f011a45a <getint>
f011a71e:	83 c4 10             	add    $0x10,%esp
f011a721:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a724:	89 55 f4             	mov    %edx,-0xc(%ebp)
			if ((long long) num < 0) {
f011a727:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a72a:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a72d:	85 d2                	test   %edx,%edx
f011a72f:	79 23                	jns    f011a754 <vprintfmt+0x29b>
				putch('-', putdat);
f011a731:	83 ec 08             	sub    $0x8,%esp
f011a734:	ff 75 0c             	pushl  0xc(%ebp)
f011a737:	6a 2d                	push   $0x2d
f011a739:	8b 45 08             	mov    0x8(%ebp),%eax
f011a73c:	ff d0                	call   *%eax
f011a73e:	83 c4 10             	add    $0x10,%esp
				num = -(long long) num;
f011a741:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011a744:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011a747:	f7 d8                	neg    %eax
f011a749:	83 d2 00             	adc    $0x0,%edx
f011a74c:	f7 da                	neg    %edx
f011a74e:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a751:	89 55 f4             	mov    %edx,-0xc(%ebp)
			}
			base = 10;
f011a754:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011a75b:	e9 bc 00 00 00       	jmp    f011a81c <vprintfmt+0x363>

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
f011a760:	83 ec 08             	sub    $0x8,%esp
f011a763:	ff 75 e8             	pushl  -0x18(%ebp)
f011a766:	8d 45 14             	lea    0x14(%ebp),%eax
f011a769:	50                   	push   %eax
f011a76a:	e8 84 fc ff ff       	call   f011a3f3 <getuint>
f011a76f:	83 c4 10             	add    $0x10,%esp
f011a772:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a775:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 10;
f011a778:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
			goto number;
f011a77f:	e9 98 00 00 00       	jmp    f011a81c <vprintfmt+0x363>

		// (unsigned) octal
		case 'o':
			// Replace this with your code.
			putch('X', putdat);
f011a784:	83 ec 08             	sub    $0x8,%esp
f011a787:	ff 75 0c             	pushl  0xc(%ebp)
f011a78a:	6a 58                	push   $0x58
f011a78c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a78f:	ff d0                	call   *%eax
f011a791:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011a794:	83 ec 08             	sub    $0x8,%esp
f011a797:	ff 75 0c             	pushl  0xc(%ebp)
f011a79a:	6a 58                	push   $0x58
f011a79c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a79f:	ff d0                	call   *%eax
f011a7a1:	83 c4 10             	add    $0x10,%esp
			putch('X', putdat);
f011a7a4:	83 ec 08             	sub    $0x8,%esp
f011a7a7:	ff 75 0c             	pushl  0xc(%ebp)
f011a7aa:	6a 58                	push   $0x58
f011a7ac:	8b 45 08             	mov    0x8(%ebp),%eax
f011a7af:	ff d0                	call   *%eax
f011a7b1:	83 c4 10             	add    $0x10,%esp
			break;
f011a7b4:	e9 ce 00 00 00       	jmp    f011a887 <vprintfmt+0x3ce>

		// pointer
		case 'p':
			putch('0', putdat);
f011a7b9:	83 ec 08             	sub    $0x8,%esp
f011a7bc:	ff 75 0c             	pushl  0xc(%ebp)
f011a7bf:	6a 30                	push   $0x30
f011a7c1:	8b 45 08             	mov    0x8(%ebp),%eax
f011a7c4:	ff d0                	call   *%eax
f011a7c6:	83 c4 10             	add    $0x10,%esp
			putch('x', putdat);
f011a7c9:	83 ec 08             	sub    $0x8,%esp
f011a7cc:	ff 75 0c             	pushl  0xc(%ebp)
f011a7cf:	6a 78                	push   $0x78
f011a7d1:	8b 45 08             	mov    0x8(%ebp),%eax
f011a7d4:	ff d0                	call   *%eax
f011a7d6:	83 c4 10             	add    $0x10,%esp
			num = (unsigned long long)
				(uint32) va_arg(ap, void *);
f011a7d9:	8b 45 14             	mov    0x14(%ebp),%eax
f011a7dc:	83 c0 04             	add    $0x4,%eax
f011a7df:	89 45 14             	mov    %eax,0x14(%ebp)
f011a7e2:	8b 45 14             	mov    0x14(%ebp),%eax
f011a7e5:	83 e8 04             	sub    $0x4,%eax
f011a7e8:	8b 00                	mov    (%eax),%eax

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
f011a7ea:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a7ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
				(uint32) va_arg(ap, void *);
			base = 16;
f011a7f4:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
			goto number;
f011a7fb:	eb 1f                	jmp    f011a81c <vprintfmt+0x363>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
f011a7fd:	83 ec 08             	sub    $0x8,%esp
f011a800:	ff 75 e8             	pushl  -0x18(%ebp)
f011a803:	8d 45 14             	lea    0x14(%ebp),%eax
f011a806:	50                   	push   %eax
f011a807:	e8 e7 fb ff ff       	call   f011a3f3 <getuint>
f011a80c:	83 c4 10             	add    $0x10,%esp
f011a80f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a812:	89 55 f4             	mov    %edx,-0xc(%ebp)
			base = 16;
f011a815:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
		number:
			printnum(putch, putdat, num, base, width, padc);
f011a81c:	0f be 55 db          	movsbl -0x25(%ebp),%edx
f011a820:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a823:	83 ec 04             	sub    $0x4,%esp
f011a826:	52                   	push   %edx
f011a827:	ff 75 e4             	pushl  -0x1c(%ebp)
f011a82a:	50                   	push   %eax
f011a82b:	ff 75 f4             	pushl  -0xc(%ebp)
f011a82e:	ff 75 f0             	pushl  -0x10(%ebp)
f011a831:	ff 75 0c             	pushl  0xc(%ebp)
f011a834:	ff 75 08             	pushl  0x8(%ebp)
f011a837:	e8 00 fb ff ff       	call   f011a33c <printnum>
f011a83c:	83 c4 20             	add    $0x20,%esp
			break;
f011a83f:	eb 46                	jmp    f011a887 <vprintfmt+0x3ce>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
f011a841:	83 ec 08             	sub    $0x8,%esp
f011a844:	ff 75 0c             	pushl  0xc(%ebp)
f011a847:	53                   	push   %ebx
f011a848:	8b 45 08             	mov    0x8(%ebp),%eax
f011a84b:	ff d0                	call   *%eax
f011a84d:	83 c4 10             	add    $0x10,%esp
			break;
f011a850:	eb 35                	jmp    f011a887 <vprintfmt+0x3ce>

		/**********************************/
		/*2023*/
		// DON'T Print Program Name & UD
		case '~':
			printProgName = 0;
f011a852:	c6 05 00 e7 83 f0 00 	movb   $0x0,0xf083e700
			break;
f011a859:	eb 2c                	jmp    f011a887 <vprintfmt+0x3ce>
		// Print Program Name & UD
		case '@':
			printProgName = 1;
f011a85b:	c6 05 00 e7 83 f0 01 	movb   $0x1,0xf083e700
			break;
f011a862:	eb 23                	jmp    f011a887 <vprintfmt+0x3ce>
		/**********************************/

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
f011a864:	83 ec 08             	sub    $0x8,%esp
f011a867:	ff 75 0c             	pushl  0xc(%ebp)
f011a86a:	6a 25                	push   $0x25
f011a86c:	8b 45 08             	mov    0x8(%ebp),%eax
f011a86f:	ff d0                	call   *%eax
f011a871:	83 c4 10             	add    $0x10,%esp
			for (fmt--; fmt[-1] != '%'; fmt--)
f011a874:	ff 4d 10             	decl   0x10(%ebp)
f011a877:	eb 03                	jmp    f011a87c <vprintfmt+0x3c3>
f011a879:	ff 4d 10             	decl   0x10(%ebp)
f011a87c:	8b 45 10             	mov    0x10(%ebp),%eax
f011a87f:	48                   	dec    %eax
f011a880:	8a 00                	mov    (%eax),%al
f011a882:	3c 25                	cmp    $0x25,%al
f011a884:	75 f3                	jne    f011a879 <vprintfmt+0x3c0>
				/* do nothing */;
			break;
f011a886:	90                   	nop
		}
	}
f011a887:	e9 35 fc ff ff       	jmp    f011a4c1 <vprintfmt+0x8>
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
				return;
f011a88c:	90                   	nop
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
f011a88d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011a890:	5b                   	pop    %ebx
f011a891:	5e                   	pop    %esi
f011a892:	5d                   	pop    %ebp
f011a893:	c3                   	ret    

f011a894 <printfmt>:

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
f011a894:	55                   	push   %ebp
f011a895:	89 e5                	mov    %esp,%ebp
f011a897:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
f011a89a:	8d 45 10             	lea    0x10(%ebp),%eax
f011a89d:	83 c0 04             	add    $0x4,%eax
f011a8a0:	89 45 f4             	mov    %eax,-0xc(%ebp)
	vprintfmt(putch, putdat, fmt, ap);
f011a8a3:	8b 45 10             	mov    0x10(%ebp),%eax
f011a8a6:	ff 75 f4             	pushl  -0xc(%ebp)
f011a8a9:	50                   	push   %eax
f011a8aa:	ff 75 0c             	pushl  0xc(%ebp)
f011a8ad:	ff 75 08             	pushl  0x8(%ebp)
f011a8b0:	e8 04 fc ff ff       	call   f011a4b9 <vprintfmt>
f011a8b5:	83 c4 10             	add    $0x10,%esp
	va_end(ap);
}
f011a8b8:	90                   	nop
f011a8b9:	c9                   	leave  
f011a8ba:	c3                   	ret    

f011a8bb <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
f011a8bb:	55                   	push   %ebp
f011a8bc:	89 e5                	mov    %esp,%ebp
	b->cnt++;
f011a8be:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a8c1:	8b 40 08             	mov    0x8(%eax),%eax
f011a8c4:	8d 50 01             	lea    0x1(%eax),%edx
f011a8c7:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a8ca:	89 50 08             	mov    %edx,0x8(%eax)
	if (b->buf < b->ebuf)
f011a8cd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a8d0:	8b 10                	mov    (%eax),%edx
f011a8d2:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a8d5:	8b 40 04             	mov    0x4(%eax),%eax
f011a8d8:	39 c2                	cmp    %eax,%edx
f011a8da:	73 12                	jae    f011a8ee <sprintputch+0x33>
		*b->buf++ = ch;
f011a8dc:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a8df:	8b 00                	mov    (%eax),%eax
f011a8e1:	8d 48 01             	lea    0x1(%eax),%ecx
f011a8e4:	8b 55 0c             	mov    0xc(%ebp),%edx
f011a8e7:	89 0a                	mov    %ecx,(%edx)
f011a8e9:	8b 55 08             	mov    0x8(%ebp),%edx
f011a8ec:	88 10                	mov    %dl,(%eax)
}
f011a8ee:	90                   	nop
f011a8ef:	5d                   	pop    %ebp
f011a8f0:	c3                   	ret    

f011a8f1 <vsnprintf>:

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
f011a8f1:	55                   	push   %ebp
f011a8f2:	89 e5                	mov    %esp,%ebp
f011a8f4:	83 ec 18             	sub    $0x18,%esp
	struct sprintbuf b = {buf, buf+n-1, 0};
f011a8f7:	8b 45 08             	mov    0x8(%ebp),%eax
f011a8fa:	89 45 ec             	mov    %eax,-0x14(%ebp)
f011a8fd:	8b 45 0c             	mov    0xc(%ebp),%eax
f011a900:	8d 50 ff             	lea    -0x1(%eax),%edx
f011a903:	8b 45 08             	mov    0x8(%ebp),%eax
f011a906:	01 d0                	add    %edx,%eax
f011a908:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011a90b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
f011a912:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a916:	74 06                	je     f011a91e <vsnprintf+0x2d>
f011a918:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011a91c:	7f 07                	jg     f011a925 <vsnprintf+0x34>
		return -E_INVAL;
f011a91e:	b8 03 00 00 00       	mov    $0x3,%eax
f011a923:	eb 20                	jmp    f011a945 <vsnprintf+0x54>

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
f011a925:	ff 75 14             	pushl  0x14(%ebp)
f011a928:	ff 75 10             	pushl  0x10(%ebp)
f011a92b:	8d 45 ec             	lea    -0x14(%ebp),%eax
f011a92e:	50                   	push   %eax
f011a92f:	68 bb a8 11 f0       	push   $0xf011a8bb
f011a934:	e8 80 fb ff ff       	call   f011a4b9 <vprintfmt>
f011a939:	83 c4 10             	add    $0x10,%esp

	// null terminate the buffer
	*b.buf = '\0';
f011a93c:	8b 45 ec             	mov    -0x14(%ebp),%eax
f011a93f:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
f011a942:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
f011a945:	c9                   	leave  
f011a946:	c3                   	ret    

f011a947 <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
f011a947:	55                   	push   %ebp
f011a948:	89 e5                	mov    %esp,%ebp
f011a94a:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
f011a94d:	8d 45 10             	lea    0x10(%ebp),%eax
f011a950:	83 c0 04             	add    $0x4,%eax
f011a953:	89 45 f4             	mov    %eax,-0xc(%ebp)
	rc = vsnprintf(buf, n, fmt, ap);
f011a956:	8b 45 10             	mov    0x10(%ebp),%eax
f011a959:	ff 75 f4             	pushl  -0xc(%ebp)
f011a95c:	50                   	push   %eax
f011a95d:	ff 75 0c             	pushl  0xc(%ebp)
f011a960:	ff 75 08             	pushl  0x8(%ebp)
f011a963:	e8 89 ff ff ff       	call   f011a8f1 <vsnprintf>
f011a968:	83 c4 10             	add    $0x10,%esp
f011a96b:	89 45 f0             	mov    %eax,-0x10(%ebp)
	va_end(ap);

	return rc;
f011a96e:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
f011a971:	c9                   	leave  
f011a972:	c3                   	ret    

f011a973 <readline>:
#include <inc/lib.h>

//static char buf[BUFLEN];

void readline(const char *prompt, char* buf)
{
f011a973:	55                   	push   %ebp
f011a974:	89 e5                	mov    %esp,%ebp
f011a976:	83 ec 18             	sub    $0x18,%esp
	int i, c, echoing;

	if (prompt != NULL)
f011a979:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011a97d:	74 13                	je     f011a992 <readline+0x1f>
		cprintf("%s", prompt);
f011a97f:	83 ec 08             	sub    $0x8,%esp
f011a982:	ff 75 08             	pushl  0x8(%ebp)
f011a985:	68 68 65 13 f0       	push   $0xf0136568
f011a98a:	e8 cd 72 fe ff       	call   f0101c5c <cprintf>
f011a98f:	83 c4 10             	add    $0x10,%esp

	i = 0;
f011a992:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	echoing = iscons(0);
f011a999:	83 ec 0c             	sub    $0xc,%esp
f011a99c:	6a 00                	push   $0x0
f011a99e:	e8 83 71 fe ff       	call   f0101b26 <iscons>
f011a9a3:	83 c4 10             	add    $0x10,%esp
f011a9a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while (1) {
		c = getchar();
f011a9a9:	e8 5f 71 fe ff       	call   f0101b0d <getchar>
f011a9ae:	89 45 ec             	mov    %eax,-0x14(%ebp)
		if (c < 0) {
f011a9b1:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011a9b5:	79 22                	jns    f011a9d9 <readline+0x66>
			if (c != -E_EOF)
f011a9b7:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011a9bb:	0f 84 ad 00 00 00    	je     f011aa6e <readline+0xfb>
				cprintf("read error: %e\n", c);
f011a9c1:	83 ec 08             	sub    $0x8,%esp
f011a9c4:	ff 75 ec             	pushl  -0x14(%ebp)
f011a9c7:	68 6b 65 13 f0       	push   $0xf013656b
f011a9cc:	e8 8b 72 fe ff       	call   f0101c5c <cprintf>
f011a9d1:	83 c4 10             	add    $0x10,%esp
			break;
f011a9d4:	e9 95 00 00 00       	jmp    f011aa6e <readline+0xfb>
		} else if (c >= ' ' && i < BUFLEN-1) {
f011a9d9:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011a9dd:	7e 34                	jle    f011aa13 <readline+0xa0>
f011a9df:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011a9e6:	7f 2b                	jg     f011aa13 <readline+0xa0>
			if (echoing)
f011a9e8:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011a9ec:	74 0e                	je     f011a9fc <readline+0x89>
				cputchar(c);
f011a9ee:	83 ec 0c             	sub    $0xc,%esp
f011a9f1:	ff 75 ec             	pushl  -0x14(%ebp)
f011a9f4:	e8 fd 70 fe ff       	call   f0101af6 <cputchar>
f011a9f9:	83 c4 10             	add    $0x10,%esp
			buf[i++] = c;
f011a9fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011a9ff:	8d 50 01             	lea    0x1(%eax),%edx
f011aa02:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011aa05:	89 c2                	mov    %eax,%edx
f011aa07:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa0a:	01 d0                	add    %edx,%eax
f011aa0c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011aa0f:	88 10                	mov    %dl,(%eax)
f011aa11:	eb 56                	jmp    f011aa69 <readline+0xf6>
		} else if (c == '\b' && i > 0) {
f011aa13:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011aa17:	75 1f                	jne    f011aa38 <readline+0xc5>
f011aa19:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011aa1d:	7e 19                	jle    f011aa38 <readline+0xc5>
			if (echoing)
f011aa1f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa23:	74 0e                	je     f011aa33 <readline+0xc0>
				cputchar(c);
f011aa25:	83 ec 0c             	sub    $0xc,%esp
f011aa28:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa2b:	e8 c6 70 fe ff       	call   f0101af6 <cputchar>
f011aa30:	83 c4 10             	add    $0x10,%esp

			i--;
f011aa33:	ff 4d f4             	decl   -0xc(%ebp)
f011aa36:	eb 31                	jmp    f011aa69 <readline+0xf6>
		} else if (c == '\n' || c == '\r') {
f011aa38:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011aa3c:	74 0a                	je     f011aa48 <readline+0xd5>
f011aa3e:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011aa42:	0f 85 61 ff ff ff    	jne    f011a9a9 <readline+0x36>
			if (echoing)
f011aa48:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aa4c:	74 0e                	je     f011aa5c <readline+0xe9>
				cputchar(c);
f011aa4e:	83 ec 0c             	sub    $0xc,%esp
f011aa51:	ff 75 ec             	pushl  -0x14(%ebp)
f011aa54:	e8 9d 70 fe ff       	call   f0101af6 <cputchar>
f011aa59:	83 c4 10             	add    $0x10,%esp

			buf[i] = 0;
f011aa5c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011aa5f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aa62:	01 d0                	add    %edx,%eax
f011aa64:	c6 00 00             	movb   $0x0,(%eax)
			break;
f011aa67:	eb 06                	jmp    f011aa6f <readline+0xfc>
		}
	}
f011aa69:	e9 3b ff ff ff       	jmp    f011a9a9 <readline+0x36>
	while (1) {
		c = getchar();
		if (c < 0) {
			if (c != -E_EOF)
				cprintf("read error: %e\n", c);
			break;
f011aa6e:	90                   	nop

			buf[i] = 0;
			break;
		}
	}
}
f011aa6f:	90                   	nop
f011aa70:	c9                   	leave  
f011aa71:	c3                   	ret    

f011aa72 <atomic_readline>:

void atomic_readline(const char *prompt, char* buf)
{
f011aa72:	55                   	push   %ebp
f011aa73:	89 e5                	mov    %esp,%ebp
f011aa75:	83 ec 18             	sub    $0x18,%esp
	sys_lock_cons();
f011aa78:	e8 de 3d ff ff       	call   f010e85b <sys_lock_cons>
	{
		int i, c, echoing;

		if (prompt != NULL)
f011aa7d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011aa81:	74 13                	je     f011aa96 <atomic_readline+0x24>
			cprintf("%s", prompt);
f011aa83:	83 ec 08             	sub    $0x8,%esp
f011aa86:	ff 75 08             	pushl  0x8(%ebp)
f011aa89:	68 68 65 13 f0       	push   $0xf0136568
f011aa8e:	e8 c9 71 fe ff       	call   f0101c5c <cprintf>
f011aa93:	83 c4 10             	add    $0x10,%esp

		i = 0;
f011aa96:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
		echoing = iscons(0);
f011aa9d:	83 ec 0c             	sub    $0xc,%esp
f011aaa0:	6a 00                	push   $0x0
f011aaa2:	e8 7f 70 fe ff       	call   f0101b26 <iscons>
f011aaa7:	83 c4 10             	add    $0x10,%esp
f011aaaa:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (1) {
			c = getchar();
f011aaad:	e8 5b 70 fe ff       	call   f0101b0d <getchar>
f011aab2:	89 45 ec             	mov    %eax,-0x14(%ebp)
			if (c < 0) {
f011aab5:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
f011aab9:	79 22                	jns    f011aadd <atomic_readline+0x6b>
				if (c != -E_EOF)
f011aabb:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
f011aabf:	0f 84 ad 00 00 00    	je     f011ab72 <atomic_readline+0x100>
					cprintf("read error: %e\n", c);
f011aac5:	83 ec 08             	sub    $0x8,%esp
f011aac8:	ff 75 ec             	pushl  -0x14(%ebp)
f011aacb:	68 6b 65 13 f0       	push   $0xf013656b
f011aad0:	e8 87 71 fe ff       	call   f0101c5c <cprintf>
f011aad5:	83 c4 10             	add    $0x10,%esp
				break;
f011aad8:	e9 95 00 00 00       	jmp    f011ab72 <atomic_readline+0x100>
			} else if (c >= ' ' && i < BUFLEN-1) {
f011aadd:	83 7d ec 1f          	cmpl   $0x1f,-0x14(%ebp)
f011aae1:	7e 34                	jle    f011ab17 <atomic_readline+0xa5>
f011aae3:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
f011aaea:	7f 2b                	jg     f011ab17 <atomic_readline+0xa5>
				if (echoing)
f011aaec:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011aaf0:	74 0e                	je     f011ab00 <atomic_readline+0x8e>
					cputchar(c);
f011aaf2:	83 ec 0c             	sub    $0xc,%esp
f011aaf5:	ff 75 ec             	pushl  -0x14(%ebp)
f011aaf8:	e8 f9 6f fe ff       	call   f0101af6 <cputchar>
f011aafd:	83 c4 10             	add    $0x10,%esp
				buf[i++] = c;
f011ab00:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011ab03:	8d 50 01             	lea    0x1(%eax),%edx
f011ab06:	89 55 f4             	mov    %edx,-0xc(%ebp)
f011ab09:	89 c2                	mov    %eax,%edx
f011ab0b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ab0e:	01 d0                	add    %edx,%eax
f011ab10:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011ab13:	88 10                	mov    %dl,(%eax)
f011ab15:	eb 56                	jmp    f011ab6d <atomic_readline+0xfb>
			} else if (c == '\b' && i > 0) {
f011ab17:	83 7d ec 08          	cmpl   $0x8,-0x14(%ebp)
f011ab1b:	75 1f                	jne    f011ab3c <atomic_readline+0xca>
f011ab1d:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
f011ab21:	7e 19                	jle    f011ab3c <atomic_readline+0xca>
				if (echoing)
f011ab23:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ab27:	74 0e                	je     f011ab37 <atomic_readline+0xc5>
					cputchar(c);
f011ab29:	83 ec 0c             	sub    $0xc,%esp
f011ab2c:	ff 75 ec             	pushl  -0x14(%ebp)
f011ab2f:	e8 c2 6f fe ff       	call   f0101af6 <cputchar>
f011ab34:	83 c4 10             	add    $0x10,%esp
				i--;
f011ab37:	ff 4d f4             	decl   -0xc(%ebp)
f011ab3a:	eb 31                	jmp    f011ab6d <atomic_readline+0xfb>
			} else if (c == '\n' || c == '\r') {
f011ab3c:	83 7d ec 0a          	cmpl   $0xa,-0x14(%ebp)
f011ab40:	74 0a                	je     f011ab4c <atomic_readline+0xda>
f011ab42:	83 7d ec 0d          	cmpl   $0xd,-0x14(%ebp)
f011ab46:	0f 85 61 ff ff ff    	jne    f011aaad <atomic_readline+0x3b>
				if (echoing)
f011ab4c:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
f011ab50:	74 0e                	je     f011ab60 <atomic_readline+0xee>
					cputchar(c);
f011ab52:	83 ec 0c             	sub    $0xc,%esp
f011ab55:	ff 75 ec             	pushl  -0x14(%ebp)
f011ab58:	e8 99 6f fe ff       	call   f0101af6 <cputchar>
f011ab5d:	83 c4 10             	add    $0x10,%esp
				buf[i] = 0;
f011ab60:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ab63:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ab66:	01 d0                	add    %edx,%eax
f011ab68:	c6 00 00             	movb   $0x0,(%eax)
				break;
f011ab6b:	eb 06                	jmp    f011ab73 <atomic_readline+0x101>
			}
		}
f011ab6d:	e9 3b ff ff ff       	jmp    f011aaad <atomic_readline+0x3b>
		while (1) {
			c = getchar();
			if (c < 0) {
				if (c != -E_EOF)
					cprintf("read error: %e\n", c);
				break;
f011ab72:	90                   	nop
				buf[i] = 0;
				break;
			}
		}
	}
	sys_unlock_cons();
f011ab73:	e8 f1 3c ff ff       	call   f010e869 <sys_unlock_cons>
}
f011ab78:	90                   	nop
f011ab79:	c9                   	leave  
f011ab7a:	c3                   	ret    

f011ab7b <strlen>:

#include <inc/string.h>

int
strlen(const char *s)
{
f011ab7b:	55                   	push   %ebp
f011ab7c:	89 e5                	mov    %esp,%ebp
f011ab7e:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; *s != '\0'; s++)
f011ab81:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ab88:	eb 06                	jmp    f011ab90 <strlen+0x15>
		n++;
f011ab8a:	ff 45 fc             	incl   -0x4(%ebp)
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
f011ab8d:	ff 45 08             	incl   0x8(%ebp)
f011ab90:	8b 45 08             	mov    0x8(%ebp),%eax
f011ab93:	8a 00                	mov    (%eax),%al
f011ab95:	84 c0                	test   %al,%al
f011ab97:	75 f1                	jne    f011ab8a <strlen+0xf>
		n++;
	return n;
f011ab99:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011ab9c:	c9                   	leave  
f011ab9d:	c3                   	ret    

f011ab9e <strnlen>:

int
strnlen(const char *s, uint32 size)
{
f011ab9e:	55                   	push   %ebp
f011ab9f:	89 e5                	mov    %esp,%ebp
f011aba1:	83 ec 10             	sub    $0x10,%esp
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011aba4:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011abab:	eb 09                	jmp    f011abb6 <strnlen+0x18>
		n++;
f011abad:	ff 45 fc             	incl   -0x4(%ebp)
int
strnlen(const char *s, uint32 size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
f011abb0:	ff 45 08             	incl   0x8(%ebp)
f011abb3:	ff 4d 0c             	decl   0xc(%ebp)
f011abb6:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011abba:	74 09                	je     f011abc5 <strnlen+0x27>
f011abbc:	8b 45 08             	mov    0x8(%ebp),%eax
f011abbf:	8a 00                	mov    (%eax),%al
f011abc1:	84 c0                	test   %al,%al
f011abc3:	75 e8                	jne    f011abad <strnlen+0xf>
		n++;
	return n;
f011abc5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011abc8:	c9                   	leave  
f011abc9:	c3                   	ret    

f011abca <strcpy>:

char *
strcpy(char *dst, const char *src)
{
f011abca:	55                   	push   %ebp
f011abcb:	89 e5                	mov    %esp,%ebp
f011abcd:	83 ec 10             	sub    $0x10,%esp
	char *ret;

	ret = dst;
f011abd0:	8b 45 08             	mov    0x8(%ebp),%eax
f011abd3:	89 45 fc             	mov    %eax,-0x4(%ebp)
	while ((*dst++ = *src++) != '\0')
f011abd6:	90                   	nop
f011abd7:	8b 45 08             	mov    0x8(%ebp),%eax
f011abda:	8d 50 01             	lea    0x1(%eax),%edx
f011abdd:	89 55 08             	mov    %edx,0x8(%ebp)
f011abe0:	8b 55 0c             	mov    0xc(%ebp),%edx
f011abe3:	8d 4a 01             	lea    0x1(%edx),%ecx
f011abe6:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011abe9:	8a 12                	mov    (%edx),%dl
f011abeb:	88 10                	mov    %dl,(%eax)
f011abed:	8a 00                	mov    (%eax),%al
f011abef:	84 c0                	test   %al,%al
f011abf1:	75 e4                	jne    f011abd7 <strcpy+0xd>
		/* do nothing */;
	return ret;
f011abf3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
f011abf6:	c9                   	leave  
f011abf7:	c3                   	ret    

f011abf8 <strncpy>:

char *
strncpy(char *dst, const char *src, uint32 size) {
f011abf8:	55                   	push   %ebp
f011abf9:	89 e5                	mov    %esp,%ebp
f011abfb:	83 ec 10             	sub    $0x10,%esp
	uint32 i;
	char *ret;

	ret = dst;
f011abfe:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac01:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (i = 0; i < size; i++) {
f011ac04:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011ac0b:	eb 1f                	jmp    f011ac2c <strncpy+0x34>
		*dst++ = *src;
f011ac0d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac10:	8d 50 01             	lea    0x1(%eax),%edx
f011ac13:	89 55 08             	mov    %edx,0x8(%ebp)
f011ac16:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ac19:	8a 12                	mov    (%edx),%dl
f011ac1b:	88 10                	mov    %dl,(%eax)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
f011ac1d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac20:	8a 00                	mov    (%eax),%al
f011ac22:	84 c0                	test   %al,%al
f011ac24:	74 03                	je     f011ac29 <strncpy+0x31>
			src++;
f011ac26:	ff 45 0c             	incl   0xc(%ebp)
strncpy(char *dst, const char *src, uint32 size) {
	uint32 i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
f011ac29:	ff 45 fc             	incl   -0x4(%ebp)
f011ac2c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ac2f:	3b 45 10             	cmp    0x10(%ebp),%eax
f011ac32:	72 d9                	jb     f011ac0d <strncpy+0x15>
		*dst++ = *src;
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
f011ac34:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011ac37:	c9                   	leave  
f011ac38:	c3                   	ret    

f011ac39 <strlcpy>:

uint32
strlcpy(char *dst, const char *src, uint32 size)
{
f011ac39:	55                   	push   %ebp
f011ac3a:	89 e5                	mov    %esp,%ebp
f011ac3c:	83 ec 10             	sub    $0x10,%esp
	char *dst_in;

	dst_in = dst;
f011ac3f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac42:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if (size > 0) {
f011ac45:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ac49:	74 30                	je     f011ac7b <strlcpy+0x42>
		while (--size > 0 && *src != '\0')
f011ac4b:	eb 16                	jmp    f011ac63 <strlcpy+0x2a>
			*dst++ = *src++;
f011ac4d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac50:	8d 50 01             	lea    0x1(%eax),%edx
f011ac53:	89 55 08             	mov    %edx,0x8(%ebp)
f011ac56:	8b 55 0c             	mov    0xc(%ebp),%edx
f011ac59:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ac5c:	89 4d 0c             	mov    %ecx,0xc(%ebp)
f011ac5f:	8a 12                	mov    (%edx),%dl
f011ac61:	88 10                	mov    %dl,(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
f011ac63:	ff 4d 10             	decl   0x10(%ebp)
f011ac66:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ac6a:	74 09                	je     f011ac75 <strlcpy+0x3c>
f011ac6c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ac6f:	8a 00                	mov    (%eax),%al
f011ac71:	84 c0                	test   %al,%al
f011ac73:	75 d8                	jne    f011ac4d <strlcpy+0x14>
			*dst++ = *src++;
		*dst = '\0';
f011ac75:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac78:	c6 00 00             	movb   $0x0,(%eax)
	}
	return dst - dst_in;
f011ac7b:	8b 55 08             	mov    0x8(%ebp),%edx
f011ac7e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ac81:	29 c2                	sub    %eax,%edx
f011ac83:	89 d0                	mov    %edx,%eax
}
f011ac85:	c9                   	leave  
f011ac86:	c3                   	ret    

f011ac87 <strcmp>:

int
strcmp(const char *p, const char *q)
{
f011ac87:	55                   	push   %ebp
f011ac88:	89 e5                	mov    %esp,%ebp
	while (*p && *p == *q)
f011ac8a:	eb 06                	jmp    f011ac92 <strcmp+0xb>
		p++, q++;
f011ac8c:	ff 45 08             	incl   0x8(%ebp)
f011ac8f:	ff 45 0c             	incl   0xc(%ebp)
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
f011ac92:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac95:	8a 00                	mov    (%eax),%al
f011ac97:	84 c0                	test   %al,%al
f011ac99:	74 0e                	je     f011aca9 <strcmp+0x22>
f011ac9b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ac9e:	8a 10                	mov    (%eax),%dl
f011aca0:	8b 45 0c             	mov    0xc(%ebp),%eax
f011aca3:	8a 00                	mov    (%eax),%al
f011aca5:	38 c2                	cmp    %al,%dl
f011aca7:	74 e3                	je     f011ac8c <strcmp+0x5>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
f011aca9:	8b 45 08             	mov    0x8(%ebp),%eax
f011acac:	8a 00                	mov    (%eax),%al
f011acae:	0f b6 d0             	movzbl %al,%edx
f011acb1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011acb4:	8a 00                	mov    (%eax),%al
f011acb6:	0f b6 c0             	movzbl %al,%eax
f011acb9:	29 c2                	sub    %eax,%edx
f011acbb:	89 d0                	mov    %edx,%eax
}
f011acbd:	5d                   	pop    %ebp
f011acbe:	c3                   	ret    

f011acbf <strncmp>:

int
strncmp(const char *p, const char *q, uint32 n)
{
f011acbf:	55                   	push   %ebp
f011acc0:	89 e5                	mov    %esp,%ebp
	while (n > 0 && *p && *p == *q)
f011acc2:	eb 09                	jmp    f011accd <strncmp+0xe>
		n--, p++, q++;
f011acc4:	ff 4d 10             	decl   0x10(%ebp)
f011acc7:	ff 45 08             	incl   0x8(%ebp)
f011acca:	ff 45 0c             	incl   0xc(%ebp)
}

int
strncmp(const char *p, const char *q, uint32 n)
{
	while (n > 0 && *p && *p == *q)
f011accd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011acd1:	74 17                	je     f011acea <strncmp+0x2b>
f011acd3:	8b 45 08             	mov    0x8(%ebp),%eax
f011acd6:	8a 00                	mov    (%eax),%al
f011acd8:	84 c0                	test   %al,%al
f011acda:	74 0e                	je     f011acea <strncmp+0x2b>
f011acdc:	8b 45 08             	mov    0x8(%ebp),%eax
f011acdf:	8a 10                	mov    (%eax),%dl
f011ace1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ace4:	8a 00                	mov    (%eax),%al
f011ace6:	38 c2                	cmp    %al,%dl
f011ace8:	74 da                	je     f011acc4 <strncmp+0x5>
		n--, p++, q++;
	if (n == 0)
f011acea:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011acee:	75 07                	jne    f011acf7 <strncmp+0x38>
		return 0;
f011acf0:	b8 00 00 00 00       	mov    $0x0,%eax
f011acf5:	eb 14                	jmp    f011ad0b <strncmp+0x4c>
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
f011acf7:	8b 45 08             	mov    0x8(%ebp),%eax
f011acfa:	8a 00                	mov    (%eax),%al
f011acfc:	0f b6 d0             	movzbl %al,%edx
f011acff:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad02:	8a 00                	mov    (%eax),%al
f011ad04:	0f b6 c0             	movzbl %al,%eax
f011ad07:	29 c2                	sub    %eax,%edx
f011ad09:	89 d0                	mov    %edx,%eax
}
f011ad0b:	5d                   	pop    %ebp
f011ad0c:	c3                   	ret    

f011ad0d <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
f011ad0d:	55                   	push   %ebp
f011ad0e:	89 e5                	mov    %esp,%ebp
f011ad10:	83 ec 04             	sub    $0x4,%esp
f011ad13:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad16:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ad19:	eb 12                	jmp    f011ad2d <strchr+0x20>
		if (*s == c)
f011ad1b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad1e:	8a 00                	mov    (%eax),%al
f011ad20:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ad23:	75 05                	jne    f011ad2a <strchr+0x1d>
			return (char *) s;
f011ad25:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad28:	eb 11                	jmp    f011ad3b <strchr+0x2e>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
f011ad2a:	ff 45 08             	incl   0x8(%ebp)
f011ad2d:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad30:	8a 00                	mov    (%eax),%al
f011ad32:	84 c0                	test   %al,%al
f011ad34:	75 e5                	jne    f011ad1b <strchr+0xe>
		if (*s == c)
			return (char *) s;
	return 0;
f011ad36:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011ad3b:	c9                   	leave  
f011ad3c:	c3                   	ret    

f011ad3d <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
f011ad3d:	55                   	push   %ebp
f011ad3e:	89 e5                	mov    %esp,%ebp
f011ad40:	83 ec 04             	sub    $0x4,%esp
f011ad43:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad46:	88 45 fc             	mov    %al,-0x4(%ebp)
	for (; *s; s++)
f011ad49:	eb 0d                	jmp    f011ad58 <strfind+0x1b>
		if (*s == c)
f011ad4b:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad4e:	8a 00                	mov    (%eax),%al
f011ad50:	3a 45 fc             	cmp    -0x4(%ebp),%al
f011ad53:	74 0e                	je     f011ad63 <strfind+0x26>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
f011ad55:	ff 45 08             	incl   0x8(%ebp)
f011ad58:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad5b:	8a 00                	mov    (%eax),%al
f011ad5d:	84 c0                	test   %al,%al
f011ad5f:	75 ea                	jne    f011ad4b <strfind+0xe>
f011ad61:	eb 01                	jmp    f011ad64 <strfind+0x27>
		if (*s == c)
			break;
f011ad63:	90                   	nop
	return (char *) s;
f011ad64:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ad67:	c9                   	leave  
f011ad68:	c3                   	ret    

f011ad69 <memset>:

// *************** The faster implementation of memset & memcpy is implemented by *************
// ****************** Team80 (Yahia Khaled, Malek Ahmed et al) - FCIS'24-25 *******************
void *
memset(void *v, int c, uint32 n)
{
f011ad69:	55                   	push   %ebp
f011ad6a:	89 e5                	mov    %esp,%ebp
f011ad6c:	83 ec 10             	sub    $0x10,%esp
//	m = n;
//	while (--m >= 0)
//		*p++ = c;

	/*Faster Implementation*/
	uint64* p64 = (uint64*)v;
f011ad6f:	8b 45 08             	mov    0x8(%ebp),%eax
f011ad72:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(n >= 8){
f011ad75:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ad79:	76 63                	jbe    f011adde <memset+0x75>
		uint64 data_block = c;
f011ad7b:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ad7e:	99                   	cltd   
f011ad7f:	89 45 f0             	mov    %eax,-0x10(%ebp)
f011ad82:	89 55 f4             	mov    %edx,-0xc(%ebp)
		data_block |= data_block << 8;
f011ad85:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ad88:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad8b:	0f a4 c2 08          	shld   $0x8,%eax,%edx
f011ad8f:	c1 e0 08             	shl    $0x8,%eax
f011ad92:	09 45 f0             	or     %eax,-0x10(%ebp)
f011ad95:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 16;
f011ad98:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ad9b:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ad9e:	0f a4 c2 10          	shld   $0x10,%eax,%edx
f011ada2:	c1 e0 10             	shl    $0x10,%eax
f011ada5:	09 45 f0             	or     %eax,-0x10(%ebp)
f011ada8:	09 55 f4             	or     %edx,-0xc(%ebp)
		data_block |= data_block << 32;
f011adab:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011adae:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011adb1:	89 c2                	mov    %eax,%edx
f011adb3:	b8 00 00 00 00       	mov    $0x0,%eax
f011adb8:	09 45 f0             	or     %eax,-0x10(%ebp)
f011adbb:	09 55 f4             	or     %edx,-0xc(%ebp)

		while(n >= 8)
f011adbe:	eb 18                	jmp    f011add8 <memset+0x6f>
			*p64++ = data_block, n -= 8;
f011adc0:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011adc3:	8d 41 08             	lea    0x8(%ecx),%eax
f011adc6:	89 45 fc             	mov    %eax,-0x4(%ebp)
f011adc9:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011adcc:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011adcf:	89 01                	mov    %eax,(%ecx)
f011add1:	89 51 04             	mov    %edx,0x4(%ecx)
f011add4:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
		uint64 data_block = c;
		data_block |= data_block << 8;
		data_block |= data_block << 16;
		data_block |= data_block << 32;

		while(n >= 8)
f011add8:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011addc:	77 e2                	ja     f011adc0 <memset+0x57>
			*p64++ = data_block, n -= 8;
	}

	if(n){
f011adde:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ade2:	74 23                	je     f011ae07 <memset+0x9e>
		uint8* p8 = (uint8*)p64;
f011ade4:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ade7:	89 45 f8             	mov    %eax,-0x8(%ebp)
		while (n-- > 0)
f011adea:	eb 0e                	jmp    f011adfa <memset+0x91>
			*p8++ = (uint8)c;
f011adec:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011adef:	8d 50 01             	lea    0x1(%eax),%edx
f011adf2:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011adf5:	8b 55 0c             	mov    0xc(%ebp),%edx
f011adf8:	88 10                	mov    %dl,(%eax)
			*p64++ = data_block, n -= 8;
	}

	if(n){
		uint8* p8 = (uint8*)p64;
		while (n-- > 0)
f011adfa:	8b 45 10             	mov    0x10(%ebp),%eax
f011adfd:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ae00:	89 55 10             	mov    %edx,0x10(%ebp)
f011ae03:	85 c0                	test   %eax,%eax
f011ae05:	75 e5                	jne    f011adec <memset+0x83>
			*p8++ = (uint8)c;
	}

	return v;
f011ae07:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ae0a:	c9                   	leave  
f011ae0b:	c3                   	ret    

f011ae0c <memcpy>:

void *
memcpy(void *dst, const void *src, uint32 n)
{
f011ae0c:	55                   	push   %ebp
f011ae0d:	89 e5                	mov    %esp,%ebp
f011ae0f:	83 ec 10             	sub    $0x10,%esp
	//	s = src;
	//	d = dst;
	//	while (n-- > 0)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
f011ae12:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ae15:	89 45 fc             	mov    %eax,-0x4(%ebp)
	uint64* d64 = (uint64*)dst;
f011ae18:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae1b:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if(n >= 8){
f011ae1e:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ae22:	76 24                	jbe    f011ae48 <memcpy+0x3c>
		while(n >= 8){
f011ae24:	eb 1c                	jmp    f011ae42 <memcpy+0x36>
			*d64 = *s64;
f011ae26:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae29:	8b 50 04             	mov    0x4(%eax),%edx
f011ae2c:	8b 00                	mov    (%eax),%eax
f011ae2e:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011ae31:	89 01                	mov    %eax,(%ecx)
f011ae33:	89 51 04             	mov    %edx,0x4(%ecx)
			n -= 8;
f011ae36:	83 6d 10 08          	subl   $0x8,0x10(%ebp)
			++s64;
f011ae3a:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
			++d64;
f011ae3e:	83 45 f8 08          	addl   $0x8,-0x8(%ebp)
	//		*d++ = *s++;
	/*Faster Implementation*/
	uint64* s64 = (uint64*)src;
	uint64* d64 = (uint64*)dst;
	if(n >= 8){
		while(n >= 8){
f011ae42:	83 7d 10 07          	cmpl   $0x7,0x10(%ebp)
f011ae46:	77 de                	ja     f011ae26 <memcpy+0x1a>
			++s64;
			++d64;
		}
	}

	if(n){
f011ae48:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011ae4c:	74 31                	je     f011ae7f <memcpy+0x73>
		uint8* s8 = (uint8*)s64;
f011ae4e:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae51:	89 45 f4             	mov    %eax,-0xc(%ebp)
		uint8* d8 = (uint8*)d64;
f011ae54:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011ae57:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while (n-- > 0)
f011ae5a:	eb 16                	jmp    f011ae72 <memcpy+0x66>
			*d8++ = *s8++;
f011ae5c:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011ae5f:	8d 50 01             	lea    0x1(%eax),%edx
f011ae62:	89 55 f0             	mov    %edx,-0x10(%ebp)
f011ae65:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011ae68:	8d 4a 01             	lea    0x1(%edx),%ecx
f011ae6b:	89 4d f4             	mov    %ecx,-0xc(%ebp)
f011ae6e:	8a 12                	mov    (%edx),%dl
f011ae70:	88 10                	mov    %dl,(%eax)
	}

	if(n){
		uint8* s8 = (uint8*)s64;
		uint8* d8 = (uint8*)d64;
		while (n-- > 0)
f011ae72:	8b 45 10             	mov    0x10(%ebp),%eax
f011ae75:	8d 50 ff             	lea    -0x1(%eax),%edx
f011ae78:	89 55 10             	mov    %edx,0x10(%ebp)
f011ae7b:	85 c0                	test   %eax,%eax
f011ae7d:	75 dd                	jne    f011ae5c <memcpy+0x50>
			*d8++ = *s8++;
	}
	return dst;
f011ae7f:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011ae82:	c9                   	leave  
f011ae83:	c3                   	ret    

f011ae84 <memmove>:

void *
memmove(void *dst, const void *src, uint32 n)
{
f011ae84:	55                   	push   %ebp
f011ae85:	89 e5                	mov    %esp,%ebp
f011ae87:	83 ec 10             	sub    $0x10,%esp
	const char *s;
	char *d;

	s = src;
f011ae8a:	8b 45 0c             	mov    0xc(%ebp),%eax
f011ae8d:	89 45 fc             	mov    %eax,-0x4(%ebp)
	d = dst;
f011ae90:	8b 45 08             	mov    0x8(%ebp),%eax
f011ae93:	89 45 f8             	mov    %eax,-0x8(%ebp)
	if (s < d && s + n > d) {
f011ae96:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011ae99:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011ae9c:	73 50                	jae    f011aeee <memmove+0x6a>
f011ae9e:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011aea1:	8b 45 10             	mov    0x10(%ebp),%eax
f011aea4:	01 d0                	add    %edx,%eax
f011aea6:	3b 45 f8             	cmp    -0x8(%ebp),%eax
f011aea9:	76 43                	jbe    f011aeee <memmove+0x6a>
		s += n;
f011aeab:	8b 45 10             	mov    0x10(%ebp),%eax
f011aeae:	01 45 fc             	add    %eax,-0x4(%ebp)
		d += n;
f011aeb1:	8b 45 10             	mov    0x10(%ebp),%eax
f011aeb4:	01 45 f8             	add    %eax,-0x8(%ebp)
		while (n-- > 0)
f011aeb7:	eb 10                	jmp    f011aec9 <memmove+0x45>
			*--d = *--s;
f011aeb9:	ff 4d f8             	decl   -0x8(%ebp)
f011aebc:	ff 4d fc             	decl   -0x4(%ebp)
f011aebf:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011aec2:	8a 10                	mov    (%eax),%dl
f011aec4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011aec7:	88 10                	mov    %dl,(%eax)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		while (n-- > 0)
f011aec9:	8b 45 10             	mov    0x10(%ebp),%eax
f011aecc:	8d 50 ff             	lea    -0x1(%eax),%edx
f011aecf:	89 55 10             	mov    %edx,0x10(%ebp)
f011aed2:	85 c0                	test   %eax,%eax
f011aed4:	75 e3                	jne    f011aeb9 <memmove+0x35>
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
f011aed6:	eb 23                	jmp    f011aefb <memmove+0x77>
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
			*d++ = *s++;
f011aed8:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011aedb:	8d 50 01             	lea    0x1(%eax),%edx
f011aede:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011aee1:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011aee4:	8d 4a 01             	lea    0x1(%edx),%ecx
f011aee7:	89 4d fc             	mov    %ecx,-0x4(%ebp)
f011aeea:	8a 12                	mov    (%edx),%dl
f011aeec:	88 10                	mov    %dl,(%eax)
		s += n;
		d += n;
		while (n-- > 0)
			*--d = *--s;
	} else
		while (n-- > 0)
f011aeee:	8b 45 10             	mov    0x10(%ebp),%eax
f011aef1:	8d 50 ff             	lea    -0x1(%eax),%edx
f011aef4:	89 55 10             	mov    %edx,0x10(%ebp)
f011aef7:	85 c0                	test   %eax,%eax
f011aef9:	75 dd                	jne    f011aed8 <memmove+0x54>
			*d++ = *s++;

	return dst;
f011aefb:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011aefe:	c9                   	leave  
f011aeff:	c3                   	ret    

f011af00 <memcmp>:

int
memcmp(const void *v1, const void *v2, uint32 n)
{
f011af00:	55                   	push   %ebp
f011af01:	89 e5                	mov    %esp,%ebp
f011af03:	83 ec 10             	sub    $0x10,%esp
	const uint8 *s1 = (const uint8 *) v1;
f011af06:	8b 45 08             	mov    0x8(%ebp),%eax
f011af09:	89 45 fc             	mov    %eax,-0x4(%ebp)
	const uint8 *s2 = (const uint8 *) v2;
f011af0c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011af0f:	89 45 f8             	mov    %eax,-0x8(%ebp)

	while (n-- > 0) {
f011af12:	eb 2a                	jmp    f011af3e <memcmp+0x3e>
		if (*s1 != *s2)
f011af14:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011af17:	8a 10                	mov    (%eax),%dl
f011af19:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011af1c:	8a 00                	mov    (%eax),%al
f011af1e:	38 c2                	cmp    %al,%dl
f011af20:	74 16                	je     f011af38 <memcmp+0x38>
			return (int) *s1 - (int) *s2;
f011af22:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011af25:	8a 00                	mov    (%eax),%al
f011af27:	0f b6 d0             	movzbl %al,%edx
f011af2a:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011af2d:	8a 00                	mov    (%eax),%al
f011af2f:	0f b6 c0             	movzbl %al,%eax
f011af32:	29 c2                	sub    %eax,%edx
f011af34:	89 d0                	mov    %edx,%eax
f011af36:	eb 18                	jmp    f011af50 <memcmp+0x50>
		s1++, s2++;
f011af38:	ff 45 fc             	incl   -0x4(%ebp)
f011af3b:	ff 45 f8             	incl   -0x8(%ebp)
memcmp(const void *v1, const void *v2, uint32 n)
{
	const uint8 *s1 = (const uint8 *) v1;
	const uint8 *s2 = (const uint8 *) v2;

	while (n-- > 0) {
f011af3e:	8b 45 10             	mov    0x10(%ebp),%eax
f011af41:	8d 50 ff             	lea    -0x1(%eax),%edx
f011af44:	89 55 10             	mov    %edx,0x10(%ebp)
f011af47:	85 c0                	test   %eax,%eax
f011af49:	75 c9                	jne    f011af14 <memcmp+0x14>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
f011af4b:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011af50:	c9                   	leave  
f011af51:	c3                   	ret    

f011af52 <memfind>:

void *
memfind(const void *s, int c, uint32 n)
{
f011af52:	55                   	push   %ebp
f011af53:	89 e5                	mov    %esp,%ebp
f011af55:	83 ec 10             	sub    $0x10,%esp
	const void *ends = (const char *) s + n;
f011af58:	8b 55 08             	mov    0x8(%ebp),%edx
f011af5b:	8b 45 10             	mov    0x10(%ebp),%eax
f011af5e:	01 d0                	add    %edx,%eax
f011af60:	89 45 fc             	mov    %eax,-0x4(%ebp)
	for (; s < ends; s++)
f011af63:	eb 15                	jmp    f011af7a <memfind+0x28>
		if (*(const unsigned char *) s == (unsigned char) c)
f011af65:	8b 45 08             	mov    0x8(%ebp),%eax
f011af68:	8a 00                	mov    (%eax),%al
f011af6a:	0f b6 d0             	movzbl %al,%edx
f011af6d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011af70:	0f b6 c0             	movzbl %al,%eax
f011af73:	39 c2                	cmp    %eax,%edx
f011af75:	74 0d                	je     f011af84 <memfind+0x32>

void *
memfind(const void *s, int c, uint32 n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
f011af77:	ff 45 08             	incl   0x8(%ebp)
f011af7a:	8b 45 08             	mov    0x8(%ebp),%eax
f011af7d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011af80:	72 e3                	jb     f011af65 <memfind+0x13>
f011af82:	eb 01                	jmp    f011af85 <memfind+0x33>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
f011af84:	90                   	nop
	return (void *) s;
f011af85:	8b 45 08             	mov    0x8(%ebp),%eax
}
f011af88:	c9                   	leave  
f011af89:	c3                   	ret    

f011af8a <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
f011af8a:	55                   	push   %ebp
f011af8b:	89 e5                	mov    %esp,%ebp
f011af8d:	83 ec 10             	sub    $0x10,%esp
	int neg = 0;
f011af90:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	long val = 0;
f011af97:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011af9e:	eb 03                	jmp    f011afa3 <strtol+0x19>
		s++;
f011afa0:	ff 45 08             	incl   0x8(%ebp)
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
f011afa3:	8b 45 08             	mov    0x8(%ebp),%eax
f011afa6:	8a 00                	mov    (%eax),%al
f011afa8:	3c 20                	cmp    $0x20,%al
f011afaa:	74 f4                	je     f011afa0 <strtol+0x16>
f011afac:	8b 45 08             	mov    0x8(%ebp),%eax
f011afaf:	8a 00                	mov    (%eax),%al
f011afb1:	3c 09                	cmp    $0x9,%al
f011afb3:	74 eb                	je     f011afa0 <strtol+0x16>
		s++;

	// plus/minus sign
	if (*s == '+')
f011afb5:	8b 45 08             	mov    0x8(%ebp),%eax
f011afb8:	8a 00                	mov    (%eax),%al
f011afba:	3c 2b                	cmp    $0x2b,%al
f011afbc:	75 05                	jne    f011afc3 <strtol+0x39>
		s++;
f011afbe:	ff 45 08             	incl   0x8(%ebp)
f011afc1:	eb 13                	jmp    f011afd6 <strtol+0x4c>
	else if (*s == '-')
f011afc3:	8b 45 08             	mov    0x8(%ebp),%eax
f011afc6:	8a 00                	mov    (%eax),%al
f011afc8:	3c 2d                	cmp    $0x2d,%al
f011afca:	75 0a                	jne    f011afd6 <strtol+0x4c>
		s++, neg = 1;
f011afcc:	ff 45 08             	incl   0x8(%ebp)
f011afcf:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
f011afd6:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011afda:	74 06                	je     f011afe2 <strtol+0x58>
f011afdc:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
f011afe0:	75 20                	jne    f011b002 <strtol+0x78>
f011afe2:	8b 45 08             	mov    0x8(%ebp),%eax
f011afe5:	8a 00                	mov    (%eax),%al
f011afe7:	3c 30                	cmp    $0x30,%al
f011afe9:	75 17                	jne    f011b002 <strtol+0x78>
f011afeb:	8b 45 08             	mov    0x8(%ebp),%eax
f011afee:	40                   	inc    %eax
f011afef:	8a 00                	mov    (%eax),%al
f011aff1:	3c 78                	cmp    $0x78,%al
f011aff3:	75 0d                	jne    f011b002 <strtol+0x78>
		s += 2, base = 16;
f011aff5:	83 45 08 02          	addl   $0x2,0x8(%ebp)
f011aff9:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
f011b000:	eb 28                	jmp    f011b02a <strtol+0xa0>
	else if (base == 0 && s[0] == '0')
f011b002:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b006:	75 15                	jne    f011b01d <strtol+0x93>
f011b008:	8b 45 08             	mov    0x8(%ebp),%eax
f011b00b:	8a 00                	mov    (%eax),%al
f011b00d:	3c 30                	cmp    $0x30,%al
f011b00f:	75 0c                	jne    f011b01d <strtol+0x93>
		s++, base = 8;
f011b011:	ff 45 08             	incl   0x8(%ebp)
f011b014:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
f011b01b:	eb 0d                	jmp    f011b02a <strtol+0xa0>
	else if (base == 0)
f011b01d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b021:	75 07                	jne    f011b02a <strtol+0xa0>
		base = 10;
f011b023:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
f011b02a:	8b 45 08             	mov    0x8(%ebp),%eax
f011b02d:	8a 00                	mov    (%eax),%al
f011b02f:	3c 2f                	cmp    $0x2f,%al
f011b031:	7e 19                	jle    f011b04c <strtol+0xc2>
f011b033:	8b 45 08             	mov    0x8(%ebp),%eax
f011b036:	8a 00                	mov    (%eax),%al
f011b038:	3c 39                	cmp    $0x39,%al
f011b03a:	7f 10                	jg     f011b04c <strtol+0xc2>
			dig = *s - '0';
f011b03c:	8b 45 08             	mov    0x8(%ebp),%eax
f011b03f:	8a 00                	mov    (%eax),%al
f011b041:	0f be c0             	movsbl %al,%eax
f011b044:	83 e8 30             	sub    $0x30,%eax
f011b047:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b04a:	eb 42                	jmp    f011b08e <strtol+0x104>
		else if (*s >= 'a' && *s <= 'z')
f011b04c:	8b 45 08             	mov    0x8(%ebp),%eax
f011b04f:	8a 00                	mov    (%eax),%al
f011b051:	3c 60                	cmp    $0x60,%al
f011b053:	7e 19                	jle    f011b06e <strtol+0xe4>
f011b055:	8b 45 08             	mov    0x8(%ebp),%eax
f011b058:	8a 00                	mov    (%eax),%al
f011b05a:	3c 7a                	cmp    $0x7a,%al
f011b05c:	7f 10                	jg     f011b06e <strtol+0xe4>
			dig = *s - 'a' + 10;
f011b05e:	8b 45 08             	mov    0x8(%ebp),%eax
f011b061:	8a 00                	mov    (%eax),%al
f011b063:	0f be c0             	movsbl %al,%eax
f011b066:	83 e8 57             	sub    $0x57,%eax
f011b069:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b06c:	eb 20                	jmp    f011b08e <strtol+0x104>
		else if (*s >= 'A' && *s <= 'Z')
f011b06e:	8b 45 08             	mov    0x8(%ebp),%eax
f011b071:	8a 00                	mov    (%eax),%al
f011b073:	3c 40                	cmp    $0x40,%al
f011b075:	7e 39                	jle    f011b0b0 <strtol+0x126>
f011b077:	8b 45 08             	mov    0x8(%ebp),%eax
f011b07a:	8a 00                	mov    (%eax),%al
f011b07c:	3c 5a                	cmp    $0x5a,%al
f011b07e:	7f 30                	jg     f011b0b0 <strtol+0x126>
			dig = *s - 'A' + 10;
f011b080:	8b 45 08             	mov    0x8(%ebp),%eax
f011b083:	8a 00                	mov    (%eax),%al
f011b085:	0f be c0             	movsbl %al,%eax
f011b088:	83 e8 37             	sub    $0x37,%eax
f011b08b:	89 45 f4             	mov    %eax,-0xc(%ebp)
		else
			break;
		if (dig >= base)
f011b08e:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b091:	3b 45 10             	cmp    0x10(%ebp),%eax
f011b094:	7d 19                	jge    f011b0af <strtol+0x125>
			break;
		s++, val = (val * base) + dig;
f011b096:	ff 45 08             	incl   0x8(%ebp)
f011b099:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b09c:	0f af 45 10          	imul   0x10(%ebp),%eax
f011b0a0:	89 c2                	mov    %eax,%edx
f011b0a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b0a5:	01 d0                	add    %edx,%eax
f011b0a7:	89 45 f8             	mov    %eax,-0x8(%ebp)
		// we don't properly detect overflow!
	}
f011b0aa:	e9 7b ff ff ff       	jmp    f011b02a <strtol+0xa0>
		else if (*s >= 'A' && *s <= 'Z')
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
			break;
f011b0af:	90                   	nop
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
f011b0b0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
f011b0b4:	74 08                	je     f011b0be <strtol+0x134>
		*endptr = (char *) s;
f011b0b6:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b0b9:	8b 55 08             	mov    0x8(%ebp),%edx
f011b0bc:	89 10                	mov    %edx,(%eax)
	return (neg ? -val : val);
f011b0be:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011b0c2:	74 07                	je     f011b0cb <strtol+0x141>
f011b0c4:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b0c7:	f7 d8                	neg    %eax
f011b0c9:	eb 03                	jmp    f011b0ce <strtol+0x144>
f011b0cb:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011b0ce:	c9                   	leave  
f011b0cf:	c3                   	ret    

f011b0d0 <ltostr>:

void
ltostr(long value, char *str)
{
f011b0d0:	55                   	push   %ebp
f011b0d1:	89 e5                	mov    %esp,%ebp
f011b0d3:	83 ec 20             	sub    $0x20,%esp
	int neg = 0;
f011b0d6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	int s = 0 ;
f011b0dd:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)

	// plus/minus sign
	if (value < 0)
f011b0e4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b0e8:	79 13                	jns    f011b0fd <ltostr+0x2d>
	{
		neg = 1;
f011b0ea:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
		str[0] = '-';
f011b0f1:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b0f4:	c6 00 2d             	movb   $0x2d,(%eax)
		value = value * -1 ;
f011b0f7:	f7 5d 08             	negl   0x8(%ebp)
		s++ ;
f011b0fa:	ff 45 f8             	incl   -0x8(%ebp)
	}
	do
	{
		int mod = value % 10 ;
f011b0fd:	8b 45 08             	mov    0x8(%ebp),%eax
f011b100:	b9 0a 00 00 00       	mov    $0xa,%ecx
f011b105:	99                   	cltd   
f011b106:	f7 f9                	idiv   %ecx
f011b108:	89 55 ec             	mov    %edx,-0x14(%ebp)
		str[s++] = mod + '0' ;
f011b10b:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b10e:	8d 50 01             	lea    0x1(%eax),%edx
f011b111:	89 55 f8             	mov    %edx,-0x8(%ebp)
f011b114:	89 c2                	mov    %eax,%edx
f011b116:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b119:	01 d0                	add    %edx,%eax
f011b11b:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b11e:	83 c2 30             	add    $0x30,%edx
f011b121:	88 10                	mov    %dl,(%eax)
		value = value / 10 ;
f011b123:	8b 4d 08             	mov    0x8(%ebp),%ecx
f011b126:	b8 67 66 66 66       	mov    $0x66666667,%eax
f011b12b:	f7 e9                	imul   %ecx
f011b12d:	c1 fa 02             	sar    $0x2,%edx
f011b130:	89 c8                	mov    %ecx,%eax
f011b132:	c1 f8 1f             	sar    $0x1f,%eax
f011b135:	29 c2                	sub    %eax,%edx
f011b137:	89 d0                	mov    %edx,%eax
f011b139:	89 45 08             	mov    %eax,0x8(%ebp)
	/*2023 FIX el7 :)*/
	//} while (value % 10 != 0);
	} while (value != 0);
f011b13c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b140:	75 bb                	jne    f011b0fd <ltostr+0x2d>

	//reverse the string
	int start = 0 ;
f011b142:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	int end = s-1 ;
f011b149:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b14c:	48                   	dec    %eax
f011b14d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	if (neg)
f011b150:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
f011b154:	74 3d                	je     f011b193 <ltostr+0xc3>
		start = 1 ;
f011b156:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
	while(start<end)
f011b15d:	eb 34                	jmp    f011b193 <ltostr+0xc3>
	{
		char tmp = str[start] ;
f011b15f:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b162:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b165:	01 d0                	add    %edx,%eax
f011b167:	8a 00                	mov    (%eax),%al
f011b169:	88 45 eb             	mov    %al,-0x15(%ebp)
		str[start] = str[end] ;
f011b16c:	8b 55 f4             	mov    -0xc(%ebp),%edx
f011b16f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b172:	01 c2                	add    %eax,%edx
f011b174:	8b 4d f0             	mov    -0x10(%ebp),%ecx
f011b177:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b17a:	01 c8                	add    %ecx,%eax
f011b17c:	8a 00                	mov    (%eax),%al
f011b17e:	88 02                	mov    %al,(%edx)
		str[end] = tmp;
f011b180:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b183:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b186:	01 c2                	add    %eax,%edx
f011b188:	8a 45 eb             	mov    -0x15(%ebp),%al
f011b18b:	88 02                	mov    %al,(%edx)
		start++ ;
f011b18d:	ff 45 f4             	incl   -0xc(%ebp)
		end-- ;
f011b190:	ff 4d f0             	decl   -0x10(%ebp)
	//reverse the string
	int start = 0 ;
	int end = s-1 ;
	if (neg)
		start = 1 ;
	while(start<end)
f011b193:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b196:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b199:	7c c4                	jl     f011b15f <ltostr+0x8f>
		str[end] = tmp;
		start++ ;
		end-- ;
	}

	str[s] = 0 ;
f011b19b:	8b 55 f8             	mov    -0x8(%ebp),%edx
f011b19e:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b1a1:	01 d0                	add    %edx,%eax
f011b1a3:	c6 00 00             	movb   $0x0,(%eax)
	// we don't properly detect overflow!

}
f011b1a6:	90                   	nop
f011b1a7:	c9                   	leave  
f011b1a8:	c3                   	ret    

f011b1a9 <strcconcat>:

void
strcconcat(const char *str1, const char *str2, char *final)
{
f011b1a9:	55                   	push   %ebp
f011b1aa:	89 e5                	mov    %esp,%ebp
f011b1ac:	83 ec 10             	sub    $0x10,%esp
	int len1 = strlen(str1);
f011b1af:	ff 75 08             	pushl  0x8(%ebp)
f011b1b2:	e8 c4 f9 ff ff       	call   f011ab7b <strlen>
f011b1b7:	83 c4 04             	add    $0x4,%esp
f011b1ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
	int len2 = strlen(str2);
f011b1bd:	ff 75 0c             	pushl  0xc(%ebp)
f011b1c0:	e8 b6 f9 ff ff       	call   f011ab7b <strlen>
f011b1c5:	83 c4 04             	add    $0x4,%esp
f011b1c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int s = 0 ;
f011b1cb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
	for (s=0 ; s < len1 ; s++)
f011b1d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011b1d9:	eb 17                	jmp    f011b1f2 <strcconcat+0x49>
		final[s] = str1[s] ;
f011b1db:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b1de:	8b 45 10             	mov    0x10(%ebp),%eax
f011b1e1:	01 c2                	add    %eax,%edx
f011b1e3:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b1e6:	8b 45 08             	mov    0x8(%ebp),%eax
f011b1e9:	01 c8                	add    %ecx,%eax
f011b1eb:	8a 00                	mov    (%eax),%al
f011b1ed:	88 02                	mov    %al,(%edx)
strcconcat(const char *str1, const char *str2, char *final)
{
	int len1 = strlen(str1);
	int len2 = strlen(str2);
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
f011b1ef:	ff 45 fc             	incl   -0x4(%ebp)
f011b1f2:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b1f5:	3b 45 f4             	cmp    -0xc(%ebp),%eax
f011b1f8:	7c e1                	jl     f011b1db <strcconcat+0x32>
		final[s] = str1[s] ;

	int i = 0 ;
f011b1fa:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
	for (i=0 ; i < len2 ; i++)
f011b201:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
f011b208:	eb 1f                	jmp    f011b229 <strcconcat+0x80>
		final[s++] = str2[i] ;
f011b20a:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b20d:	8d 50 01             	lea    0x1(%eax),%edx
f011b210:	89 55 fc             	mov    %edx,-0x4(%ebp)
f011b213:	89 c2                	mov    %eax,%edx
f011b215:	8b 45 10             	mov    0x10(%ebp),%eax
f011b218:	01 c2                	add    %eax,%edx
f011b21a:	8b 4d f8             	mov    -0x8(%ebp),%ecx
f011b21d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b220:	01 c8                	add    %ecx,%eax
f011b222:	8a 00                	mov    (%eax),%al
f011b224:	88 02                	mov    %al,(%edx)
	int s = 0 ;
	for (s=0 ; s < len1 ; s++)
		final[s] = str1[s] ;

	int i = 0 ;
	for (i=0 ; i < len2 ; i++)
f011b226:	ff 45 f8             	incl   -0x8(%ebp)
f011b229:	8b 45 f8             	mov    -0x8(%ebp),%eax
f011b22c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
f011b22f:	7c d9                	jl     f011b20a <strcconcat+0x61>
		final[s++] = str2[i] ;

	final[s] = 0;
f011b231:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b234:	8b 45 10             	mov    0x10(%ebp),%eax
f011b237:	01 d0                	add    %edx,%eax
f011b239:	c6 00 00             	movb   $0x0,(%eax)
}
f011b23c:	90                   	nop
f011b23d:	c9                   	leave  
f011b23e:	c3                   	ret    

f011b23f <strsplit>:
int strsplit(char *string, char *SPLIT_CHARS, char **argv, int * argc)
{
f011b23f:	55                   	push   %ebp
f011b240:	89 e5                	mov    %esp,%ebp
	// Parse the command string into splitchars-separated arguments
	*argc = 0;
f011b242:	8b 45 14             	mov    0x14(%ebp),%eax
f011b245:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	(argv)[*argc] = 0;
f011b24b:	8b 45 14             	mov    0x14(%ebp),%eax
f011b24e:	8b 00                	mov    (%eax),%eax
f011b250:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b257:	8b 45 10             	mov    0x10(%ebp),%eax
f011b25a:	01 d0                	add    %edx,%eax
f011b25c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011b262:	eb 0c                	jmp    f011b270 <strsplit+0x31>
			*string++ = 0;
f011b264:	8b 45 08             	mov    0x8(%ebp),%eax
f011b267:	8d 50 01             	lea    0x1(%eax),%edx
f011b26a:	89 55 08             	mov    %edx,0x8(%ebp)
f011b26d:	c6 00 00             	movb   $0x0,(%eax)
	*argc = 0;
	(argv)[*argc] = 0;
	while (1)
	{
		// trim splitchars
		while (*string && strchr(SPLIT_CHARS, *string))
f011b270:	8b 45 08             	mov    0x8(%ebp),%eax
f011b273:	8a 00                	mov    (%eax),%al
f011b275:	84 c0                	test   %al,%al
f011b277:	74 18                	je     f011b291 <strsplit+0x52>
f011b279:	8b 45 08             	mov    0x8(%ebp),%eax
f011b27c:	8a 00                	mov    (%eax),%al
f011b27e:	0f be c0             	movsbl %al,%eax
f011b281:	50                   	push   %eax
f011b282:	ff 75 0c             	pushl  0xc(%ebp)
f011b285:	e8 83 fa ff ff       	call   f011ad0d <strchr>
f011b28a:	83 c4 08             	add    $0x8,%esp
f011b28d:	85 c0                	test   %eax,%eax
f011b28f:	75 d3                	jne    f011b264 <strsplit+0x25>
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
f011b291:	8b 45 08             	mov    0x8(%ebp),%eax
f011b294:	8a 00                	mov    (%eax),%al
f011b296:	84 c0                	test   %al,%al
f011b298:	74 5a                	je     f011b2f4 <strsplit+0xb5>
			break;

		//check current number of arguments
		if (*argc == MAX_ARGUMENTS-1)
f011b29a:	8b 45 14             	mov    0x14(%ebp),%eax
f011b29d:	8b 00                	mov    (%eax),%eax
f011b29f:	83 f8 0f             	cmp    $0xf,%eax
f011b2a2:	75 07                	jne    f011b2ab <strsplit+0x6c>
		{
			return 0;
f011b2a4:	b8 00 00 00 00       	mov    $0x0,%eax
f011b2a9:	eb 66                	jmp    f011b311 <strsplit+0xd2>
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
f011b2ab:	8b 45 14             	mov    0x14(%ebp),%eax
f011b2ae:	8b 00                	mov    (%eax),%eax
f011b2b0:	8d 48 01             	lea    0x1(%eax),%ecx
f011b2b3:	8b 55 14             	mov    0x14(%ebp),%edx
f011b2b6:	89 0a                	mov    %ecx,(%edx)
f011b2b8:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b2bf:	8b 45 10             	mov    0x10(%ebp),%eax
f011b2c2:	01 c2                	add    %eax,%edx
f011b2c4:	8b 45 08             	mov    0x8(%ebp),%eax
f011b2c7:	89 02                	mov    %eax,(%edx)
		while (*string && !strchr(SPLIT_CHARS, *string))
f011b2c9:	eb 03                	jmp    f011b2ce <strsplit+0x8f>
			string++;
f011b2cb:	ff 45 08             	incl   0x8(%ebp)
			return 0;
		}

		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
f011b2ce:	8b 45 08             	mov    0x8(%ebp),%eax
f011b2d1:	8a 00                	mov    (%eax),%al
f011b2d3:	84 c0                	test   %al,%al
f011b2d5:	74 8b                	je     f011b262 <strsplit+0x23>
f011b2d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011b2da:	8a 00                	mov    (%eax),%al
f011b2dc:	0f be c0             	movsbl %al,%eax
f011b2df:	50                   	push   %eax
f011b2e0:	ff 75 0c             	pushl  0xc(%ebp)
f011b2e3:	e8 25 fa ff ff       	call   f011ad0d <strchr>
f011b2e8:	83 c4 08             	add    $0x8,%esp
f011b2eb:	85 c0                	test   %eax,%eax
f011b2ed:	74 dc                	je     f011b2cb <strsplit+0x8c>
			string++;
	}
f011b2ef:	e9 6e ff ff ff       	jmp    f011b262 <strsplit+0x23>
		while (*string && strchr(SPLIT_CHARS, *string))
			*string++ = 0;

		//if the command string is finished, then break the loop
		if (*string == 0)
			break;
f011b2f4:	90                   	nop
		// save the previous argument and scan past next arg
		(argv)[(*argc)++] = string;
		while (*string && !strchr(SPLIT_CHARS, *string))
			string++;
	}
	(argv)[*argc] = 0;
f011b2f5:	8b 45 14             	mov    0x14(%ebp),%eax
f011b2f8:	8b 00                	mov    (%eax),%eax
f011b2fa:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
f011b301:	8b 45 10             	mov    0x10(%ebp),%eax
f011b304:	01 d0                	add    %edx,%eax
f011b306:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return 1 ;
f011b30c:	b8 01 00 00 00       	mov    $0x1,%eax
}
f011b311:	c9                   	leave  
f011b312:	c3                   	ret    

f011b313 <str2lower>:


char* str2lower(char *dst, const char *src)
{
f011b313:	55                   	push   %ebp
f011b314:	89 e5                	mov    %esp,%ebp
f011b316:	83 ec 10             	sub    $0x10,%esp
	char* ret = dst;
f011b319:	8b 45 08             	mov    0x8(%ebp),%eax
f011b31c:	89 45 f8             	mov    %eax,-0x8(%ebp)
	for (int i = 0; i < strlen(src); ++i)
f011b31f:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
f011b326:	eb 4a                	jmp    f011b372 <str2lower+0x5f>
	{
		dst[i] = src[i] ;
f011b328:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b32b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b32e:	01 c2                	add    %eax,%edx
f011b330:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b333:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b336:	01 c8                	add    %ecx,%eax
f011b338:	8a 00                	mov    (%eax),%al
f011b33a:	88 02                	mov    %al,(%edx)
		if (src[i] >= 'A' && src[i] <= 'Z')
f011b33c:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b33f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b342:	01 d0                	add    %edx,%eax
f011b344:	8a 00                	mov    (%eax),%al
f011b346:	3c 40                	cmp    $0x40,%al
f011b348:	7e 25                	jle    f011b36f <str2lower+0x5c>
f011b34a:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b34d:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b350:	01 d0                	add    %edx,%eax
f011b352:	8a 00                	mov    (%eax),%al
f011b354:	3c 5a                	cmp    $0x5a,%al
f011b356:	7f 17                	jg     f011b36f <str2lower+0x5c>
		{
			dst[i] += 32 ;
f011b358:	8b 55 fc             	mov    -0x4(%ebp),%edx
f011b35b:	8b 45 08             	mov    0x8(%ebp),%eax
f011b35e:	01 d0                	add    %edx,%eax
f011b360:	8b 4d fc             	mov    -0x4(%ebp),%ecx
f011b363:	8b 55 08             	mov    0x8(%ebp),%edx
f011b366:	01 ca                	add    %ecx,%edx
f011b368:	8a 12                	mov    (%edx),%dl
f011b36a:	83 c2 20             	add    $0x20,%edx
f011b36d:	88 10                	mov    %dl,(%eax)


char* str2lower(char *dst, const char *src)
{
	char* ret = dst;
	for (int i = 0; i < strlen(src); ++i)
f011b36f:	ff 45 fc             	incl   -0x4(%ebp)
f011b372:	ff 75 0c             	pushl  0xc(%ebp)
f011b375:	e8 01 f8 ff ff       	call   f011ab7b <strlen>
f011b37a:	83 c4 04             	add    $0x4,%esp
f011b37d:	3b 45 fc             	cmp    -0x4(%ebp),%eax
f011b380:	7f a6                	jg     f011b328 <str2lower+0x15>
		if (src[i] >= 'A' && src[i] <= 'Z')
		{
			dst[i] += 32 ;
		}
	}
	return ret;
f011b382:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
f011b385:	c9                   	leave  
f011b386:	c3                   	ret    

f011b387 <disk_interrupt_handler>:
#define IDE_ERR		0x01

static int diskno = 0;

void disk_interrupt_handler(struct Trapframe *tf)
{
f011b387:	55                   	push   %ebp
f011b388:	89 e5                	mov    %esp,%ebp
f011b38a:	83 ec 18             	sub    $0x18,%esp
	int r;
	cprintf("\n>>>>>>>> DISK INTERRUPT <<<<<<<<<\n");
f011b38d:	83 ec 0c             	sub    $0xc,%esp
f011b390:	68 7c 65 13 f0       	push   $0xf013657c
f011b395:	e8 c2 68 fe ff       	call   f0101c5c <cprintf>
f011b39a:	83 c4 10             	add    $0x10,%esp
f011b39d:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011b3a4:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b3a7:	89 c2                	mov    %eax,%edx
f011b3a9:	ec                   	in     (%dx),%al
f011b3aa:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011b3ad:	8a 45 ef             	mov    -0x11(%ebp),%al
	if (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011b3b0:	0f b6 c0             	movzbl %al,%eax
f011b3b3:	89 45 f4             	mov    %eax,-0xc(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
		signal_ksemaphore(&DISKsem);
#endif
	}

}
f011b3b6:	90                   	nop
f011b3b7:	c9                   	leave  
f011b3b8:	c3                   	ret    

f011b3b9 <ide_init>:

void ide_init()
{
f011b3b9:	55                   	push   %ebp
f011b3ba:	89 e5                	mov    %esp,%ebp
		irq_install_handler(14, &disk_interrupt_handler);
		init_ksemaphore(&DISKsem, 0, "DISK semaphore");
		init_ksemaphore(&DISKmutex, 1, "DISK mutex");
	}
#endif
}
f011b3bc:	90                   	nop
f011b3bd:	5d                   	pop    %ebp
f011b3be:	c3                   	ret    

f011b3bf <ide_wait_ready>:


static int ide_wait_ready(bool check_error)
{
f011b3bf:	55                   	push   %ebp
f011b3c0:	89 e5                	mov    %esp,%ebp
f011b3c2:	83 ec 18             	sub    $0x18,%esp
	int r;

#if DISK_IO_METHOD == PROGRAMMED_IO
	while (((r = inb(0x1F7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
f011b3c5:	90                   	nop
f011b3c6:	c7 45 f0 f7 01 00 00 	movl   $0x1f7,-0x10(%ebp)

static __inline uint8
inb(int port)
{
	uint8 data;
	__asm __volatile("inb %w1,%0" : "=a" (data) : "d" (port));
f011b3cd:	8b 45 f0             	mov    -0x10(%ebp),%eax
f011b3d0:	89 c2                	mov    %eax,%edx
f011b3d2:	ec                   	in     (%dx),%al
f011b3d3:	88 45 ef             	mov    %al,-0x11(%ebp)
	return data;
f011b3d6:	8a 45 ef             	mov    -0x11(%ebp),%al
f011b3d9:	0f b6 c0             	movzbl %al,%eax
f011b3dc:	89 45 f4             	mov    %eax,-0xc(%ebp)
f011b3df:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b3e2:	25 c0 00 00 00       	and    $0xc0,%eax
f011b3e7:	83 f8 40             	cmp    $0x40,%eax
f011b3ea:	75 da                	jne    f011b3c6 <ide_wait_ready+0x7>
#elif DISK_IO_METHOD == INT_SEMAPHORE
		wait_ksemaphore(&DISKsem);
	}
#endif
#endif
	if (check_error && (r & (IDE_DF|IDE_ERR)) != 0)
f011b3ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
f011b3f0:	74 24                	je     f011b416 <ide_wait_ready+0x57>
f011b3f2:	8b 45 f4             	mov    -0xc(%ebp),%eax
f011b3f5:	83 e0 21             	and    $0x21,%eax
f011b3f8:	85 c0                	test   %eax,%eax
f011b3fa:	74 1a                	je     f011b416 <ide_wait_ready+0x57>
	{
		panic("ERROR @ ide_wait_ready() = %x(%d)\n",r,r);
f011b3fc:	83 ec 0c             	sub    $0xc,%esp
f011b3ff:	ff 75 f4             	pushl  -0xc(%ebp)
f011b402:	ff 75 f4             	pushl  -0xc(%ebp)
f011b405:	68 a0 65 13 f0       	push   $0xf01365a0
f011b40a:	6a 54                	push   $0x54
f011b40c:	68 c3 65 13 f0       	push   $0xf01365c3
f011b411:	e8 99 5b fe ff       	call   f0100faf <_panic>
		LOG_STATMENT(cprintf("ERROR @ ide_wait_ready() = %x(%d)\n",r,r););
		return -1;
	}
	return 0;
f011b416:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b41b:	c9                   	leave  
f011b41c:	c3                   	ret    

f011b41d <ide_read>:

int	ide_read(uint32 secno, void *dst, uint32 nsecs)
{
f011b41d:	55                   	push   %ebp
f011b41e:	89 e5                	mov    %esp,%ebp
f011b420:	57                   	push   %edi
f011b421:	53                   	push   %ebx
f011b422:	83 ec 40             	sub    $0x40,%esp
	int r;

	assert(nsecs <= 256);
f011b425:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011b42c:	76 16                	jbe    f011b444 <ide_read+0x27>
f011b42e:	68 ce 65 13 f0       	push   $0xf01365ce
f011b433:	68 db 65 13 f0       	push   $0xf01365db
f011b438:	6a 5f                	push   $0x5f
f011b43a:	68 c3 65 13 f0       	push   $0xf01365c3
f011b43f:	e8 6b 5b fe ff       	call   f0100faf <_panic>

	struct Env* e = get_cpu_proc();
f011b444:	e8 cf 06 ff ff       	call   f010bb18 <get_cpu_proc>
f011b449:	89 45 f4             	mov    %eax,-0xc(%ebp)
#elif DISK_IO_METHOD == INT_SEMAPHORE
	wait_ksemaphore(&DISKmutex);
#endif
	{
		if (e) LOG_STATMENT(cprintf("ide_read: %d inside CS\n", e->env_id););
		ide_wait_ready(0);
f011b44c:	83 ec 0c             	sub    $0xc,%esp
f011b44f:	6a 00                	push   $0x0
f011b451:	e8 69 ff ff ff       	call   f011b3bf <ide_wait_ready>
f011b456:	83 c4 10             	add    $0x10,%esp

		outb(0x1F2, nsecs);
f011b459:	8b 45 10             	mov    0x10(%ebp),%eax
f011b45c:	0f b6 c0             	movzbl %al,%eax
f011b45f:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f011b466:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011b469:	8a 45 ce             	mov    -0x32(%ebp),%al
f011b46c:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b46f:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f011b470:	8b 45 08             	mov    0x8(%ebp),%eax
f011b473:	0f b6 c0             	movzbl %al,%eax
f011b476:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f011b47d:	88 45 cf             	mov    %al,-0x31(%ebp)
f011b480:	8a 45 cf             	mov    -0x31(%ebp),%al
f011b483:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b486:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f011b487:	8b 45 08             	mov    0x8(%ebp),%eax
f011b48a:	c1 e8 08             	shr    $0x8,%eax
f011b48d:	0f b6 c0             	movzbl %al,%eax
f011b490:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f011b497:	88 45 d0             	mov    %al,-0x30(%ebp)
f011b49a:	8a 45 d0             	mov    -0x30(%ebp),%al
f011b49d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b4a0:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f011b4a1:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4a4:	c1 e8 10             	shr    $0x10,%eax
f011b4a7:	0f b6 c0             	movzbl %al,%eax
f011b4aa:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f011b4b1:	88 45 d1             	mov    %al,-0x2f(%ebp)
f011b4b4:	8a 45 d1             	mov    -0x2f(%ebp),%al
f011b4b7:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b4ba:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011b4bb:	a1 24 e5 83 f0       	mov    0xf083e524,%eax
f011b4c0:	83 e0 01             	and    $0x1,%eax
f011b4c3:	c1 e0 04             	shl    $0x4,%eax
f011b4c6:	88 c2                	mov    %al,%dl
f011b4c8:	8b 45 08             	mov    0x8(%ebp),%eax
f011b4cb:	c1 e8 18             	shr    $0x18,%eax
f011b4ce:	83 e0 0f             	and    $0xf,%eax
f011b4d1:	09 d0                	or     %edx,%eax
f011b4d3:	83 c8 e0             	or     $0xffffffe0,%eax
f011b4d6:	0f b6 c0             	movzbl %al,%eax
f011b4d9:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f011b4e0:	88 45 d2             	mov    %al,-0x2e(%ebp)
f011b4e3:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011b4e6:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b4e9:	ee                   	out    %al,(%dx)
f011b4ea:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f011b4f1:	c6 45 d3 20          	movb   $0x20,-0x2d(%ebp)
f011b4f5:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011b4f8:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b4fb:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011b4fc:	eb 64                	jmp    f011b562 <ide_read+0x145>
			if ((r = ide_wait_ready(1)) < 0)
f011b4fe:	83 ec 0c             	sub    $0xc,%esp
f011b501:	6a 01                	push   $0x1
f011b503:	e8 b7 fe ff ff       	call   f011b3bf <ide_wait_ready>
f011b508:	83 c4 10             	add    $0x10,%esp
f011b50b:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b50e:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011b512:	79 14                	jns    f011b528 <ide_read+0x10b>
			{
				panic("FAILURE to read %d sectors to disk\n",nsecs);
f011b514:	ff 75 10             	pushl  0x10(%ebp)
f011b517:	68 f0 65 13 f0       	push   $0xf01365f0
f011b51c:	6a 79                	push   $0x79
f011b51e:	68 c3 65 13 f0       	push   $0xf01365c3
f011b523:	e8 87 5a fe ff       	call   f0100faf <_panic>
f011b528:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f011b52f:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b532:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011b535:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
insl(int port, void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\tinsl"			:
f011b53c:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b53f:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f011b542:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b545:	89 cb                	mov    %ecx,%ebx
f011b547:	89 df                	mov    %ebx,%edi
f011b549:	89 c1                	mov    %eax,%ecx
f011b54b:	fc                   	cld    
f011b54c:	f2 6d                	repnz insl (%dx),%es:(%edi)
f011b54e:	89 c8                	mov    %ecx,%eax
f011b550:	89 fb                	mov    %edi,%ebx
f011b552:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f011b555:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F4, (secno >> 8) & 0xFF);
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x20);	// CMD 0x20 means read sector

		for (; nsecs > 0; nsecs--, dst += SECTSIZE) {
f011b558:	ff 4d 10             	decl   0x10(%ebp)
f011b55b:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011b562:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b566:	75 96                	jne    f011b4fe <ide_read+0xe1>
	signal_ksemaphore(&DISKmutex);
#endif

	if (e) LOG_STATMENT(cprintf("ide_read: %d Left CS\n", e->env_id););

	return 0;
f011b568:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b56d:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b570:	5b                   	pop    %ebx
f011b571:	5f                   	pop    %edi
f011b572:	5d                   	pop    %ebp
f011b573:	c3                   	ret    

f011b574 <ide_write>:

int ide_write(uint32 secno, const void *src, uint32 nsecs)
{
f011b574:	55                   	push   %ebp
f011b575:	89 e5                	mov    %esp,%ebp
f011b577:	56                   	push   %esi
f011b578:	53                   	push   %ebx
f011b579:	83 ec 40             	sub    $0x40,%esp
	int r;

	//LOG_STATMENT(cprintf("1 ==> nsecs = %d\n",nsecs);)
	assert(nsecs <= 256);
f011b57c:	81 7d 10 00 01 00 00 	cmpl   $0x100,0x10(%ebp)
f011b583:	76 19                	jbe    f011b59e <ide_write+0x2a>
f011b585:	68 ce 65 13 f0       	push   $0xf01365ce
f011b58a:	68 db 65 13 f0       	push   $0xf01365db
f011b58f:	68 8f 00 00 00       	push   $0x8f
f011b594:	68 c3 65 13 f0       	push   $0xf01365c3
f011b599:	e8 11 5a fe ff       	call   f0100faf <_panic>

	struct Env* e = get_cpu_proc();
f011b59e:	e8 75 05 ff ff       	call   f010bb18 <get_cpu_proc>
f011b5a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
	wait_ksemaphore(&DISKmutex);
#endif
	{
		if (e) LOG_STATMENT(cprintf("ide_write: %d inside CS\n", e->env_id););

		ide_wait_ready(0);
f011b5a6:	83 ec 0c             	sub    $0xc,%esp
f011b5a9:	6a 00                	push   $0x0
f011b5ab:	e8 0f fe ff ff       	call   f011b3bf <ide_wait_ready>
f011b5b0:	83 c4 10             	add    $0x10,%esp

		//LOG_STATMENT(cprintf("3 ==> nsecs = %d\n",nsecs);)
		outb(0x1F2, nsecs);
f011b5b3:	8b 45 10             	mov    0x10(%ebp),%eax
f011b5b6:	0f b6 c0             	movzbl %al,%eax
f011b5b9:	c7 45 ec f2 01 00 00 	movl   $0x1f2,-0x14(%ebp)
f011b5c0:	88 45 ce             	mov    %al,-0x32(%ebp)
}

static __inline void
outb(int port, uint8 data)
{
	__asm __volatile("outb %0,%w1" : : "a" (data), "d" (port));
f011b5c3:	8a 45 ce             	mov    -0x32(%ebp),%al
f011b5c6:	8b 55 ec             	mov    -0x14(%ebp),%edx
f011b5c9:	ee                   	out    %al,(%dx)
		outb(0x1F3, secno & 0xFF);
f011b5ca:	8b 45 08             	mov    0x8(%ebp),%eax
f011b5cd:	0f b6 c0             	movzbl %al,%eax
f011b5d0:	c7 45 e8 f3 01 00 00 	movl   $0x1f3,-0x18(%ebp)
f011b5d7:	88 45 cf             	mov    %al,-0x31(%ebp)
f011b5da:	8a 45 cf             	mov    -0x31(%ebp),%al
f011b5dd:	8b 55 e8             	mov    -0x18(%ebp),%edx
f011b5e0:	ee                   	out    %al,(%dx)
		outb(0x1F4, (secno >> 8) & 0xFF);
f011b5e1:	8b 45 08             	mov    0x8(%ebp),%eax
f011b5e4:	c1 e8 08             	shr    $0x8,%eax
f011b5e7:	0f b6 c0             	movzbl %al,%eax
f011b5ea:	c7 45 e4 f4 01 00 00 	movl   $0x1f4,-0x1c(%ebp)
f011b5f1:	88 45 d0             	mov    %al,-0x30(%ebp)
f011b5f4:	8a 45 d0             	mov    -0x30(%ebp),%al
f011b5f7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
f011b5fa:	ee                   	out    %al,(%dx)
		outb(0x1F5, (secno >> 16) & 0xFF);
f011b5fb:	8b 45 08             	mov    0x8(%ebp),%eax
f011b5fe:	c1 e8 10             	shr    $0x10,%eax
f011b601:	0f b6 c0             	movzbl %al,%eax
f011b604:	c7 45 e0 f5 01 00 00 	movl   $0x1f5,-0x20(%ebp)
f011b60b:	88 45 d1             	mov    %al,-0x2f(%ebp)
f011b60e:	8a 45 d1             	mov    -0x2f(%ebp),%al
f011b611:	8b 55 e0             	mov    -0x20(%ebp),%edx
f011b614:	ee                   	out    %al,(%dx)
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
f011b615:	a1 24 e5 83 f0       	mov    0xf083e524,%eax
f011b61a:	83 e0 01             	and    $0x1,%eax
f011b61d:	c1 e0 04             	shl    $0x4,%eax
f011b620:	88 c2                	mov    %al,%dl
f011b622:	8b 45 08             	mov    0x8(%ebp),%eax
f011b625:	c1 e8 18             	shr    $0x18,%eax
f011b628:	83 e0 0f             	and    $0xf,%eax
f011b62b:	09 d0                	or     %edx,%eax
f011b62d:	83 c8 e0             	or     $0xffffffe0,%eax
f011b630:	0f b6 c0             	movzbl %al,%eax
f011b633:	c7 45 dc f6 01 00 00 	movl   $0x1f6,-0x24(%ebp)
f011b63a:	88 45 d2             	mov    %al,-0x2e(%ebp)
f011b63d:	8a 45 d2             	mov    -0x2e(%ebp),%al
f011b640:	8b 55 dc             	mov    -0x24(%ebp),%edx
f011b643:	ee                   	out    %al,(%dx)
f011b644:	c7 45 d4 f7 01 00 00 	movl   $0x1f7,-0x2c(%ebp)
f011b64b:	c6 45 d3 30          	movb   $0x30,-0x2d(%ebp)
f011b64f:	8a 45 d3             	mov    -0x2d(%ebp),%al
f011b652:	8b 55 d4             	mov    -0x2c(%ebp),%edx
f011b655:	ee                   	out    %al,(%dx)
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011b656:	eb 67                	jmp    f011b6bf <ide_write+0x14b>
			if ((r = ide_wait_ready(1)) < 0)
f011b658:	83 ec 0c             	sub    $0xc,%esp
f011b65b:	6a 01                	push   $0x1
f011b65d:	e8 5d fd ff ff       	call   f011b3bf <ide_wait_ready>
f011b662:	83 c4 10             	add    $0x10,%esp
f011b665:	89 45 d8             	mov    %eax,-0x28(%ebp)
f011b668:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
f011b66c:	79 17                	jns    f011b685 <ide_write+0x111>
			{
				panic("FAILURE to write %d sectors to disk\n",nsecs);
f011b66e:	ff 75 10             	pushl  0x10(%ebp)
f011b671:	68 14 66 13 f0       	push   $0xf0136614
f011b676:	68 ab 00 00 00       	push   $0xab
f011b67b:	68 c3 65 13 f0       	push   $0xf01365c3
f011b680:	e8 2a 59 fe ff       	call   f0100faf <_panic>
f011b685:	c7 45 f0 f0 01 00 00 	movl   $0x1f0,-0x10(%ebp)
f011b68c:	8b 45 0c             	mov    0xc(%ebp),%eax
f011b68f:	89 45 c8             	mov    %eax,-0x38(%ebp)
f011b692:	c7 45 c4 80 00 00 00 	movl   $0x80,-0x3c(%ebp)
}

static __inline void
outsl(int port, const void *addr, int cnt)
{
	__asm __volatile("cld\n\trepne\n\toutsl"		:
f011b699:	8b 55 f0             	mov    -0x10(%ebp),%edx
f011b69c:	8b 4d c8             	mov    -0x38(%ebp),%ecx
f011b69f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
f011b6a2:	89 cb                	mov    %ecx,%ebx
f011b6a4:	89 de                	mov    %ebx,%esi
f011b6a6:	89 c1                	mov    %eax,%ecx
f011b6a8:	fc                   	cld    
f011b6a9:	f2 6f                	repnz outsl %ds:(%esi),(%dx)
f011b6ab:	89 c8                	mov    %ecx,%eax
f011b6ad:	89 f3                	mov    %esi,%ebx
f011b6af:	89 5d c8             	mov    %ebx,-0x38(%ebp)
f011b6b2:	89 45 c4             	mov    %eax,-0x3c(%ebp)
		outb(0x1F5, (secno >> 16) & 0xFF);
		outb(0x1F6, 0xE0 | ((diskno&1)<<4) | ((secno>>24)&0x0F));
		outb(0x1F7, 0x30);	// CMD 0x30 means write sector


		for (; nsecs > 0; nsecs--, src += SECTSIZE) {
f011b6b5:	ff 4d 10             	decl   0x10(%ebp)
f011b6b8:	81 45 0c 00 02 00 00 	addl   $0x200,0xc(%ebp)
f011b6bf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
f011b6c3:	75 93                	jne    f011b658 <ide_write+0xe4>
	if (e) LOG_STATMENT(cprintf("ide_write: %d Left CS\n", e->env_id););

	//LOG_STATMENT(cprintf("5\n");)
	//cprintf("returning from ide_write \n");

	return 0;
f011b6c5:	b8 00 00 00 00       	mov    $0x0,%eax
}
f011b6ca:	8d 65 f8             	lea    -0x8(%ebp),%esp
f011b6cd:	5b                   	pop    %ebx
f011b6ce:	5e                   	pop    %esi
f011b6cf:	5d                   	pop    %ebp
f011b6d0:	c3                   	ret    

f011b6d1 <to_page_va>:
//==================================================================================//
//==================================
// [1] GET PAGE VA:
//==================================
__inline__ uint32 to_page_va(struct PageInfoElement *ptrPageInfo)
{
f011b6d1:	55                   	push   %ebp
f011b6d2:	89 e5                	mov    %esp,%ebp
f011b6d4:	83 ec 10             	sub    $0x10,%esp
	//Get start VA of the page from the corresponding Page Info pointer
	int idxInPageInfoArr = (ptrPageInfo - pageBlockInfoArr);
f011b6d7:	8b 45 08             	mov    0x8(%ebp),%eax
f011b6da:	ba c0 e9 83 f0       	mov    $0xf083e9c0,%edx
f011b6df:	29 d0                	sub    %edx,%eax
f011b6e1:	c1 f8 02             	sar    $0x2,%eax
f011b6e4:	89 c2                	mov    %eax,%edx
f011b6e6:	89 d0                	mov    %edx,%eax
f011b6e8:	c1 e0 02             	shl    $0x2,%eax
f011b6eb:	01 d0                	add    %edx,%eax
f011b6ed:	c1 e0 02             	shl    $0x2,%eax
f011b6f0:	01 d0                	add    %edx,%eax
f011b6f2:	c1 e0 02             	shl    $0x2,%eax
f011b6f5:	01 d0                	add    %edx,%eax
f011b6f7:	89 c1                	mov    %eax,%ecx
f011b6f9:	c1 e1 08             	shl    $0x8,%ecx
f011b6fc:	01 c8                	add    %ecx,%eax
f011b6fe:	89 c1                	mov    %eax,%ecx
f011b700:	c1 e1 10             	shl    $0x10,%ecx
f011b703:	01 c8                	add    %ecx,%eax
f011b705:	01 c0                	add    %eax,%eax
f011b707:	01 d0                	add    %edx,%eax
f011b709:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return dynAllocStart + (idxInPageInfoArr << PGSHIFT);
f011b70c:	8b 45 fc             	mov    -0x4(%ebp),%eax
f011b70f:	c1 e0 0c             	shl    $0xc,%eax
f011b712:	89 c2                	mov    %eax,%edx
f011b714:	a1 1c 6b 85 f0       	mov    0xf0856b1c,%eax
f011b719:	01 d0                	add    %edx,%eax
}
f011b71b:	c9                   	leave  
f011b71c:	c3                   	ret    

f011b71d <initialize_dynamic_allocator>:
//==================================
// [1] INITIALIZE DYNAMIC ALLOCATOR:
//==================================
bool is_initialized = 0;
void initialize_dynamic_allocator(uint32 daStart, uint32 daEnd)
{
f011b71d:	55                   	push   %ebp
f011b71e:	89 e5                	mov    %esp,%ebp
f011b720:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(daEnd <= daStart + DYN_ALLOC_MAX_SIZE);
f011b723:	8b 45 08             	mov    0x8(%ebp),%eax
f011b726:	05 00 00 00 02       	add    $0x2000000,%eax
f011b72b:	3b 45 0c             	cmp    0xc(%ebp),%eax
f011b72e:	73 16                	jae    f011b746 <initialize_dynamic_allocator+0x29>
f011b730:	68 3c 66 13 f0       	push   $0xf013663c
f011b735:	68 62 66 13 f0       	push   $0xf0136662
f011b73a:	6a 26                	push   $0x26
f011b73c:	68 77 66 13 f0       	push   $0xf0136677
f011b741:	e8 69 58 fe ff       	call   f0100faf <_panic>
		is_initialized = 1;
f011b746:	c7 05 28 e5 83 f0 01 	movl   $0x1,0xf083e528
f011b74d:	00 00 00 
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #1 initialize_dynamic_allocator
	//Your code is here
	//Comment the following line
	panic("initialize_dynamic_allocator() Not implemented yet");
f011b750:	83 ec 04             	sub    $0x4,%esp
f011b753:	68 90 66 13 f0       	push   $0xf0136690
f011b758:	6a 2e                	push   $0x2e
f011b75a:	68 77 66 13 f0       	push   $0xf0136677
f011b75f:	e8 4b 58 fe ff       	call   f0100faf <_panic>

f011b764 <get_block_size>:

//===========================
// [2] GET BLOCK SIZE:
//===========================
__inline__ uint32 get_block_size(void *va)
{
f011b764:	55                   	push   %ebp
f011b765:	89 e5                	mov    %esp,%ebp
f011b767:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #2 get_block_size
	//Your code is here
	//Comment the following line
	panic("get_block_size() Not implemented yet");
f011b76a:	83 ec 04             	sub    $0x4,%esp
f011b76d:	68 c4 66 13 f0       	push   $0xf01366c4
f011b772:	6a 3a                	push   $0x3a
f011b774:	68 77 66 13 f0       	push   $0xf0136677
f011b779:	e8 31 58 fe ff       	call   f0100faf <_panic>

f011b77e <alloc_block>:

//===========================
// 3) ALLOCATE BLOCK:
//===========================
void *alloc_block(uint32 size)
{
f011b77e:	55                   	push   %ebp
f011b77f:	89 e5                	mov    %esp,%ebp
f011b781:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert(size <= DYN_ALLOC_MAX_BLOCK_SIZE);
f011b784:	81 7d 08 00 08 00 00 	cmpl   $0x800,0x8(%ebp)
f011b78b:	76 16                	jbe    f011b7a3 <alloc_block+0x25>
f011b78d:	68 ec 66 13 f0       	push   $0xf01366ec
f011b792:	68 62 66 13 f0       	push   $0xf0136662
f011b797:	6a 46                	push   $0x46
f011b799:	68 77 66 13 f0       	push   $0xf0136677
f011b79e:	e8 0c 58 fe ff       	call   f0100faf <_panic>
	//==================================================================================
	//==================================================================================
	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #3 alloc_block
	//Your code is here
	//Comment the following line
	panic("alloc_block() Not implemented yet");
f011b7a3:	83 ec 04             	sub    $0x4,%esp
f011b7a6:	68 10 67 13 f0       	push   $0xf0136710
f011b7ab:	6a 4d                	push   $0x4d
f011b7ad:	68 77 66 13 f0       	push   $0xf0136677
f011b7b2:	e8 f8 57 fe ff       	call   f0100faf <_panic>

f011b7b7 <free_block>:

//===========================
// [4] FREE BLOCK:
//===========================
void free_block(void *va)
{
f011b7b7:	55                   	push   %ebp
f011b7b8:	89 e5                	mov    %esp,%ebp
f011b7ba:	83 ec 08             	sub    $0x8,%esp
	//==================================================================================
	//DON'T CHANGE THESE LINES==========================================================
	//==================================================================================
	{
		assert((uint32)va >= dynAllocStart && (uint32)va < dynAllocEnd);
f011b7bd:	8b 55 08             	mov    0x8(%ebp),%edx
f011b7c0:	a1 1c 6b 85 f0       	mov    0xf0856b1c,%eax
f011b7c5:	39 c2                	cmp    %eax,%edx
f011b7c7:	72 0c                	jb     f011b7d5 <free_block+0x1e>
f011b7c9:	8b 55 08             	mov    0x8(%ebp),%edx
f011b7cc:	a1 40 e5 83 f0       	mov    0xf083e540,%eax
f011b7d1:	39 c2                	cmp    %eax,%edx
f011b7d3:	72 16                	jb     f011b7eb <free_block+0x34>
f011b7d5:	68 34 67 13 f0       	push   $0xf0136734
f011b7da:	68 62 66 13 f0       	push   $0xf0136662
f011b7df:	6a 5b                	push   $0x5b
f011b7e1:	68 77 66 13 f0       	push   $0xf0136677
f011b7e6:	e8 c4 57 fe ff       	call   f0100faf <_panic>
	//==================================================================================

	//TODO: [PROJECT'25.GM#1] DYNAMIC ALLOCATOR - #4 free_block
	//Your code is here
	//Comment the following line
	panic("free_block() Not implemented yet");
f011b7eb:	83 ec 04             	sub    $0x4,%esp
f011b7ee:	68 6c 67 13 f0       	push   $0xf013676c
f011b7f3:	6a 63                	push   $0x63
f011b7f5:	68 77 66 13 f0       	push   $0xf0136677
f011b7fa:	e8 b0 57 fe ff       	call   f0100faf <_panic>

f011b7ff <realloc_block>:

//===========================
// [1] REALLOCATE BLOCK:
//===========================
void *realloc_block(void* va, uint32 new_size)
{
f011b7ff:	55                   	push   %ebp
f011b800:	89 e5                	mov    %esp,%ebp
f011b802:	83 ec 08             	sub    $0x8,%esp
	//TODO: [PROJECT'25.BONUS#2] KERNEL REALLOC - realloc_block
	//Your code is here
	//Comment the following line
	panic("realloc_block() Not implemented yet");
f011b805:	83 ec 04             	sub    $0x4,%esp
f011b808:	68 90 67 13 f0       	push   $0xf0136790
f011b80d:	6a 72                	push   $0x72
f011b80f:	68 77 66 13 f0       	push   $0xf0136677
f011b814:	e8 96 57 fe ff       	call   f0100faf <_panic>
f011b819:	66 90                	xchg   %ax,%ax
f011b81b:	90                   	nop

f011b81c <__moddi3>:
f011b81c:	55                   	push   %ebp
f011b81d:	57                   	push   %edi
f011b81e:	56                   	push   %esi
f011b81f:	53                   	push   %ebx
f011b820:	83 ec 2c             	sub    $0x2c,%esp
f011b823:	8b 74 24 40          	mov    0x40(%esp),%esi
f011b827:	8b 7c 24 44          	mov    0x44(%esp),%edi
f011b82b:	8b 4c 24 48          	mov    0x48(%esp),%ecx
f011b82f:	8b 5c 24 4c          	mov    0x4c(%esp),%ebx
f011b833:	89 d8                	mov    %ebx,%eax
f011b835:	85 ff                	test   %edi,%edi
f011b837:	0f 88 d3 00 00 00    	js     f011b910 <__moddi3+0xf4>
f011b83d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
f011b844:	00 
f011b845:	85 c0                	test   %eax,%eax
f011b847:	0f 88 ab 00 00 00    	js     f011b8f8 <__moddi3+0xdc>
f011b84d:	89 0c 24             	mov    %ecx,(%esp)
f011b850:	89 5c 24 04          	mov    %ebx,0x4(%esp)
f011b854:	89 74 24 10          	mov    %esi,0x10(%esp)
f011b858:	89 fb                	mov    %edi,%ebx
f011b85a:	8b 14 24             	mov    (%esp),%edx
f011b85d:	8b 4c 24 04          	mov    0x4(%esp),%ecx
f011b861:	89 d0                	mov    %edx,%eax
f011b863:	89 54 24 18          	mov    %edx,0x18(%esp)
f011b867:	89 ca                	mov    %ecx,%edx
f011b869:	8b 0c 24             	mov    (%esp),%ecx
f011b86c:	89 34 24             	mov    %esi,(%esp)
f011b86f:	89 7c 24 14          	mov    %edi,0x14(%esp)
f011b873:	85 d2                	test   %edx,%edx
f011b875:	75 15                	jne    f011b88c <__moddi3+0x70>
f011b877:	89 c7                	mov    %eax,%edi
f011b879:	39 d8                	cmp    %ebx,%eax
f011b87b:	76 5b                	jbe    f011b8d8 <__moddi3+0xbc>
f011b87d:	89 f0                	mov    %esi,%eax
f011b87f:	89 da                	mov    %ebx,%edx
f011b881:	f7 f7                	div    %edi
f011b883:	89 d3                	mov    %edx,%ebx
f011b885:	89 d8                	mov    %ebx,%eax
f011b887:	31 d2                	xor    %edx,%edx
f011b889:	eb 09                	jmp    f011b894 <__moddi3+0x78>
f011b88b:	90                   	nop
f011b88c:	39 fa                	cmp    %edi,%edx
f011b88e:	76 1c                	jbe    f011b8ac <__moddi3+0x90>
f011b890:	89 f0                	mov    %esi,%eax
f011b892:	89 fa                	mov    %edi,%edx
f011b894:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
f011b898:	85 c9                	test   %ecx,%ecx
f011b89a:	74 07                	je     f011b8a3 <__moddi3+0x87>
f011b89c:	f7 d8                	neg    %eax
f011b89e:	83 d2 00             	adc    $0x0,%edx
f011b8a1:	f7 da                	neg    %edx
f011b8a3:	83 c4 2c             	add    $0x2c,%esp
f011b8a6:	5b                   	pop    %ebx
f011b8a7:	5e                   	pop    %esi
f011b8a8:	5f                   	pop    %edi
f011b8a9:	5d                   	pop    %ebp
f011b8aa:	c3                   	ret    
f011b8ab:	90                   	nop
f011b8ac:	0f bd c2             	bsr    %edx,%eax
f011b8af:	83 f0 1f             	xor    $0x1f,%eax
f011b8b2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
f011b8b6:	75 6c                	jne    f011b924 <__moddi3+0x108>
f011b8b8:	39 fa                	cmp    %edi,%edx
f011b8ba:	72 05                	jb     f011b8c1 <__moddi3+0xa5>
f011b8bc:	3b 0c 24             	cmp    (%esp),%ecx
f011b8bf:	77 0e                	ja     f011b8cf <__moddi3+0xb3>
f011b8c1:	8b 34 24             	mov    (%esp),%esi
f011b8c4:	29 ce                	sub    %ecx,%esi
f011b8c6:	19 d3                	sbb    %edx,%ebx
f011b8c8:	89 5c 24 14          	mov    %ebx,0x14(%esp)
f011b8cc:	89 34 24             	mov    %esi,(%esp)
f011b8cf:	8b 04 24             	mov    (%esp),%eax
f011b8d2:	8b 54 24 14          	mov    0x14(%esp),%edx
f011b8d6:	eb bc                	jmp    f011b894 <__moddi3+0x78>
f011b8d8:	85 c9                	test   %ecx,%ecx
f011b8da:	75 0b                	jne    f011b8e7 <__moddi3+0xcb>
f011b8dc:	b8 01 00 00 00       	mov    $0x1,%eax
f011b8e1:	31 d2                	xor    %edx,%edx
f011b8e3:	f7 f1                	div    %ecx
f011b8e5:	89 c1                	mov    %eax,%ecx
f011b8e7:	89 d8                	mov    %ebx,%eax
f011b8e9:	31 d2                	xor    %edx,%edx
f011b8eb:	f7 f1                	div    %ecx
f011b8ed:	8b 04 24             	mov    (%esp),%eax
f011b8f0:	f7 f1                	div    %ecx
f011b8f2:	89 d3                	mov    %edx,%ebx
f011b8f4:	eb 8f                	jmp    f011b885 <__moddi3+0x69>
f011b8f6:	66 90                	xchg   %ax,%ax
f011b8f8:	89 c8                	mov    %ecx,%eax
f011b8fa:	89 da                	mov    %ebx,%edx
f011b8fc:	f7 d8                	neg    %eax
f011b8fe:	83 d2 00             	adc    $0x0,%edx
f011b901:	f7 da                	neg    %edx
f011b903:	89 04 24             	mov    %eax,(%esp)
f011b906:	89 54 24 04          	mov    %edx,0x4(%esp)
f011b90a:	e9 45 ff ff ff       	jmp    f011b854 <__moddi3+0x38>
f011b90f:	90                   	nop
f011b910:	f7 de                	neg    %esi
f011b912:	83 d7 00             	adc    $0x0,%edi
f011b915:	f7 df                	neg    %edi
f011b917:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
f011b91e:	ff 
f011b91f:	e9 21 ff ff ff       	jmp    f011b845 <__moddi3+0x29>
f011b924:	b8 20 00 00 00       	mov    $0x20,%eax
f011b929:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f011b92d:	29 f8                	sub    %edi,%eax
f011b92f:	89 c6                	mov    %eax,%esi
f011b931:	89 44 24 14          	mov    %eax,0x14(%esp)
f011b935:	89 f9                	mov    %edi,%ecx
f011b937:	d3 e2                	shl    %cl,%edx
f011b939:	8b 6c 24 18          	mov    0x18(%esp),%ebp
f011b93d:	89 e8                	mov    %ebp,%eax
f011b93f:	89 f1                	mov    %esi,%ecx
f011b941:	d3 e8                	shr    %cl,%eax
f011b943:	09 d0                	or     %edx,%eax
f011b945:	89 04 24             	mov    %eax,(%esp)
f011b948:	89 ea                	mov    %ebp,%edx
f011b94a:	89 f9                	mov    %edi,%ecx
f011b94c:	d3 e2                	shl    %cl,%edx
f011b94e:	89 d7                	mov    %edx,%edi
f011b950:	89 da                	mov    %ebx,%edx
f011b952:	d3 e2                	shl    %cl,%edx
f011b954:	8b 6c 24 10          	mov    0x10(%esp),%ebp
f011b958:	d3 e5                	shl    %cl,%ebp
f011b95a:	8b 44 24 10          	mov    0x10(%esp),%eax
f011b95e:	89 f1                	mov    %esi,%ecx
f011b960:	d3 e8                	shr    %cl,%eax
f011b962:	09 d0                	or     %edx,%eax
f011b964:	d3 eb                	shr    %cl,%ebx
f011b966:	89 da                	mov    %ebx,%edx
f011b968:	f7 34 24             	divl   (%esp)
f011b96b:	89 d3                	mov    %edx,%ebx
f011b96d:	f7 e7                	mul    %edi
f011b96f:	89 c6                	mov    %eax,%esi
f011b971:	89 d1                	mov    %edx,%ecx
f011b973:	39 d3                	cmp    %edx,%ebx
f011b975:	72 29                	jb     f011b9a0 <__moddi3+0x184>
f011b977:	74 33                	je     f011b9ac <__moddi3+0x190>
f011b979:	89 e8                	mov    %ebp,%eax
f011b97b:	29 f0                	sub    %esi,%eax
f011b97d:	19 cb                	sbb    %ecx,%ebx
f011b97f:	89 de                	mov    %ebx,%esi
f011b981:	8a 4c 24 14          	mov    0x14(%esp),%cl
f011b985:	d3 e6                	shl    %cl,%esi
f011b987:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
f011b98b:	89 f9                	mov    %edi,%ecx
f011b98d:	d3 e8                	shr    %cl,%eax
f011b98f:	09 c6                	or     %eax,%esi
f011b991:	89 f0                	mov    %esi,%eax
f011b993:	89 f9                	mov    %edi,%ecx
f011b995:	d3 eb                	shr    %cl,%ebx
f011b997:	89 da                	mov    %ebx,%edx
f011b999:	e9 f6 fe ff ff       	jmp    f011b894 <__moddi3+0x78>
f011b99e:	66 90                	xchg   %ax,%ax
f011b9a0:	29 f8                	sub    %edi,%eax
f011b9a2:	1b 14 24             	sbb    (%esp),%edx
f011b9a5:	89 d1                	mov    %edx,%ecx
f011b9a7:	89 c6                	mov    %eax,%esi
f011b9a9:	eb ce                	jmp    f011b979 <__moddi3+0x15d>
f011b9ab:	90                   	nop
f011b9ac:	39 c5                	cmp    %eax,%ebp
f011b9ae:	72 f0                	jb     f011b9a0 <__moddi3+0x184>
f011b9b0:	89 d9                	mov    %ebx,%ecx
f011b9b2:	eb c5                	jmp    f011b979 <__moddi3+0x15d>

f011b9b4 <__udivdi3>:
f011b9b4:	55                   	push   %ebp
f011b9b5:	57                   	push   %edi
f011b9b6:	56                   	push   %esi
f011b9b7:	53                   	push   %ebx
f011b9b8:	83 ec 1c             	sub    $0x1c,%esp
f011b9bb:	8b 5c 24 30          	mov    0x30(%esp),%ebx
f011b9bf:	8b 4c 24 34          	mov    0x34(%esp),%ecx
f011b9c3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f011b9c7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
f011b9cb:	89 ca                	mov    %ecx,%edx
f011b9cd:	89 f8                	mov    %edi,%eax
f011b9cf:	8b 74 24 3c          	mov    0x3c(%esp),%esi
f011b9d3:	85 f6                	test   %esi,%esi
f011b9d5:	75 2d                	jne    f011ba04 <__udivdi3+0x50>
f011b9d7:	39 cf                	cmp    %ecx,%edi
f011b9d9:	77 65                	ja     f011ba40 <__udivdi3+0x8c>
f011b9db:	89 fd                	mov    %edi,%ebp
f011b9dd:	85 ff                	test   %edi,%edi
f011b9df:	75 0b                	jne    f011b9ec <__udivdi3+0x38>
f011b9e1:	b8 01 00 00 00       	mov    $0x1,%eax
f011b9e6:	31 d2                	xor    %edx,%edx
f011b9e8:	f7 f7                	div    %edi
f011b9ea:	89 c5                	mov    %eax,%ebp
f011b9ec:	31 d2                	xor    %edx,%edx
f011b9ee:	89 c8                	mov    %ecx,%eax
f011b9f0:	f7 f5                	div    %ebp
f011b9f2:	89 c1                	mov    %eax,%ecx
f011b9f4:	89 d8                	mov    %ebx,%eax
f011b9f6:	f7 f5                	div    %ebp
f011b9f8:	89 cf                	mov    %ecx,%edi
f011b9fa:	89 fa                	mov    %edi,%edx
f011b9fc:	83 c4 1c             	add    $0x1c,%esp
f011b9ff:	5b                   	pop    %ebx
f011ba00:	5e                   	pop    %esi
f011ba01:	5f                   	pop    %edi
f011ba02:	5d                   	pop    %ebp
f011ba03:	c3                   	ret    
f011ba04:	39 ce                	cmp    %ecx,%esi
f011ba06:	77 28                	ja     f011ba30 <__udivdi3+0x7c>
f011ba08:	0f bd fe             	bsr    %esi,%edi
f011ba0b:	83 f7 1f             	xor    $0x1f,%edi
f011ba0e:	75 40                	jne    f011ba50 <__udivdi3+0x9c>
f011ba10:	39 ce                	cmp    %ecx,%esi
f011ba12:	72 0a                	jb     f011ba1e <__udivdi3+0x6a>
f011ba14:	3b 44 24 08          	cmp    0x8(%esp),%eax
f011ba18:	0f 87 9e 00 00 00    	ja     f011babc <__udivdi3+0x108>
f011ba1e:	b8 01 00 00 00       	mov    $0x1,%eax
f011ba23:	89 fa                	mov    %edi,%edx
f011ba25:	83 c4 1c             	add    $0x1c,%esp
f011ba28:	5b                   	pop    %ebx
f011ba29:	5e                   	pop    %esi
f011ba2a:	5f                   	pop    %edi
f011ba2b:	5d                   	pop    %ebp
f011ba2c:	c3                   	ret    
f011ba2d:	8d 76 00             	lea    0x0(%esi),%esi
f011ba30:	31 ff                	xor    %edi,%edi
f011ba32:	31 c0                	xor    %eax,%eax
f011ba34:	89 fa                	mov    %edi,%edx
f011ba36:	83 c4 1c             	add    $0x1c,%esp
f011ba39:	5b                   	pop    %ebx
f011ba3a:	5e                   	pop    %esi
f011ba3b:	5f                   	pop    %edi
f011ba3c:	5d                   	pop    %ebp
f011ba3d:	c3                   	ret    
f011ba3e:	66 90                	xchg   %ax,%ax
f011ba40:	89 d8                	mov    %ebx,%eax
f011ba42:	f7 f7                	div    %edi
f011ba44:	31 ff                	xor    %edi,%edi
f011ba46:	89 fa                	mov    %edi,%edx
f011ba48:	83 c4 1c             	add    $0x1c,%esp
f011ba4b:	5b                   	pop    %ebx
f011ba4c:	5e                   	pop    %esi
f011ba4d:	5f                   	pop    %edi
f011ba4e:	5d                   	pop    %ebp
f011ba4f:	c3                   	ret    
f011ba50:	bd 20 00 00 00       	mov    $0x20,%ebp
f011ba55:	89 eb                	mov    %ebp,%ebx
f011ba57:	29 fb                	sub    %edi,%ebx
f011ba59:	89 f9                	mov    %edi,%ecx
f011ba5b:	d3 e6                	shl    %cl,%esi
f011ba5d:	89 c5                	mov    %eax,%ebp
f011ba5f:	88 d9                	mov    %bl,%cl
f011ba61:	d3 ed                	shr    %cl,%ebp
f011ba63:	89 e9                	mov    %ebp,%ecx
f011ba65:	09 f1                	or     %esi,%ecx
f011ba67:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
f011ba6b:	89 f9                	mov    %edi,%ecx
f011ba6d:	d3 e0                	shl    %cl,%eax
f011ba6f:	89 c5                	mov    %eax,%ebp
f011ba71:	89 d6                	mov    %edx,%esi
f011ba73:	88 d9                	mov    %bl,%cl
f011ba75:	d3 ee                	shr    %cl,%esi
f011ba77:	89 f9                	mov    %edi,%ecx
f011ba79:	d3 e2                	shl    %cl,%edx
f011ba7b:	8b 44 24 08          	mov    0x8(%esp),%eax
f011ba7f:	88 d9                	mov    %bl,%cl
f011ba81:	d3 e8                	shr    %cl,%eax
f011ba83:	09 c2                	or     %eax,%edx
f011ba85:	89 d0                	mov    %edx,%eax
f011ba87:	89 f2                	mov    %esi,%edx
f011ba89:	f7 74 24 0c          	divl   0xc(%esp)
f011ba8d:	89 d6                	mov    %edx,%esi
f011ba8f:	89 c3                	mov    %eax,%ebx
f011ba91:	f7 e5                	mul    %ebp
f011ba93:	39 d6                	cmp    %edx,%esi
f011ba95:	72 19                	jb     f011bab0 <__udivdi3+0xfc>
f011ba97:	74 0b                	je     f011baa4 <__udivdi3+0xf0>
f011ba99:	89 d8                	mov    %ebx,%eax
f011ba9b:	31 ff                	xor    %edi,%edi
f011ba9d:	e9 58 ff ff ff       	jmp    f011b9fa <__udivdi3+0x46>
f011baa2:	66 90                	xchg   %ax,%ax
f011baa4:	8b 54 24 08          	mov    0x8(%esp),%edx
f011baa8:	89 f9                	mov    %edi,%ecx
f011baaa:	d3 e2                	shl    %cl,%edx
f011baac:	39 c2                	cmp    %eax,%edx
f011baae:	73 e9                	jae    f011ba99 <__udivdi3+0xe5>
f011bab0:	8d 43 ff             	lea    -0x1(%ebx),%eax
f011bab3:	31 ff                	xor    %edi,%edi
f011bab5:	e9 40 ff ff ff       	jmp    f011b9fa <__udivdi3+0x46>
f011baba:	66 90                	xchg   %ax,%ax
f011babc:	31 c0                	xor    %eax,%eax
f011babe:	e9 37 ff ff ff       	jmp    f011b9fa <__udivdi3+0x46>
f011bac3:	90                   	nop

f011bac4 <__umoddi3>:
f011bac4:	55                   	push   %ebp
f011bac5:	57                   	push   %edi
f011bac6:	56                   	push   %esi
f011bac7:	53                   	push   %ebx
f011bac8:	83 ec 1c             	sub    $0x1c,%esp
f011bacb:	8b 4c 24 30          	mov    0x30(%esp),%ecx
f011bacf:	8b 74 24 34          	mov    0x34(%esp),%esi
f011bad3:	8b 7c 24 38          	mov    0x38(%esp),%edi
f011bad7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
f011badb:	89 44 24 0c          	mov    %eax,0xc(%esp)
f011badf:	89 4c 24 08          	mov    %ecx,0x8(%esp)
f011bae3:	89 f3                	mov    %esi,%ebx
f011bae5:	89 fa                	mov    %edi,%edx
f011bae7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f011baeb:	89 34 24             	mov    %esi,(%esp)
f011baee:	85 c0                	test   %eax,%eax
f011baf0:	75 1a                	jne    f011bb0c <__umoddi3+0x48>
f011baf2:	39 f7                	cmp    %esi,%edi
f011baf4:	0f 86 a2 00 00 00    	jbe    f011bb9c <__umoddi3+0xd8>
f011bafa:	89 c8                	mov    %ecx,%eax
f011bafc:	89 f2                	mov    %esi,%edx
f011bafe:	f7 f7                	div    %edi
f011bb00:	89 d0                	mov    %edx,%eax
f011bb02:	31 d2                	xor    %edx,%edx
f011bb04:	83 c4 1c             	add    $0x1c,%esp
f011bb07:	5b                   	pop    %ebx
f011bb08:	5e                   	pop    %esi
f011bb09:	5f                   	pop    %edi
f011bb0a:	5d                   	pop    %ebp
f011bb0b:	c3                   	ret    
f011bb0c:	39 f0                	cmp    %esi,%eax
f011bb0e:	0f 87 ac 00 00 00    	ja     f011bbc0 <__umoddi3+0xfc>
f011bb14:	0f bd e8             	bsr    %eax,%ebp
f011bb17:	83 f5 1f             	xor    $0x1f,%ebp
f011bb1a:	0f 84 ac 00 00 00    	je     f011bbcc <__umoddi3+0x108>
f011bb20:	bf 20 00 00 00       	mov    $0x20,%edi
f011bb25:	29 ef                	sub    %ebp,%edi
f011bb27:	89 fe                	mov    %edi,%esi
f011bb29:	89 7c 24 0c          	mov    %edi,0xc(%esp)
f011bb2d:	89 e9                	mov    %ebp,%ecx
f011bb2f:	d3 e0                	shl    %cl,%eax
f011bb31:	89 d7                	mov    %edx,%edi
f011bb33:	89 f1                	mov    %esi,%ecx
f011bb35:	d3 ef                	shr    %cl,%edi
f011bb37:	09 c7                	or     %eax,%edi
f011bb39:	89 e9                	mov    %ebp,%ecx
f011bb3b:	d3 e2                	shl    %cl,%edx
f011bb3d:	89 14 24             	mov    %edx,(%esp)
f011bb40:	89 d8                	mov    %ebx,%eax
f011bb42:	d3 e0                	shl    %cl,%eax
f011bb44:	89 c2                	mov    %eax,%edx
f011bb46:	8b 44 24 08          	mov    0x8(%esp),%eax
f011bb4a:	d3 e0                	shl    %cl,%eax
f011bb4c:	89 44 24 04          	mov    %eax,0x4(%esp)
f011bb50:	8b 44 24 08          	mov    0x8(%esp),%eax
f011bb54:	89 f1                	mov    %esi,%ecx
f011bb56:	d3 e8                	shr    %cl,%eax
f011bb58:	09 d0                	or     %edx,%eax
f011bb5a:	d3 eb                	shr    %cl,%ebx
f011bb5c:	89 da                	mov    %ebx,%edx
f011bb5e:	f7 f7                	div    %edi
f011bb60:	89 d3                	mov    %edx,%ebx
f011bb62:	f7 24 24             	mull   (%esp)
f011bb65:	89 c6                	mov    %eax,%esi
f011bb67:	89 d1                	mov    %edx,%ecx
f011bb69:	39 d3                	cmp    %edx,%ebx
f011bb6b:	0f 82 87 00 00 00    	jb     f011bbf8 <__umoddi3+0x134>
f011bb71:	0f 84 91 00 00 00    	je     f011bc08 <__umoddi3+0x144>
f011bb77:	8b 54 24 04          	mov    0x4(%esp),%edx
f011bb7b:	29 f2                	sub    %esi,%edx
f011bb7d:	19 cb                	sbb    %ecx,%ebx
f011bb7f:	89 d8                	mov    %ebx,%eax
f011bb81:	8a 4c 24 0c          	mov    0xc(%esp),%cl
f011bb85:	d3 e0                	shl    %cl,%eax
f011bb87:	89 e9                	mov    %ebp,%ecx
f011bb89:	d3 ea                	shr    %cl,%edx
f011bb8b:	09 d0                	or     %edx,%eax
f011bb8d:	89 e9                	mov    %ebp,%ecx
f011bb8f:	d3 eb                	shr    %cl,%ebx
f011bb91:	89 da                	mov    %ebx,%edx
f011bb93:	83 c4 1c             	add    $0x1c,%esp
f011bb96:	5b                   	pop    %ebx
f011bb97:	5e                   	pop    %esi
f011bb98:	5f                   	pop    %edi
f011bb99:	5d                   	pop    %ebp
f011bb9a:	c3                   	ret    
f011bb9b:	90                   	nop
f011bb9c:	89 fd                	mov    %edi,%ebp
f011bb9e:	85 ff                	test   %edi,%edi
f011bba0:	75 0b                	jne    f011bbad <__umoddi3+0xe9>
f011bba2:	b8 01 00 00 00       	mov    $0x1,%eax
f011bba7:	31 d2                	xor    %edx,%edx
f011bba9:	f7 f7                	div    %edi
f011bbab:	89 c5                	mov    %eax,%ebp
f011bbad:	89 f0                	mov    %esi,%eax
f011bbaf:	31 d2                	xor    %edx,%edx
f011bbb1:	f7 f5                	div    %ebp
f011bbb3:	89 c8                	mov    %ecx,%eax
f011bbb5:	f7 f5                	div    %ebp
f011bbb7:	89 d0                	mov    %edx,%eax
f011bbb9:	e9 44 ff ff ff       	jmp    f011bb02 <__umoddi3+0x3e>
f011bbbe:	66 90                	xchg   %ax,%ax
f011bbc0:	89 c8                	mov    %ecx,%eax
f011bbc2:	89 f2                	mov    %esi,%edx
f011bbc4:	83 c4 1c             	add    $0x1c,%esp
f011bbc7:	5b                   	pop    %ebx
f011bbc8:	5e                   	pop    %esi
f011bbc9:	5f                   	pop    %edi
f011bbca:	5d                   	pop    %ebp
f011bbcb:	c3                   	ret    
f011bbcc:	3b 04 24             	cmp    (%esp),%eax
f011bbcf:	72 06                	jb     f011bbd7 <__umoddi3+0x113>
f011bbd1:	3b 7c 24 04          	cmp    0x4(%esp),%edi
f011bbd5:	77 0f                	ja     f011bbe6 <__umoddi3+0x122>
f011bbd7:	89 f2                	mov    %esi,%edx
f011bbd9:	29 f9                	sub    %edi,%ecx
f011bbdb:	1b 54 24 0c          	sbb    0xc(%esp),%edx
f011bbdf:	89 14 24             	mov    %edx,(%esp)
f011bbe2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
f011bbe6:	8b 44 24 04          	mov    0x4(%esp),%eax
f011bbea:	8b 14 24             	mov    (%esp),%edx
f011bbed:	83 c4 1c             	add    $0x1c,%esp
f011bbf0:	5b                   	pop    %ebx
f011bbf1:	5e                   	pop    %esi
f011bbf2:	5f                   	pop    %edi
f011bbf3:	5d                   	pop    %ebp
f011bbf4:	c3                   	ret    
f011bbf5:	8d 76 00             	lea    0x0(%esi),%esi
f011bbf8:	2b 04 24             	sub    (%esp),%eax
f011bbfb:	19 fa                	sbb    %edi,%edx
f011bbfd:	89 d1                	mov    %edx,%ecx
f011bbff:	89 c6                	mov    %eax,%esi
f011bc01:	e9 71 ff ff ff       	jmp    f011bb77 <__umoddi3+0xb3>
f011bc06:	66 90                	xchg   %ax,%ax
f011bc08:	39 44 24 04          	cmp    %eax,0x4(%esp)
f011bc0c:	72 ea                	jb     f011bbf8 <__umoddi3+0x134>
f011bc0e:	89 d9                	mov    %ebx,%ecx
f011bc10:	e9 62 ff ff ff       	jmp    f011bb77 <__umoddi3+0xb3>
